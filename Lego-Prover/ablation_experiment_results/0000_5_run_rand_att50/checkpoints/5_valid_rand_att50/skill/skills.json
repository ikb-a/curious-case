{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "log_exp_general": {"skill_name": "log_exp_general", "marker": "lemma log_exp_general:\n  fixes a b :: real\n  fixes n :: nat\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"b \\<noteq> 1\" \"n > 0\"\n  shows \"log a (b^n) = n * log a b\"\nproof -\n  have \"log a (b^n) = n * log a b\" using log_nat_power[of b a n] assms by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma log_exp_general:\n  fixes a b :: real\n  fixes n :: nat\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"b \\<noteq> 1\" \"n > 0\"\n  shows \"log a (b^n) = n * log a b\"\nproof -\n  have \"log a (b^n) = n * log a b\" using log_nat_power[of b a n] assms by auto\n  then show ?thesis by simp\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "log_power_identity": {"skill_name": "log_power_identity", "marker": "lemma log_power_identity:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\" using log_nat_power[of a a n] \n    by (simp add: assms(1))\n  then show ?thesis using assms(1) assms(2) by simp\nqed", "description": "-", "full_code": "lemma log_power_identity:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\" using log_nat_power[of a a n] \n    by (simp add: assms(1))\n  then show ?thesis using assms(1) assms(2) by simp\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "a_times_inverse": {"skill_name": "a_times_inverse", "marker": "lemma a_times_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  using assms by (auto simp: field_simps)", "description": "-", "full_code": "lemma a_times_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  using assms by (auto simp: field_simps)", "origin": "a_times_vera", "update_count": 0}, "log_power_identityV2": {"skill_name": "log_power_identityV2", "marker": "lemma log_power_identity:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\"\n  shows \"log a (b^2) = 2 * log a b\"\n  using log_exponentiation[of a b 2] assms by fastforce", "description": "-", "full_code": "lemma log_exponentiation:\n  fixes a b :: real\n  fixes n :: nat\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"b \\<noteq> 1\" \"n > 0\"\n  shows \"log a (b^n) = n * log a b\"\nproof -\n  have \"log a (b^n) = n * log a b\" using log_nat_power[of b a n] assms by simp\n  then show ?thesis by simp\nqed\n\nlemma log_power_identity:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\"\n  shows \"log a (b^2) = 2 * log a b\"\n  using log_exponentiation[of a b 2] assms by fastforce", "origin": "log_exp_general", "update_count": 0}, "log_sum_identity": {"skill_name": "log_sum_identity", "marker": "lemma log_sum_identity:\n  fixes a x y :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"x > 0\" \"y > 0\"\n  shows \"log a (x * y) = log a x + log a y\"\nproof -\n  have \"log a (x * y) = log a x + log a y\" using log_mult[of a x y] assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma log_sum_identity:\n  fixes a x y :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"x > 0\" \"y > 0\"\n  shows \"log a (x * y) = log a x + log a y\"\nproof -\n  have \"log a (x * y) = log a x + log a y\" using log_mult[of a x y] assms by simp\n  then show ?thesis by simp\nqed", "origin": "log_exp_general", "update_count": 0}, "substitute_linear_eq": {"skill_name": "substitute_linear_eq", "marker": "lemma substitute_linear_eq:\n  fixes a b :: real\n  assumes \"3 * a + 2 * b = 12\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have \"2 * b = 12 - 3 * a\" \n    using assms by (simp add: algebra_simps)\n  then show ?thesis \n    by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma substitute_linear_eq:\n  fixes a b :: real\n  assumes \"3 * a + 2 * b = 12\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have \"2 * b = 12 - 3 * a\" \n    using assms by (simp add: algebra_simps)\n  then show ?thesis \n    by (simp add: divide_simps)\nqed", "origin": "do_request", "update_count": 0}, "substitute_linear_eqV2": {"skill_name": "substitute_linear_eqV2", "marker": "lemma substitute_linear_eq:\n  fixes a b :: real\n  assumes \"3 * a + 2 * b = 12\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have \"2 * b = 12 - 3 * a\"\n    using assms by simp\n  then show ?thesis\n    by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma substitute_linear_eq:\n  fixes a b :: real\n  assumes \"3 * a + 2 * b = 12\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have \"2 * b = 12 - 3 * a\"\n    using assms by simp\n  then show ?thesis\n    by (simp add: divide_simps)\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e=11 \\<and> x= (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e=11 \\<and> x= (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "data/full_data/debug/valid_rand/algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4.json_v0", "update_count": -1}, "valid_operations": {"skill_name": "valid_operations", "marker": "lemma valid_operations:\n  fixes x y z :: real\n  assumes \"x = y\"\n  shows \"x + z = y + z\"\nproof -\n  have \"x + z = y + z\"\n    using assms by (simp add: assms)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma valid_operations:\n  fixes x y z :: real\n  assumes \"x = y\"\n  shows \"x + z = y + z\"\nproof -\n  have \"x + z = y + z\"\n    using assms by (simp add: assms)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "isolate_variable": {"skill_name": "isolate_variable", "marker": "lemma isolate_variable:\n  fixes x y :: real\n  assumes \"x + y = c\"\n  shows \"y = c - x\"\nproof -\n  have \"y = c - x\" \n  proof -\n    from assms have \"y = c - x\" by auto\n    thus ?thesis by assumption\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma isolate_variable:\n  fixes x y :: real\n  assumes \"x + y = c\"\n  shows \"y = c - x\"\nproof -\n  have \"y = c - x\" \n  proof -\n    from assms have \"y = c - x\" by auto\n    thus ?thesis by assumption\n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "isolate_variableV2": {"skill_name": "isolate_variableV2", "marker": "lemma isolate_variable:\n  fixes x y :: real\n  assumes \"x + y = c\"\n  shows \"y = c - x\"\nproof -\n  have \"y = c - x\" by (metis assms diff_diff_eq diff_eq_diff_eq eq_iff_diff_eq_0 neg_equal_iff_equal)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma isolate_variable:\n  fixes x y :: real\n  assumes \"x + y = c\"\n  shows \"y = c - x\"\nproof -\n  have \"y = c - x\" by (metis assms diff_diff_eq diff_eq_diff_eq eq_iff_diff_eq_0 neg_equal_iff_equal)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "cancle_div_multi": {"skill_name": "cancle_div_multi", "marker": "lemma cancle_div_multi:\n  fixes x a b c d:: real\n  assumes \"x > 0\" \"d > 0\" \"a + b / x = c\" \"e + f / x = g\"\n  shows \"(a * x + b) + (e * x + f) = (c + g) * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by (metis assms(3) mult.commute)\n  have \"x * (e + f / x) = g * x\" using assms(4) by auto\n  then have \"x * (a + b / x) + x * (e + f / x) = c * x + g * x\"\n    by (metis \\<open>x * (a + b / x) = c * x\\<close> comm_semiring_class.distrib mult.commute ring_class.ring_distribs(2))\n  then show ?thesis\n    using assms(1) by sos\nqed", "description": "-", "full_code": "lemma cancle_div_multi:\n  fixes x a b c d:: real\n  assumes \"x > 0\" \"d > 0\" \"a + b / x = c\" \"e + f / x = g\"\n  shows \"(a * x + b) + (e * x + f) = (c + g) * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by (metis assms(3) mult.commute)\n  have \"x * (e + f / x) = g * x\" using assms(4) by auto\n  then have \"x * (a + b / x) + x * (e + f / x) = c * x + g * x\"\n    by (metis \\<open>x * (a + b / x) = c * x\\<close> comm_semiring_class.distrib mult.commute ring_class.ring_distribs(2))\n  then show ?thesis\n    using assms(1) by sos\nqed", "origin": "cancle_div", "update_count": 0}, "logarithm_property_power": {"skill_name": "logarithm_property_power", "marker": "lemma logarithm_property_power:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    by (simp add: assms(1) assms(2) log_nat_power)\n  then show ?thesis \n    using assms(1) assms(2) by simp\nqed", "description": "-", "full_code": "lemma logarithm_property_power:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    by (simp add: assms(1) assms(2) log_nat_power)\n  then show ?thesis \n    using assms(1) assms(2) by simp\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "mathd_algebra_109": {"skill_name": "mathd_algebra_109", "marker": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a+2*b=12\"\n    and h1 : \"a=4\"\n  shows \"b=0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "", "full_code": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a+2*b=12\"\n    and h1 : \"a=4\"\n  shows \"b=0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "data/full_data/debug/valid_rand/mathd_algebra_109.json_v0", "update_count": -1}, "mod_add_power_for_any_x": {"skill_name": "mod_add_power_for_any_x", "marker": "lemma mod_add_power_for_any_x:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\"\n  shows \"((x + b)^c) mod n = ((x mod n + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_for_any_x:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\"\n  shows \"((x + b)^c) mod n = ((x mod n + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  thus ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "algebra_2varlineareq": {"skill_name": "algebra_2varlineareq", "marker": "theorem algebra_2varlineareq:\n  fixes x e :: real\n  assumes h0: \"x + e = a\"\n    and h1: \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  then have eq_simplified: \"x + a = b\" by simp\n  have x_value: \"x = b - a\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq)\n  then show ?thesis using e_expr by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq:\n  fixes x e :: real\n  assumes h0: \"x + e = a\"\n    and h1: \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  then have eq_simplified: \"x + a = b\" by simp\n  have x_value: \"x = b - a\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq)\n  then show ?thesis using e_expr by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "linear_system_solution": {"skill_name": "linear_system_solution", "marker": "theorem linear_system_solution:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem linear_system_solution:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "linear_function_slope": {"skill_name": "linear_function_slope", "marker": "lemma linear_function_slope:\n  fixes m c :: real\n  assumes \"(\\<forall>x. f x = m * x + c)\"\n  shows \"f(a) - f(b) = m * (a - b)\"\nproof -\n  have \"f(a) = m * a + c\" using assms by (simp)\n  moreover have \"f(b) = m * b + c\" using assms by (simp)\n  ultimately have \"f(a) - f(b) = (m * a + c) - (m * b + c)\"\n    by (simp)\n  thus ?thesis\n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma linear_function_slope:\n  fixes m c :: real\n  assumes \"(\\<forall>x. f x = m * x + c)\"\n  shows \"f(a) - f(b) = m * (a - b)\"\nproof -\n  have \"f(a) = m * a + c\" using assms by (simp)\n  moreover have \"f(b) = m * b + c\" using assms by (simp)\n  ultimately have \"f(a) - f(b) = (m * a + c) - (m * b + c)\"\n    by (simp)\n  thus ?thesis\n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "linear_function_slopeV2": {"skill_name": "linear_function_slopeV2", "marker": "lemma linear_function_slope:\n  fixes m c :: real\n  assumes \"(\\<forall>x. f x = m * x + c)\"\n  shows \"f(a) - f(b) = m * (a - b)\"\nproof -\n  have f_a: \"f(a) = m * a + c\" using assms by (simp)\n  have f_b: \"f(b) = m * b + c\" using assms by (simp)\n  have \"f(a) - f(b) = (m * a + c) - (m * b + c)\" \n    by (simp add: f_a f_b)\n  then have \"f(a) - f(b) = m * a - m * b\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma linear_function_slope:\n  fixes m c :: real\n  assumes \"(\\<forall>x. f x = m * x + c)\"\n  shows \"f(a) - f(b) = m * (a - b)\"\nproof -\n  have f_a: \"f(a) = m * a + c\" using assms by (simp)\n  have f_b: \"f(b) = m * b + c\" using assms by (simp)\n  have \"f(a) - f(b) = (m * a + c) - (m * b + c)\" \n    by (simp add: f_a f_b)\n  then have \"f(a) - f(b) = m * a - m * b\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "linear_function_slopeV3": {"skill_name": "linear_function_slopeV3", "marker": "lemma linear_function_slope:\n  fixes m c :: real\n  assumes \"(\\<forall>x. f x = m * x + c)\"\n  shows \"f(a) - f(b) = m * (a - b)\"\nproof -\n  have \"f(a) = m * a + c\" using assms by (simp)\n  have \"f(b) = m * b + c\" using assms by (simp)\n  then have \"f(a) - f(b) = (m * a + c) - (m * b + c)\" \n    by (metis assms)\n  then have \"f(a) - f(b) = m * a + c - m * b - c\" \n    by (simp)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma linear_function_slope:\n  fixes m c :: real\n  assumes \"(\\<forall>x. f x = m * x + c)\"\n  shows \"f(a) - f(b) = m * (a - b)\"\nproof -\n  have \"f(a) = m * a + c\" using assms by (simp)\n  have \"f(b) = m * b + c\" using assms by (simp)\n  then have \"f(a) - f(b) = (m * a + c) - (m * b + c)\" \n    by (metis assms)\n  then have \"f(a) - f(b) = m * a + c - m * b - c\" \n    by (simp)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "algebra_nvarlineareq": {"skill_name": "algebra_nvarlineareq", "marker": "theorem algebra_nvarlineareq:\n  fixes x e :: \"complex list\"\n  assumes h0 : \"x ! 0 + e ! 0 = 7\"\n    and h1 : \"2 * x ! 0 + e ! 0 = 3\"\n  shows \"e ! 0 = 11 \\<and> x ! 0 = (-4)\"\nproof -\n  have e_expr: \"e ! 0 = 7 - x ! 0\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x ! 0 + (7 - x ! 0) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x ! 0 + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x ! 0 = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x ! 0 = -4\" by simp\n  have e_value: \"e ! 0 = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e ! 0 = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_nvarlineareq:\n  fixes x e :: \"complex list\"\n  assumes h0 : \"x ! 0 + e ! 0 = 7\"\n    and h1 : \"2 * x ! 0 + e ! 0 = 3\"\n  shows \"e ! 0 = 11 \\<and> x ! 0 = (-4)\"\nproof -\n  have e_expr: \"e ! 0 = 7 - x ! 0\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x ! 0 + (7 - x ! 0) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x ! 0 + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x ! 0 = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x ! 0 = -4\" by simp\n  have e_value: \"e ! 0 = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e ! 0 = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "distinct_nonzero": {"skill_name": "distinct_nonzero", "marker": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  have \"x * y \\<noteq> 0\"\n  proof -\n    from assms have \"x \\<noteq> 0\" and \"y \\<noteq> 0\" by auto\n    thus ?thesis\n      by auto\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  have \"x * y \\<noteq> 0\"\n  proof -\n    from assms have \"x \\<noteq> 0\" and \"y \\<noteq> 0\" by auto\n    thus ?thesis\n      by auto\n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sum_of_non_negatives": {"skill_name": "sum_of_non_negatives", "marker": "lemma sum_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b = a + b\" by simp\n  moreover have \"a >= 0\" using assms(1) by simp\n  moreover have \"b >= 0\" using assms(2) by simp\n  ultimately show ?thesis\n    by (metis add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma sum_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b = a + b\" by simp\n  moreover have \"a >= 0\" using assms(1) by simp\n  moreover have \"b >= 0\" using assms(2) by simp\n  ultimately show ?thesis\n    by (metis add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "sum_of_non_negativesV2": {"skill_name": "sum_of_non_negativesV2", "marker": "lemma sum_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b = a + 0 + b\" by simp\n  also have \"... >= 0 + b\" using assms(1) by simp\n  finally have \"a + b >= b\" by simp\n  moreover have \"b >= 0\" using assms(2) by simp\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b = a + 0 + b\" by simp\n  also have \"... >= 0 + b\" using assms(1) by simp\n  finally have \"a + b >= b\" by simp\n  moreover have \"b >= 0\" using assms(2) by simp\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sum_of_non_negativesV3": {"skill_name": "sum_of_non_negativesV3", "marker": "lemma sum_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b = a + b\" by simp\n  then have \"a + b >= 0 + 0\" using assms by (simp add: add_nonneg_nonneg)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b = a + b\" by simp\n  then have \"a + b >= 0 + 0\" using assms by (simp add: add_nonneg_nonneg)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negativity_of_squares": {"skill_name": "non_negativity_of_squares", "marker": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a > 0 \\<or> a < 0\" by auto\n    then show ?thesis\n    proof\n      assume \"a > 0\"\n      then have \"a * a > 0\" by (simp add: mult_pos_pos)\n      thus ?thesis by simp\n    next\n      assume \"a < 0\"\n      then have \"a * a > 0\" by (simp add: mult_neg_neg)\n      thus ?thesis by simp\n    qed\n  qed\nqed", "description": "-", "full_code": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a > 0 \\<or> a < 0\" by auto\n    then show ?thesis\n    proof\n      assume \"a > 0\"\n      then have \"a * a > 0\" by (simp add: mult_pos_pos)\n      thus ?thesis by simp\n    next\n      assume \"a < 0\"\n      then have \"a * a > 0\" by (simp add: mult_neg_neg)\n      thus ?thesis by simp\n    qed\n  qed\nqed", "origin": "do_request", "update_count": 0}, "non_negativity_of_squaresV2": {"skill_name": "non_negativity_of_squaresV2", "marker": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"a * a >= 0\" \n  proof (cases \"a >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"a < 0\" by simp\n    then have \"a * a = (-a) * (-a)\" by (simp add: field_simps)\n    also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n    finally show ?thesis .\n  qed\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"a * a >= 0\" \n  proof (cases \"a >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"a < 0\" by simp\n    then have \"a * a = (-a) * (-a)\" by (simp add: field_simps)\n    also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n    finally show ?thesis .\n  qed\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negativity_of_squaresV3": {"skill_name": "non_negativity_of_squaresV3", "marker": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show ?thesis \n    using mult_nonneg_nonneg[of a a] \n    by auto\nqed", "description": "-", "full_code": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show ?thesis \n    using mult_nonneg_nonneg[of a a] \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "non_negativity_of_squaresV4": {"skill_name": "non_negativity_of_squaresV4", "marker": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"a * a >= 0\" \n  proof (cases \"a >= 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a < 0\" by simp\n    hence \"a * a = -a * -a\" by (simp add: mult_neg_neg)\n    also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n    finally show ?thesis by simp\n  qed\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"a * a >= 0\" \n  proof (cases \"a >= 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a < 0\" by simp\n    hence \"a * a = -a * -a\" by (simp add: mult_neg_neg)\n    also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n    finally show ?thesis by simp\n  qed\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negativity_of_squaresV5": {"skill_name": "non_negativity_of_squaresV5", "marker": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"a^2 >= 0\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"a > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"a < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\nqed", "description": "-", "full_code": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"a^2 >= 0\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"a > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"a < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\nqed", "origin": "do_request", "update_count": 0}, "linear_equation_solution": {"skill_name": "linear_equation_solution", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  then have \"2 * b = c - 3 * d\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  then have \"2 * b = c - 3 * d\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_solutionV2": {"skill_name": "linear_equation_solutionV2", "marker": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0 : \"m * a + n * b = p\"\n    and h1 : \"m > 0\"\n    and h2 : \"n > 0\"\n  shows \"b = (p - m * a) / n\"\nproof -\n  have eq: \"m * a + n * b = p\" using h0 by simp\n  then have \"n * b = p - m * a\" by (simp add: algebra_simps)\n  then have \"b = (p - m * a) / n\" using h2 by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0 : \"m * a + n * b = p\"\n    and h1 : \"m > 0\"\n    and h2 : \"n > 0\"\n  shows \"b = (p - m * a) / n\"\nproof -\n  have eq: \"m * a + n * b = p\" using h0 by simp\n  then have \"n * b = p - m * a\" by (simp add: algebra_simps)\n  then have \"b = (p - m * a) / n\" using h2 by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_linear_equation": {"skill_name": "solve_linear_equation", "marker": "lemma solve_linear_equation:\n  fixes a b :: real\n  assumes h0: \"m * a + c = b\"\n  shows \"c = b - m * a\"\nproof -\n  have \"m * a + c - m * a = b - m * a\" using h0 by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma solve_linear_equation:\n  fixes a b :: real\n  assumes h0: \"m * a + c = b\"\n  shows \"c = b - m * a\"\nproof -\n  have \"m * a + c - m * a = b - m * a\" using h0 by simp\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_solutionV3": {"skill_name": "linear_equation_solutionV3", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m * a + c = n\"\n    and h1 : \"a = k\"\n  shows \"m * k + c = n\"\nproof -\n  have eq: \"m * a + c = n\" using h0 by simp\n  have \"m * k + c = n\" using h1 eq by simp\n  show ?thesis by (metis \\<open>m * k + c = n\\<close>)\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m * a + c = n\"\n    and h1 : \"a = k\"\n  shows \"m * k + c = n\"\nproof -\n  have eq: \"m * a + c = n\" using h0 by simp\n  have \"m * k + c = n\" using h1 eq by simp\n  show ?thesis by (metis \\<open>m * k + c = n\\<close>)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "algebra_2varlinear_generic": {"skill_name": "algebra_2varlinear_generic", "marker": "lemma algebra_2varlinear_generic:\n  fixes a b c d :: complex\n  assumes h0 : \"a + b = c\"\n    and h1 : \"2 * a + b = d\"\n  shows \"b = c - a \\<and> a = (d - b) / 2\"\nproof -\n  have b_expr: \"b = c - a\" using h0 by (auto simp: field_simps)\n  have a_expr: \"2 * a + (c - a) = d\" using b_expr h1 by simp\n  then have \"a = (d - (c - a)) / 2\" by (simp add: field_simps)\n  thus ?thesis using b_expr by simp\nqed", "description": "-", "full_code": "lemma algebra_2varlinear_generic:\n  fixes a b c d :: complex\n  assumes h0 : \"a + b = c\"\n    and h1 : \"2 * a + b = d\"\n  shows \"b = c - a \\<and> a = (d - b) / 2\"\nproof -\n  have b_expr: \"b = c - a\" using h0 by (auto simp: field_simps)\n  have a_expr: \"2 * a + (c - a) = d\" using b_expr h1 by simp\n  then have \"a = (d - (c - a)) / 2\" by (simp add: field_simps)\n  thus ?thesis using b_expr by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "case_analysis_modulo_4": {"skill_name": "case_analysis_modulo_4", "marker": "lemma case_analysis_modulo_4:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" by (simp add: mod_less)\n  then have \"a mod 4 \\<in> {0, 1, 2, 3}\" by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma case_analysis_modulo_4:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" by (simp add: mod_less)\n  then have \"a mod 4 \\<in> {0, 1, 2, 3}\" by auto\n  then show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "non_negativity_of_squaresV6": {"skill_name": "non_negativity_of_squaresV6", "marker": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  thus ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a * a > 0\" using mult_pos_pos[of \"a\" \"a\"] by sos\n    thus ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma non_negativity_of_squares:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  thus ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a * a > 0\" using mult_pos_pos[of \"a\" \"a\"] by sos\n    thus ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "linear_combination": {"skill_name": "linear_combination", "marker": "lemma linear_combination:\n  fixes x e :: real\n  assumes h0: \"x + e = c\"\n  shows \"e = c - x\"\n  using assms by auto", "description": "-", "full_code": "lemma linear_combination:\n  fixes x e :: real\n  assumes h0: \"x + e = c\"\n  shows \"e = c - x\"\n  using assms by auto", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4V2": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4V2", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have \"x = -4\" by simp\n  have \"e = 7 - (-4)\" using e_expr by (metis \\<open>x = - 4\\<close>)\n  then show ?thesis by (metis \\<open>x = - 4\\<close> add.commute diff_minus_eq_add numeral_Bit0 numeral_eq_iff numeral_plus_numeral semiring_norm(7))\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have \"x = -4\" by simp\n  have \"e = 7 - (-4)\" using e_expr by (metis \\<open>x = - 4\\<close>)\n  then show ?thesis by (metis \\<open>x = - 4\\<close> add.commute diff_minus_eq_add numeral_Bit0 numeral_eq_iff numeral_plus_numeral semiring_norm(7))\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "simplify_sqrt": {"skill_name": "simplify_sqrt", "marker": "lemma simplify_sqrt:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt(a) * sqrt(b) = sqrt(a * b)\"\nproof -\n  have \"sqrt(a) * sqrt(b) = sqrt(a * b) * sqrt(1)\" \n    by (metis mult_cancel_left2 real_sqrt_eq_1_iff real_sqrt_mult)\n  then show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma simplify_sqrt:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt(a) * sqrt(b) = sqrt(a * b)\"\nproof -\n  have \"sqrt(a) * sqrt(b) = sqrt(a * b) * sqrt(1)\" \n    by (metis mult_cancel_left2 real_sqrt_eq_1_iff real_sqrt_mult)\n  then show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "divisibility_properties": {"skill_name": "divisibility_properties", "marker": "lemma divisibility_properties:\n  fixes a b :: nat\n  assumes \"a mod b = 0\"\n  shows \"\\<exists>k. a = b * k\" \nproof -\n  obtain q where \"a = b * q\" \"a mod b = 0\" using assms by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma divisibility_properties:\n  fixes a b :: nat\n  assumes \"a mod b = 0\"\n  shows \"\\<exists>k. a = b * k\" \nproof -\n  obtain q where \"a = b * q\" \"a mod b = 0\" using assms by auto\n  then show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  have x_value: \"x = 3 - 7\" by (metis \\<open>x + 7 = 3\\<close> add.commute add_diff_cancel dbl_inc_simps(3) h0)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  have x_value: \"x = 3 - 7\" by (metis \\<open>x + 7 = 3\\<close> add.commute add_diff_cancel dbl_inc_simps(3) h0)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "rearranging_equation": {"skill_name": "rearranging_equation", "marker": "lemma rearranging_equation:\n  fixes a b c :: real\n  shows \"b = a - c \\<longleftrightarrow> a = b + c\"\nproof -\n  have \"b = a - c \\<Longrightarrow> a = b + c\"\n    by (simp add: field_simps)\n  moreover have \"a = b + c \\<Longrightarrow> b = a - c\"\n    by (simp add: field_simps)\n  ultimately show \"b = a - c \\<longleftrightarrow> a = b + c\" by blast\nqed", "description": "-", "full_code": "lemma rearranging_equation:\n  fixes a b c :: real\n  shows \"b = a - c \\<longleftrightarrow> a = b + c\"\nproof -\n  have \"b = a - c \\<Longrightarrow> a = b + c\"\n    by (simp add: field_simps)\n  moreover have \"a = b + c \\<Longrightarrow> b = a - c\"\n    by (simp add: field_simps)\n  ultimately show \"b = a - c \\<longleftrightarrow> a = b + c\" by blast\nqed", "origin": "do_request", "update_count": 0}, "rearranging_equationV2": {"skill_name": "rearranging_equationV2", "marker": "lemma rearranging_equation:\n  fixes a b c :: real\n  shows \"b = a - c \\<longleftrightarrow> a = b + c\"\nproof -\n  {\n    assume \"b = a - c\"\n    then have \"a = b + c\" by (simp add: field_simps)\n  }\n  moreover\n  {\n    assume \"a = b + c\"\n    then have \"b = a - c\" by (simp add: field_simps)\n  }\n  ultimately show \"b = a - c \\<longleftrightarrow> a = b + c\" by blast\nqed", "description": "-", "full_code": "lemma rearranging_equation:\n  fixes a b c :: real\n  shows \"b = a - c \\<longleftrightarrow> a = b + c\"\nproof -\n  {\n    assume \"b = a - c\"\n    then have \"a = b + c\" by (simp add: field_simps)\n  }\n  moreover\n  {\n    assume \"a = b + c\"\n    then have \"b = a - c\" by (simp add: field_simps)\n  }\n  ultimately show \"b = a - c \\<longleftrightarrow> a = b + c\" by blast\nqed", "origin": "do_request", "update_count": 0}, "rearranging_equationV3": {"skill_name": "rearranging_equationV3", "marker": "lemma rearranging_equation:\n  fixes a b c :: real\n  shows \"b = a - c \\<longleftrightarrow> a = b + c\"\nproof -\n  {\n    assume h1: \"b = a - c\"\n    have \"a = b + c\" using h1 by simp\n  }\n  moreover\n  {\n    assume h2: \"a = b + c\"\n    have \"b = a - c\" using h2 by simp\n  }\n  ultimately show ?thesis by blast\nqed", "description": "-", "full_code": "lemma rearranging_equation:\n  fixes a b c :: real\n  shows \"b = a - c \\<longleftrightarrow> a = b + c\"\nproof -\n  {\n    assume h1: \"b = a - c\"\n    have \"a = b + c\" using h1 by simp\n  }\n  moreover\n  {\n    assume h2: \"a = b + c\"\n    have \"b = a - c\" using h2 by simp\n  }\n  ultimately show ?thesis by blast\nqed", "origin": "do_request", "update_count": 0}, "rearranging_equationV4": {"skill_name": "rearranging_equationV4", "marker": "lemma rearranging_equation:\n  fixes a b c :: real\n  shows \"b = a - c \\<longleftrightarrow> a = b + c\"\nproof -\n  have \"b = a - c \\<longrightarrow> a = b + c\" \n    by (simp add: field_simps)\n  have \"a = b + c \\<longrightarrow> b = a - c\" \n    by (simp add: field_simps)\n  show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma rearranging_equation:\n  fixes a b c :: real\n  shows \"b = a - c \\<longleftrightarrow> a = b + c\"\nproof -\n  have \"b = a - c \\<longrightarrow> a = b + c\" \n    by (simp add: field_simps)\n  have \"a = b + c \\<longrightarrow> b = a - c\" \n    by (simp add: field_simps)\n  show ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "rearranging_equationV5": {"skill_name": "rearranging_equationV5", "marker": "lemma rearranging_equation:\n  fixes a b c :: real\n  shows \"b = a - c \\<longleftrightarrow> a = b + c\"\nproof -\n  have \"b = a - c \\<longrightarrow> a = b + c\" \n    by auto\n  have \"a = b + c \\<longrightarrow> b = a - c\" \n    by auto\n  show \"b = a - c \\<longleftrightarrow> a = b + c\" \n    by auto\nqed", "description": "-", "full_code": "lemma rearranging_equation:\n  fixes a b c :: real\n  shows \"b = a - c \\<longleftrightarrow> a = b + c\"\nproof -\n  have \"b = a - c \\<longrightarrow> a = b + c\" \n    by auto\n  have \"a = b + c \\<longrightarrow> b = a - c\" \n    by auto\n  show \"b = a - c \\<longleftrightarrow> a = b + c\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "expand_expression": {"skill_name": "expand_expression", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: lhs)\n  have rhs: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  show ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n      by sos\n    also have \"... = (x * y)^2 + (x^2 + y^2) + 1\"\n      by (simp add: algebra_simps)\n    finally show ?thesis\n      by (simp add: rhs)\n  qed\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: lhs)\n  have rhs: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  show ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n      by sos\n    also have \"... = (x * y)^2 + (x^2 + y^2) + 1\"\n      by (simp add: algebra_simps)\n    finally show ?thesis\n      by (simp add: rhs)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "expand_expressionV2": {"skill_name": "expand_expressionV2", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have left_side: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  have right_side: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    using left_side by simp\n  have \"x^2 + 2 * x * y + y^2 = (x + y)^2\"\n    by sos\n  thus ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n      by sos\n    also have \"... = (x * y)^2 + (x^2 + 2 * x * y + y^2) - 2 * (x * y) + 1\"\n      by simp\n    finally show ?thesis\n      unfolding right_side by simp\n  qed\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have left_side: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  have right_side: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    using left_side by simp\n  have \"x^2 + 2 * x * y + y^2 = (x + y)^2\"\n    by sos\n  thus ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n      by sos\n    also have \"... = (x * y)^2 + (x^2 + 2 * x * y + y^2) - 2 * (x * y) + 1\"\n      by simp\n    finally show ?thesis\n      unfolding right_side by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "expand_expressionV3": {"skill_name": "expand_expressionV3", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have left_side: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have right_side: \"(x^2 * y^2 + x^2 + y^2 + 1) = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: power2_eq_square)\n  show ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n      by (simp add: left_side)\n    also have \"... = (x * y)^2 + x^2 + y^2 + 1\" using algebra_simps by auto\n    finally show ?thesis using right_side by simp\n  qed\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have left_side: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have right_side: \"(x^2 * y^2 + x^2 + y^2 + 1) = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: power2_eq_square)\n  show ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n      by (simp add: left_side)\n    also have \"... = (x * y)^2 + x^2 + y^2 + 1\" using algebra_simps by auto\n    finally show ?thesis using right_side by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "prime_product": {"skill_name": "prime_product", "marker": "lemma prime_product:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  then have \"a * b = a * 1 \\<or> a * b = 1 * b\" using prime_def by (metis assms(3) comm_monoid_mult_class.mult_1 dvd_triv_right mult.comm_neutral prime_nat_iff)\n  {\n    assume \"a > 1\"\n    then have \"b = 1\" using prime_def assms by (metis less_not_refl2 prime_product)\n  }\n  then show \"a = 1 \\<or> b = 1\" using prime_def assms by fastforce\nqed", "description": "-", "full_code": "lemma prime_product:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  then have \"a * b = a * 1 \\<or> a * b = 1 * b\" using prime_def by (metis assms(3) comm_monoid_mult_class.mult_1 dvd_triv_right mult.comm_neutral prime_nat_iff)\n  {\n    assume \"a > 1\"\n    then have \"b = 1\" using prime_def assms by (metis less_not_refl2 prime_product)\n  }\n  then show \"a = 1 \\<or> b = 1\" using prime_def assms by fastforce\nqed", "origin": "do_request", "update_count": 0}, "non_negative_sum": {"skill_name": "non_negative_sum", "marker": "lemma non_negative_sum:\n  fixes a b c :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\"\n  shows \"a + b + c >= 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by simp\n  moreover have \"a + b >= 0\" \n  proof -\n    have \"a + b = a + b\" by simp\n    moreover have \"a >= 0\" using assms(1) by simp\n    moreover have \"b >= 0\" using assms(2) by simp\n    ultimately show \"a + b >= 0\" by (metis add_nonneg_nonneg)\n  qed\n  ultimately have \"a + b + c >= 0 + c\" by (simp add: add_nonneg_nonneg)\n  thus ?thesis by (simp add: assms(3))\nqed", "description": "-", "full_code": "lemma non_negative_sum:\n  fixes a b c :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\"\n  shows \"a + b + c >= 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by simp\n  moreover have \"a + b >= 0\" \n  proof -\n    have \"a + b = a + b\" by simp\n    moreover have \"a >= 0\" using assms(1) by simp\n    moreover have \"b >= 0\" using assms(2) by simp\n    ultimately show \"a + b >= 0\" by (metis add_nonneg_nonneg)\n  qed\n  ultimately have \"a + b + c >= 0 + c\" by (simp add: add_nonneg_nonneg)\n  thus ?thesis by (simp add: assms(3))\nqed", "origin": "do_request", "update_count": 0}, "non_negative_sumV2": {"skill_name": "non_negative_sumV2", "marker": "lemma non_negative_sum:\n  fixes a b c :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\"\n  shows \"a + b + c >= 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by auto\n  moreover have \"a + b >= 0\" \n  proof -\n    have \"a + b = a + b\" by simp\n    then have \"a + b >= 0 + 0\" using assms(1) assms(2) \n      by (simp add: add_nonneg_nonneg)\n    thus ?thesis by simp\n  qed\n  moreover have \"c >= 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma non_negative_sum:\n  fixes a b c :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\"\n  shows \"a + b + c >= 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by auto\n  moreover have \"a + b >= 0\" \n  proof -\n    have \"a + b = a + b\" by simp\n    then have \"a + b >= 0 + 0\" using assms(1) assms(2) \n      by (simp add: add_nonneg_nonneg)\n    thus ?thesis by simp\n  qed\n  moreover have \"c >= 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "linear_function_difference": {"skill_name": "linear_function_difference", "marker": "lemma linear_function_difference:\n  fixes m c :: real and x y :: real\n  assumes \"f x = m * x + c\" and \"f y = m * y + c\"\n  shows \"f y - f x = m * (y - x)\"\nproof -\n  have \"f y = m * y + c\" using assms(2) by simp\n  have \"f x = m * x + c\" using assms(1) by simp\n  then have \"f y - f x = (m * y + c) - (m * x + c)\" \n    by (metis assms(2))\n  then have \"f y - f x = m * y + c - m * x - c\" \n    by (simp)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma linear_function_difference:\n  fixes m c :: real and x y :: real\n  assumes \"f x = m * x + c\" and \"f y = m * y + c\"\n  shows \"f y - f x = m * (y - x)\"\nproof -\n  have \"f y = m * y + c\" using assms(2) by simp\n  have \"f x = m * x + c\" using assms(1) by simp\n  then have \"f y - f x = (m * y + c) - (m * x + c)\" \n    by (metis assms(2))\n  then have \"f y - f x = m * y + c - m * x - c\" \n    by (simp)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "linear_function_differenceV2": {"skill_name": "linear_function_differenceV2", "marker": "lemma linear_function_difference:\n  fixes m c :: real and x y :: real\n  assumes \"f x = m * x + c\" and \"f y = m * y + c\"\n  shows \"f y - f x = m * (y - x)\"\nproof -\n  have \"f y - f x = (m * y + c) - (m * x + c)\"\n    using assms by simp\n  then have \"f y - f x = (m * y + c - m * x - c)\"\n    by (simp)\n  then have \"f y - f x = m * y - m * x\"\n    by (simp add: algebra_simps)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma linear_function_difference:\n  fixes m c :: real and x y :: real\n  assumes \"f x = m * x + c\" and \"f y = m * y + c\"\n  shows \"f y - f x = m * (y - x)\"\nproof -\n  have \"f y - f x = (m * y + c) - (m * x + c)\"\n    using assms by simp\n  then have \"f y - f x = (m * y + c - m * x - c)\"\n    by (simp)\n  then have \"f y - f x = m * y - m * x\"\n    by (simp add: algebra_simps)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "prime_productV2": {"skill_name": "prime_productV2", "marker": "lemma prime_product:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\" \n      using prime_def by (metis assms(3) dvd_triv_left mult.right_neutral nat_neq_iff prime_nat_iff)\n    hence \"b = 1\" by (metis assms(1) nat_mult_eq_cancel1)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\" \n      using prime_def by (metis assms(3) dvd_triv_right mult_1 nat_neq_iff prime_nat_iff)\n    hence \"a = 1\" by (metis assms(3) dvdI mult_delta_right mult_right_cancel nat_int_comparison(1) prime_nat_iff prime_product)\n  }\n  then show \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "description": "-", "full_code": "lemma prime_product:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\" \n      using prime_def by (metis assms(3) dvd_triv_left mult.right_neutral nat_neq_iff prime_nat_iff)\n    hence \"b = 1\" by (metis assms(1) nat_mult_eq_cancel1)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\" \n      using prime_def by (metis assms(3) dvd_triv_right mult_1 nat_neq_iff prime_nat_iff)\n    hence \"a = 1\" by (metis assms(3) dvdI mult_delta_right mult_right_cancel nat_int_comparison(1) prime_nat_iff prime_product)\n  }\n  then show \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV2": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV2", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have simplified: \"x + 7 = 3\" by (metis add.commute add_diff_cancel dbl_def dbl_inc_simps(3) dbl_simps(3) eq_simplified h0 mult_2)\n  have x_value: \"x = 3 - 7\" using simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have simplified: \"x + 7 = 3\" by (metis add.commute add_diff_cancel dbl_def dbl_inc_simps(3) dbl_simps(3) eq_simplified h0 mult_2)\n  have x_value: \"x = 3 - 7\" using simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e z :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"z = 2 * x + e + 5\"\n  shows \"e = 11 \\<and> x = (-4) \\<and> z = 8\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then have \"e = 11\" using e_value_final by simp\n  have z_value: \"z = 2 * (-4) + e + 5\" using h2 x_value_final e_value_final by simp\n  then have \"z = -8 + 11 + 5\" by (metis \\<open>e = 11\\<close> add.commute add.inverse_inverse add_diff_cancel_left' add_diff_cancel_right' dbl_def dbl_inc_def dbl_inc_simps(3) dbl_inc_simps(5) dbl_simps(3) dbl_simps(5) diff_add_cancel diff_conv_add_uminus diff_minus_eq_add h1 h2 minus_diff_eq mult_2 uminus_add_conv_diff x_value_final)\n  then show ?thesis using x_value_final e_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e z :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"z = 2 * x + e + 5\"\n  shows \"e = 11 \\<and> x = (-4) \\<and> z = 8\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then have \"e = 11\" using e_value_final by simp\n  have z_value: \"z = 2 * (-4) + e + 5\" using h2 x_value_final e_value_final by simp\n  then have \"z = -8 + 11 + 5\" by (metis \\<open>e = 11\\<close> add.commute add.inverse_inverse add_diff_cancel_left' add_diff_cancel_right' dbl_def dbl_inc_def dbl_inc_simps(3) dbl_inc_simps(5) dbl_simps(3) dbl_simps(5) diff_add_cancel diff_conv_add_uminus diff_minus_eq_add h1 h2 minus_diff_eq mult_2 uminus_add_conv_diff x_value_final)\n  then show ?thesis using x_value_final e_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV3": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV3", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by simp\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by simp\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "mod_sum": {"skill_name": "mod_sum", "marker": "lemma mod_sum:\n  fixes a b :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"a + b = (a mod m) + (b mod m) + m * ((a div m) + (b div m))\" \n    by (auto simp: field_simps)\n  then have \"(a + b) mod m = ((a mod m) + (b mod m) + m * ((a div m) + (b div m))) mod m\"\n    by simp\n  also have \"... = ((a mod m) + (b mod m)) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes a b :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"a + b = (a mod m) + (b mod m) + m * ((a div m) + (b div m))\" \n    by (auto simp: field_simps)\n  then have \"(a + b) mod m = ((a mod m) + (b mod m) + m * ((a div m) + (b div m))) mod m\"\n    by simp\n  also have \"... = ((a mod m) + (b mod m)) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_extended": {"skill_name": "mathd_algebra_109_extended", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  hence \"12 + 2 * b = c\" using h2 by simp\n  thus \"b = 0\" \n    by (metis ab_left_minus dbl_def dbl_simps(3) double_zero_sym h2 minus_add_cancel mult_2)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  hence \"12 + 2 * b = c\" using h2 by simp\n  thus \"b = 0\" \n    by (metis ab_left_minus dbl_def dbl_simps(3) double_zero_sym h2 minus_add_cancel mult_2)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_extendedV2": {"skill_name": "mathd_algebra_109_extendedV2", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 2*a + b\"\n  shows \"b = 0\" and \"c = 8\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show \"b = 0\" using `2 * b = 0` by simp\n  have c_eq: \"c = 2*a + b\" using h2 h1 by simp\n  thus \"c = 8\" using `b = 0` by (metis add.comm_neutral dbl_def dbl_simps(3) dbl_simps(5) h1 mult_2)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 2*a + b\"\n  shows \"b = 0\" and \"c = 8\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show \"b = 0\" using `2 * b = 0` by simp\n  have c_eq: \"c = 2*a + b\" using h2 h1 by simp\n  thus \"c = 8\" using `b = 0` by (metis add.comm_neutral dbl_def dbl_simps(3) dbl_simps(5) h1 mult_2)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_extendedV3": {"skill_name": "mathd_algebra_109_extendedV3", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  hence \"2 * b = c - 12\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  hence \"2 * b = c - 12\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_slope": {"skill_name": "linear_slope", "marker": "lemma linear_slope:\n  fixes m c :: real and x y :: real\n  assumes \"f x = m * x + c\" and \"f y = m * y + c\"\n  shows \"f x - f y = m * (x - y)\"\nproof -\n  have \"f x = m * x + c\" using assms(1) by simp\n  have \"f y = m * y + c\" using assms(2) by simp\n  then have \"f x - f y = (m * x + c) - (m * y + c)\"\n    by (metis assms(1))\n  then have \"f x - f y = m * x + c - m * y - c\"\n    by (simp)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma linear_slope:\n  fixes m c :: real and x y :: real\n  assumes \"f x = m * x + c\" and \"f y = m * y + c\"\n  shows \"f x - f y = m * (x - y)\"\nproof -\n  have \"f x = m * x + c\" using assms(1) by simp\n  have \"f y = m * y + c\" using assms(2) by simp\n  then have \"f x - f y = (m * x + c) - (m * y + c)\"\n    by (metis assms(1))\n  then have \"f x - f y = m * x + c - m * y - c\"\n    by (simp)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "non_zero_multiplication": {"skill_name": "non_zero_multiplication", "marker": "lemma non_zero_multiplication:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a * c = b * c\"\nproof -\n  from assms(1) have \"a * c = b * c\" \n    by (simp add: assms(1))\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_zero_multiplication:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a * c = b * c\"\nproof -\n  from assms(1) have \"a * c = b * c\" \n    by (simp add: assms(1))\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "non_zero_multiplicationV2": {"skill_name": "non_zero_multiplicationV2", "marker": "lemma non_zero_multiplication:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a * c = b * c\"\nproof -\n  have \"a * c = b * c\"\n  proof -\n    from assms(1) have \"b = a\" by simp\n    thus ?thesis \n      using assms(1) by (simp add: mult.commute)\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_zero_multiplication:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a * c = b * c\"\nproof -\n  have \"a * c = b * c\"\n  proof -\n    from assms(1) have \"b = a\" by simp\n    thus ?thesis \n      using assms(1) by (simp add: mult.commute)\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "substitution_in_linear_equation": {"skill_name": "substitution_in_linear_equation", "marker": "theorem substitution_in_linear_equation:\n  fixes a b :: real\n  assumes h0 : \"m * a + n * b = c\"\n    and h1 : \"a = k\"\n  shows \"m * k + n * b = c\"\nproof -\n  have eq: \"m * a + n * b = c\" using h0 by simp\n  then show ?thesis using h1 by simp\nqed", "description": "-", "full_code": "theorem substitution_in_linear_equation:\n  fixes a b :: real\n  assumes h0 : \"m * a + n * b = c\"\n    and h1 : \"a = k\"\n  shows \"m * k + n * b = c\"\nproof -\n  have eq: \"m * a + n * b = c\" using h0 by simp\n  then show ?thesis using h1 by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_linear_equation_generalized": {"skill_name": "solve_linear_equation_generalized", "marker": "theorem solve_linear_equation_generalized:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using assms by simp\n  then have \"a * x = c - b\" by simp\n  then show \"x = (c - b) / a\" using assms(1) by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem solve_linear_equation_generalized:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using assms by simp\n  then have \"a * x = c - b\" by simp\n  then show \"x = (c - b) / a\" using assms(1) by (auto simp: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_linear_equation_with_parameters": {"skill_name": "solve_linear_equation_with_parameters", "marker": "theorem solve_linear_equation_with_parameters:\n  fixes a b c :: real\n  assumes h0: \"a > 0\"\n    and h1: \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have eq: \"a * x + b = c\" using h1 by simp\n  then have \"a * x = c - b\" by auto\n  then show \"x = (c - b) / a\" using h0 by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem solve_linear_equation_with_parameters:\n  fixes a b c :: real\n  assumes h0: \"a > 0\"\n    and h1: \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have eq: \"a * x + b = c\" using h1 by simp\n  then have \"a * x = c - b\" by auto\n  then show \"x = (c - b) / a\" using h0 by (auto simp: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_slopeV2": {"skill_name": "linear_slopeV2", "marker": "lemma linear_slope:\n  fixes m c :: real and x y :: real\n  assumes \"f x = m * x + c\" and \"f y = m * y + c\"\n  shows \"f x - f y = m * (x - y)\"\nproof -\n  have f_x: \"f x = m * x + c\" using assms(1) by simp\n  have f_y: \"f y = m * y + c\" using assms(2) by simp\n  have \"f x - f y = (m * x + c) - (m * y + c)\" \n    by (simp add: f_x f_y)\n  then have \"f x - f y = m * x + c - m * y - c\" \n    by (simp)\n  then have \"f x - f y = m * x - m * y\" \n    by (simp add: algebra_simps)\n  thus ?thesis \n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma linear_slope:\n  fixes m c :: real and x y :: real\n  assumes \"f x = m * x + c\" and \"f y = m * y + c\"\n  shows \"f x - f y = m * (x - y)\"\nproof -\n  have f_x: \"f x = m * x + c\" using assms(1) by simp\n  have f_y: \"f y = m * y + c\" using assms(2) by simp\n  have \"f x - f y = (m * x + c) - (m * y + c)\" \n    by (simp add: f_x f_y)\n  then have \"f x - f y = m * x + c - m * y - c\" \n    by (simp)\n  then have \"f x - f y = m * x - m * y\" \n    by (simp add: algebra_simps)\n  thus ?thesis \n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "non_negative_squares": {"skill_name": "non_negative_squares", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"0 \\<le> a^2\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then show ?thesis \n    proof (cases \"a > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n      also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n      finally show ?thesis by simp\n    qed\n  qed\nnext\n  have \"b^2 = b * b\" by sos\n  then show \"0 \\<le> b^2\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then show ?thesis \n    proof (cases \"b > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n      also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n      finally show ?thesis by simp\n    qed\n  qed\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"0 \\<le> a^2\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then show ?thesis \n    proof (cases \"a > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n      also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n      finally show ?thesis by simp\n    qed\n  qed\nnext\n  have \"b^2 = b * b\" by sos\n  then show \"0 \\<le> b^2\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then show ?thesis \n    proof (cases \"b > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n      also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n      finally show ?thesis by simp\n    qed\n  qed\nqed", "origin": "do_request", "update_count": 0}, "non_negative_squaresV2": {"skill_name": "non_negative_squaresV2", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  have \"b^2 = b * b\" by sos\n  have \"0 \\<le> a^2\" \n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"a > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"a < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  moreover have \"0 \\<le> b^2\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"b > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"b < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  ultimately show \"0 \\<le> a^2\" and \"0 \\<le> b^2\" by blast+\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  have \"b^2 = b * b\" by sos\n  have \"0 \\<le> a^2\" \n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"a > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"a < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  moreover have \"0 \\<le> b^2\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"b > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"b < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  ultimately show \"0 \\<le> a^2\" and \"0 \\<le> b^2\" by blast+\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_v2": {"skill_name": "mathd_algebra_109_v2", "marker": "theorem mathd_algebra_109_v2:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  then have \"12 + 2 * b = 12\" by simp\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_v2:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  then have \"12 + 2 * b = 12\" by simp\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_v3": {"skill_name": "mathd_algebra_109_v3", "marker": "theorem mathd_algebra_109_v3:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 2 * b\"\n  shows \"c = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by simp\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_left_right)\n  hence \"b = 0\" by auto\n  thus \"c = 0\" using h2 by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_v3:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 2 * b\"\n  shows \"c = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by simp\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_left_right)\n  hence \"b = 0\" by auto\n  thus \"c = 0\" using h2 by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "non_zero_multiplicationV3": {"skill_name": "non_zero_multiplicationV3", "marker": "lemma non_zero_multiplication:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a * c = b * c\"\nproof -\n  have \"a * c = b * c\"\n  proof -\n    from assms(1) have \"b * c = a * c\" by (simp add: assms(1))\n    thus ?thesis by auto\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma non_zero_multiplication:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a * c = b * c\"\nproof -\n  have \"a * c = b * c\"\n  proof -\n    from assms(1) have \"b * c = a * c\" by (simp add: assms(1))\n    thus ?thesis by auto\n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "non_zero_multiplicationV4": {"skill_name": "non_zero_multiplicationV4", "marker": "lemma non_zero_multiplication:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a * c = b * c\"\nproof -\n  have \"a * c = b * c\" using assms by (metis assms(1) mult.commute)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_zero_multiplication:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a * c = b * c\"\nproof -\n  have \"a * c = b * c\" using assms by (metis assms(1) mult.commute)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "non_zero_multiplicationV5": {"skill_name": "non_zero_multiplicationV5", "marker": "lemma non_zero_multiplication:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a * c = b * c\"\nproof -\n  have \"a * c = b * c\" \n  proof -\n    from assms(1) have \"a = b\" by auto\n    then show ?thesis \n      by (metis assms(1) mult.commute) \n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma non_zero_multiplication:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a * c = b * c\"\nproof -\n  have \"a * c = b * c\" \n  proof -\n    from assms(1) have \"a = b\" by auto\n    then show ?thesis \n      by (metis assms(1) mult.commute) \n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "min_value_of_squares": {"skill_name": "min_value_of_squares", "marker": "lemma min_value_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  have \"y^2 = y * y\" by sos\n  have \"x^2 + y^2 = (x * x) + (y * y)\" by sos\n  moreover have \"x^2 >= 0\" \n  proof (cases \"x = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x \\<noteq> 0\" by simp\n    then have \"x > 0 \\<or> x < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"x > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"x < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  moreover have \"y^2 >= 0\"\n  proof (cases \"y = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"y \\<noteq> 0\" by simp\n    then have \"y > 0 \\<or> y < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"y > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"y < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  ultimately have \"x^2 >= 0\" and \"y^2 >= 0\" by blast+\n  then show \"x^2 + y^2 >= 0\" \n    by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma min_value_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  have \"y^2 = y * y\" by sos\n  have \"x^2 + y^2 = (x * x) + (y * y)\" by sos\n  moreover have \"x^2 >= 0\" \n  proof (cases \"x = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x \\<noteq> 0\" by simp\n    then have \"x > 0 \\<or> x < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"x > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"x < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  moreover have \"y^2 >= 0\"\n  proof (cases \"y = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"y \\<noteq> 0\" by simp\n    then have \"y > 0 \\<or> y < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"y > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"y < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  ultimately have \"x^2 >= 0\" and \"y^2 >= 0\" by blast+\n  then show \"x^2 + y^2 >= 0\" \n    by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "units_digit_of_square": {"skill_name": "units_digit_of_square", "marker": "lemma units_digit_of_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  have \"n = 10 * (n div 10) + (n mod 10)\" by auto\n  then have \"n^2 = (10 * (n div 10) + (n mod 10))^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * (n mod 10) + (n mod 10)^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2\"\n    by (simp add: mult.assoc)\n  then have \"(n^2) mod 10 = ((n mod 10)^2) mod 10\"\n    by (metis power_mod)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma units_digit_of_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  have \"n = 10 * (n div 10) + (n mod 10)\" by auto\n  then have \"n^2 = (10 * (n div 10) + (n mod 10))^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * (n mod 10) + (n mod 10)^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2\"\n    by (simp add: mult.assoc)\n  then have \"(n^2) mod 10 = ((n mod 10)^2) mod 10\"\n    by (metis power_mod)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "solve_for_x": {"skill_name": "solve_for_x", "marker": "lemma solve_for_x:\n  fixes x :: real\n  assumes \"9 = sqrt (x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" by simp\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma solve_for_x:\n  fixes x :: real\n  assumes \"9 = sqrt (x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" by simp\n  then show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_general": {"skill_name": "mathd_algebra_109_general", "marker": "theorem mathd_algebra_109_general:\n  fixes a b :: real\n  assumes h0: \"3*a + 2*b = c\"  \n    and h1: \"a = d\"            \n  shows \"b = (c - 3*d) / 2\"     \nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  have \"2 * b = c - 3 * d\" by (smt (verit) h0 h1)\n  show ?thesis using `2 * b = c - 3 * d` by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_general:\n  fixes a b :: real\n  assumes h0: \"3*a + 2*b = c\"  \n    and h1: \"a = d\"            \n  shows \"b = (c - 3*d) / 2\"     \nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  have \"2 * b = c - 3 * d\" by (smt (verit) h0 h1)\n  show ?thesis using `2 * b = c - 3 * d` by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "substitution_and_simplification": {"skill_name": "substitution_and_simplification", "marker": "lemma substitution_and_simplification:\n  fixes a b c :: real\n  assumes h0: \"k * a + m * b = n\"\n    and h1: \"a = p\"\n  shows \"k * p + m * b = n\"\nproof -\n  have \"k * a + m * b = n\" using h0 by simp\n  then have \"k * p + m * b = n\" using h1 by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma substitution_and_simplification:\n  fixes a b c :: real\n  assumes h0: \"k * a + m * b = n\"\n    and h1: \"a = p\"\n  shows \"k * p + m * b = n\"\nproof -\n  have \"k * a + m * b = n\" using h0 by simp\n  then have \"k * p + m * b = n\" using h1 by simp\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_for_xV2": {"skill_name": "solve_for_xV2", "marker": "lemma solve_for_x:\n  fixes x :: real\n  assumes \"9 = sqrt (x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" by simp\n  then have \"x = 81 - 9\" by (simp add: algebra_simps)\n  thus \"x = 72\" by simp\nqed", "description": "-", "full_code": "lemma solve_for_x:\n  fixes x :: real\n  assumes \"9 = sqrt (x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" by simp\n  then have \"x = 81 - 9\" by (simp add: algebra_simps)\n  thus \"x = 72\" by simp\nqed", "origin": "do_request", "update_count": 0}, "min_value_of_expression": {"skill_name": "min_value_of_expression", "marker": "lemma min_value_of_expression:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\" \n    by auto\n  have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y) - 1)^2 + (x + y)^2 + 0\" \n    by simp\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis \n    by sos\nqed", "description": "-", "full_code": "lemma min_value_of_expression:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\" \n    by auto\n  have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y) - 1)^2 + (x + y)^2 + 0\" \n    by simp\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis \n    by sos\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_2d_general": {"skill_name": "mathd_algebra_109_2d_general", "marker": "lemma mathd_algebra_109_2D_general:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\" \n      and h1 : \"a = x\"  \n  shows \"b = (12 - 3*x) / 2\"  \nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * x + 2 * b = 12\" using h1 by (metis h0)\n  hence \"2 * b = 12 - 3 * x\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_2D:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\" \n      and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed\n\nlemma mathd_algebra_109_2D_general:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\" \n      and h1 : \"a = x\"  \n  shows \"b = (12 - 3*x) / 2\"  \nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * x + 2 * b = 12\" using h1 by (metis h0)\n  hence \"2 * b = 12 - 3 * x\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_extendedV4": {"skill_name": "mathd_algebra_109_extendedV4", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\" and \"3*a + 2*b = 12 \\<Longrightarrow> b = (12 - 3*a)/2\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show \"b = 0\" using `2 * b = 0` by simp\nnext\n  show \"3*a + 2*b = 12 \\<Longrightarrow> b = (12 - 3*a)/2\"\n    by auto\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\" and \"3*a + 2*b = 12 \\<Longrightarrow> b = (12 - 3*a)/2\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show \"b = 0\" using `2 * b = 0` by simp\nnext\n  show \"3*a + 2*b = 12 \\<Longrightarrow> b = (12 - 3*a)/2\"\n    by auto\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "manipulate_equation": {"skill_name": "manipulate_equation", "marker": "lemma manipulate_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2 / x - (y + 2 / y) = 0\" using assms by auto\n  then have \"x - y + 2 / x - 2 / y = 0\" by auto\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma manipulate_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2 / x - (y + 2 / y) = 0\" using assms by auto\n  then have \"x - y + 2 / x - 2 / y = 0\" by auto\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "manipulate_equationV2": {"skill_name": "manipulate_equationV2", "marker": "lemma manipulate_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y + (2/x - 2/y) = 0\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma manipulate_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y + (2/x - 2/y) = 0\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "linear_equation_solutionV4": {"skill_name": "linear_equation_solutionV4", "marker": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  then show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  then show ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "min_value_of_non_negatives": {"skill_name": "min_value_of_non_negatives", "marker": "lemma min_value_of_non_negatives:\n  fixes a b c :: real\n  assumes \"a \\<ge> 0\" and \"b \\<ge> 0\" and \"c \\<ge> 0\"\n  shows \"a + b + c \\<ge> 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by auto\n  moreover have \"a + b \\<ge> 0\" \n  proof -\n    have \"a + b = a + b\" by simp\n    then have \"a + b \\<ge> 0 + 0\" using assms(1) assms(2) \n      by (simp add: add_nonneg_nonneg)\n    thus ?thesis by simp\n  qed\n  moreover have \"c \\<ge> 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma min_value_of_non_negatives:\n  fixes a b c :: real\n  assumes \"a \\<ge> 0\" and \"b \\<ge> 0\" and \"c \\<ge> 0\"\n  shows \"a + b + c \\<ge> 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by auto\n  moreover have \"a + b \\<ge> 0\" \n  proof -\n    have \"a + b = a + b\" by simp\n    then have \"a + b \\<ge> 0 + 0\" using assms(1) assms(2) \n      by (simp add: add_nonneg_nonneg)\n    thus ?thesis by simp\n  qed\n  moreover have \"c \\<ge> 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "sum_possible_values": {"skill_name": "sum_possible_values", "marker": "lemma sum_possible_values:\n  fixes N1 N2 :: nat\n  assumes \"N1 = 21\" \"N2 = 45\"\n  shows \"N1 + N2 = 66\"\nproof -\n  have \"N1 + N2 = 21 + 45\" using assms by simp\n  also have \"... = 66\" by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_possible_values:\n  fixes N1 N2 :: nat\n  assumes \"N1 = 21\" \"N2 = 45\"\n  shows \"N1 + N2 = 66\"\nproof -\n  have \"N1 + N2 = 21 + 45\" using assms by simp\n  also have \"... = 66\" by simp\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "polynomial_expansion": {"skill_name": "polynomial_expansion", "marker": "lemma polynomial_expansion:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have \" (x + y)^2 = (x + y) * (x + y)\" \n    by sos\n  also have \"... = x * (x + y) + y * (x + y)\" \n    by (simp add: distrib_right)\n  also have \"... = x * x + x * y + y * x + y * y\" \n    by (simp add: distrib_left)\n  also have \"... = x^2 + 2 * (x * y) + y^2\" \n    by sos\n  finally show ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma polynomial_expansion:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have \" (x + y)^2 = (x + y) * (x + y)\" \n    by sos\n  also have \"... = x * (x + y) + y * (x + y)\" \n    by (simp add: distrib_right)\n  also have \"... = x * x + x * y + y * x + y * y\" \n    by (simp add: distrib_left)\n  also have \"... = x^2 + 2 * (x * y) + y^2\" \n    by sos\n  finally show ?thesis \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "linear_equation_solutionV5": {"skill_name": "linear_equation_solutionV5", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0: \"m * a + n * b = p\"\n      and h1: \"a = c\"\n  shows \"m * c + n * b = p\"\nproof -\n  have eq: \"m * a + n * b = p\" using h0 by simp\n  have \"m * c + n * b = p\" using h1 eq by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0: \"m * a + n * b = p\"\n      and h1: \"a = c\"\n  shows \"m * c + n * b = p\"\nproof -\n  have eq: \"m * a + n * b = p\" using h0 by simp\n  have \"m * c + n * b = p\" using h1 eq by simp\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "cancel_div": {"skill_name": "cancel_div", "marker": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    by (metis add.commute assms(1) divide_divide_eq_left' divide_divide_eq_right divide_less_eq_1_pos divide_self_if less_numeral_extra(1) mult.commute mult.right_neutral real_divide_square_eq times_divide_eq_left times_divide_eq_right verit_comp_simplify1(1))\nqed", "description": "-", "full_code": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    by (metis add.commute assms(1) divide_divide_eq_left' divide_divide_eq_right divide_less_eq_1_pos divide_self_if less_numeral_extra(1) mult.commute mult.right_neutral real_divide_square_eq times_divide_eq_left times_divide_eq_right verit_comp_simplify1(1))\nqed", "origin": "do_request", "update_count": 0}, "cancel_divV2": {"skill_name": "cancel_divV2", "marker": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by (simp)\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then have \"x * a + b = c * x\"\n    using assms(1) by (simp add: mult.commute)\n  thus ?thesis\n    by sos\nqed", "description": "-", "full_code": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by (simp)\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then have \"x * a + b = c * x\"\n    using assms(1) by (simp add: mult.commute)\n  thus ?thesis\n    by sos\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareqV2": {"skill_name": "algebra_2varlineareqV2", "marker": "theorem algebra_2varlineareq:\n  fixes x e :: complex\n  assumes h0 : \"x + e = k\"  \n    and h1 : \"2 * x + e = m\"  \n  shows \"e = m - 2 * (k - e) \\<and> x = (m - e) / 2\"  \nproof -\n  have e_expr: \"e = k - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (k - x) = m\" using e_expr h1 by simp\n  have eq_simplified: \"x + k = m\" using eq_substituted by simp\n  have x_value: \"x = m - k\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq)\n  hence x_value_final: \"x = (m - e) / 2\" using e_expr by (auto simp: field_simps)\n  have e_value: \"e = k - x\" using e_expr x_value_final by blast\n  thus ?thesis using x_value_final by fastforce\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq:\n  fixes x e :: complex\n  assumes h0 : \"x + e = k\"  \n    and h1 : \"2 * x + e = m\"  \n  shows \"e = m - 2 * (k - e) \\<and> x = (m - e) / 2\"  \nproof -\n  have e_expr: \"e = k - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (k - x) = m\" using e_expr h1 by simp\n  have eq_simplified: \"x + k = m\" using eq_substituted by simp\n  have x_value: \"x = m - k\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq)\n  hence x_value_final: \"x = (m - e) / 2\" using e_expr by (auto simp: field_simps)\n  have e_value: \"e = k - x\" using e_expr x_value_final by blast\n  thus ?thesis using x_value_final by fastforce\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "explore_algebraic_relationships": {"skill_name": "explore_algebraic_relationships", "marker": "lemma explore_algebraic_relationships:\n  fixes x e :: complex\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n  shows \"x + e = 7 \\<longleftrightarrow> e = 7 - x\"\nproof -\n  have \"x + e = 7 \\<longrightarrow> e = 7 - x\" using h0 by (auto simp: field_simps)\n  moreover have \"e = 7 - x \\<longrightarrow> x + e = 7\" by simp\n  ultimately show ?thesis by blast\nqed", "description": "-", "full_code": "lemma explore_algebraic_relationships:\n  fixes x e :: complex\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n  shows \"x + e = 7 \\<longleftrightarrow> e = 7 - x\"\nproof -\n  have \"x + e = 7 \\<longrightarrow> e = 7 - x\" using h0 by (auto simp: field_simps)\n  moreover have \"e = 7 - x \\<longrightarrow> x + e = 7\" by simp\n  ultimately show ?thesis by blast\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "extend_algebraic_properties": {"skill_name": "extend_algebraic_properties", "marker": "lemma extend_algebraic_properties:\n  fixes x y e :: complex\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n    and h2: \"e = 11\"\n  shows \"x = -4\"\nproof -\n  have e_value: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have \"7 - x = 11\" using h2 by (metis e_value)\n  thus ?thesis by (smt (verit) algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 h0 h1)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed\n\nlemma extend_algebraic_properties:\n  fixes x y e :: complex\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n    and h2: \"e = 11\"\n  shows \"x = -4\"\nproof -\n  have e_value: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have \"7 - x = 11\" using h2 by (metis e_value)\n  thus ?thesis by (smt (verit) algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 h0 h1)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "amc12a_2013_p8": {"skill_name": "amc12a_2013_p8", "marker": "theorem amc12a_2013_p8:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n    using h2 cross_mult by sos\n  thus ?thesis by simp\nqed", "description": "", "full_code": "theorem amc12a_2013_p8:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n    using h2 cross_mult by sos\n  thus ?thesis by simp\nqed", "origin": "data/full_data/debug/valid_rand/amc12a_2013_p8.json_v3", "update_count": -1}, "min_value_of_non_negativesV2": {"skill_name": "min_value_of_non_negativesV2", "marker": "lemma min_value_of_non_negatives:\n  fixes a b c :: real\n  assumes \"a \\<ge> 0\" and \"b \\<ge> 0\" and \"c \\<ge> 0\"\n  shows \"a + b + c \\<ge> 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by (simp add: add.assoc)\n  moreover have \"a + b \\<ge> 0\" \n  proof -\n    have \"a + b = a + b\" by simp\n    then have \"a + b \\<ge> 0 + 0\" using assms(1) assms(2) \n      by (simp add: add_nonneg_nonneg)\n    thus ?thesis by simp\n  qed\n  ultimately have \"(a + b) + c \\<ge> 0 + c\" by (simp add: add_nonneg_nonneg)\n  thus ?thesis using assms(3) by simp\nqed", "description": "-", "full_code": "lemma min_value_of_non_negatives:\n  fixes a b c :: real\n  assumes \"a \\<ge> 0\" and \"b \\<ge> 0\" and \"c \\<ge> 0\"\n  shows \"a + b + c \\<ge> 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by (simp add: add.assoc)\n  moreover have \"a + b \\<ge> 0\" \n  proof -\n    have \"a + b = a + b\" by simp\n    then have \"a + b \\<ge> 0 + 0\" using assms(1) assms(2) \n      by (simp add: add_nonneg_nonneg)\n    thus ?thesis by simp\n  qed\n  ultimately have \"(a + b) + c \\<ge> 0 + c\" by (simp add: add_nonneg_nonneg)\n  thus ?thesis using assms(3) by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV2": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV2", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e f :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"f + e = 5\"\n  shows \"e = 11 \\<and> x = (-4) \\<and> f = -6\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then have e_final: \"e = 11\" using x_value_final by auto\n  have f_expr: \"f = 5 - e\" using h2 by (auto simp: field_simps)\n  then have f_value: \"f = 5 - 11\" using e_final by simp\n  thus ?thesis using e_final x_value_final f_value by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e f :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"f + e = 5\"\n  shows \"e = 11 \\<and> x = (-4) \\<and> f = -6\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then have e_final: \"e = 11\" using x_value_final by auto\n  have f_expr: \"f = 5 - e\" using h2 by (auto simp: field_simps)\n  then have f_value: \"f = 5 - 11\" using e_final by simp\n  thus ?thesis using e_final x_value_final f_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "sqrt_non_negative": {"skill_name": "sqrt_non_negative", "marker": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt x \\<ge> 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" by (metis assms max.absorb_iff2 max.commute)\n  also have \"max x 0 = x\" using assms by (simp add: max_def)\n  finally have \"sqrt x = sqrt x\" by simp\n  thus ?thesis\n    by (metis assms real_sqrt_ge_zero)\nqed", "description": "-", "full_code": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt x \\<ge> 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" by (metis assms max.absorb_iff2 max.commute)\n  also have \"max x 0 = x\" using assms by (simp add: max_def)\n  finally have \"sqrt x = sqrt x\" by simp\n  thus ?thesis\n    by (metis assms real_sqrt_ge_zero)\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV3": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV3", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: complex\n  assumes h0 : \"\\<forall>(x::complex). x + e = 7\"\n    and h1 : \"\\<forall>(x::complex). 2 * x + e = 3\"\n  shows \"\\<exists>e x. e = 11 \\<and> x = (-4)\"\nproof -\n  obtain x where x_def: \"x + e = 7\" using h0 by blast\n  obtain e where e_def: \"2 * x + e = 3\" using h1 by blast\n  have e_expr: \"e = 7 - x\" using x_def by (metis add_diff_cancel_left' add_left_imp_eq diff_add_cancel diff_minus_eq_add h0 semiring_norm(5))\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr e_def by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final e_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: complex\n  assumes h0 : \"\\<forall>(x::complex). x + e = 7\"\n    and h1 : \"\\<forall>(x::complex). 2 * x + e = 3\"\n  shows \"\\<exists>e x. e = 11 \\<and> x = (-4)\"\nproof -\n  obtain x where x_def: \"x + e = 7\" using h0 by blast\n  obtain e where e_def: \"2 * x + e = 3\" using h1 by blast\n  have e_expr: \"e = 7 - x\" using x_def by (metis add_diff_cancel_left' add_left_imp_eq diff_add_cancel diff_minus_eq_add h0 semiring_norm(5))\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr e_def by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final e_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "sqrt_non_negativeV2": {"skill_name": "sqrt_non_negativeV2", "marker": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt x \\<ge> 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" \n    using assms by (simp add: max_def)\n  also have \"... \\<ge> 0\" \n    using assms by (simp add: sqrt_def)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt x \\<ge> 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" \n    using assms by (simp add: max_def)\n  also have \"... \\<ge> 0\" \n    using assms by (simp add: sqrt_def)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_non_negativeV3": {"skill_name": "sqrt_non_negativeV3", "marker": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt x \\<ge> 0\"\nproof -\n  have \"sqrt x = sqrt (max 0 x)\" \n    by (metis assms max.absorb_iff2)\n  also have \"... = sqrt x\" \n    using assms by (simp add: max_def)\n  finally show ?thesis\n    using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt x \\<ge> 0\"\nproof -\n  have \"sqrt x = sqrt (max 0 x)\" \n    by (metis assms max.absorb_iff2)\n  also have \"... = sqrt x\" \n    using assms by (simp add: max_def)\n  finally show ?thesis\n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simple": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simple", "marker": "lemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simple:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  let ?e = \"7 - x\"\n  have e_expr: \"?e = e\" using h0 by simp\n  have eq_substituted: \"2 * x + ?e = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x + (7 - x) = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  then have \"x = 3 - 7\" by (simp add: algebra_simps)\n  then have x_value: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value by simp\n  then show ?thesis using x_value by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  let ?e = \"7 - x\"\n  have e_expr: \"?e = e\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + ?e = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x + (7 - x) = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  then have \"x = 3 - 7\" by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value by simp\n  then show ?thesis using x_value by (simp add: algebra_simps)\nqed\n\nlemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simple:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  let ?e = \"7 - x\"\n  have e_expr: \"?e = e\" using h0 by simp\n  have eq_substituted: \"2 * x + ?e = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x + (7 - x) = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  then have \"x = 3 - 7\" by (simp add: algebra_simps)\n  then have x_value: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value by simp\n  then show ?thesis using x_value by (simp add: algebra_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4V3": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4V3", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  let ?e = \"7 - x\"\n  have e_expr: \"?e = e\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + ?e = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x + (7 - x) = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  then have \"x = 3 - 7\" by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value by simp\n  then show ?thesis using x_value by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  let ?e = \"7 - x\"\n  have e_expr: \"?e = e\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + ?e = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x + (7 - x) = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  then have \"x = 3 - 7\" by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value by simp\n  then show ?thesis using x_value by (simp add: algebra_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3", "marker": "lemma algebra_2varlineareq_xpeeq7_2xpeeq3:\n  fixes x e :: complex\n  assumes h0: \"x + e = 7\" \n    and h1: \"2 * x + e = 3\"\n  shows \"e = 11\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel minus_equation_iff neg_numeral_neq_numeral numeral_times_minus_swap square_eq_iff uminus_add_conv_diff)\n  have e_value: \"e = 7 - x\" using e_expr by simp\n  thus \"e = 11\" using x_value by simp\nqed", "description": "-", "full_code": "lemma algebra_2varlineareq_xpeeq7:\n  fixes x e :: complex\n  assumes h0: \"x + e = 7\"\n  shows \"e = 7 - x\"\nproof -\n  show \"e = 7 - x\" using h0 by (auto simp: field_simps)\nqed\n\nlemma algebra_2varlineareq_xpeeq7_2xpeeq3:\n  fixes x e :: complex\n  assumes h0: \"x + e = 7\" \n    and h1: \"2 * x + e = 3\"\n  shows \"e = 11\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel minus_equation_iff neg_numeral_neq_numeral numeral_times_minus_swap square_eq_iff uminus_add_conv_diff)\n  have e_value: \"e = 7 - x\" using e_expr by simp\n  thus \"e = 11\" using x_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7": {"skill_name": "algebra_2varlineareq_xpeeq7", "marker": "lemma algebra_2varlineareq_xpeeq7:\n  fixes x e :: complex\n  assumes h0: \"x + e = 7\"\n  shows \"e = 7 - x\"\nproof -\n  show \"e = 7 - x\" using h0 by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma algebra_2varlineareq_xpeeq7:\n  fixes x e :: complex\n  assumes h0: \"x + e = 7\"\n  shows \"e = 7 - x\"\nproof -\n  show \"e = 7 - x\" using h0 by (auto simp: field_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "power_mod": {"skill_name": "power_mod", "marker": "lemma power_mod:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a^(Suc n) = a^n * a\" by simp\n  also have \"(a^(Suc n)) mod m = (a^n * a) mod m\" by (auto simp: field_simps)\n  finally show ?case \n  proof -\n    have \"(a^n * a) mod m = ((a^n mod m) * (a mod m)) mod m\"\n      using assms by (metis mod_mult_eq)\n    thus ?thesis using Suc.IH by (metis power_mod)\n  qed\nqed", "description": "-", "full_code": "lemma power_mod:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a^(Suc n) = a^n * a\" by simp\n  also have \"(a^(Suc n)) mod m = (a^n * a) mod m\" by (auto simp: field_simps)\n  finally show ?case \n  proof -\n    have \"(a^n * a) mod m = ((a^n mod m) * (a mod m)) mod m\"\n      using assms by (metis mod_mult_eq)\n    thus ?thesis using Suc.IH by (metis power_mod)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sum_integer_partitions": {"skill_name": "sum_integer_partitions", "marker": "lemma sum_integer_partitions:\n  fixes n :: nat\n  assumes \"n = a + b\"\n  shows \"a <= n \\<and> b <= n\"\nproof -\n  have \"a + b = n\" using assms by simp\n  hence \"a <= a + b\" by (simp add: le_add2)\n  hence \"a <= n\" by (metis add_leE assms order_refl)\n  moreover have \"b <= a + b\" using assms by (simp add: le_add2)\n  hence \"b <= n\" by (metis add_leE assms le_refl)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_integer_partitions:\n  fixes n :: nat\n  assumes \"n = a + b\"\n  shows \"a <= n \\<and> b <= n\"\nproof -\n  have \"a + b = n\" using assms by simp\n  hence \"a <= a + b\" by (simp add: le_add2)\n  hence \"a <= n\" by (metis add_leE assms order_refl)\n  moreover have \"b <= a + b\" using assms by (simp add: le_add2)\n  hence \"b <= n\" by (metis add_leE assms le_refl)\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "trivial_inequality": {"skill_name": "trivial_inequality", "marker": "lemma trivial_inequality:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 2 * x * y\"\nproof -\n  have \"x^2 - 2 * x * y + y^2 = (x - y)^2\" by sos\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma trivial_inequality:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 2 * x * y\"\nproof -\n  have \"x^2 - 2 * x * y + y^2 = (x - y)^2\" by sos\n  thus ?thesis by sos\nqed", "origin": "do_request", "update_count": 0}, "trivial_inequalityV2": {"skill_name": "trivial_inequalityV2", "marker": "lemma trivial_inequality:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 2 * x * y\"\nproof -\n  have \"x^2 - 2 * x * y + y^2 = (x - y)^2\"\n    by sos\n  hence \"x^2 + y^2 - 2 * x * y = (x - y)^2\"\n    by simp\n  thus ?thesis\n    by sos\nqed", "description": "-", "full_code": "lemma trivial_inequality:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 2 * x * y\"\nproof -\n  have \"x^2 - 2 * x * y + y^2 = (x - y)^2\"\n    by sos\n  hence \"x^2 + y^2 - 2 * x * y = (x - y)^2\"\n    by simp\n  thus ?thesis\n    by sos\nqed", "origin": "do_request", "update_count": 0}, "combine_fractions": {"skill_name": "combine_fractions", "marker": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a/b) - (c/d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (smt (verit) assms(1) assms(2) frac_eq_eq mult.assoc mult.commute no_zero_divisors nonzero_mult_divide_mult_cancel_left2)\n  also have \"... = (a * d - c * b) / (b * d)\"\n    by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a/b) - (c/d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (smt (verit) assms(1) assms(2) frac_eq_eq mult.assoc mult.commute no_zero_divisors nonzero_mult_divide_mult_cancel_left2)\n  also have \"... = (a * d - c * b) / (b * d)\"\n    by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "linear_equation_solver": {"skill_name": "linear_equation_solver", "marker": "lemma linear_equation_solver:\n  fixes x e :: complex\n  assumes h0: \"x + e = a\" \n    and h1: \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have simplified_eq: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using simplified_eq by (metis add.commute add_diff_cancel)\n  then have e_value: \"e = a - (b - a)\" using e_expr by simp\n  then show ?thesis using x_value by auto\nqed", "description": "-", "full_code": "lemma linear_equation_solver:\n  fixes x e :: complex\n  assumes h0: \"x + e = a\" \n    and h1: \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have simplified_eq: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using simplified_eq by (metis add.commute add_diff_cancel)\n  then have e_value: \"e = a - (b - a)\" using e_expr by simp\n  then show ?thesis using x_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "linear_system_solutionV2": {"skill_name": "linear_system_solutionV2", "marker": "lemma linear_system_solution:\n  fixes x e :: complex\n  assumes h0: \"x + e = a\"  \n    and h1: \"2 * x + e = b\" \n  shows \"e = a - x \\<and> x = (b - a) / 1\"  \nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  then have x_value: \"x = b - a\" by (metis add.commute add_diff_cancel)\n  then show ?thesis using e_expr x_value by auto\nqed", "description": "-", "full_code": "lemma linear_system_solution:\n  fixes x e :: complex\n  assumes h0: \"x + e = a\"  \n    and h1: \"2 * x + e = b\" \n  shows \"e = a - x \\<and> x = (b - a) / 1\"  \nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  then have x_value: \"x = b - a\" by (metis add.commute add_diff_cancel)\n  then show ?thesis using e_expr x_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "quadratic_root_substitution": {"skill_name": "quadratic_root_substitution", "marker": "lemma quadratic_root_substitution:\n  fixes a b c k x :: real\n  assumes \"a * x^2 + b * x + c = 0\"\n  shows \"c = - (a * x^2 + b * x)\"\nproof -\n  have \"a * x^2 + b * x + c = 0\" using assms by simp\n  then have \"c = - (a * x^2 + b * x)\" by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma quadratic_root_substitution:\n  fixes a b c k x :: real\n  assumes \"a * x^2 + b * x + c = 0\"\n  shows \"c = - (a * x^2 + b * x)\"\nproof -\n  have \"a * x^2 + b * x + c = 0\" using assms by simp\n  then have \"c = - (a * x^2 + b * x)\" by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "quadratic_root_substitutionV2": {"skill_name": "quadratic_root_substitutionV2", "marker": "lemma quadratic_root_substitution:\n  fixes a b c k x :: real\n  assumes \"a * x^2 + b * x + c = 0\"\n  shows \"c = - (a * x^2 + b * x)\"\nproof -\n  obtain lhs where eq: \"lhs = a * x^2 + b * x + c\" using assms by simp\n  have \"lhs = 0\" using assms by (metis eq)\n  thus ?thesis by (simp add: eq)\nqed", "description": "-", "full_code": "lemma quadratic_root_substitution:\n  fixes a b c k x :: real\n  assumes \"a * x^2 + b * x + c = 0\"\n  shows \"c = - (a * x^2 + b * x)\"\nproof -\n  obtain lhs where eq: \"lhs = a * x^2 + b * x + c\" using assms by simp\n  have \"lhs = 0\" using assms by (metis eq)\n  thus ?thesis by (simp add: eq)\nqed", "origin": "do_request", "update_count": 0}, "solve_linear_equation_general": {"skill_name": "solve_linear_equation_general", "marker": "theorem solve_linear_equation_general:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \n  and \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using assms by simp\n  then have \"a * x = c - b\" by simp\n  then show ?thesis using assms by (simp add: field_split_simps)\nqed", "description": "-", "full_code": "theorem solve_linear_equation_general:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \n  and \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using assms by simp\n  then have \"a * x = c - b\" by simp\n  then show ?thesis using assms by (simp add: field_split_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_linear_equationV2": {"skill_name": "solve_linear_equationV2", "marker": "theorem solve_linear_equation:\n  fixes a b c :: real\n  assumes h0: \"a > 0\"\n    and h1: \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using h1 by simp\n  then have \"a * x = c - b\" by simp\n  then show ?thesis using h0 by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem solve_linear_equation:\n  fixes a b c :: real\n  assumes h0: \"a > 0\"\n    and h1: \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using h1 by simp\n  then have \"a * x = c - b\" by simp\n  then show ?thesis using h0 by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "expand_square": {"skill_name": "expand_square", "marker": "lemma expand_square:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a - b) * (a - b)\" by sos\n  also have \"... = a * a - 2 * a * b + b * b\" by (simp add: algebra_simps)\n  finally show ?thesis by sos\nqed", "description": "-", "full_code": "lemma expand_square:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a - b) * (a - b)\" by sos\n  also have \"... = a * a - 2 * a * b + b * b\" by (simp add: algebra_simps)\n  finally show ?thesis by sos\nqed", "origin": "do_request", "update_count": 0}, "expand_squareV2": {"skill_name": "expand_squareV2", "marker": "lemma expand_square:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a * a) - 2 * a * b + (b * b)\"\n    by sos\n  show ?thesis\n    using left_side by sos\nqed", "description": "-", "full_code": "lemma expand_square:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a * a) - 2 * a * b + (b * b)\"\n    by sos\n  show ?thesis\n    using left_side by sos\nqed", "origin": "do_request", "update_count": 0}, "expand_squareV3": {"skill_name": "expand_squareV3", "marker": "lemma expand_square:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \" (a - b)^2 = (a - b) * (a - b)\"\n    by sos\n  also have \"... = a * a - a * b - b * a + b * b\"\n    by sos\n  also have \"... = a^2 - 2 * a * b + b^2\"\n    by sos\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma expand_square:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \" (a - b)^2 = (a - b) * (a - b)\"\n    by sos\n  also have \"... = a * a - a * b - b * a + b * b\"\n    by sos\n  also have \"... = a^2 - 2 * a * b + b^2\"\n    by sos\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "expand_squareV4": {"skill_name": "expand_squareV4", "marker": "lemma expand_square:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a - b) * (a - b)\" by sos\n  also have \"... = a * a - 2 * a * b + b * b\" \n  proof -\n    have \"a * a - 2 * a * b + b * b = a^2 - 2 * a * b + b^2\" by sos\n    thus ?thesis by (simp add: algebra_simps)\n  qed\n  finally show ?thesis by sos\nqed", "description": "-", "full_code": "lemma expand_square:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a - b) * (a - b)\" by sos\n  also have \"... = a * a - 2 * a * b + b * b\" \n  proof -\n    have \"a * a - 2 * a * b + b * b = a^2 - 2 * a * b + b^2\" by sos\n    thus ?thesis by (simp add: algebra_simps)\n  qed\n  finally show ?thesis by sos\nqed", "origin": "do_request", "update_count": 0}, "combine_fractionsV2": {"skill_name": "combine_fractionsV2", "marker": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have \"a / c + b / d = a / c + b * (1 / d)\"\n    by simp\n  then have \"a / c + b * (1 / d) = a / c + (b * c) / (c * d)\"\n    by (smt (verit) add_left_imp_eq assms(1) nless_le nonzero_mult_divide_mult_cancel_right2)\n  then have \"a / c + (b * c) / (c * d) = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (metis assms(2) divide_self less_numeral_extra(3) mult.commute mult_cancel_right2 times_divide_times_eq)\n  then have \"(a * d) / (c * d) + (b * c) / (c * d) = (a * d + b * c) / (c * d)\"\n    by (metis add_divide_distrib)\n  thus ?thesis\n    by (metis add_frac_eq assms(1) assms(2) less_numeral_extra(3))\nqed", "description": "-", "full_code": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have \"a / c + b / d = a / c + b * (1 / d)\"\n    by simp\n  then have \"a / c + b * (1 / d) = a / c + (b * c) / (c * d)\"\n    by (smt (verit) add_left_imp_eq assms(1) nless_le nonzero_mult_divide_mult_cancel_right2)\n  then have \"a / c + (b * c) / (c * d) = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (metis assms(2) divide_self less_numeral_extra(3) mult.commute mult_cancel_right2 times_divide_times_eq)\n  then have \"(a * d) / (c * d) + (b * c) / (c * d) = (a * d + b * c) / (c * d)\"\n    by (metis add_divide_distrib)\n  thus ?thesis\n    by (metis add_frac_eq assms(1) assms(2) less_numeral_extra(3))\nqed", "origin": "do_request", "update_count": 0}, "combine_fractionsV3": {"skill_name": "combine_fractionsV3", "marker": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have \"a / c + b / d = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (smt (verit) assms(1) assms(2) linorder_neq_iff nonzero_mult_divide_mult_cancel_right nonzero_mult_divide_mult_cancel_right2)\n  also have \"... = (a * d + b * c) / (c * d)\"\n    by (auto simp: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have \"a / c + b / d = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (smt (verit) assms(1) assms(2) linorder_neq_iff nonzero_mult_divide_mult_cancel_right nonzero_mult_divide_mult_cancel_right2)\n  also have \"... = (a * d + b * c) / (c * d)\"\n    by (auto simp: field_simps)\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_generalized": {"skill_name": "mathd_algebra_109_generalized", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_generalized": {"skill_name": "mathd_algebra_generalized", "marker": "theorem mathd_algebra_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = d\"  \n    and h1 : \"a = e\"  \n  shows \"b = (d - 3 * e) / 2\"  \nproof -\n  have eq: \"3 * a + 2 * b = d\" using h0 by simp\n  have \"3 * e + 2 * b = d\" using h1 eq by simp\n  have \"2 * b = d - 3 * e\" by (smt (verit) h0 h1)\n  show ?thesis using `2 * b = d - 3 * e` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = d\"  \n    and h1 : \"a = e\"  \n  shows \"b = (d - 3 * e) / 2\"  \nproof -\n  have eq: \"3 * a + 2 * b = d\" using h0 by simp\n  have \"3 * e + 2 * b = d\" using h1 eq by simp\n  have \"2 * b = d - 3 * e\" by (smt (verit) h0 h1)\n  show ?thesis using `2 * b = d - 3 * e` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sum_of_values": {"skill_name": "sum_of_values", "marker": "lemma sum_of_values:\n  shows \"21 + 45 = 66\"\nproof -\n  have \"21 + 45 = 66\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_values:\n  shows \"21 + 45 = 66\"\nproof -\n  have \"21 + 45 = 66\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_more_vars": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_more_vars", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_more_vars:\n  fixes x e f :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"f = 2 * x + e + 5\"\n  shows \"e = 11 \\<and> x = (-4) \\<and> f = 8\"\nproof -\n  obtain x_val where x_val_def: \"x_val = 7 - e\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * (7 - e) + e = 3\" using x_val_def h1 by (metis add.commute add_diff_cancel_left' dbl_def dbl_inc_simps(3) dbl_simps(3) dbl_simps(5) h0 inc.simps(1) mult_2 numeral_One)\n  have eq_simplified: \"14 - 2 * e + e = 3\" using eq_substituted by simp\n  have \"14 - e = 3\" using eq_simplified by simp\n  then have e_value: \"e = 14 - 3\" by simp\n  hence e_value_final: \"e = 11\" by simp\n  then have x_value: \"x = 7 - e\" using h0 by (metis add_diff_cancel uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by (simp add: e_value_final)\n  have f_value: \"f = 2 * x + e + 5\" using h2 by simp\n  have f_value_final: \"f = 2 * (-4) + 11 + 5\" by (metis dbl_inc_simps(3) dbl_simps(3) e_value_final h1 h2 x_value_final)\n  thus ?thesis using x_value_final e_value_final f_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_more_vars:\n  fixes x e f :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"f = 2 * x + e + 5\"\n  shows \"e = 11 \\<and> x = (-4) \\<and> f = 8\"\nproof -\n  obtain x_val where x_val_def: \"x_val = 7 - e\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * (7 - e) + e = 3\" using x_val_def h1 by (metis add.commute add_diff_cancel_left' dbl_def dbl_inc_simps(3) dbl_simps(3) dbl_simps(5) h0 inc.simps(1) mult_2 numeral_One)\n  have eq_simplified: \"14 - 2 * e + e = 3\" using eq_substituted by simp\n  have \"14 - e = 3\" using eq_simplified by simp\n  then have e_value: \"e = 14 - 3\" by simp\n  hence e_value_final: \"e = 11\" by simp\n  then have x_value: \"x = 7 - e\" using h0 by (metis add_diff_cancel uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by (simp add: e_value_final)\n  have f_value: \"f = 2 * x + e + 5\" using h2 by simp\n  have f_value_final: \"f = 2 * (-4) + 11 + 5\" by (metis dbl_inc_simps(3) dbl_simps(3) e_value_final h1 h2 x_value_final)\n  thus ?thesis using x_value_final e_value_final f_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV4": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV4", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  obtain x_val where x_val_def: \"x_val = 7 - e\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * (7 - e) + e = 3\" using x_val_def h1 by (metis add.commute add_diff_cancel_left' dbl_def dbl_inc_simps(3) dbl_simps(3) h0 mult_2)\n  have eq_simplified: \"14 - 2 * e + e = 3\" using eq_substituted by simp\n  have \"14 - e = 3\" using eq_simplified by simp\n  then have e_value: \"e = 14 - 3\" by simp\n  hence e_value_final: \"e = 11\" by simp\n  then have x_value: \"x = 7 - e\" using h0 by (metis add_diff_cancel_right' uminus_add_conv_diff)\n  then show ?thesis using e_value_final by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  obtain x_val where x_val_def: \"x_val = 7 - e\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * (7 - e) + e = 3\" using x_val_def h1 by (metis add.commute add_diff_cancel_left' dbl_def dbl_inc_simps(3) dbl_simps(3) h0 mult_2)\n  have eq_simplified: \"14 - 2 * e + e = 3\" using eq_substituted by simp\n  have \"14 - e = 3\" using eq_simplified by simp\n  then have e_value: \"e = 14 - 3\" by simp\n  hence e_value_final: \"e = 11\" by simp\n  then have x_value: \"x = 7 - e\" using h0 by (metis add_diff_cancel_right' uminus_add_conv_diff)\n  then show ?thesis using e_value_final by (auto simp: field_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "amc12a_2013_p8_generalized": {"skill_name": "amc12a_2013_p8_generalized", "marker": "theorem amc12a_2013_p8_generalized:\n  fixes x y :: real and n :: nat\n  assumes h0 : \"x\\<noteq>0\" \n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"\\<forall>k. x + k/x = y + k/y\"\n  shows \"x * y = k\"\nproof -\n  have \"x + k/x = y + k/y\" using h3 by simp\n  have rearranged: \"x - y = (k/y - k/x)\" by (smt (verit) h3)\n  have cross_mult: \"(x - y) * x * y = k * (x - y)\" \n    using rearranged by (metis add.comm_neutral add_divide_eq_if_simps(1) div_0 h2 h3)\n  then have \"x * y = k\" \n    using h2 by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_generalized:\n  fixes x y :: real and n :: nat\n  assumes h0 : \"x\\<noteq>0\" \n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"\\<forall>k. x + k/x = y + k/y\"\n  shows \"x * y = k\"\nproof -\n  have \"x + k/x = y + k/y\" using h3 by simp\n  have rearranged: \"x - y = (k/y - k/x)\" by (smt (verit) h3)\n  have cross_mult: \"(x - y) * x * y = k * (x - y)\" \n    using rearranged by (metis add.comm_neutral add_divide_eq_if_simps(1) div_0 h2 h3)\n  then have \"x * y = k\" \n    using h2 by auto\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "combine_fractionsV4": {"skill_name": "combine_fractionsV4", "marker": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have left_side: \"a / c + b / d = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (smt (verit) assms(1) assms(2) linorder_neq_iff nonzero_mult_divide_mult_cancel_right nonzero_mult_divide_mult_cancel_right2)\n  have \"a / c + b / d = (a * d + b * c) / (c * d)\"\n  proof -\n    have \"a / c + b / d = (a * d + b * c) / (c * d)\"\n      by (metis add_cancel_left_right add_frac_eq divide_eq_0_iff left_side mult.commute mult_eq_0_iff times_divide_times_eq)\n    thus ?thesis by simp\n  qed\n  thus ?thesis\n    using left_side by simp\nqed", "description": "-", "full_code": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have left_side: \"a / c + b / d = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (smt (verit) assms(1) assms(2) linorder_neq_iff nonzero_mult_divide_mult_cancel_right nonzero_mult_divide_mult_cancel_right2)\n  have \"a / c + b / d = (a * d + b * c) / (c * d)\"\n  proof -\n    have \"a / c + b / d = (a * d + b * c) / (c * d)\"\n      by (metis add_cancel_left_right add_frac_eq divide_eq_0_iff left_side mult.commute mult_eq_0_iff times_divide_times_eq)\n    thus ?thesis by simp\n  qed\n  thus ?thesis\n    using left_side by simp\nqed", "origin": "do_request", "update_count": 0}, "extend_dimensions_example": {"skill_name": "extend_dimensions_example", "marker": "lemma extend_dimensions_example:\n  fixes a :: real\n    and f :: \"real \\<Rightarrow> real\"\n  assumes h0 : \"\\<And>x. f x = a * (x - 2)^2 + 3\" \n  shows \"f (x + 2) = a * x^2 + 3\"\nproof -\n  have \"f (x + 2) = a * ((x + 2) - 2)^2 + 3\" using h0 by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma extend_dimensions_example:\n  fixes a :: real\n    and f :: \"real \\<Rightarrow> real\"\n  assumes h0 : \"\\<And>x. f x = a * (x - 2)^2 + 3\" \n  shows \"f (x + 2) = a * x^2 + 3\"\nproof -\n  have \"f (x + 2) = a * ((x + 2) - 2)^2 + 3\" using h0 by simp\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "amc12a_2013_p8_high_dim": {"skill_name": "amc12a_2013_p8_high_dim", "marker": "theorem amc12a_2013_p8_high_dim:\n  fixes x y :: real\n    and n :: nat\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\n  and \"x^n * y^n = 2^n\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n    using h2 cross_mult by sos\n  thus \"x * y = 2\" by simp\n  moreover have \"x^n * y^n = (x * y)^n\" \n    using `x * y = 2` by (metis power_mult_distrib)\n  ultimately show \"x^n * y^n = 2^n\" by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_high_dim:\n  fixes x y :: real\n    and n :: nat\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\n  and \"x^n * y^n = 2^n\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n    using h2 cross_mult by sos\n  thus \"x * y = 2\" by simp\n  moreover have \"x^n * y^n = (x * y)^n\" \n    using `x * y = 2` by (metis power_mult_distrib)\n  ultimately show \"x^n * y^n = 2^n\" by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_generalized": {"skill_name": "amc12a_generalized", "marker": "theorem amc12a_generalized:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\"\n    and h1: \"y \\<noteq> 0\"\n    and h2: \"x \\<noteq> y\"\n    and h3: \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\"\n    using rearranged by sos\n  then have \"x * y = 2\" using h2 by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_generalized:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\"\n    and h1: \"y \\<noteq> 0\"\n    and h2: \"x \\<noteq> y\"\n    and h3: \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\"\n    using rearranged by sos\n  then have \"x * y = 2\" using h2 by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2017_p2": {"skill_name": "amc12a_2017_p2", "marker": "theorem amc12a_2017_p2:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\"\n    and h1: \"y \\<noteq> 0\"\n    and h2: \"x + y = 4 * (x * y)\"\n  shows \"1/x + 1/y = 4\"\nproof -\n  have \"x + y = 4 * (x * y)\" using h2 by simp\n  then have \"1/x + 1/y = (y + x) / (x * y)\" by (auto simp: field_simps)\n  also have \"... = 4\" using h0 h1 by (metis add.commute div_by_1 divide_eq_0_iff frac_eq_eq h2 mult_cancel_left2 nonzero_mult_div_cancel_right nonzero_mult_divide_mult_cancel_right2 zero_neq_one)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2017_p2:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\"\n    and h1: \"y \\<noteq> 0\"\n    and h2: \"x + y = 4 * (x * y)\"\n  shows \"1/x + 1/y = 4\"\nproof -\n  have \"x + y = 4 * (x * y)\" using h2 by simp\n  then have \"1/x + 1/y = (y + x) / (x * y)\" by (auto simp: field_simps)\n  also have \"... = 4\" using h0 h1 by (metis add.commute div_by_1 divide_eq_0_iff frac_eq_eq h2 mult_cancel_left2 nonzero_mult_div_cancel_right nonzero_mult_divide_mult_cancel_right2 zero_neq_one)\n  finally show ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "expand_expressionV4": {"skill_name": "expand_expressionV4", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have left_side: \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\" \n    by sos\n  have right_side: \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: left_side right_side)\n  also have \"... = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have left_side: \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\" \n    by sos\n  have right_side: \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: left_side right_side)\n  also have \"... = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "expand_expressionV5": {"skill_name": "expand_expressionV5", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have lhs: \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  have rhs: \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    using lhs rhs by simp\n  also have \"... = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have lhs: \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  have rhs: \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    using lhs rhs by simp\n  also have \"... = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "minimum_value_of_squares": {"skill_name": "minimum_value_of_squares", "marker": "lemma minimum_value_of_squares:\n  fixes x y :: real\n  shows \"1 = min ((x * y - 1)^2 + (x + y)^2) (1)\"\nproof -\n  let ?f = \"((x * y - 1)^2 + (x + y)^2)\"\n  have \"1 \\<le> ?f\"\n  proof -\n    have \"((x * y) - 1)^2 \\<ge> 0\"\n      by auto\n    have \"(x + y)^2 \\<ge> 0\"\n      by auto\n    thus ?thesis\n      by sos\n  qed\n  have \"?f \\<ge> 1 \\<longrightarrow> min ?f 1 = 1\"\n    by auto\n  have \"?f < 1 \\<longrightarrow> min ?f 1 = ?f\"\n    by auto\n  thus \"1 = min ?f 1\"\n  proof (cases \"?f < 1\")\n    case True\n    then show ?thesis\n      by sos\n  next\n    case False\n    then show ?thesis\n      by (simp add: min_def)\n  qed\nqed", "description": "-", "full_code": "lemma minimum_value_of_squares:\n  fixes x y :: real\n  shows \"1 = min ((x * y - 1)^2 + (x + y)^2) (1)\"\nproof -\n  let ?f = \"((x * y - 1)^2 + (x + y)^2)\"\n  have \"1 \\<le> ?f\"\n  proof -\n    have \"((x * y) - 1)^2 \\<ge> 0\"\n      by auto\n    have \"(x + y)^2 \\<ge> 0\"\n      by auto\n    thus ?thesis\n      by sos\n  qed\n  have \"?f \\<ge> 1 \\<longrightarrow> min ?f 1 = 1\"\n    by auto\n  have \"?f < 1 \\<longrightarrow> min ?f 1 = ?f\"\n    by auto\n  thus \"1 = min ?f 1\"\n  proof (cases \"?f < 1\")\n    case True\n    then show ?thesis\n      by sos\n  next\n    case False\n    then show ?thesis\n      by (simp add: min_def)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sqrt_equivalence": {"skill_name": "sqrt_equivalence", "marker": "lemma sqrt_equivalence:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 72 + 9\" using assms by simp\n  hence \"x + 9 = 81\" by simp\n  then have \"sqrt (x + 9) = sqrt 81\" by simp\n  thus \"sqrt (x + 9) = 9\" by auto\nqed", "description": "-", "full_code": "lemma sqrt_equivalence:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 72 + 9\" using assms by simp\n  hence \"x + 9 = 81\" by simp\n  then have \"sqrt (x + 9) = sqrt 81\" by simp\n  thus \"sqrt (x + 9) = 9\" by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_equivalenceV2": {"skill_name": "sqrt_equivalenceV2", "marker": "lemma sqrt_equivalence:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 72 + 9\" using assms by simp\n  hence \"x + 9 = 81\" by simp\n  then show \"sqrt (x + 9) = 9\" by (simp add: sqrt_def)\nqed", "description": "-", "full_code": "lemma sqrt_equivalence:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 72 + 9\" using assms by simp\n  hence \"x + 9 = 81\" by simp\n  then show \"sqrt (x + 9) = 9\" by (simp add: sqrt_def)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_equivalenceV3": {"skill_name": "sqrt_equivalenceV3", "marker": "lemma sqrt_equivalence:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"sqrt (x + 9) = sqrt (72 + 9)\" using assms by simp\n  also have \"... = sqrt 81\" by simp\n  also have \"... = 9\" by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_equivalence:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"sqrt (x + 9) = sqrt (72 + 9)\" using assms by simp\n  also have \"... = sqrt 81\" by simp\n  also have \"... = 9\" by simp\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_equivalenceV4": {"skill_name": "sqrt_equivalenceV4", "marker": "lemma sqrt_equivalence:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 72 + 9\" using assms by simp\n  also have \"... = 81\" by simp\n  finally have \"sqrt (x + 9) = sqrt 81\" by simp\n  then show ?thesis by (simp add: real_sqrt_unique)\nqed", "description": "-", "full_code": "lemma sqrt_equivalence:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 72 + 9\" using assms by simp\n  also have \"... = 81\" by simp\n  finally have \"sqrt (x + 9) = sqrt 81\" by simp\n  then show ?thesis by (simp add: real_sqrt_unique)\nqed", "origin": "do_request", "update_count": 0}, "expand_expressionV6": {"skill_name": "expand_expressionV6", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: lhs)\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 + (x^2 + y^2) - 2 * (x * y) + 1 + 2 * (x * y)\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  then show ?thesis\n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: lhs)\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 + (x^2 + y^2) - 2 * (x * y) + 1 + 2 * (x * y)\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  then show ?thesis\n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "expand_expressionV7": {"skill_name": "expand_expressionV7", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: algebra_simps power2_eq_square)\n  have rhs: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  show ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n      by (simp add: lhs)\n    also have \"... = (x * y)^2 + (x^2 + y^2) + 1\"\n      by (simp add: algebra_simps)\n    finally show ?thesis\n      using rhs by simp\n  qed\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: algebra_simps power2_eq_square)\n  have rhs: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  show ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n      by (simp add: lhs)\n    also have \"... = (x * y)^2 + (x^2 + y^2) + 1\"\n      by (simp add: algebra_simps)\n    finally show ?thesis\n      using rhs by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sqrt_equivalenceV5": {"skill_name": "sqrt_equivalenceV5", "marker": "lemma sqrt_equivalence:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 72 + 9\" using assms by simp\n  hence \"x + 9 = 81\" by simp\n  then have \"sqrt (x + 9) = sqrt 81\" by simp\n  also have \"sqrt 81 = 9\" by simp\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma sqrt_equivalence:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 72 + 9\" using assms by simp\n  hence \"x + 9 = 81\" by simp\n  then have \"sqrt (x + 9) = sqrt 81\" by simp\n  also have \"sqrt 81 = 9\" by simp\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "amc12a_generalizedV2": {"skill_name": "amc12a_generalizedV2", "marker": "theorem amc12a_generalized:\n  fixes x y z :: real\n  assumes h0: \"x \\<noteq> 0\"\n    and h1: \"y \\<noteq> 0\"\n    and h2: \"z \\<noteq> 0\"\n    and h3: \"x \\<noteq> y\"\n    and h4: \"x \\<noteq> z\"\n    and h5: \"y \\<noteq> z\"\n    and h6: \"x + 2/x = y + 2/y\"\n    and h7: \"x + 2/x = z + 2/z\"\n  shows \"x * y * z = 4\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h6 by simp\n  have \"x + 2/x = z + 2/z\" using h7 by simp\n  have rearranged_y: \"x - y = (2/y - 2/x)\" by (smt (verit) h6)\n  have rearranged_z: \"x - z = (2/z - 2/x)\" by (smt (verit) h7)\n  have cross_mult_y: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged_y by sos\n  have cross_mult_z: \"(x - z) * x * z = 2 * (x - z)\" \n    using rearranged_z by sos\n  have \"x * y = 2\" using h3 cross_mult_y by sos\n  have \"x * z = 2\" using h4 cross_mult_z by sos\n  thus ?thesis by (metis \\<open>x * y = 2\\<close> add.commute add_diff_cancel_left' add_diff_cancel_right' add_divide_eq_if_simps(1) dbl_simps(3) eq_divide_eq h1 h2 h5 h6 h7)\nqed", "description": "-", "full_code": "theorem amc12a_generalized:\n  fixes x y z :: real\n  assumes h0: \"x \\<noteq> 0\"\n    and h1: \"y \\<noteq> 0\"\n    and h2: \"z \\<noteq> 0\"\n    and h3: \"x \\<noteq> y\"\n    and h4: \"x \\<noteq> z\"\n    and h5: \"y \\<noteq> z\"\n    and h6: \"x + 2/x = y + 2/y\"\n    and h7: \"x + 2/x = z + 2/z\"\n  shows \"x * y * z = 4\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h6 by simp\n  have \"x + 2/x = z + 2/z\" using h7 by simp\n  have rearranged_y: \"x - y = (2/y - 2/x)\" by (smt (verit) h6)\n  have rearranged_z: \"x - z = (2/z - 2/x)\" by (smt (verit) h7)\n  have cross_mult_y: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged_y by sos\n  have cross_mult_z: \"(x - z) * x * z = 2 * (x - z)\" \n    using rearranged_z by sos\n  have \"x * y = 2\" using h3 cross_mult_y by sos\n  have \"x * z = 2\" using h4 cross_mult_z by sos\n  thus ?thesis by (metis \\<open>x * y = 2\\<close> add.commute add_diff_cancel_left' add_diff_cancel_right' add_divide_eq_if_simps(1) dbl_simps(3) eq_divide_eq h1 h2 h5 h6 h7)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "polynomial_expansionV2": {"skill_name": "polynomial_expansionV2", "marker": "lemma polynomial_expansion:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have lhs: \"(x + y)^2 = (x + y) * (x + y)\" \n    by sos\n  also have \"... = x * (x + y) + y * (x + y)\" \n    by (simp add: distrib_right)\n  also have \"... = x^2 + x * y + y * x + y^2\" \n    by sos\n  also have \"... = x^2 + 2 * x * y + y^2\" \n    by auto\n  finally show ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma polynomial_expansion:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have lhs: \"(x + y)^2 = (x + y) * (x + y)\" \n    by sos\n  also have \"... = x * (x + y) + y * (x + y)\" \n    by (simp add: distrib_right)\n  also have \"... = x^2 + x * y + y * x + y^2\" \n    by sos\n  also have \"... = x^2 + 2 * x * y + y^2\" \n    by auto\n  finally show ?thesis \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "polynomial_expansionV3": {"skill_name": "polynomial_expansionV3", "marker": "lemma polynomial_expansion:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have \" (x + y)^2 = (x + y) * (x + y)\" \n    by sos\n  also have \"... = x * (x + y) + y * (x + y)\" \n    by (simp add: algebra_simps)\n  also have \"... = x^2 + x * y + y * x + y^2\" \n    by sos\n  also have \"... = x^2 + 2 * x * y + y^2\" \n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma polynomial_expansion:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have \" (x + y)^2 = (x + y) * (x + y)\" \n    by sos\n  also have \"... = x * (x + y) + y * (x + y)\" \n    by (simp add: algebra_simps)\n  also have \"... = x^2 + x * y + y * x + y^2\" \n    by sos\n  also have \"... = x^2 + 2 * x * y + y^2\" \n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "real_properties": {"skill_name": "real_properties", "marker": "lemma real_properties:\n  fixes x y z :: real\n  assumes \"x = y + z\"\n  shows \"x^2 = y^2 + 2 * y * z + z^2\"\nproof -\n  have \"x^2 = (y + z)^2\" using assms by (simp)\n  also have \"... = y^2 + 2 * y * z + z^2\" by sos\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma real_properties:\n  fixes x y z :: real\n  assumes \"x = y + z\"\n  shows \"x^2 = y^2 + 2 * y * z + z^2\"\nproof -\n  have \"x^2 = (y + z)^2\" using assms by (simp)\n  also have \"... = y^2 + 2 * y * z + z^2\" by sos\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "real_propertiesV2": {"skill_name": "real_propertiesV2", "marker": "lemma real_properties:\n  fixes x y z :: real\n  assumes \"x = y + z\"\n  shows \"x^2 = y^2 + 2*y*z + z^2\"\nproof -\n  have \"x^2 = (y + z)^2\" using assms by simp\n  also have \"(y + z)^2 = y^2 + 2*y*z + z^2\" by sos\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma real_properties:\n  fixes x y z :: real\n  assumes \"x = y + z\"\n  shows \"x^2 = y^2 + 2*y*z + z^2\"\nproof -\n  have \"x^2 = (y + z)^2\" using assms by simp\n  also have \"(y + z)^2 = y^2 + 2*y*z + z^2\" by sos\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "solve_linear_equation_with_parametrization": {"skill_name": "solve_linear_equation_with_parametrization", "marker": "theorem solve_linear_equation_with_parametrization:\n  fixes a b :: real\n  assumes h0: \"m * a + n * b = c\"\n    and h1: \"m > 0\"\n    and h2: \"n > 0\"\n  shows \"b = (c - m * a) / n\"\nproof -\n  have \"m * a + n * b = c\" using h0 by simp\n  then have \"n * b = c - m * a\" by simp\n  then show ?thesis using h1 h2\n    by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem solve_linear_equation_with_parametrization:\n  fixes a b :: real\n  assumes h0: \"m * a + n * b = c\"\n    and h1: \"m > 0\"\n    and h2: \"n > 0\"\n  shows \"b = (c - m * a) / n\"\nproof -\n  have \"m * a + n * b = c\" using h0 by simp\n  then have \"n * b = c - m * a\" by simp\n  then show ?thesis using h1 h2\n    by (auto simp: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sqrt_equation": {"skill_name": "sqrt_equation", "marker": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9\" using assms by simp\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show \"x = 72\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9\" using assms by simp\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show \"x = 72\" by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_equationV2": {"skill_name": "sqrt_equationV2", "marker": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  also have \"... = 81\" by simp\n  finally have \"x + 9 = 81\" by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  also have \"... = 81\" by simp\n  finally have \"x + 9 = 81\" by simp\n  then show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_simplified": {"skill_name": "algebra_2varlineareq_simplified", "marker": "lemma algebra_2varlineareq_simplified:\n  fixes x e :: real\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by (simp)\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by (simp)\n  have x_value: \"x = 3 - 7\" using eq_simplified by (simp)\n  then have x_value_final: \"x = -4\" by (simp)\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by (simp)\n  then show ?thesis using x_value_final by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma algebra_2varlineareq_simplified:\n  fixes x e :: real\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by (simp)\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by (simp)\n  have x_value: \"x = 3 - 7\" using eq_simplified by (simp)\n  then have x_value_final: \"x = -4\" by (simp)\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by (simp)\n  then show ?thesis using x_value_final by (simp add: field_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "multi_dimensional_algebra": {"skill_name": "multi_dimensional_algebra", "marker": "theorem multi_dimensional_algebra:\n  fixes a :: \"real list\" and b :: \"real list\"\n  assumes \"length a = n\" \"length b = n\" \"3 * (a ! 0) + 2 * (b ! 0) = 12\" \n    and \"a ! 0 = 4\"\n  shows \"b ! 0 = 0\"\nproof -\n  have \"3 * (a ! 0) + 2 * (b ! 0) = 12\" using assms(3) by simp\n  have \"3 * 4 + 2 * (b ! 0) = 12\" using assms(4) by (metis add.left_commute add.right_neutral add_0_iff assms(3) comm_monoid_add_class.add_0 mult_2)\n  have \"12 + 2 * (b ! 0) = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b ! 0 = 12\\<close>)\n  have \"2 * (b ! 0) = 0\" by (smt (verit) assms(3) assms(4))\n  thus ?thesis using `2 * (b ! 0) = 0` by simp\nqed", "description": "-", "full_code": "theorem multi_dimensional_algebra:\n  fixes a :: \"real list\" and b :: \"real list\"\n  assumes \"length a = n\" \"length b = n\" \"3 * (a ! 0) + 2 * (b ! 0) = 12\" \n    and \"a ! 0 = 4\"\n  shows \"b ! 0 = 0\"\nproof -\n  have \"3 * (a ! 0) + 2 * (b ! 0) = 12\" using assms(3) by simp\n  have \"3 * 4 + 2 * (b ! 0) = 12\" using assms(4) by (metis add.left_commute add.right_neutral add_0_iff assms(3) comm_monoid_add_class.add_0 mult_2)\n  have \"12 + 2 * (b ! 0) = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b ! 0 = 12\\<close>)\n  have \"2 * (b ! 0) = 0\" by (smt (verit) assms(3) assms(4))\n  thus ?thesis using `2 * (b ! 0) = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_extendedV5": {"skill_name": "mathd_algebra_109_extendedV5", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 5\"\n  shows \"b = 0\" \n    and \"3*a + c = 17\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  thus \"b = 0\" using `2 * b = 0` by simp\n  show \"3 * a + c = 17\" using h1 h2\n    by (simp add: `a = 4` `c = 5` field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 5\"\n  shows \"b = 0\" \n    and \"3*a + c = 17\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  thus \"b = 0\" using `2 * b = 0` by simp\n  show \"3 * a + c = 17\" using h1 h2\n    by (simp add: `a = 4` `c = 5` field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_generalizedV2": {"skill_name": "mathd_algebra_generalizedV2", "marker": "theorem mathd_algebra_generalized:\n  fixes a b c :: real\n  assumes h0: \"p * a + q * b + r * c = s\"\n    and h1: \"a = x\"\n    and h2: \"p > 0\" \"q > 0\" \"r > 0\"\n  shows \"b = (s - p * x - r * c) / q\"\nproof -\n  have eq: \"p * a + q * b + r * c = s\" using h0 by simp\n  have \"p * x + q * b + r * c = s\" using h1 eq by simp\n  have \"q * b = s - p * x - r * c\" by (smt (verit) h0 h1)\n  thus \"b = (s - p * x - r * c) / q\" using h2 by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_generalized:\n  fixes a b c :: real\n  assumes h0: \"p * a + q * b + r * c = s\"\n    and h1: \"a = x\"\n    and h2: \"p > 0\" \"q > 0\" \"r > 0\"\n  shows \"b = (s - p * x - r * c) / q\"\nproof -\n  have eq: \"p * a + q * b + r * c = s\" using h0 by simp\n  have \"p * x + q * b + r * c = s\" using h1 eq by simp\n  have \"q * b = s - p * x - r * c\" by (smt (verit) h0 h1)\n  thus \"b = (s - p * x - r * c) / q\" using h2 by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_solutionV6": {"skill_name": "linear_equation_solutionV6", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"a * x + b = c\"\n    and h1 : \"a \\<noteq> 0\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using h0 by simp\n  then have \"a * x = c - b\" by simp\n  then show \"x = (c - b) / a\" using h1 by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"a * x + b = c\"\n    and h1 : \"a \\<noteq> 0\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using h0 by simp\n  then have \"a * x = c - b\" by simp\n  then show \"x = (c - b) / a\" using h1 by (auto simp: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_n_general": {"skill_name": "mathd_algebra_n_general", "marker": "lemma mathd_algebra_n_general:\n  fixes a b c :: real\n  assumes \"n > 0\" \"c = 3 * a + 2 * b\"\n    and \"a = 4\" \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have \"3 * 4 + 2 * b = 12\" using assms by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_n:\n  fixes a b :: real\n  assumes h0: \"3*a + 2*b = 12\" \n    and h1: \"a = 4\" \n    and dim: \"n > 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed\n\nlemma mathd_algebra_n_general:\n  fixes a b c :: real\n  assumes \"n > 0\" \"c = 3 * a + 2 * b\"\n    and \"a = 4\" \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have \"3 * 4 + 2 * b = 12\" using assms by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_n_dimensions": {"skill_name": "mathd_algebra_109_n_dimensions", "marker": "theorem mathd_algebra_109_n_dimensions:\n  fixes a b :: \"real list\" and n :: nat\n  assumes \"length a = n\" \"length b = n\" \n    and h0: \"\\<forall>i < n. 3 * a ! i + 2 * b ! i = 12\"\n    and h1: \"\\<forall>i < n. a ! i = 4\"\n  shows \"\\<forall>i < n. b ! i = 0\"\nproof -\n  have \"\\<forall>i < n. 3 * (a ! i) + 2 * (b ! i) = 12\" using h0 by simp\n  have \"\\<forall>i < n. 3 * 4 + 2 * (b ! i) = 12\" using h1 by (metis h0 mult_2)\n  hence \"\\<forall>i < n. 12 + 2 * (b ! i) = 12\" by simp\n  hence \"\\<forall>i < n. 2 * (b ! i) = 0\" by (metis add_cancel_right_right)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_n_dimensions:\n  fixes a b :: \"real list\" and n :: nat\n  assumes \"length a = n\" \"length b = n\" \n    and h0: \"\\<forall>i < n. 3 * a ! i + 2 * b ! i = 12\"\n    and h1: \"\\<forall>i < n. a ! i = 4\"\n  shows \"\\<forall>i < n. b ! i = 0\"\nproof -\n  have \"\\<forall>i < n. 3 * (a ! i) + 2 * (b ! i) = 12\" using h0 by simp\n  have \"\\<forall>i < n. 3 * 4 + 2 * (b ! i) = 12\" using h1 by (metis h0 mult_2)\n  hence \"\\<forall>i < n. 12 + 2 * (b ! i) = 12\" by simp\n  hence \"\\<forall>i < n. 2 * (b ! i) = 0\" by (metis add_cancel_right_right)\n  thus ?thesis by auto\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "algebra_2varlineareq_xpeeq_a_ypeeq_b_xeqn_c": {"skill_name": "algebra_2varlineareq_xpeeq_a_ypeeq_b_xeqn_c", "marker": "theorem algebra_2varlineareq_xpeeq_a_ypeeq_b_xeqn_c:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (b - 2*a) / -1 \\<and> x = (a - e)\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  then have x_value: \"x = b - a\" by (metis add_diff_cancel diff_add_eq)\n  then have e_value: \"e = a - (b - a)\" using e_expr x_value by simp\n  then show ?thesis using x_value e_value by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq_a_ypeeq_b_xeqn_c:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (b - 2*a) / -1 \\<and> x = (a - e)\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  then have x_value: \"x = b - a\" by (metis add_diff_cancel diff_add_eq)\n  then have e_value: \"e = a - (b - a)\" using e_expr x_value by simp\n  then show ?thesis using x_value e_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "units_digit_of_squareV2": {"skill_name": "units_digit_of_squareV2", "marker": "lemma units_digit_of_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  obtain m where \"k = 10 * m\" using assms by auto\n  then have \"k^2 = (10 * m)^2\" by simp\n  hence \"k^2 = 100 * m^2\" by (simp add: power2_eq_square)\n  then have \"(k^2) mod 10 = (100 * m^2) mod 10\" by simp\n  also have \"... = 0\" by (simp add: mod_mult_self2)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma units_digit_of_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  obtain m where \"k = 10 * m\" using assms by auto\n  then have \"k^2 = (10 * m)^2\" by simp\n  hence \"k^2 = 100 * m^2\" by (simp add: power2_eq_square)\n  then have \"(k^2) mod 10 = (100 * m^2) mod 10\" by simp\n  also have \"... = 0\" by (simp add: mod_mult_self2)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "amc12a_2013_p8_evolved": {"skill_name": "amc12a_2013_p8_evolved", "marker": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have rearranged: \"x - y = (2/y - 2/x)\" by auto\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged h2 by sos\n  have \"x * y = 2\" \n    using h2 cross_mult by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have rearranged: \"x - y = (2/y - 2/x)\" by auto\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged h2 by sos\n  have \"x * y = 2\" \n    using h2 cross_mult by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_simplified": {"skill_name": "amc12a_2013_p8_simplified", "marker": "theorem amc12a_2013_p8_simplified:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\" \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  obtain a b where \"x = a\" and \"y = b\" using assms by auto\n  have \"a + 2/a = b + 2/b\" using assms(4) by (metis \\<open>x = a\\<close> \\<open>y = b\\<close>)\n  have \"a - b = (2/b - 2/a)\" by (smt (verit) \\<open>a + 2 / a = b + 2 / b\\<close> \\<open>x = a\\<close> \\<open>y = b\\<close>)\n  have \"((a - b) * a * b) = 2 * (a - b)\" using `a - b = (2/b - 2/a)` by sos\n  hence \"a * b = 2\" by (smt (verit) \\<open>a + 2 / a = b + 2 / b\\<close> \\<open>x = a\\<close> \\<open>y = b\\<close> amc12a_2013_p8_evolved assms(1) assms(2) assms(3))\n  thus ?thesis by (metis \\<open>x = a\\<close> \\<open>y = b\\<close>)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  then have \"x * y = 2\" \n    using h2 by sos\n  thus ?thesis by simp\nqed\n\ntheorem amc12a_2013_p8_simplified:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\" \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  obtain a b where \"x = a\" and \"y = b\" using assms by auto\n  have \"a + 2/a = b + 2/b\" using assms(4) by (metis \\<open>x = a\\<close> \\<open>y = b\\<close>)\n  have \"a - b = (2/b - 2/a)\" by (smt (verit) \\<open>a + 2 / a = b + 2 / b\\<close> \\<open>x = a\\<close> \\<open>y = b\\<close>)\n  have \"((a - b) * a * b) = 2 * (a - b)\" using `a - b = (2/b - 2/a)` by sos\n  hence \"a * b = 2\" by (smt (verit) \\<open>a + 2 / a = b + 2 / b\\<close> \\<open>x = a\\<close> \\<open>y = b\\<close> amc12a_2013_p8_evolved assms(1) assms(2) assms(3))\n  thus ?thesis by (metis \\<open>x = a\\<close> \\<open>y = b\\<close>)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_v2": {"skill_name": "amc12a_2013_p8_v2", "marker": "theorem amc12a_2013_p8_v2:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have \"x - y = (2/y - 2/x)\" by auto\n  have \"x - y \\<noteq> 0\" using h2 by simp\n  have \"x * y * (x - y) = 2 * (x - y)\" \n    using `x - y = (2/y - 2/x)` by sos\n  then have \"x * y = 2\" \n    using `x - y \\<noteq> 0` by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_v2:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have \"x - y = (2/y - 2/x)\" by auto\n  have \"x - y \\<noteq> 0\" using h2 by simp\n  have \"x * y * (x - y) = 2 * (x - y)\" \n    using `x - y = (2/y - 2/x)` by sos\n  then have \"x * y = 2\" \n    using `x - y \\<noteq> 0` by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "mathd_algebra_109_generalizedV2": {"skill_name": "mathd_algebra_109_generalizedV2", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b + d = c\"\n    and h1 : \"a = 4\" \"d = 0\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b + d = c\" using h0 by simp\n  have \"3 * 4 + 2 * b + 0 = c\" using h1(1) eq by (metis dbl_inc_simps(3) dbl_simps(3) h1(2))\n  hence \"12 + 2 * b = c\" by simp\n  thus ?thesis using h1(2) by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b + d = c\"\n    and h1 : \"a = 4\" \"d = 0\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b + d = c\" using h0 by simp\n  have \"3 * 4 + 2 * b + 0 = c\" using h1(1) eq by (metis dbl_inc_simps(3) dbl_simps(3) h1(2))\n  hence \"12 + 2 * b = c\" by simp\n  thus ?thesis using h1(2) by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolved": {"skill_name": "mathd_algebra_109_evolved", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  hence \"12 + 2 * b = c\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  hence \"12 + 2 * b = c\" by simp\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_generalizedV3": {"skill_name": "mathd_algebra_109_generalizedV3", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = k\"  \n    and h1 : \"a = x\" \n  shows \"b = (k - 3 * x) / 2\"\nproof -\n  have \"3 * a + 2 * b = k\" using h0 by simp\n  have \"3 * x + 2 * b = k\" using h1 by (metis h0)\n  hence \"2 * b = k - 3 * x\" by simp\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = k\"  \n    and h1 : \"a = x\" \n  shows \"b = (k - 3 * x) / 2\"\nproof -\n  have \"3 * a + 2 * b = k\" using h0 by simp\n  have \"3 * x + 2 * b = k\" using h1 by (metis h0)\n  hence \"2 * b = k - 3 * x\" by simp\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolvedV2": {"skill_name": "mathd_algebra_109_evolvedV2", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  hence \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (metis add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  hence \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (metis add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolvedV3": {"skill_name": "mathd_algebra_109_evolvedV3", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"3 * 4 + 2 * b = 12\" using h1 by simp\n  then have \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (simp add: add_cancel_right_right)\n  thus \"b = 0\" by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"3 * 4 + 2 * b = 12\" using h1 by simp\n  then have \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (simp add: add_cancel_right_right)\n  thus \"b = 0\" by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_generalizedV4": {"skill_name": "mathd_algebra_109_generalizedV4", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = d\"\n    and h1: \"a = x\"\n  shows \"b = (d - 3 * x) / 2\"\nproof -\n  have \"3 * a + 2 * b = d\" using h0 by simp\n  then have \"3 * x + 2 * b = d\" using h1 by simp\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = d\"\n    and h1: \"a = x\"\n  shows \"b = (d - 3 * x) / 2\"\nproof -\n  have \"3 * a + 2 * b = d\" using h0 by simp\n  then have \"3 * x + 2 * b = d\" using h1 by simp\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "amc12a_2013_p8_extended": {"skill_name": "amc12a_2013_p8_extended", "marker": "theorem amc12a_2013_p8_extended:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\"\n    and h4 : \"x\\<noteq>z\"\n    and h5 : \"y\\<noteq>z\"\n    and h6 : \"x + 2/x = y + 2/y\"\n    and h7 : \"y + 2/y = z + 2/z\"\n  shows \"x * y * z = 4\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h6 by simp\n  have \"y + 2/y = z + 2/z\" using h7 by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" by (smt (verit) h6)\n  have rearranged2: \"y - z = (2/z - 2/y)\" by (smt (verit) h7)\n  have cross_mult1: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged1 by sos\n  have cross_mult2: \"(y - z) * y * z = 2 * (y - z)\" \n    using rearranged2 by sos\n  have \"x * y = 2\" \n    using h3 cross_mult1 by sos\n  have \"y * z = 2\" \n    using h5 cross_mult2 by sos\n  then show \"x * y * z = 4\" \n    using `x * y = 2` by (metis add_diff_cancel_left' dbl_simps(3) diff_add_cancel eq_divide_eq h1 h2 h4 rearranged2)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_extended:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\"\n    and h4 : \"x\\<noteq>z\"\n    and h5 : \"y\\<noteq>z\"\n    and h6 : \"x + 2/x = y + 2/y\"\n    and h7 : \"y + 2/y = z + 2/z\"\n  shows \"x * y * z = 4\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h6 by simp\n  have \"y + 2/y = z + 2/z\" using h7 by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" by (smt (verit) h6)\n  have rearranged2: \"y - z = (2/z - 2/y)\" by (smt (verit) h7)\n  have cross_mult1: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged1 by sos\n  have cross_mult2: \"(y - z) * y * z = 2 * (y - z)\" \n    using rearranged2 by sos\n  have \"x * y = 2\" \n    using h3 cross_mult1 by sos\n  have \"y * z = 2\" \n    using h5 cross_mult2 by sos\n  then show \"x * y * z = 4\" \n    using `x * y = 2` by (metis add_diff_cancel_left' dbl_simps(3) diff_add_cancel eq_divide_eq h1 h2 h4 rearranged2)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "mathd_algebra_109_generalizedV5": {"skill_name": "mathd_algebra_109_generalizedV5", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have \"3 * a = 3 * 4\" using h1 by simp\n  hence \"3 * a = 12\" by simp\n  then have \"3 * a + 2 * b = c\" using h0 by simp\n  thus ?thesis using h0 h1 by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have \"3 * a = 3 * 4\" using h1 by simp\n  hence \"3 * a = 12\" by simp\n  then have \"3 * a + 2 * b = c\" using h0 by simp\n  thus ?thesis using h0 h1 by (simp add: algebra_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolvedV4": {"skill_name": "mathd_algebra_109_evolvedV4", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  from h1 have \"3 * a = 3 * 4\" by simp\n  hence \"3 * a = 12\" by simp\n  then have \"3 * a + 2 * b = 12\" using h0 by simp\n  thus \"b = 0\" using h0 h1 by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  from h1 have \"3 * a = 3 * 4\" by simp\n  hence \"3 * a = 12\" by simp\n  then have \"3 * a + 2 * b = 12\" using h0 by simp\n  thus \"b = 0\" using h0 h1 by (simp add: algebra_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolvedV5": {"skill_name": "mathd_algebra_109_evolvedV5", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  from h1 have \"3 * a = 3 * 4\" by simp\n  then have \"3 * a = 12\" by simp\n  moreover have \"3 * a + 2 * b = 12\" using h0 by simp\n  ultimately have \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (simp add: add_cancel_right_right)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  from h1 have \"3 * a = 3 * 4\" by simp\n  then have \"3 * a = 12\" by simp\n  moreover have \"3 * a + 2 * b = 12\" using h0 by simp\n  ultimately have \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (simp add: add_cancel_right_right)\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sqrt_equationV3": {"skill_name": "sqrt_equationV3", "marker": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  hence \"x + 9 = 81\" by simp\n  then have \"x = 81 - 9\" by simp\n  thus \"x = 72\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  hence \"x + 9 = 81\" by simp\n  then have \"x = 81 - 9\" by simp\n  thus \"x = 72\" by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_general": {"skill_name": "algebra_2varlineareq_general", "marker": "theorem algebra_2varlineareq_general:\n  fixes a b c d :: complex\n  assumes h0 : \"a + b = c\"\n    and h1 : \"2 * a + b = d\"\n  shows \"b = c - a \\<and> a = (d - b) / 2\"\nproof -\n  have b_expr: \"b = c - a\" using h0 by (auto simp: field_simps)\n  have a_expr: \"a = (d - b) / 2\" using h1 b_expr by auto\n  then show ?thesis using b_expr by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_general:\n  fixes a b c d :: complex\n  assumes h0 : \"a + b = c\"\n    and h1 : \"2 * a + b = d\"\n  shows \"b = c - a \\<and> a = (d - b) / 2\"\nproof -\n  have b_expr: \"b = c - a\" using h0 by (auto simp: field_simps)\n  have a_expr: \"a = (d - b) / 2\" using h1 b_expr by auto\n  then show ?thesis using b_expr by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "sum_of_squares_nonnegative": {"skill_name": "sum_of_squares_nonnegative", "marker": "lemma sum_of_squares_nonnegative:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  have \"b^2 = b * b\" by sos\n  then have \"a^2 + b^2 = a * a + b * b\" by sos\n  moreover have \"a * a \\<ge> 0\" by (simp add: mult_nonneg_nonneg)\n  moreover have \"b * b \\<ge> 0\" by (simp add: mult_nonneg_nonneg)\n  ultimately show ?thesis by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma sum_of_squares_nonnegative:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  have \"b^2 = b * b\" by sos\n  then have \"a^2 + b^2 = a * a + b * b\" by sos\n  moreover have \"a * a \\<ge> 0\" by (simp add: mult_nonneg_nonneg)\n  moreover have \"b * b \\<ge> 0\" by (simp add: mult_nonneg_nonneg)\n  ultimately show ?thesis by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalized": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalized", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalized:\n  fixes x e :: \"complex\"\n  assumes h0: \"x + e = a\"\n    and h1: \"2 * x + e = b\"\n  shows \"e = a + a - b \\<and> x = (b - a) / 1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  then show ?thesis using e_expr by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalized:\n  fixes x e :: \"complex\"\n  assumes h0: \"x + e = a\"\n    and h1: \"2 * x + e = b\"\n  shows \"e = a + a - b \\<and> x = (b - a) / 1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  then show ?thesis using e_expr by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "sqrt_simplification": {"skill_name": "sqrt_simplification", "marker": "lemma sqrt_simplification:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x) * sqrt(y) = sqrt(x * y)\"\nproof -\n  have \"sqrt(x) * sqrt(y) = sqrt(x * y) * sqrt(1)\" \n    by (metis mult_cancel_left2 real_sqrt_eq_1_iff real_sqrt_mult assms)\n  then show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma sqrt_simplification:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x) * sqrt(y) = sqrt(x * y)\"\nproof -\n  have \"sqrt(x) * sqrt(y) = sqrt(x * y) * sqrt(1)\" \n    by (metis mult_cancel_left2 real_sqrt_eq_1_iff real_sqrt_mult assms)\n  then show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_simplificationV2": {"skill_name": "sqrt_simplificationV2", "marker": "lemma sqrt_simplification:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x) * sqrt(y) = sqrt(x * y)\"\nproof -\n  have \"sqrt(x) * sqrt(y) = sqrt(x * y) * sqrt(1)\" \n    by (metis mult_cancel_left2 real_sqrt_eq_1_iff real_sqrt_mult)\n  also have \"... = sqrt(x * y)\" \n    by (simp add: real_sqrt_eq_1_iff)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_simplification:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x) * sqrt(y) = sqrt(x * y)\"\nproof -\n  have \"sqrt(x) * sqrt(y) = sqrt(x * y) * sqrt(1)\" \n    by (metis mult_cancel_left2 real_sqrt_eq_1_iff real_sqrt_mult)\n  also have \"... = sqrt(x * y)\" \n    by (simp add: real_sqrt_eq_1_iff)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_simplificationV3": {"skill_name": "sqrt_simplificationV3", "marker": "lemma sqrt_simplification:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x) * sqrt(y) = sqrt(x * y)\"\nproof -\n  have \"sqrt(x) * sqrt(y) = sqrt(x * y * 1)\" \n    by (metis mult_cancel_left2 real_sqrt_mult)\n  also have \"1 = sqrt(1)\" \n    by auto\n  then have \"sqrt(x * y * 1) = sqrt(x * y) * sqrt(1)\" \n    by (metis assms real_sqrt_mult)\n  finally show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma sqrt_simplification:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x) * sqrt(y) = sqrt(x * y)\"\nproof -\n  have \"sqrt(x) * sqrt(y) = sqrt(x * y * 1)\" \n    by (metis mult_cancel_left2 real_sqrt_mult)\n  also have \"1 = sqrt(1)\" \n    by auto\n  then have \"sqrt(x * y * 1) = sqrt(x * y) * sqrt(1)\" \n    by (metis assms real_sqrt_mult)\n  finally show ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "inequality_floor": {"skill_name": "inequality_floor", "marker": "lemma inequality_floor:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  moreover have \"r < n + 1\" using assms\n    by auto\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_floor:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  moreover have \"r < n + 1\" using assms\n    by auto\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "inequality_floorV2": {"skill_name": "inequality_floorV2", "marker": "lemma inequality_floor:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  from assms have \"n \\<le> r\" by auto\n  moreover have \"r < n + 1\"\n  proof -\n    have \"n \\<le> r\" using assms by auto\n    then show ?thesis using assms by auto\n  qed\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_floor:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  from assms have \"n \\<le> r\" by auto\n  moreover have \"r < n + 1\"\n  proof -\n    have \"n \\<le> r\" using assms by auto\n    then show ?thesis using assms by auto\n  qed\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_extendedV6": {"skill_name": "mathd_algebra_109_extendedV6", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" using h2 by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  have \"2 * b = 12 - 12\" by (metis \\<open>12 + 2 * b = c\\<close> add.commute add.left_commute add_diff_cancel add_diff_eq add_minus_cancel diff_conv_add_uminus diff_minus_eq_add equation_minus_iff group_cancel.neg1 h2 minus_diff_eq mult.commute mult_2 mult_2_right square_eq_iff uminus_add_conv_diff verit_minus_simplify(4))\n  have \"2 * b = 0\" by (metis \\<open>2 * b = 12 - 12\\<close> cancel_comm_monoid_add_class.diff_cancel dbl_simps(3) h2)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" using h2 by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  have \"2 * b = 12 - 12\" by (metis \\<open>12 + 2 * b = c\\<close> add.commute add.left_commute add_diff_cancel add_diff_eq add_minus_cancel diff_conv_add_uminus diff_minus_eq_add equation_minus_iff group_cancel.neg1 h2 minus_diff_eq mult.commute mult_2 mult_2_right square_eq_iff uminus_add_conv_diff verit_minus_simplify(4))\n  have \"2 * b = 0\" by (metis \\<open>2 * b = 12 - 12\\<close> cancel_comm_monoid_add_class.diff_cancel dbl_simps(3) h2)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sqrt_limit": {"skill_name": "sqrt_limit", "marker": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  have \"81 = x + 9\" by (metis \\<open>9\\<^sup>2 = x + 9\\<close> abs_numeral add.commute add.left_commute add_One_commute num_double numeral_Bit0 numeral_Bit1 numeral_times_numeral power2_eq_square real_sqrt_abs2 real_sqrt_mult_self semiring_norm(3) semiring_norm(6) sqr.simps(2) sqr.simps(3) sqr_conv_mult)\n  have \"x = 81 - 9\" by (metis \\<open>81 = x + 9\\<close> add_diff_cancel semiring_norm(3) semiring_norm(5))\n  then show ?thesis by auto\nqed", "description": "", "full_code": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  have \"81 = x + 9\" by (metis \\<open>9\\<^sup>2 = x + 9\\<close> abs_numeral add.commute add.left_commute add_One_commute num_double numeral_Bit0 numeral_Bit1 numeral_times_numeral power2_eq_square real_sqrt_abs2 real_sqrt_mult_self semiring_norm(3) semiring_norm(6) sqr.simps(2) sqr.simps(3) sqr_conv_mult)\n  have \"x = 81 - 9\" by (metis \\<open>81 = x + 9\\<close> add_diff_cancel semiring_norm(3) semiring_norm(5))\n  then show ?thesis by auto\nqed", "origin": "data/full_data/debug/valid_rand/mathd_algebra_31.json_v8", "update_count": -1}, "rearrangement_of_equations": {"skill_name": "rearrangement_of_equations", "marker": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b = a + b - b\" using assms by simp\n  then show \"a = c - b\" by simp\nqed", "description": "-", "full_code": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b = a + b - b\" using assms by simp\n  then show \"a = c - b\" by simp\nqed", "origin": "do_request", "update_count": 0}, "rearrangement_of_equationsV2": {"skill_name": "rearrangement_of_equationsV2", "marker": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  from assms have \"a = c - b\" \n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  from assms have \"a = c - b\" \n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_xeqn4_general": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_xeqn4_general", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_xeqn4_general:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a + (-x) \\<and> x = (b - a) / 1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using eq_simplified by auto\n  then have e_value: \"e = a - (b - a)\" using e_expr x_value by simp\n  then show ?thesis using x_value by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed\n\ntheorem algebra_2varlineareq_xpeeq7_2xpeeq3_xeqn4_general:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a + (-x) \\<and> x = (b - a) / 1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using eq_simplified by auto\n  then have e_value: \"e = a - (b - a)\" using e_expr x_value by simp\n  then show ?thesis using x_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_modified": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_modified", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_modified:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  hence \"2 * x + (7 - x) = 3\" using h1 by simp\n  thus ?thesis\n  proof -\n    have eq_simplified: \"x + 7 = 3\" using `2 * x + (7 - x) = 3` by simp\n    have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n    then have x_value_final: \"x = -4\" by simp\n    have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n    then show ?thesis using x_value_final by auto\n  qed\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_modified:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  hence \"2 * x + (7 - x) = 3\" using h1 by simp\n  thus ?thesis\n  proof -\n    have eq_simplified: \"x + 7 = 3\" using `2 * x + (7 - x) = 3` by simp\n    have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n    then have x_value_final: \"x = -4\" by simp\n    have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n    then show ?thesis using x_value_final by auto\n  qed\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "expanded_case_for_var_eq": {"skill_name": "expanded_case_for_var_eq", "marker": "lemma expanded_case_for_var_eq:\n  fixes x y :: complex\n  assumes h0 : \"x + y = 7\" \n    and h1 : \"2 * x + y = 3\"\n  shows \"y = 11 \\<and> x = -4\"\nproof -\n  have y_expr: \"y = 7 - x\" using h0 by (auto simp: field_simps)\n  hence \"2 * x + (7 - x) = 3\" using h1 by simp\n  thus ?thesis\n  proof -\n    have eq_simplified: \"x + 7 = 3\" using `2 * x + (7 - x) = 3` by simp\n    have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n    then have x_value_final: \"x = -4\" by simp\n    have y_value: \"y = 7 - (-4)\" using y_expr x_value_final by simp\n    then show ?thesis using x_value_final by auto\n  qed\nqed", "description": "-", "full_code": "lemma expanded_case_for_var_eq:\n  fixes x y :: complex\n  assumes h0 : \"x + y = 7\" \n    and h1 : \"2 * x + y = 3\"\n  shows \"y = 11 \\<and> x = -4\"\nproof -\n  have y_expr: \"y = 7 - x\" using h0 by (auto simp: field_simps)\n  hence \"2 * x + (7 - x) = 3\" using h1 by simp\n  thus ?thesis\n  proof -\n    have eq_simplified: \"x + 7 = 3\" using `2 * x + (7 - x) = 3` by simp\n    have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n    then have x_value_final: \"x = -4\" by simp\n    have y_value: \"y = 7 - (-4)\" using y_expr x_value_final by simp\n    then show ?thesis using x_value_final by auto\n  qed\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV4": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV4", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x = -4 \\<and> e = 11\"\nproof -\n  obtain a where \"x = a\" by auto\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * a + (7 - a) = 3\" using e_expr by (metis \\<open>x = a\\<close> h1 one_plus_BitM or_not_num_neg.simps(2) uminus_add_conv_diff)\n  have eq_simplified: \"a + 7 = 3\" using eq_substituted by simp\n  have a_value: \"a = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value: \"x = -4\" by (metis \\<open>x = a\\<close> add.commute dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value by simp\n  then show ?thesis using x_value e_value by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x = -4 \\<and> e = 11\"\nproof -\n  obtain a where \"x = a\" by auto\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * a + (7 - a) = 3\" using e_expr by (metis \\<open>x = a\\<close> h1 one_plus_BitM or_not_num_neg.simps(2) uminus_add_conv_diff)\n  have eq_simplified: \"a + 7 = 3\" using eq_substituted by simp\n  have a_value: \"a = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value: \"x = -4\" by (metis \\<open>x = a\\<close> add.commute dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value by simp\n  then show ?thesis using x_value e_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_yxpeq7_2yxpeq3_eeq11_yeqn4": {"skill_name": "algebra_2varlineareq_yxpeq7_2yxpeq3_eeq11_yeqn4", "marker": "theorem algebra_2varlineareq_yxpeq7_2yxpeq3_eeq11_yeqn4:\n  fixes y e :: complex\n  assumes h0 : \"y + e = 7\"\n    and h1 : \"2 * y + e = 3\"\n  shows \"y = -4 \\<and> e = 11\"\nproof -\n  have e_expr: \"e = 7 - y\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * y + (7 - y) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"y + 7 = 3\" using eq_substituted by simp\n  have y_value: \"y = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have y_value_final: \"y = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr y_value_final by simp\n  then show ?thesis using y_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_yxpeq7_2yxpeq3_eeq11_yeqn4:\n  fixes y e :: complex\n  assumes h0 : \"y + e = 7\"\n    and h1 : \"2 * y + e = 3\"\n  shows \"y = -4 \\<and> e = 11\"\nproof -\n  have e_expr: \"e = 7 - y\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * y + (7 - y) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"y + 7 = 3\" using eq_substituted by simp\n  have y_value: \"y = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have y_value_final: \"y = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr y_value_final by simp\n  then show ?thesis using y_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "mathd_algebra_110": {"skill_name": "mathd_algebra_110", "marker": "theorem mathd_algebra_110:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"2 * b = 12 - 3 * a\" by (simp add: algebra_simps)\n  then show ?thesis using h1 by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_110:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"2 * b = 12 - 3 * a\" by (simp add: algebra_simps)\n  then show ?thesis using h1 by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "algebra_linear_system": {"skill_name": "algebra_linear_system", "marker": "theorem algebra_linear_system:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by simp\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem algebra_linear_system:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by simp\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "non_negative_squaresV3": {"skill_name": "non_negative_squaresV3", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have a_square_non_negative: \"0 \\<le> a^2\"\n  proof -\n    have \"a^2 = a * a\" by (simp add: power2_eq_square)\n    then show ?thesis\n    proof (cases \"a = 0\")\n      case True\n      then show ?thesis by simp\n    next\n      case False\n      then have \"a \\<noteq> 0\" by simp\n      then show ?thesis \n      proof (cases \"a > 0\")\n        case True\n        then show ?thesis by (simp add: mult_nonneg_nonneg)\n      next\n        case False\n        then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n        hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n        also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n        finally show ?thesis by simp\n      qed\n    qed\n  qed\n  have b_square_non_negative: \"0 \\<le> b^2\"\n  proof -\n    have \"b^2 = b * b\" by (simp add: power2_eq_square)\n    then show ?thesis\n    proof (cases \"b = 0\")\n      case True\n      then show ?thesis by simp\n    next\n      case False\n      then have \"b \\<noteq> 0\" by simp\n      then show ?thesis \n      proof (cases \"b > 0\")\n        case True\n        then show ?thesis by (simp add: mult_nonneg_nonneg)\n      next\n        case False\n        then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n        hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n        also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n        finally show ?thesis by simp\n      qed\n    qed\n  qed\n  thus \"0 \\<le> a^2\" and \"0 \\<le> b^2\" by auto\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have a_square_non_negative: \"0 \\<le> a^2\"\n  proof -\n    have \"a^2 = a * a\" by (simp add: power2_eq_square)\n    then show ?thesis\n    proof (cases \"a = 0\")\n      case True\n      then show ?thesis by simp\n    next\n      case False\n      then have \"a \\<noteq> 0\" by simp\n      then show ?thesis \n      proof (cases \"a > 0\")\n        case True\n        then show ?thesis by (simp add: mult_nonneg_nonneg)\n      next\n        case False\n        then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n        hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n        also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n        finally show ?thesis by simp\n      qed\n    qed\n  qed\n  have b_square_non_negative: \"0 \\<le> b^2\"\n  proof -\n    have \"b^2 = b * b\" by (simp add: power2_eq_square)\n    then show ?thesis\n    proof (cases \"b = 0\")\n      case True\n      then show ?thesis by simp\n    next\n      case False\n      then have \"b \\<noteq> 0\" by simp\n      then show ?thesis \n      proof (cases \"b > 0\")\n        case True\n        then show ?thesis by (simp add: mult_nonneg_nonneg)\n      next\n        case False\n        then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n        hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n        also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n        finally show ?thesis by simp\n      qed\n    qed\n  qed\n  thus \"0 \\<le> a^2\" and \"0 \\<le> b^2\" by auto\nqed", "origin": "do_request", "update_count": 0}, "two_var_linear_eq": {"skill_name": "two_var_linear_eq", "marker": "lemma two_var_linear_eq:\n  fixes x y :: complex\n  assumes h0: \"x + y = a\"  \n      and h1: \"b * x + c * y = d\"  \n  shows \"y = a - x\"  \nproof -\n  have \"y = a - x\" using h0 by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma two_var_linear_eq:\n  fixes x y :: complex\n  assumes h0: \"x + y = a\"  \n      and h1: \"b * x + c * y = d\"  \n  shows \"y = a - x\"  \nproof -\n  have \"y = a - x\" using h0 by auto\n  thus ?thesis by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "substitution_for_linear_equations": {"skill_name": "substitution_for_linear_equations", "marker": "lemma substitution_for_linear_equations:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"  \n      and h1 : \"2 * x + e = b\"  \n  shows \"e = a - x\"  \n      and \"2 * x + (a - x) = b\"  \nproof -\n  show \"e = a - x\" using h0 by auto\n  then show \"2 * x + (a - x) = b\" using h1 by simp\nqed", "description": "-", "full_code": "lemma substitution_for_linear_equations:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"  \n      and h1 : \"2 * x + e = b\"  \n  shows \"e = a - x\"  \n      and \"2 * x + (a - x) = b\"  \nproof -\n  show \"e = a - x\" using h0 by auto\n  then show \"2 * x + (a - x) = b\" using h1 by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "modulo_squared_equivalence_4": {"skill_name": "modulo_squared_equivalence_4", "marker": "lemma modulo_squared_equivalence_4:\n  fixes a b :: int\n  assumes \"b = a mod 4\"\n  shows \"a^2 mod 4 = b^2 mod 4\"\nproof -\n  have \"a = 4 * (a div 4) + b\" using assms by auto\n  then have \"a^2 = (4 * (a div 4) + b)^2\" by simp\n  also have \"... = (4 * (a div 4))^2 + 2 * (4 * (a div 4)) * b + b^2\" by (smt (verit) power2_sum)\n  also have \"... = 16 * (a div 4)^2 + 8 * (a div 4) * b + b^2\" by auto\n  finally have \"a^2 = 16 * (a div 4)^2 + 8 * (a div 4) * b + b^2\" .\n  then have \"a^2 mod 4 = (16 * (a div 4)^2 + 8 * (a div 4) * b + b^2) mod 4\" by simp\n  also have \"... = (0 + 0 + b^2) mod 4\" by (smt (verit) \\<open>a\\<^sup>2 = 16 * (a div 4)\\<^sup>2 + 8 * (a div 4) * b + b\\<^sup>2\\<close> assms power_mod)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma modulo_squared_equivalence_4:\n  fixes a b :: int\n  assumes \"b = a mod 4\"\n  shows \"a^2 mod 4 = b^2 mod 4\"\nproof -\n  have \"a = 4 * (a div 4) + b\" using assms by auto\n  then have \"a^2 = (4 * (a div 4) + b)^2\" by simp\n  also have \"... = (4 * (a div 4))^2 + 2 * (4 * (a div 4)) * b + b^2\" by (smt (verit) power2_sum)\n  also have \"... = 16 * (a div 4)^2 + 8 * (a div 4) * b + b^2\" by auto\n  finally have \"a^2 = 16 * (a div 4)^2 + 8 * (a div 4) * b + b^2\" .\n  then have \"a^2 mod 4 = (16 * (a div 4)^2 + 8 * (a div 4) * b + b^2) mod 4\" by simp\n  also have \"... = (0 + 0 + b^2) mod 4\" by (smt (verit) \\<open>a\\<^sup>2 = 16 * (a div 4)\\<^sup>2 + 8 * (a div 4) * b + b\\<^sup>2\\<close> assms power_mod)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "linear_equations_solution": {"skill_name": "linear_equations_solution", "marker": "lemma linear_equations_solution:\n  fixes x e :: real\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = b - 2 * (a - e) \\<and> x = (a - e)\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  then have eq_simplified: \"x + a = b\" by simp\n  have x_value: \"x = b - a\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq)\n  then have e_value: \"e = a - (b - a)\" using e_expr by simp\n  then show ?thesis using x_value by auto\nqed", "description": "-", "full_code": "lemma linear_equations_solution:\n  fixes x e :: real\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = b - 2 * (a - e) \\<and> x = (a - e)\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  then have eq_simplified: \"x + a = b\" by simp\n  have x_value: \"x = b - a\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq)\n  then have e_value: \"e = a - (b - a)\" using e_expr by simp\n  then show ?thesis using x_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "non_negative_squaresV4": {"skill_name": "non_negative_squaresV4", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"a^2 >= 0\" \n    using mult_nonneg_nonneg[of a a] \n    by auto\n  have \"b^2 = b * b\" by sos\n  then show \"b^2 >= 0\" \n    using mult_nonneg_nonneg[of b b] \n    by auto\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"a^2 >= 0\" \n    using mult_nonneg_nonneg[of a a] \n    by auto\n  have \"b^2 = b * b\" by sos\n  then show \"b^2 >= 0\" \n    using mult_nonneg_nonneg[of b b] \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "non_negative_squaresV5": {"skill_name": "non_negative_squaresV5", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"a^2 >= 0\" \n  proof (cases \"a >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"a < 0\" by (simp)\n    hence \"a^2 = (-a) * (-a)\" by sos\n    also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n    finally show ?thesis by simp\n  qed\n  have \"b^2 = b * b\" by sos\n  then show \"b^2 >= 0\" \n  proof (cases \"b >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"b < 0\" by (simp)\n    hence \"b^2 = (-b) * (-b)\" by sos\n    also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n    finally show ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"a^2 >= 0\" \n  proof (cases \"a >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"a < 0\" by (simp)\n    hence \"a^2 = (-a) * (-a)\" by sos\n    also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n    finally show ?thesis by simp\n  qed\n  have \"b^2 = b * b\" by sos\n  then show \"b^2 >= 0\" \n  proof (cases \"b >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"b < 0\" by (simp)\n    hence \"b^2 = (-b) * (-b)\" by sos\n    also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n    finally show ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "amc12a_2013_p8_alternative": {"skill_name": "amc12a_2013_p8_alternative", "marker": "lemma amc12a_2013_p8_alternative:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\" \n      and h1: \"y \\<noteq> 0\" \n      and h2: \"x \\<noteq> y\" \n      and h3: \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have \"(x - y) * (x * y) = 2 * (x - y)\" \n    using h2 by (metis add_diff_add amc12a_2013_p8_extended diff_add_eq diff_diff_eq2 h0 h1 h3 mult_2 mult_2_right)\n  thus ?thesis using h2 by sos\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_extended:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\" \n      and h1: \"y \\<noteq> 0\" \n      and h2: \"x \\<noteq> y\" \n      and h3: \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  hence rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit))\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  then obtain c where c_def: \"c = (x - y)\" \"c \\<noteq> 0\" \n    using h2 by auto\n  have \"x * y = 2\" \n    using c_def(2) cross_mult by (metis c_def(1) diff_frac_eq divide_divide_eq_left' h0 h1 mult.assoc mult.commute mult_2 mult_2_right mult_divide_mult_cancel_left_if mult_eq_0_iff mult_numeral_1_right nonzero_divide_mult_cancel_right nonzero_mult_div_cancel_left nonzero_mult_divide_mult_cancel_left2 numeral_One one_add_one rearranged right_diff_distrib times_divide_eq_right)\n  thus ?thesis by simp\nqed\n\nlemma amc12a_2013_p8_alternative:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\" \n      and h1: \"y \\<noteq> 0\" \n      and h2: \"x \\<noteq> y\" \n      and h3: \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have \"(x - y) * (x * y) = 2 * (x - y)\" \n    using h2 by (metis add_diff_add amc12a_2013_p8_extended diff_add_eq diff_diff_eq2 h0 h1 h3 mult_2 mult_2_right)\n  thus ?thesis using h2 by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_extendedV2": {"skill_name": "amc12a_2013_p8_extendedV2", "marker": "theorem amc12a_2013_p8_extended:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\" \n      and h1: \"y \\<noteq> 0\" \n      and h2: \"x \\<noteq> y\" \n      and h3: \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  hence rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit))\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  then obtain c where c_def: \"c = (x - y)\" \"c \\<noteq> 0\" \n    using h2 by auto\n  have \"x * y = 2\" \n    using c_def(2) cross_mult by (metis c_def(1) diff_frac_eq divide_divide_eq_left' h0 h1 mult.assoc mult.commute mult_2 mult_2_right mult_divide_mult_cancel_left_if mult_eq_0_iff mult_numeral_1_right nonzero_divide_mult_cancel_right nonzero_mult_div_cancel_left nonzero_mult_divide_mult_cancel_left2 numeral_One one_add_one rearranged right_diff_distrib times_divide_eq_right)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_extended:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\" \n      and h1: \"y \\<noteq> 0\" \n      and h2: \"x \\<noteq> y\" \n      and h3: \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  hence rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit))\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  then obtain c where c_def: \"c = (x - y)\" \"c \\<noteq> 0\" \n    using h2 by auto\n  have \"x * y = 2\" \n    using c_def(2) cross_mult by (metis c_def(1) diff_frac_eq divide_divide_eq_left' h0 h1 mult.assoc mult.commute mult_2 mult_2_right mult_divide_mult_cancel_left_if mult_eq_0_iff mult_numeral_1_right nonzero_divide_mult_cancel_right nonzero_mult_div_cancel_left nonzero_mult_divide_mult_cancel_left2 numeral_One one_add_one rearranged right_diff_distrib times_divide_eq_right)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "square_non_negative": {"skill_name": "square_non_negative", "marker": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  from `a = b` have \"b^2 = a * a\" by sos\n  thus \"a^2 = b^2\" by sos\nqed", "description": "-", "full_code": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  from `a = b` have \"b^2 = a * a\" by sos\n  thus \"a^2 = b^2\" by sos\nqed", "origin": "do_request", "update_count": 0}, "square_non_negativeV2": {"skill_name": "square_non_negativeV2", "marker": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by simp\n  then have \"b^2 = a^2\" by (simp add: power2_eq_square)\n  thus \"a^2 = b^2\" by simp\nqed", "description": "-", "full_code": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by simp\n  then have \"b^2 = a^2\" by (simp add: power2_eq_square)\n  thus \"a^2 = b^2\" by simp\nqed", "origin": "do_request", "update_count": 0}, "square_non_negativeV3": {"skill_name": "square_non_negativeV3", "marker": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"... = b * b\" using assms(1) by (simp add: power2_eq_square)\n  also have \"... = b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"... = b * b\" using assms(1) by (simp add: power2_eq_square)\n  also have \"... = b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_non_negativeV4": {"skill_name": "square_non_negativeV4", "marker": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by simp\n  moreover from assms(2) have \"0 \\<le> a\" by simp\n  ultimately show \"a^2 = b^2\" \n    by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by simp\n  moreover from assms(2) have \"0 \\<le> a\" by simp\n  ultimately show \"a^2 = b^2\" \n    by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "square_non_negativeV5": {"skill_name": "square_non_negativeV5", "marker": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) show ?thesis\n    by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) show ?thesis\n    by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV5": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV5", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by (simp add: field_simps)\n  have \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value by simp\n  then show ?thesis using x_value by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by (simp add: field_simps)\n  have \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value by simp\n  then show ?thesis using x_value by (simp add: field_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_parametrized": {"skill_name": "algebra_2varlineareq_parametrized", "marker": "theorem algebra_2varlineareq_parametrized:\n  fixes a b c d e :: complex\n  assumes h0 : \"a + b = c\"\n    and h1 : \"2 * a + b = d\"\n  shows \"b = c - a \\<and> a = (d - c) / 1\"\nproof -\n  have b_expr: \"b = c - a\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * a + (c - a) = d\" using b_expr h1 by simp\n  have eq_simplified: \"a + c = d\" using eq_substituted by (simp add: field_simps)\n  have \"a = d - c\" using eq_simplified by (simp add: field_simps)\n  thus ?thesis using b_expr by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_parametrized:\n  fixes a b c d e :: complex\n  assumes h0 : \"a + b = c\"\n    and h1 : \"2 * a + b = d\"\n  shows \"b = c - a \\<and> a = (d - c) / 1\"\nproof -\n  have b_expr: \"b = c - a\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * a + (c - a) = d\" using b_expr h1 by simp\n  have eq_simplified: \"a + c = d\" using eq_substituted by (simp add: field_simps)\n  have \"a = d - c\" using eq_simplified by (simp add: field_simps)\n  thus ?thesis using b_expr by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_generalized": {"skill_name": "algebra_2varlineareq_generalized", "marker": "theorem algebra_2varlineareq_generalized:\n  fixes a b c d e :: complex\n  assumes h0 : \"a + b = c\"\n    and h1 : \"d * a + b = e\"\n  shows \"b = e - d * (c - b)\"\nproof -\n  have b_expr: \"b = c - a\" using h0 by auto\n  have eq_substituted: \"d * a + (c - a) = e\" using b_expr h1 by simp\n  then show ?thesis by (metis add_diff_cancel add_diff_cancel_left' h0 h1 mult.commute)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_generalized:\n  fixes a b c d e :: complex\n  assumes h0 : \"a + b = c\"\n    and h1 : \"d * a + b = e\"\n  shows \"b = e - d * (c - b)\"\nproof -\n  have b_expr: \"b = c - a\" using h0 by auto\n  have eq_substituted: \"d * a + (c - a) = e\" using b_expr h1 by simp\n  then show ?thesis by (metis add_diff_cancel add_diff_cancel_left' h0 h1 mult.commute)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "sqrt_limit_multi_dim": {"skill_name": "sqrt_limit_multi_dim", "marker": "lemma sqrt_limit_multi_dim:\n  fixes x :: real\n  assumes \"n > 0\" \"n = sqrt(x + n)\"\n  shows \"x = n^2 - n\"\nproof -\n  have \"n^2 = x + n\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_limit_multi_dim:\n  fixes x :: real\n  assumes \"n > 0\" \"n = sqrt(x + n)\"\n  shows \"x = n^2 - n\"\nproof -\n  have \"n^2 = x + n\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then show ?thesis by auto\nqed", "origin": "sqrt_limit", "update_count": 0}, "mathd_algebra_109_evolvedV6": {"skill_name": "mathd_algebra_109_evolvedV6", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b + c = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b + 0 = 12\" using h1 h2 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) `3 * 4 + 2 * b + 0 = 12`)\n  have \"2 * b = 0\" by (metis `12 + 2 * b = 12` add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b + c = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b + 0 = 12\" using h1 h2 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) `3 * 4 + 2 * b + 0 = 12`)\n  have \"2 * b = 0\" by (metis `12 + 2 * b = 12` add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV6": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV6", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  from h0 obtain e' where e_expr: \"e' = 7 - x\" by auto\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by (metis add.commute add_diff_cancel dbl_def dbl_inc_simps(3) dbl_simps(3) h0 mult_2)\n  then have eq_simplified: \"x + 7 = 3\" by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by (metis add.commute add_diff_cancel diff_minus_eq_add h0 one_plus_BitM or_not_num_neg.simps(2))\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  thus ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  from h0 obtain e' where e_expr: \"e' = 7 - x\" by auto\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by (metis add.commute add_diff_cancel dbl_def dbl_inc_simps(3) dbl_simps(3) h0 mult_2)\n  then have eq_simplified: \"x + 7 = 3\" by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by (metis add.commute add_diff_cancel diff_minus_eq_add h0 one_plus_BitM or_not_num_neg.simps(2))\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  thus ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "min_value_of_squaresV2": {"skill_name": "min_value_of_squaresV2", "marker": "lemma min_value_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\nproof -\n  have \"x^2 \\<ge> 0\" \n    by auto\n  have \"y^2 \\<ge> 0\" \n    by auto\n  have \"x^2 + y^2 = x^2 + y^2 + 0\"\n    by simp\n  thus ?thesis \n    by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma min_value_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\nproof -\n  have \"x^2 \\<ge> 0\" \n    by auto\n  have \"y^2 \\<ge> 0\" \n    by auto\n  have \"x^2 + y^2 = x^2 + y^2 + 0\"\n    by simp\n  thus ?thesis \n    by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "min_value_of_squaresV3": {"skill_name": "min_value_of_squaresV3", "marker": "lemma min_value_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\nproof -\n  have \"x^2 \\<ge> 0\" \n    by auto\n  moreover have \"y^2 \\<ge> 0\" \n    by auto\n  ultimately show ?thesis \n    by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma min_value_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\nproof -\n  have \"x^2 \\<ge> 0\" \n    by auto\n  moreover have \"y^2 \\<ge> 0\" \n    by auto\n  ultimately show ?thesis \n    by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "amc12a_2013_p8_extendedV3": {"skill_name": "amc12a_2013_p8_extendedV3", "marker": "theorem amc12a_2013_p8_extended:\n  fixes x y z :: real\n  assumes h0 : \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"z \\<noteq> 0\"\n    and h1 : \"x \\<noteq> y\" \"y \\<noteq> z\" \"z \\<noteq> x\"\n    and h2 : \"x + 2/x = y + 2/y\" \"y + 2/y = z + 2/z\"\n  shows \"x * y * z = 4\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h2(1) by simp\n  have \"y + 2/y = z + 2/z\" using h2(2) by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" by (smt (verit) h2(1))\n  have rearranged2: \"y - z = (2/z - 2/y)\" by (smt (verit) h2(2))\n  have cross_mult1: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged1 by sos\n  have cross_mult2: \"(y - z) * y * z = 2 * (y - z)\" \n    using rearranged2 by sos\n  have \"x * y = 2\" using h1(1) cross_mult1 by sos\n  have \"y * z = 2\" using h1(2) cross_mult2 by sos\n  then have \"x * y * z = (2/z) * z\" by (metis \\<open>x * y = 2\\<close> add_diff_cancel_left' dbl_simps(3) diff_add_cancel eq_divide_eq h0(2) h0(3) h1(3) rearranged2)\n  thus ?thesis by (metis \\<open>x * y = 2\\<close> \\<open>y * z = 2\\<close> add_diff_cancel_left' dbl_simps(3) diff_add_cancel eq_divide_eq h0(2) h0(3) h1(3) rearranged2)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_extended:\n  fixes x y z :: real\n  assumes h0 : \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"z \\<noteq> 0\"\n    and h1 : \"x \\<noteq> y\" \"y \\<noteq> z\" \"z \\<noteq> x\"\n    and h2 : \"x + 2/x = y + 2/y\" \"y + 2/y = z + 2/z\"\n  shows \"x * y * z = 4\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h2(1) by simp\n  have \"y + 2/y = z + 2/z\" using h2(2) by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" by (smt (verit) h2(1))\n  have rearranged2: \"y - z = (2/z - 2/y)\" by (smt (verit) h2(2))\n  have cross_mult1: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged1 by sos\n  have cross_mult2: \"(y - z) * y * z = 2 * (y - z)\" \n    using rearranged2 by sos\n  have \"x * y = 2\" using h1(1) cross_mult1 by sos\n  have \"y * z = 2\" using h1(2) cross_mult2 by sos\n  then have \"x * y * z = (2/z) * z\" by (metis \\<open>x * y = 2\\<close> add_diff_cancel_left' dbl_simps(3) diff_add_cancel eq_divide_eq h0(2) h0(3) h1(3) rearranged2)\n  thus ?thesis by (metis \\<open>x * y = 2\\<close> \\<open>y * z = 2\\<close> add_diff_cancel_left' dbl_simps(3) diff_add_cancel eq_divide_eq h0(2) h0(3) h1(3) rearranged2)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "sum_of_non_negativesV4": {"skill_name": "sum_of_non_negativesV4", "marker": "lemma sum_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\n  by (simp add: assms)", "description": "-", "full_code": "lemma sum_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\n  by (simp add: assms)", "origin": "do_request", "update_count": 0}, "lcm_coprime": {"skill_name": "lcm_coprime", "marker": "lemma lcm_coprime:\n  fixes a b :: nat\n  assumes \"gcd a b = 1\"\n  shows \"lcm a b = a * b\"\nproof -\n  have \"lcm a b = (a * b) div (gcd a b)\" by (metis lcm_nat_def)\n  then have \"lcm a b = (a * b) div 1\" using assms by simp\n  then show \"lcm a b = a * b\" by simp\nqed", "description": "-", "full_code": "lemma lcm_coprime:\n  fixes a b :: nat\n  assumes \"gcd a b = 1\"\n  shows \"lcm a b = a * b\"\nproof -\n  have \"lcm a b = (a * b) div (gcd a b)\" by (metis lcm_nat_def)\n  then have \"lcm a b = (a * b) div 1\" using assms by simp\n  then show \"lcm a b = a * b\" by simp\nqed", "origin": "do_request", "update_count": 0}, "lcm_coprimeV2": {"skill_name": "lcm_coprimeV2", "marker": "lemma lcm_coprime:\n  fixes a b :: nat\n  assumes \"gcd a b = 1\"\n  shows \"lcm a b = a * b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\" by (simp add: lcm_gcd)\n  then have \"lcm a b * 1 = a * b\" using assms by simp\n  thus ?thesis by (simp add: assms)\nqed", "description": "-", "full_code": "lemma lcm_coprime:\n  fixes a b :: nat\n  assumes \"gcd a b = 1\"\n  shows \"lcm a b = a * b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\" by (simp add: lcm_gcd)\n  then have \"lcm a b * 1 = a * b\" using assms by simp\n  thus ?thesis by (simp add: assms)\nqed", "origin": "do_request", "update_count": 0}, "lcm_coprimeV3": {"skill_name": "lcm_coprimeV3", "marker": "lemma lcm_coprime:\n  fixes a b :: nat\n  assumes \"gcd a b = 1\"\n  shows \"lcm a b = a * b\"\nproof -\n  have \"lcm a b = (a * b) div gcd a b\" by (metis lcm_nat_def)\n  then have \"lcm a b = (a * b) div 1\" using assms by auto\n  also have \"... = a * b\" by auto\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma lcm_coprime:\n  fixes a b :: nat\n  assumes \"gcd a b = 1\"\n  shows \"lcm a b = a * b\"\nproof -\n  have \"lcm a b = (a * b) div gcd a b\" by (metis lcm_nat_def)\n  then have \"lcm a b = (a * b) div 1\" using assms by auto\n  also have \"... = a * b\" by auto\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "lcm_coprimeV4": {"skill_name": "lcm_coprimeV4", "marker": "lemma lcm_coprime:\n  fixes a b :: nat\n  assumes \"gcd a b = 1\"\n  shows \"lcm a b = a * b\"\nproof -\n  have \"lcm a b = (a * b) div (gcd a b)\"\n    by (metis lcm_nat_def)\n  then show \"lcm a b = a * b\" \n    using assms by auto\nqed", "description": "-", "full_code": "lemma lcm_coprime:\n  fixes a b :: nat\n  assumes \"gcd a b = 1\"\n  shows \"lcm a b = a * b\"\nproof -\n  have \"lcm a b = (a * b) div (gcd a b)\"\n    by (metis lcm_nat_def)\n  then show \"lcm a b = a * b\" \n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "lcm_coprimeV5": {"skill_name": "lcm_coprimeV5", "marker": "lemma lcm_coprime:\n  fixes a b :: nat\n  assumes \"gcd a b = 1\"\n  shows \"lcm a b = a * b\"\nproof -\n  have \"lcm a b = (a * b) div (gcd a b)\"\n    by (metis lcm_nat_def)\n  from assms have \"gcd a b = 1\" by simp\n  then have \"lcm a b = (a * b) div 1\"\n    by (metis \\<open>lcm a b = a * b div gcd a b\\<close> mult_delta_right)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma lcm_coprime:\n  fixes a b :: nat\n  assumes \"gcd a b = 1\"\n  shows \"lcm a b = a * b\"\nproof -\n  have \"lcm a b = (a * b) div (gcd a b)\"\n    by (metis lcm_nat_def)\n  from assms have \"gcd a b = 1\" by simp\n  then have \"lcm a b = (a * b) div 1\"\n    by (metis \\<open>lcm a b = a * b div gcd a b\\<close> mult_delta_right)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_generalV2": {"skill_name": "mathd_algebra_109_generalV2", "marker": "theorem mathd_algebra_109_general:\n  fixes a b :: real\n  assumes h0 : \"c * a + d * b = e\" \n      and h1 : \"a = f\"\n      and h2 : \"c > 0\" \"d > 0\" \"e > 0\" \"f > 0\"\n  shows \"b = (e - c * f) / d\"\nproof -\n  have eq: \"c * a + d * b = e\" using h0 by simp\n  have \"c * f + d * b = e\" using h1 eq by simp\n  have \"d * b = e - c * f\" by (smt (verit) h0 h1)\n  then show ?thesis using h2 by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_general:\n  fixes a b :: real\n  assumes h0 : \"c * a + d * b = e\" \n      and h1 : \"a = f\"\n      and h2 : \"c > 0\" \"d > 0\" \"e > 0\" \"f > 0\"\n  shows \"b = (e - c * f) / d\"\nproof -\n  have eq: \"c * a + d * b = e\" using h0 by simp\n  have \"c * f + d * b = e\" using h1 eq by simp\n  have \"d * b = e - c * f\" by (smt (verit) h0 h1)\n  then show ?thesis using h2 by (auto simp: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_generalV3": {"skill_name": "mathd_algebra_109_generalV3", "marker": "theorem mathd_algebra_109_general:\n  fixes a b :: real\n  assumes h0 : \"k * a + m * b = c\"\n    and h1 : \"a = a_val\"\n    and h2 : \"k > 0\" \"m > 0\"\n  shows \"b = (c - k * a_val) / m\"\nproof -\n  have eq: \"k * a + m * b = c\" using h0 by simp\n  have \"k * a_val + m * b = c\" using h1 eq by simp\n  have \"m * b = c - k * a_val\" by (metis \\<open>k * a_val + m * b = c\\<close> add_diff_cancel_left' h1 mult_delta_right)\n  thus ?thesis by (metis h2(2) less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_general:\n  fixes a b :: real\n  assumes h0 : \"k * a + m * b = c\"\n    and h1 : \"a = a_val\"\n    and h2 : \"k > 0\" \"m > 0\"\n  shows \"b = (c - k * a_val) / m\"\nproof -\n  have eq: \"k * a + m * b = c\" using h0 by simp\n  have \"k * a_val + m * b = c\" using h1 eq by simp\n  have \"m * b = c - k * a_val\" by (metis \\<open>k * a_val + m * b = c\\<close> add_diff_cancel_left' h1 mult_delta_right)\n  thus ?thesis by (metis h2(2) less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sqrt_limit_general": {"skill_name": "sqrt_limit_general", "marker": "lemma sqrt_limit_general:\n  fixes x :: real\n  assumes \"n > 0\" \"k > 0\" \"k = sqrt(x + k)\"\n  shows \"x = k^2 - k\"\nproof -\n  have \"k^2 = x + k\" using assms(3) by (smt (verit) assms(2) less_eq_real_def real_sqrt_le_iff real_sqrt_pow2_iff real_sqrt_zero)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_limit_general:\n  fixes x :: real\n  assumes \"n > 0\" \"k > 0\" \"k = sqrt(x + k)\"\n  shows \"x = k^2 - k\"\nproof -\n  have \"k^2 = x + k\" using assms(3) by (smt (verit) assms(2) less_eq_real_def real_sqrt_le_iff real_sqrt_pow2_iff real_sqrt_zero)\n  then show ?thesis by auto\nqed", "origin": "sqrt_limit", "update_count": 0}, "units_digit_modulo": {"skill_name": "units_digit_modulo", "marker": "lemma units_digit_modulo:\n  fixes a :: nat\n  shows \"a mod 10 = (a mod 10)\"\nproof -\n  show ?thesis by simp\nqed", "description": "-", "full_code": "lemma units_digit_modulo:\n  fixes a :: nat\n  shows \"a mod 10 = (a mod 10)\"\nproof -\n  show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "units_digit_moduloV2": {"skill_name": "units_digit_moduloV2", "marker": "lemma units_digit_modulo:\n  fixes a :: nat\n  shows \"a mod 10 = (a mod 10)\"\nproof -\n  have \"a mod 10 = a mod 10\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma units_digit_modulo:\n  fixes a :: nat\n  shows \"a mod 10 = (a mod 10)\"\nproof -\n  have \"a mod 10 = a mod 10\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "units_digit_of_squareV3": {"skill_name": "units_digit_of_squareV3", "marker": "lemma units_digit_of_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  have \"n = 10 * (n div 10) + (n mod 10)\" by auto\n  then have \"n^2 = (10 * (n div 10) + (n mod 10))^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * (n mod 10) + (n mod 10)^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2\" by simp\n  finally have \"n^2 = 100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2\" .\n  then have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2) mod 10\" by simp\n  also have \"... = (0 + 0 + (n mod 10)^2) mod 10\" by (metis add_cancel_right_left calculation group_cancel.add1 power_mod)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma units_digit_of_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  have \"n = 10 * (n div 10) + (n mod 10)\" by auto\n  then have \"n^2 = (10 * (n div 10) + (n mod 10))^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * (n mod 10) + (n mod 10)^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2\" by simp\n  finally have \"n^2 = 100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2\" .\n  then have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2) mod 10\" by simp\n  also have \"... = (0 + 0 + (n mod 10)^2) mod 10\" by (metis add_cancel_right_left calculation group_cancel.add1 power_mod)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_limit_generalV2": {"skill_name": "sqrt_limit_generalV2", "marker": "lemma sqrt_limit_general:\n  fixes x :: real\n  assumes \"y = sqrt(x + z)\" and \"z > 0\" and \"y > 0\"\n  shows \"x = y^2 - z\"\nproof -\n  have \"y^2 = x + z\" using assms by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_limit_general:\n  fixes x :: real\n  assumes \"y = sqrt(x + z)\" and \"z > 0\" and \"y > 0\"\n  shows \"x = y^2 - z\"\nproof -\n  have \"y^2 = x + z\" using assms by auto\n  thus ?thesis by auto\nqed", "origin": "sqrt_limit", "update_count": 0}, "add_modulo": {"skill_name": "add_modulo", "marker": "lemma add_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\" by (simp add: nat_eq_iff)\n  have \"b = (b mod 10) + 10 * (b div 10)\" by (simp add: nat_eq_iff)\n  then have \"a + b = (a mod 10) + (b mod 10) + 10 * ((a div 10) + (b div 10))\" \n    by simp\n  then have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma add_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\" by (simp add: nat_eq_iff)\n  have \"b = (b mod 10) + 10 * (b div 10)\" by (simp add: nat_eq_iff)\n  then have \"a + b = (a mod 10) + (b mod 10) + 10 * ((a div 10) + (b div 10))\" \n    by simp\n  then have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "add_moduloV2": {"skill_name": "add_moduloV2", "marker": "lemma add_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\" by auto\n  have \"b = (b mod 10) + 10 * (b div 10)\" by auto\n  then have \"a + b = ((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))\" \n    by auto\n  then have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma add_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\" by auto\n  have \"b = (b mod 10) + 10 * (b div 10)\" by auto\n  then have \"a + b = ((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))\" \n    by auto\n  then have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "add_moduloV3": {"skill_name": "add_moduloV3", "marker": "lemma add_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\"\n    by auto\n  have \"b = (b mod 10) + 10 * (b div 10)\"\n    by auto\n  then have \"a + b = (a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma add_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\"\n    by auto\n  have \"b = (b mod 10) + 10 * (b div 10)\"\n    by auto\n  then have \"a + b = (a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_fractionsV5": {"skill_name": "combine_fractionsV5", "marker": "lemma combine_fractions:\n  fixes x y z :: real\n  shows \"x / a + y / a = (x + y) / a\"\nproof -\n  have \"x / a + y / a = (x + y) / a\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    thus ?thesis by (simp add: field_simps)\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_fractions:\n  fixes x y z :: real\n  shows \"x / a + y / a = (x + y) / a\"\nproof -\n  have \"x / a + y / a = (x + y) / a\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    thus ?thesis by (simp add: field_simps)\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_fractionsV6": {"skill_name": "combine_fractionsV6", "marker": "lemma combine_fractions:\n  fixes x y a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"x / a + y / a = (x + y) / a\"\nproof -\n  have \"x / a + y / a = (x + y) / a\"\n    by (metis add_divide_distrib)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_fractions:\n  fixes x y a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"x / a + y / a = (x + y) / a\"\nproof -\n  have \"x / a + y / a = (x + y) / a\"\n    by (metis add_divide_distrib)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_fractionsV7": {"skill_name": "combine_fractionsV7", "marker": "lemma combine_fractions:\n  fixes x y a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"x / a + y / a = (x + y) / a\"\nproof -\n  have \"x / a + y / a = (x + y) / a\"\n  proof -\n    have \"x / a + y / a = (x + y) / a\"\n      by (metis add_divide_distrib)\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_fractions:\n  fixes x y a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"x / a + y / a = (x + y) / a\"\nproof -\n  have \"x / a + y / a = (x + y) / a\"\n  proof -\n    have \"x / a + y / a = (x + y) / a\"\n      by (metis add_divide_distrib)\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_root_expression": {"skill_name": "simplify_square_root_expression", "marker": "lemma simplify_square_root_expression:\n  fixes a b c :: real\n  assumes \"c \\<noteq> 0\" \"b \\<ge> 0\"\n  shows \"((a - sqrt b) / c)^2 = (a^2 - 2*a*sqrt b + b) / (c^2)\"\nproof -\n  have left_side: \"((a - sqrt b) / c)^2 = (a - sqrt b)^2 / (c^2)\"\n    by (auto simp: field_simps)\n  have right_side: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  have \"(sqrt b)^2 = b\"\n    by (metis assms(2) real_sqrt_pow2)\n  have final_eq: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    by (metis \\<open>(sqrt b)\\<^sup>2 = b\\<close> right_side)\n  then show ?thesis using left_side final_eq by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b c :: real\n  assumes \"c \\<noteq> 0\" \"b \\<ge> 0\"\n  shows \"((a - sqrt b) / c)^2 = (a^2 - 2*a*sqrt b + b) / (c^2)\"\nproof -\n  have left_side: \"((a - sqrt b) / c)^2 = (a - sqrt b)^2 / (c^2)\"\n    by (auto simp: field_simps)\n  have right_side: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  have \"(sqrt b)^2 = b\"\n    by (metis assms(2) real_sqrt_pow2)\n  have final_eq: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    by (metis \\<open>(sqrt b)\\<^sup>2 = b\\<close> right_side)\n  then show ?thesis using left_side final_eq by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_root_expressionV2": {"skill_name": "simplify_square_root_expressionV2", "marker": "lemma simplify_square_root_expression:\n  fixes a b c :: real\n  assumes \"c \\<noteq> 0\" \"b \\<ge> 0\"  \n  shows \"((a - sqrt b) / c)^2 = (a^2 - 2*a*sqrt b + b) / (c^2)\"\nproof -\n  have left_side: \"((a - sqrt b) / c)^2 = (a - sqrt b)^2 / (c^2)\"\n    by (simp add: power_divide)\n  have expansion: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    by (metis assms(2) real_sqrt_pow2)\n  then have \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    using expansion by simp\n  then show ?thesis \n    using left_side by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b c :: real\n  assumes \"c \\<noteq> 0\" \"b \\<ge> 0\"  \n  shows \"((a - sqrt b) / c)^2 = (a^2 - 2*a*sqrt b + b) / (c^2)\"\nproof -\n  have left_side: \"((a - sqrt b) / c)^2 = (a - sqrt b)^2 / (c^2)\"\n    by (simp add: power_divide)\n  have expansion: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    by (metis assms(2) real_sqrt_pow2)\n  then have \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    using expansion by simp\n  then show ?thesis \n    using left_side by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_root_expressionV3": {"skill_name": "simplify_square_root_expressionV3", "marker": "lemma simplify_square_root_expression:\n  fixes a b c :: real\n  assumes \"c \\<noteq> 0\" \"b \\<ge> 0\"\n  shows \"((a - sqrt b) / c)^2 = (a^2 - 2 * a * sqrt b + b) / (c^2)\"\nproof -\n  have left_side: \"((a - sqrt b) / c)^2 = (a - sqrt b)^2 / c^2\"\n    by (simp add: power_divide)\n  also have \"... = (a^2 - 2 * a * sqrt b + (sqrt b)^2) / c^2\"\n    by (metis diff_add_eq power2_diff power2_eq_square)\n  also have \"... = (a^2 - 2 * a * sqrt b + b) / c^2\"\n    by (smt (verit) assms(2) real_sqrt_pow2_iff)\n  finally show ?thesis\n    by (simp add: left_side)\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b c :: real\n  assumes \"c \\<noteq> 0\" \"b \\<ge> 0\"\n  shows \"((a - sqrt b) / c)^2 = (a^2 - 2 * a * sqrt b + b) / (c^2)\"\nproof -\n  have left_side: \"((a - sqrt b) / c)^2 = (a - sqrt b)^2 / c^2\"\n    by (simp add: power_divide)\n  also have \"... = (a^2 - 2 * a * sqrt b + (sqrt b)^2) / c^2\"\n    by (metis diff_add_eq power2_diff power2_eq_square)\n  also have \"... = (a^2 - 2 * a * sqrt b + b) / c^2\"\n    by (smt (verit) assms(2) real_sqrt_pow2_iff)\n  finally show ?thesis\n    by (simp add: left_side)\nqed", "origin": "do_request", "update_count": 0}, "linear_combinationV2": {"skill_name": "linear_combinationV2", "marker": "lemma linear_combination:\n  fixes a b :: complex\n  assumes h0: \"a + b = c\" \n      and h1: \"2 * a + b = d\"\n  shows \"a = (d - c) / 1 \\<and> b = c - a\"\nproof -\n  obtain x where \"x = c - b\" using h0 by auto\n  then have a_expr: \"a = c - b\" by (metis add.commute add_scale_eq_noteq cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0 h0 mult.commute mult_delta_left mult_delta_right)\n  then have \"2 * a + b = 2 * (c - b) + b\" by simp\n  then have \"2 * a + b = 2 * c - 2 * b + b\" by simp\n  then have \"2 * a + b = 2 * c - b\" by simp\n  then have \"b = 2 * c - d\" using h1 by simp\n  then have \"a = c - (2 * c - d)\" using a_expr by simp\n  then show ?thesis by (metis \\<open>2 * a + b = 2 * c - b\\<close> a_expr add.commute add_diff_cancel_right' add_diff_eq add_left_cancel add_left_imp_eq add_right_imp_eq cancel_ab_semigroup_add_class.diff_right_commute diff_add_cancel diff_add_eq diff_add_eq_diff_diff_swap diff_diff_eq diff_diff_eq2 div_by_1 eq_diff_eq h0 h1 mult.commute mult_2_right)\nqed", "description": "-", "full_code": "lemma linear_combination:\n  fixes a b :: complex\n  assumes h0: \"a + b = c\" \n      and h1: \"2 * a + b = d\"\n  shows \"a = (d - c) / 1 \\<and> b = c - a\"\nproof -\n  obtain x where \"x = c - b\" using h0 by auto\n  then have a_expr: \"a = c - b\" by (metis add.commute add_scale_eq_noteq cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0 h0 mult.commute mult_delta_left mult_delta_right)\n  then have \"2 * a + b = 2 * (c - b) + b\" by simp\n  then have \"2 * a + b = 2 * c - 2 * b + b\" by simp\n  then have \"2 * a + b = 2 * c - b\" by simp\n  then have \"b = 2 * c - d\" using h1 by simp\n  then have \"a = c - (2 * c - d)\" using a_expr by simp\n  then show ?thesis by (metis \\<open>2 * a + b = 2 * c - b\\<close> a_expr add.commute add_diff_cancel_right' add_diff_eq add_left_cancel add_left_imp_eq add_right_imp_eq cancel_ab_semigroup_add_class.diff_right_commute diff_add_cancel diff_add_eq diff_add_eq_diff_diff_swap diff_diff_eq diff_diff_eq2 div_by_1 eq_diff_eq h0 h1 mult.commute mult_2_right)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "add_moduloV4": {"skill_name": "add_moduloV4", "marker": "lemma add_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\" by auto\n  then have \"a mod 10 + b mod 10 < 20\" by auto\n  hence \"(a mod 10 + b mod 10) mod 10 = a mod 10 + b mod 10 - 10 * ((a mod 10 + b mod 10) div 10)\" \n    by (metis minus_div_mult_eq_mod minus_mult_div_eq_mod)\n  have \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\n    by presburger\n  thus ?thesis by (simp add: mod_add_eq)\nqed", "description": "-", "full_code": "lemma add_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\" by auto\n  then have \"a mod 10 + b mod 10 < 20\" by auto\n  hence \"(a mod 10 + b mod 10) mod 10 = a mod 10 + b mod 10 - 10 * ((a mod 10 + b mod 10) div 10)\" \n    by (metis minus_div_mult_eq_mod minus_mult_div_eq_mod)\n  have \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\n    by presburger\n  thus ?thesis by (simp add: mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "add_moduloV5": {"skill_name": "add_moduloV5", "marker": "lemma add_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a mod 10 + b mod 10 < 20\" \n    using mod_less by auto\n  moreover have \"(a + b) mod 10 < 10\" \n    using mod_less by auto\n  hence \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\n    by presburger\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma add_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a mod 10 + b mod 10 < 20\" \n    using mod_less by auto\n  moreover have \"(a + b) mod 10 < 10\" \n    using mod_less by auto\n  hence \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\n    by presburger\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "cross_multiplication_inequality": {"skill_name": "cross_multiplication_inequality", "marker": "lemma cross_multiplication_inequality:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n    and \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using assms(4) by simp\n  then have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit))\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  then have \"x * y = 2\" \n    using assms(3) by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma cross_multiplication_inequality:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n    and \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using assms(4) by simp\n  then have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit))\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  then have \"x * y = 2\" \n    using assms(3) by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "sqrt_limitV2": {"skill_name": "sqrt_limitV2", "marker": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x + 9 = 9^2\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 81\" using assms by (simp)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x + 9 = 9^2\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 81\" using assms by (simp)\n  then show ?thesis by auto\nqed", "origin": "sqrt_limit", "update_count": 0}, "solve_sqrt_equation": {"skill_name": "solve_sqrt_equation", "marker": "lemma solve_sqrt_equation:\n  fixes x :: real\n  assumes \"y = sqrt(x + 9)\" and \"y > 0\"\n  shows \"x = y^2 - 9\"\nproof -\n  have \"y^2 = x + 9\" using assms(1) by (metis assms(2) less_eq_real_def real_sqrt_eq_iff real_sqrt_unique)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma solve_sqrt_equation:\n  fixes x :: real\n  assumes \"y = sqrt(x + 9)\" and \"y > 0\"\n  shows \"x = y^2 - 9\"\nproof -\n  have \"y^2 = x + 9\" using assms(1) by (metis assms(2) less_eq_real_def real_sqrt_eq_iff real_sqrt_unique)\n  then show ?thesis by simp\nqed", "origin": "sqrt_limit", "update_count": 0}, "mathd_algebra_109_extendedV7": {"skill_name": "mathd_algebra_109_extendedV7", "marker": "lemma mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  then have \"12 + 2 * b = c\" using h2 by simp\n  have \"c - 12 = 2 * b\" using `12 + 2 * b = c` by simp\n  have \"2 * b = 0\" using h2 by (metis \\<open>c - 12 = 2 * b\\<close> dbl_simps(3) diff_self)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed\n\nlemma mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  then have \"12 + 2 * b = c\" using h2 by simp\n  have \"c - 12 = 2 * b\" using `12 + 2 * b = c` by simp\n  have \"2 * b = 0\" using h2 by (metis \\<open>c - 12 = 2 * b\\<close> dbl_simps(3) diff_self)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mod_addition": {"skill_name": "mod_addition", "marker": "lemma mod_addition:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  have \"a = (a mod m) + m * (a div m)\" by auto\n  have \"b = (b mod m) + m * (b div m)\" by auto\n  then have \"a + b = ((a mod m) + (b mod m)) + m * ((a div m) + (b div m))\" \n    by (auto simp: field_simps)\n  then have \"(a + b) mod m = (((a mod m) + (b mod m)) + m * ((a div m) + (b div m))) mod m\" \n    by presburger\n  also have \"... = ((a mod m) + (b mod m)) mod m\" \n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  have \"a = (a mod m) + m * (a div m)\" by auto\n  have \"b = (b mod m) + m * (b div m)\" by auto\n  then have \"a + b = ((a mod m) + (b mod m)) + m * ((a div m) + (b div m))\" \n    by (auto simp: field_simps)\n  then have \"(a + b) mod m = (((a mod m) + (b mod m)) + m * ((a div m) + (b div m))) mod m\" \n    by presburger\n  also have \"... = ((a mod m) + (b mod m)) mod m\" \n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_additionV2": {"skill_name": "mod_additionV2", "marker": "lemma mod_addition:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  have \"a = (a mod m) + m * (a div m)\"\n    by auto\n  have \"b = (b mod m) + m * (b div m)\"\n    by auto\n  then have \"a + b = (a mod m + b mod m) + m * (a div m + b div m)\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((a mod m + b mod m) + m * (a div m + b div m)) mod m\"\n    by simp\n  also have \"... = (a mod m + b mod m) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  have \"a = (a mod m) + m * (a div m)\"\n    by auto\n  have \"b = (b mod m) + m * (b div m)\"\n    by auto\n  then have \"a + b = (a mod m + b mod m) + m * (a div m + b div m)\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((a mod m + b mod m) + m * (a div m + b div m)) mod m\"\n    by simp\n  also have \"... = (a mod m + b mod m) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negative_sumV3": {"skill_name": "non_negative_sumV3", "marker": "lemma non_negative_sum:\n  fixes a b c :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\"\n  shows \"a + b + c >= 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by simp\n  moreover have \"a + b >= 0\"\n  proof -\n    have \"a + b = a + b\" by simp\n    moreover have \"a >= 0\" using assms(1) by simp\n    moreover have \"b >= 0\" using assms(2) by simp\n    ultimately show \"a + b >= 0\" by (metis add_nonneg_nonneg)\n  qed\n  moreover have \"c >= 0\" using assms(3) by simp\n  ultimately show ?thesis \n    using add_nonneg_nonneg by blast\nqed", "description": "-", "full_code": "lemma non_negative_sum:\n  fixes a b c :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\"\n  shows \"a + b + c >= 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by simp\n  moreover have \"a + b >= 0\"\n  proof -\n    have \"a + b = a + b\" by simp\n    moreover have \"a >= 0\" using assms(1) by simp\n    moreover have \"b >= 0\" using assms(2) by simp\n    ultimately show \"a + b >= 0\" by (metis add_nonneg_nonneg)\n  qed\n  moreover have \"c >= 0\" using assms(3) by simp\n  ultimately show ?thesis \n    using add_nonneg_nonneg by blast\nqed", "origin": "do_request", "update_count": 0}, "sqrt_limit_generalized": {"skill_name": "sqrt_limit_generalized", "marker": "lemma sqrt_limit_generalized:\n  fixes x y :: real\n  assumes \"y = sqrt(x + y)\" and \"y > 0\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then have \"x = y^2 - y\" by (metis add_diff_cancel semiring_norm(3) semiring_norm(5))\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_limit_generalized:\n  fixes x y :: real\n  assumes \"y = sqrt(x + y)\" and \"y > 0\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then have \"x = y^2 - y\" by (metis add_diff_cancel semiring_norm(3) semiring_norm(5))\n  then show ?thesis by simp\nqed", "origin": "sqrt_limit", "update_count": 0}, "cross_multiplication_inequalityV2": {"skill_name": "cross_multiplication_inequalityV2", "marker": "lemma cross_multiplication_inequality:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\" and \"a / b = c / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a / b = c / d\" using assms by simp\n  then show \"a * d = b * c\" by (metis assms(1) assms(2) div_by_1 divide_cancel_right frac_eq_eq mult.commute times_divide_eq_left zero_neq_one)\nqed", "description": "-", "full_code": "lemma cross_multiplication_inequality:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\" and \"a / b = c / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a / b = c / d\" using assms by simp\n  then show \"a * d = b * c\" by (metis assms(1) assms(2) div_by_1 divide_cancel_right frac_eq_eq mult.commute times_divide_eq_left zero_neq_one)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "sqrt_square_inequality": {"skill_name": "sqrt_square_inequality", "marker": "lemma sqrt_square_inequality:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt(x^2) = abs(x)\"\nproof -\n  have \"sqrt(x^2) = sqrt((abs(x))^2)\" using assms by (simp add: power2_eq_square)\n  then show ?thesis by (simp add: real_sqrt_abs)\nqed", "description": "-", "full_code": "lemma sqrt_square_inequality:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt(x^2) = abs(x)\"\nproof -\n  have \"sqrt(x^2) = sqrt((abs(x))^2)\" using assms by (simp add: power2_eq_square)\n  then show ?thesis by (simp add: real_sqrt_abs)\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_equationV4": {"skill_name": "sqrt_equationV4", "marker": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt(x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" by (simp add: power2_eq_square)\n  then show ?thesis by (simp add: add_diff_cancel)\nqed", "description": "-", "full_code": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt(x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" by (simp add: power2_eq_square)\n  then show ?thesis by (simp add: add_diff_cancel)\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_convergence": {"skill_name": "sqrt_convergence", "marker": "lemma sqrt_convergence:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x = 0 \\<longleftrightarrow> x = 0\"\nproof -\n  have \"sqrt x = 0 \\<Longrightarrow> x = 0\" \n  proof -\n    assume \"sqrt x = 0\"\n    have \"x = (sqrt x)^2\" by (metis \\<open>sqrt x = 0\\<close> abs_0_eq assms nless_le one_add_one power2_eq_iff_nonneg power_abs real_sqrt_eq_iff real_sqrt_eq_zero_cancel_iff real_sqrt_pow2 real_sqrt_power zero_less_abs_iff)\n    thus ?thesis using `sqrt x = 0` by simp\n  qed\n  have \"x = 0 \\<Longrightarrow> sqrt x = 0\" \n  proof -\n    assume \"x = 0\"\n    thus ?thesis by simp\n  qed\n  show \"sqrt x = 0 \\<longleftrightarrow> x = 0\" \n    by (metis `x >= 0` `sqrt x = 0 \\<Longrightarrow> x = 0` `x = 0 \\<Longrightarrow> sqrt x = 0` assms)\nqed", "description": "-", "full_code": "lemma sqrt_convergence:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x = 0 \\<longleftrightarrow> x = 0\"\nproof -\n  have \"sqrt x = 0 \\<Longrightarrow> x = 0\" \n  proof -\n    assume \"sqrt x = 0\"\n    have \"x = (sqrt x)^2\" by (metis \\<open>sqrt x = 0\\<close> abs_0_eq assms nless_le one_add_one power2_eq_iff_nonneg power_abs real_sqrt_eq_iff real_sqrt_eq_zero_cancel_iff real_sqrt_pow2 real_sqrt_power zero_less_abs_iff)\n    thus ?thesis using `sqrt x = 0` by simp\n  qed\n  have \"x = 0 \\<Longrightarrow> sqrt x = 0\" \n  proof -\n    assume \"x = 0\"\n    thus ?thesis by simp\n  qed\n  show \"sqrt x = 0 \\<longleftrightarrow> x = 0\" \n    by (metis `x >= 0` `sqrt x = 0 \\<Longrightarrow> x = 0` `x = 0 \\<Longrightarrow> sqrt x = 0` assms)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_addition": {"skill_name": "sqrt_addition", "marker": "lemma sqrt_addition:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt(x + 9) = 9\"\nproof -\n  have \"x + 9 = 72 + 9\" using assms by simp\n  then have \"x + 9 = 81\" by simp\n  then have \"sqrt(x + 9) = sqrt(81)\" by (simp add: \\<open>x + 9 = 81\\<close>)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_addition:\n  fixes x :: real\n  assumes \"x = 72\"\n  shows \"sqrt(x + 9) = 9\"\nproof -\n  have \"x + 9 = 72 + 9\" using assms by simp\n  then have \"x + 9 = 81\" by simp\n  then have \"sqrt(x + 9) = sqrt(81)\" by (simp add: \\<open>x + 9 = 81\\<close>)\n  then show ?thesis by simp\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_limit_with_substitution": {"skill_name": "sqrt_limit_with_substitution", "marker": "lemma sqrt_limit_with_substitution:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x = 81 - 9\" by (simp add: power2_eq_square)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_limit_with_substitution:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x = 81 - 9\" by (simp add: power2_eq_square)\n  thus ?thesis by simp\nqed", "origin": "sqrt_limit", "update_count": 0}, "sum_floor_properties": {"skill_name": "sum_floor_properties", "marker": "lemma sum_floor_properties:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\nproof -\n  have \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_floor_properties:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\nproof -\n  have \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareqV3": {"skill_name": "algebra_2varlineareqV3", "marker": "theorem algebra_2varlineareq:\n  fixes x e :: real\n  assumes h0 : \"x + e = m\"\n    and h1 : \"2 * x + e = n\"\n  shows \"e = (m - x) \\<and> x = (n - m) / 1\"\nproof -\n  have e_expr: \"e = m - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (m - x) = n\" using e_expr h1 by simp\n  have eq_simplified: \"x + m = n\" using eq_substituted by simp\n  have x_value: \"x = n - m\" using eq_simplified by simp\n  then have x_value_final: \"x = (n - m) / 1\" by simp\n  have e_value: \"e = m - (n - m)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq:\n  fixes x e :: real\n  assumes h0 : \"x + e = m\"\n    and h1 : \"2 * x + e = n\"\n  shows \"e = (m - x) \\<and> x = (n - m) / 1\"\nproof -\n  have e_expr: \"e = m - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (m - x) = n\" using e_expr h1 by simp\n  have eq_simplified: \"x + m = n\" using eq_substituted by simp\n  have x_value: \"x = n - m\" using eq_simplified by simp\n  then have x_value_final: \"x = (n - m) / 1\" by simp\n  have e_value: \"e = m - (n - m)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "minimum_value_of_squaresV2": {"skill_name": "minimum_value_of_squaresV2", "marker": "lemma minimum_value_of_squares:\n  fixes x y :: real\n  shows \"1 = min ((x * y - 1)^2 + (x + y)^2) (1)\"\nproof -\n  let ?f = \"(\\<lambda>xy. (xy - 1)^2 + (x + y)^2)\"\n  have \"1 = min (?f (x * y)) (1)\"\n  proof (cases \"((x * y - 1)^2 + (x + y)^2) \\<le> 1\")\n    case True\n    then show ?thesis \n      by sos\n  next\n    case False\n    then have \"((x * y - 1)^2 + (x + y)^2) > 1\" \n      by simp\n    then show ?thesis \n      by simp\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma minimum_value_of_squares:\n  fixes x y :: real\n  shows \"1 = min ((x * y - 1)^2 + (x + y)^2) (1)\"\nproof -\n  let ?f = \"(\\<lambda>xy. (xy - 1)^2 + (x + y)^2)\"\n  have \"1 = min (?f (x * y)) (1)\"\n  proof (cases \"((x * y - 1)^2 + (x + y)^2) \\<le> 1\")\n    case True\n    then show ?thesis \n      by sos\n  next\n    case False\n    then have \"((x * y - 1)^2 + (x + y)^2) > 1\" \n      by simp\n    then show ?thesis \n      by simp\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "minimum_value_of_squaresV3": {"skill_name": "minimum_value_of_squaresV3", "marker": "lemma minimum_value_of_squares:\n  fixes x y :: real\n  shows \"1 = min ((x * y - 1)^2 + (x + y)^2) (1)\"\nproof -\n  have \"((x * y - 1)^2 + (x + y)^2) \\<ge> 0\" \n    by auto\n  have \"1 = min ((x * y - 1)^2 + (x + y)^2) (1) \\<longleftrightarrow> ((x * y - 1)^2 + (x + y)^2) \\<ge> 1\" \n    by auto\n  show ?thesis \n  proof (cases \"((x * y - 1)^2 + (x + y)^2) < 1\")\n    case True\n    then have \"min ((x * y - 1)^2 + (x + y)^2) (1) = 1\" \n      by sos\n    then show ?thesis by simp\n  next\n    case False\n    then have \"((x * y - 1)^2 + (x + y)^2) \\<ge> 1\" \n      by simp\n    then show ?thesis \n      by auto\n  qed\nqed", "description": "-", "full_code": "lemma minimum_value_of_squares:\n  fixes x y :: real\n  shows \"1 = min ((x * y - 1)^2 + (x + y)^2) (1)\"\nproof -\n  have \"((x * y - 1)^2 + (x + y)^2) \\<ge> 0\" \n    by auto\n  have \"1 = min ((x * y - 1)^2 + (x + y)^2) (1) \\<longleftrightarrow> ((x * y - 1)^2 + (x + y)^2) \\<ge> 1\" \n    by auto\n  show ?thesis \n  proof (cases \"((x * y - 1)^2 + (x + y)^2) < 1\")\n    case True\n    then have \"min ((x * y - 1)^2 + (x + y)^2) (1) = 1\" \n      by sos\n    then show ?thesis by simp\n  next\n    case False\n    then have \"((x * y - 1)^2 + (x + y)^2) \\<ge> 1\" \n      by simp\n    then show ?thesis \n      by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "equality_transformation": {"skill_name": "equality_transformation", "marker": "theorem equality_transformation:\n  fixes x y z :: real\n  assumes h0: \"x + 2/x = y + 2/y\"\n    and h1: \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y = 2\"\nproof -\n  have rearranged: \"x - y = (2/y - 2/x)\" using h0 by simp\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  then have \"x * y = 2\" \n    using h1(3) by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem equality_transformation:\n  fixes x y z :: real\n  assumes h0: \"x + 2/x = y + 2/y\"\n    and h1: \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y = 2\"\nproof -\n  have rearranged: \"x - y = (2/y - 2/x)\" using h0 by simp\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  then have \"x * y = 2\" \n    using h1(3) by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiplication": {"skill_name": "cross_multiplication", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \"a / b = c / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a / b = c / d\" using assms(3) by simp\n  then have \"a * d = c * b\" by (metis assms(1) assms(2) frac_eq_eq)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \"a / b = c / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a / b = c / d\" using assms(3) by simp\n  then have \"a * d = c * b\" by (metis assms(1) assms(2) frac_eq_eq)\n  then show ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "algebraic_substitution": {"skill_name": "algebraic_substitution", "marker": "lemma algebraic_substitution:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = 12\"\n    and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "lemma algebraic_substitution:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = 12\"\n    and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complicated": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complicated", "marker": "lemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complicated:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x + e = 7 \\<and> e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis ab_group_add_class.ab_diff_conv_add_uminus ab_semigroup_add_class.add_ac(1) add.commute add_diff_cancel add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simple diff_diff_eq diff_minus_eq_add group_cancel.sub1 left_add_twice minus_diff_eq minus_equation_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed\n\nlemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simple:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e + x = 7\"\nproof -\n  show ?thesis using h0 by (auto simp: field_simps)\nqed\n\nlemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complicated:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x + e = 7 \\<and> e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis ab_group_add_class.ab_diff_conv_add_uminus ab_semigroup_add_class.add_ac(1) add.commute add_diff_cancel add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simple diff_diff_eq diff_minus_eq_add group_cancel.sub1 left_add_twice minus_diff_eq minus_equation_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpleV2": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpleV2", "marker": "lemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simple:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e + x = 7\"\nproof -\n  show ?thesis using h0 by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed\n\nlemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simple:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e + x = 7\"\nproof -\n  show ?thesis using h0 by (auto simp: field_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "sum_floor_propertiesV2": {"skill_name": "sum_floor_propertiesV2", "marker": "lemma sum_floor_properties:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\nproof -\n  from assms show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_floor_properties:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\nproof -\n  from assms show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_properties": {"skill_name": "sqrt_properties", "marker": "lemma sqrt_properties:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x * y) = sqrt(x) * sqrt(y)\"\nproof -\n  have \"sqrt(x * y) = sqrt(x * y * 1)\" \n    by (metis mult_cancel_left2 real_sqrt_mult assms)\n  also have \"1 = sqrt(1)\" \n    by auto\n  then have \"sqrt(x * y * 1) = sqrt(x * y) * sqrt(1)\" \n    by (metis assms real_sqrt_mult)\n  also have \"sqrt(x * y) = sqrt(x) * sqrt(y)\" \n    by (metis assms real_sqrt_mult)\n  finally show ?thesis \n    by (metis \\<open>sqrt (x * y) = sqrt x * sqrt y\\<close>)\nqed", "description": "-", "full_code": "lemma sqrt_properties:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x * y) = sqrt(x) * sqrt(y)\"\nproof -\n  have \"sqrt(x * y) = sqrt(x * y * 1)\" \n    by (metis mult_cancel_left2 real_sqrt_mult assms)\n  also have \"1 = sqrt(1)\" \n    by auto\n  then have \"sqrt(x * y * 1) = sqrt(x * y) * sqrt(1)\" \n    by (metis assms real_sqrt_mult)\n  also have \"sqrt(x * y) = sqrt(x) * sqrt(y)\" \n    by (metis assms real_sqrt_mult)\n  finally show ?thesis \n    by (metis \\<open>sqrt (x * y) = sqrt x * sqrt y\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_propertiesV2": {"skill_name": "sqrt_propertiesV2", "marker": "lemma sqrt_properties:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x * y) = sqrt(x) * sqrt(y)\"\nproof -\n  have \"sqrt(x * y) = sqrt(x) * sqrt(y)\" \n    using assms by (metis real_sqrt_mult)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_properties:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x * y) = sqrt(x) * sqrt(y)\"\nproof -\n  have \"sqrt(x * y) = sqrt(x) * sqrt(y)\" \n    using assms by (metis real_sqrt_mult)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_propertiesV3": {"skill_name": "sqrt_propertiesV3", "marker": "lemma sqrt_properties:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x * y) = sqrt(x) * sqrt(y)\"\nproof -\n  have \"sqrt(x * y) * sqrt(1) = sqrt(x * y)\" \n    by auto\n  also have \"sqrt(1) = 1\" \n    by auto\n  then have \"sqrt(x * y) = sqrt(x) * sqrt(y) * sqrt(1)\"\n    by (metis mult.right_neutral real_sqrt_eq_1_iff real_sqrt_mult)\n  thus ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma sqrt_properties:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x * y) = sqrt(x) * sqrt(y)\"\nproof -\n  have \"sqrt(x * y) * sqrt(1) = sqrt(x * y)\" \n    by auto\n  also have \"sqrt(1) = 1\" \n    by auto\n  then have \"sqrt(x * y) = sqrt(x) * sqrt(y) * sqrt(1)\"\n    by (metis mult.right_neutral real_sqrt_eq_1_iff real_sqrt_mult)\n  thus ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_limit_alternative": {"skill_name": "sqrt_limit_alternative", "marker": "lemma sqrt_limit_alternative:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus \"x = 72\" by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma sqrt_limit_alternative:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus \"x = 72\" by (simp add: power2_eq_square)\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_limit_extended": {"skill_name": "sqrt_limit_extended", "marker": "lemma sqrt_limit_extended:\n  fixes x y :: real\n  assumes \"y = sqrt(x + y)\" \"y > 0\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma sqrt_limit_extended:\n  fixes x y :: real\n  assumes \"y = sqrt(x + y)\" \"y > 0\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_limit_extendedV2": {"skill_name": "sqrt_limit_extendedV2", "marker": "lemma sqrt_limit_extended:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  hence \"81 = x + 9\" by simp\n  thus ?thesis by (simp add: add_diff_cancel)\nqed", "description": "-", "full_code": "lemma sqrt_limit_extended:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  hence \"81 = x + 9\" by simp\n  thus ?thesis by (simp add: add_diff_cancel)\nqed", "origin": "sqrt_limit", "update_count": 0}, "simplify_expression": {"skill_name": "simplify_expression", "marker": "lemma simplify_expression:\n  fixes a b c d :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a * a) - 2 * a * b + (b * b)\"\n    by sos\n  show ?thesis\n    using left_side by sos\nqed", "description": "-", "full_code": "lemma simplify_expression:\n  fixes a b c d :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a * a) - 2 * a * b + (b * b)\"\n    by sos\n  show ?thesis\n    using left_side by sos\nqed", "origin": "do_request", "update_count": 0}, "simplify_expressionV2": {"skill_name": "simplify_expressionV2", "marker": "lemma simplify_expression:\n  fixes a b c d :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n    by (simp add: power2_diff)\n  show ?thesis\n    using left_side by simp\nqed", "description": "-", "full_code": "lemma simplify_expression:\n  fixes a b c d :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n    by (simp add: power2_diff)\n  show ?thesis\n    using left_side by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_evolvedV7": {"skill_name": "mathd_algebra_109_evolvedV7", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = (c - 3 * a) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" using h2 by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  then have \"2 * b = c - 12\" by (smt (verit) h2 add_cancel_right_right)\n  show ?thesis using `2 * b = c - 12` by (smt (verit) \\<open>12 + 2 * b = c\\<close> add_cancel_right_right add_right_imp_eq diff_divide_distrib h0 h2)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = (c - 3 * a) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" using h2 by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  then have \"2 * b = c - 12\" by (smt (verit) h2 add_cancel_right_right)\n  show ?thesis using `2 * b = c - 12` by (smt (verit) \\<open>12 + 2 * b = c\\<close> add_cancel_right_right add_right_imp_eq diff_divide_distrib h0 h2)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sum_of_floors": {"skill_name": "sum_of_floors", "marker": "lemma sum_of_floors:\n  fixes r :: real\n  assumes \"x + y = 546\" and \"x + 1 = y\"\n  shows \"x = floor r\"\nproof -\n  from assms have \"x + (x + 1) = 546\" by auto\n  then have \"2 * x + 1 = 546\" by simp\n  then have \"2 * x = 545\" by simp\n  then have \"x = 272.5\" by (simp add: field_simps)\n  let ?r = \"x\"\n  have \"floor ?r = floor 272.5\" by (smt (verit) \\<open>2 * x = 545\\<close>)\n  thus ?thesis by (smt (verit) assms(1) assms(2)) \nqed", "description": "-", "full_code": "lemma sum_of_floors:\n  fixes r :: real\n  assumes \"x + y = 546\" and \"x + 1 = y\"\n  shows \"x = floor r\"\nproof -\n  from assms have \"x + (x + 1) = 546\" by auto\n  then have \"2 * x + 1 = 546\" by simp\n  then have \"2 * x = 545\" by simp\n  then have \"x = 272.5\" by (simp add: field_simps)\n  let ?r = \"x\"\n  have \"floor ?r = floor 272.5\" by (smt (verit) \\<open>2 * x = 545\\<close>)\n  thus ?thesis by (smt (verit) assms(1) assms(2)) \nqed", "origin": "do_request", "update_count": 0}, "sum_of_floorsV2": {"skill_name": "sum_of_floorsV2", "marker": "lemma sum_of_floors:\n  fixes r :: real\n  assumes \"x + y = 546\" and \"x + 1 = y\"\n  shows \"x = floor r\"\nproof -\n  have \"y = x + 1\" using assms(2) by simp\n  from assms(1) have \"x + (x + 1) = 546\" \n    by (metis assms(2))\n  have \"2 * x + 1 = 546\" by (metis \\<open>x + (x + 1) = 546\\<close> add.commute add.left_commute mult.commute mult_2_right)\n  have \"2 * x = 545\" by (smt (verit) assms(1) assms(2))\n  have \"x = 272.5\" by (smt (verit) \\<open>2 * x = 545\\<close>)\n  have \"floor r = 272\" by (smt (verit) assms(1) assms(2))\n  thus \"x = floor r\" by (smt (verit) assms(1) assms(2))\nqed", "description": "-", "full_code": "lemma sum_of_floors:\n  fixes r :: real\n  assumes \"x + y = 546\" and \"x + 1 = y\"\n  shows \"x = floor r\"\nproof -\n  have \"y = x + 1\" using assms(2) by simp\n  from assms(1) have \"x + (x + 1) = 546\" \n    by (metis assms(2))\n  have \"2 * x + 1 = 546\" by (metis \\<open>x + (x + 1) = 546\\<close> add.commute add.left_commute mult.commute mult_2_right)\n  have \"2 * x = 545\" by (smt (verit) assms(1) assms(2))\n  have \"x = 272.5\" by (smt (verit) \\<open>2 * x = 545\\<close>)\n  have \"floor r = 272\" by (smt (verit) assms(1) assms(2))\n  thus \"x = floor r\" by (smt (verit) assms(1) assms(2))\nqed", "origin": "do_request", "update_count": 0}, "real_sqrt_positive": {"skill_name": "real_sqrt_positive", "marker": "lemma real_sqrt_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max 0 a)\" \n    by (metis assms max.absorb_iff2)\n  also have \"... = sqrt a\" \n    using assms by (simp add: max_def)\n  finally show ?thesis \n    using assms by auto\nqed", "description": "-", "full_code": "lemma real_sqrt_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max 0 a)\" \n    by (metis assms max.absorb_iff2)\n  also have \"... = sqrt a\" \n    using assms by (simp add: max_def)\n  finally show ?thesis \n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "real_sqrt_positiveV2": {"skill_name": "real_sqrt_positiveV2", "marker": "lemma real_sqrt_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max a 0)\" \n    using assms by (simp add: max_def)\n  also have \"max a 0 = a\" \n    using assms by (simp add: max_def)\n  finally have \"sqrt a = sqrt a\" by simp\n  thus ?thesis \n    by (metis assms real_sqrt_ge_zero)\nqed", "description": "-", "full_code": "lemma real_sqrt_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max a 0)\" \n    using assms by (simp add: max_def)\n  also have \"max a 0 = a\" \n    using assms by (simp add: max_def)\n  finally have \"sqrt a = sqrt a\" by simp\n  thus ?thesis \n    by (metis assms real_sqrt_ge_zero)\nqed", "origin": "do_request", "update_count": 0}, "real_sqrt_positiveV3": {"skill_name": "real_sqrt_positiveV3", "marker": "lemma real_sqrt_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max a 0)\" \n    using assms by (simp add: max_def)\n  also have \"... >= 0\" \n    using assms by (simp add: sqrt_def)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma real_sqrt_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max a 0)\" \n    using assms by (simp add: max_def)\n  also have \"... >= 0\" \n    using assms by (simp add: sqrt_def)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_generalizedV2": {"skill_name": "algebra_2varlineareq_generalizedV2", "marker": "theorem algebra_2varlineareq_generalized:\n  fixes x e c d :: complex\n  assumes h0 : \"x + e = c\"\n    and h1 : \"2 * x + e = d\"\n  shows \"e = (2*c - d) / 1 \\<and> x = (d - c) / 1\"\nproof -\n  have e_expr: \"e = c - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (c - x) = d\" using e_expr h1 by simp\n  have eq_simplified: \"x + c = d\" using eq_substituted by simp\n  have x_value: \"x = d - c\" using eq_simplified by auto\n  then have e_value: \"e = c - (d - c)\" using e_expr x_value by simp\n  have e_value_final: \"e = 2*c - d\" using e_value by simp\n  thus ?thesis using x_value e_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_generalized:\n  fixes x e c d :: complex\n  assumes h0 : \"x + e = c\"\n    and h1 : \"2 * x + e = d\"\n  shows \"e = (2*c - d) / 1 \\<and> x = (d - c) / 1\"\nproof -\n  have e_expr: \"e = c - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (c - x) = d\" using e_expr h1 by simp\n  have eq_simplified: \"x + c = d\" using eq_substituted by simp\n  have x_value: \"x = d - c\" using eq_simplified by auto\n  then have e_value: \"e = c - (d - c)\" using e_expr x_value by simp\n  have e_value_final: \"e = 2*c - d\" using e_value by simp\n  thus ?thesis using x_value e_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "sum_integer_partitionsV2": {"skill_name": "sum_integer_partitionsV2", "marker": "lemma sum_integer_partitions:\n  fixes n :: nat\n  assumes \"n = a + b\"\n  shows \"a <= n \\<and> b <= n\"\nproof -\n  have \"a + b = n\" using assms by simp\n  hence \"a <= a + b\" by auto\n  moreover have \"b <= a + b\" by auto\n  ultimately show \"a <= n \\<and> b <= n\" \n    by (metis add_leE assms order_refl)\nqed", "description": "-", "full_code": "lemma sum_integer_partitions:\n  fixes n :: nat\n  assumes \"n = a + b\"\n  shows \"a <= n \\<and> b <= n\"\nproof -\n  have \"a + b = n\" using assms by simp\n  hence \"a <= a + b\" by auto\n  moreover have \"b <= a + b\" by auto\n  ultimately show \"a <= n \\<and> b <= n\" \n    by (metis add_leE assms order_refl)\nqed", "origin": "do_request", "update_count": 0}, "amc12a_2013_p8_evolvedV2": {"skill_name": "amc12a_2013_p8_evolvedV2", "marker": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have rearranged: \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  have cross_mult: \"x * y * (x - y) = 2 * (x - y)\" \n    using rearranged by sos\n  then have \"x * y * (x - y) - 2 * (x - y) = 0\" by simp\n  then have \"((x * y) - 2) * (x - y) = 0\" by (simp add: field_simps)\n  thus \"x * y = 2\" using h2 by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have rearranged: \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  have cross_mult: \"x * y * (x - y) = 2 * (x - y)\" \n    using rearranged by sos\n  then have \"x * y * (x - y) - 2 * (x - y) = 0\" by simp\n  then have \"((x * y) - 2) * (x - y) = 0\" by (simp add: field_simps)\n  thus \"x * y = 2\" using h2 by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "real_sqrt_positiveV4": {"skill_name": "real_sqrt_positiveV4", "marker": "lemma real_sqrt_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max a 0)\" \n    using assms by auto\n  also have \"max a 0 = a\" using assms by (simp add: max_def)\n  finally have \"sqrt a = sqrt a\" by simp\n  thus ?thesis\n    by (metis assms real_sqrt_ge_zero)\nqed", "description": "-", "full_code": "lemma real_sqrt_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max a 0)\" \n    using assms by auto\n  also have \"max a 0 = a\" using assms by (simp add: max_def)\n  finally have \"sqrt a = sqrt a\" by simp\n  thus ?thesis\n    by (metis assms real_sqrt_ge_zero)\nqed", "origin": "do_request", "update_count": 0}, "power_modV2": {"skill_name": "power_modV2", "marker": "lemma power_mod:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a^(Suc n) = a^n * a\" by simp\n  then have \"(a^(Suc n)) mod m = (a^n * a) mod m\" by presburger\n  also have \"... = ((a^n mod m) * (a mod m)) mod m\" \n    using assms by (metis mod_mult_eq)\n  also have \"... = ((a mod m)^n * (a mod m)) mod m\"\n    by (metis Suc \\<open>a ^ Suc n = a ^ n * a\\<close> \\<open>a ^ Suc n mod m = a ^ n * a mod m\\<close> mod_mult_cong mod_mult_eq mod_mult_right_eq mult.commute)\n  finally show ?case by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma power_mod:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a^(Suc n) = a^n * a\" by simp\n  then have \"(a^(Suc n)) mod m = (a^n * a) mod m\" by presburger\n  also have \"... = ((a^n mod m) * (a mod m)) mod m\" \n    using assms by (metis mod_mult_eq)\n  also have \"... = ((a mod m)^n * (a mod m)) mod m\"\n    by (metis Suc \\<open>a ^ Suc n = a ^ n * a\\<close> \\<open>a ^ Suc n mod m = a ^ n * a mod m\\<close> mod_mult_cong mod_mult_eq mod_mult_right_eq mult.commute)\n  finally show ?case by (auto simp: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "power_modV3": {"skill_name": "power_modV3", "marker": "lemma power_mod:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a ^ Suc n = a * (a ^ n)\" by simp\n    then have \"(a ^ Suc n) mod m = (a * (a ^ n)) mod m\" by simp\n    also have \"... = ((a mod m) * (a ^ n) mod m) mod m\"\n      using `m > 0` by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod m) * ((a ^ n) mod m)) mod m\"\n      by (metis \\<open>a * a ^ n mod m = a mod m * a ^ n mod m mod m\\<close> mod_mult_eq)\n    also have \"... = (a mod m) ^ Suc n mod m\"\n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "description": "-", "full_code": "lemma power_mod:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a ^ Suc n = a * (a ^ n)\" by simp\n    then have \"(a ^ Suc n) mod m = (a * (a ^ n)) mod m\" by simp\n    also have \"... = ((a mod m) * (a ^ n) mod m) mod m\"\n      using `m > 0` by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod m) * ((a ^ n) mod m)) mod m\"\n      by (metis \\<open>a * a ^ n mod m = a mod m * a ^ n mod m mod m\\<close> mod_mult_eq)\n    also have \"... = (a mod m) ^ Suc n mod m\"\n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "power_modV4": {"skill_name": "power_modV4", "marker": "lemma power_mod:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^Suc n = a * (a^n)\" by simp\n    then have \"(a^Suc n) mod m = (a * (a^n)) mod m\" by simp\n    also have \"... = ((a mod m) * (a^n mod m)) mod m\"\n      using assms by (metis mod_mult_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\"\n      by (simp add: Suc.IH)\n    also have \"... = ((a mod m)^(Suc n)) mod m\" by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "description": "-", "full_code": "lemma power_mod:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^Suc n = a * (a^n)\" by simp\n    then have \"(a^Suc n) mod m = (a * (a^n)) mod m\" by simp\n    also have \"... = ((a mod m) * (a^n mod m)) mod m\"\n      using assms by (metis mod_mult_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\"\n      by (simp add: Suc.IH)\n    also have \"... = ((a mod m)^(Suc n)) mod m\" by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "expand_expressionV8": {"skill_name": "expand_expressionV8", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have lhs_expanded: \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2) = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  have rhs_expanded: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: power2_eq_square)\n  show ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 + x^2 + y^2 + 1\"\n      using lhs_expanded by simp\n    also have \"... = (x^2 * y^2 + x^2 + y^2 + 1)\"\n      using rhs_expanded by simp\n    finally show ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have lhs_expanded: \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2) = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  have rhs_expanded: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: power2_eq_square)\n  show ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 + x^2 + y^2 + 1\"\n      using lhs_expanded by simp\n    also have \"... = (x^2 * y^2 + x^2 + y^2 + 1)\"\n      using rhs_expanded by simp\n    finally show ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_extendedV8": {"skill_name": "mathd_algebra_109_extendedV8", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"n * a + m * b = k\" \n    and h1 : \"a = r\" \n    and h2 : \"n > 0\" and \"m > 0\" and \"k > 0\"\n  shows \"b = (k - n * r) / m\"\nproof -\n  have eq: \"n * a + m * b = k\" using h0 by simp\n  have \"n * r + m * b = k\" using h1 eq by simp\n  have \"m * b = k - n * r\" by (smt (verit) h0 h1)\n  show ?thesis using `m > 0` by (metis \\<open>m * b = k - n * r\\<close> less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"n * a + m * b = k\" \n    and h1 : \"a = r\" \n    and h2 : \"n > 0\" and \"m > 0\" and \"k > 0\"\n  shows \"b = (k - n * r) / m\"\nproof -\n  have eq: \"n * a + m * b = k\" using h0 by simp\n  have \"n * r + m * b = k\" using h1 eq by simp\n  have \"m * b = k - n * r\" by (smt (verit) h0 h1)\n  show ?thesis using `m > 0` by (metis \\<open>m * b = k - n * r\\<close> less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_n_dimensional": {"skill_name": "mathd_algebra_n_dimensional", "marker": "lemma mathd_algebra_n_dimensional:\n  fixes a b :: \"real list\"\n  assumes h0: \"length a = 3\" and h1: \"length b = 3\"\n  and h2: \"3 * (a!0) + 2 * (b!0) = 12\"\n  and h3: \"a!0 = 4\"\n  shows \"b!0 = 0\"\nproof -\n  have eq: \"3 * (a!0) + 2 * (b!0) = 12\" using h2 by simp\n  have \"3 * 4 + 2 * (b!0) = 12\" using h3 eq by simp\n  have \"12 + 2 * (b!0) = 12\" by (smt (verit) \\<open>3 * 4 + 2 * (b!0) = 12\\<close>)\n  have \"2 * (b!0) = 0\" by (metis \\<open>12 + 2 * (b!0) = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * (b!0) = 0` by simp\nqed", "description": "-", "full_code": "lemma mathd_algebra_n_dimensional:\n  fixes a b :: \"real list\"\n  assumes h0: \"length a = 3\" and h1: \"length b = 3\"\n  and h2: \"3 * (a!0) + 2 * (b!0) = 12\"\n  and h3: \"a!0 = 4\"\n  shows \"b!0 = 0\"\nproof -\n  have eq: \"3 * (a!0) + 2 * (b!0) = 12\" using h2 by simp\n  have \"3 * 4 + 2 * (b!0) = 12\" using h3 eq by simp\n  have \"12 + 2 * (b!0) = 12\" by (smt (verit) \\<open>3 * 4 + 2 * (b!0) = 12\\<close>)\n  have \"2 * (b!0) = 0\" by (metis \\<open>12 + 2 * (b!0) = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * (b!0) = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_combinationV3": {"skill_name": "linear_combinationV3", "marker": "lemma linear_combination:\n  fixes a b :: real\n  assumes h0: \"x + e = a\"\n    and h1: \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - e) / 2\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  then have \"2 * x + (a - x) = b\" using h1 by simp\n  then show ?thesis using e_expr by auto\nqed", "description": "-", "full_code": "lemma linear_combination:\n  fixes a b :: real\n  assumes h0: \"x + e = a\"\n    and h1: \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - e) / 2\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  then have \"2 * x + (a - x) = b\" using h1 by simp\n  then show ?thesis using e_expr by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "mathd_algebra_generalizedV3": {"skill_name": "mathd_algebra_generalizedV3", "marker": "theorem mathd_algebra_generalized:\n  fixes a b c :: real\n  assumes h0 : \"c * a + b = d\"  \n    and h1 : \"a = e\"            \n  shows \"b = d - c * e\"         \nproof -\n  have eq: \"c * a + b = d\" using h0 by simp\n  have \"c * e + b = d\" using h1 eq by simp\n  have \"b = d - c * e\" using `c * e + b = d` by simp\n  show ?thesis by (metis \\<open>b = d - c * e\\<close>)\nqed", "description": "-", "full_code": "theorem mathd_algebra_generalized:\n  fixes a b c :: real\n  assumes h0 : \"c * a + b = d\"  \n    and h1 : \"a = e\"            \n  shows \"b = d - c * e\"         \nproof -\n  have eq: \"c * a + b = d\" using h0 by simp\n  have \"c * e + b = d\" using h1 eq by simp\n  have \"b = d - c * e\" using `c * e + b = d` by simp\n  show ?thesis by (metis \\<open>b = d - c * e\\<close>)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equations_solutionV2": {"skill_name": "linear_equations_solutionV2", "marker": "lemma linear_equations_solution:\n  fixes a b c d :: complex\n  assumes \"a + b = 7\" \"2 * a + b = 3\"\n  shows \"b = 11 \\<and> a = (-4)\"\nproof -\n  have b_expr: \"b = 7 - a\" using assms(1) by (auto simp: field_simps)\n  have eq_substituted: \"2 * a + (7 - a) = 3\" using b_expr assms(2) by simp\n  have eq_simplified: \"a + 7 = 3\" using eq_substituted by simp\n  have a_value: \"a = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have a_value_final: \"a = -4\" by simp\n  have b_value: \"b = 7 - (-4)\" using b_expr a_value_final by simp\n  have b_value_final: \"b = 7 + 4\" using b_value by simp\n  thus \"b = 11 \\<and> a = (-4)\" using a_value_final b_value_final by auto\nqed", "description": "-", "full_code": "lemma linear_equations_solution:\n  fixes a b c d :: complex\n  assumes \"a + b = 7\" \"2 * a + b = 3\"\n  shows \"b = 11 \\<and> a = (-4)\"\nproof -\n  have b_expr: \"b = 7 - a\" using assms(1) by (auto simp: field_simps)\n  have eq_substituted: \"2 * a + (7 - a) = 3\" using b_expr assms(2) by simp\n  have eq_simplified: \"a + 7 = 3\" using eq_substituted by simp\n  have a_value: \"a = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have a_value_final: \"a = -4\" by simp\n  have b_value: \"b = 7 - (-4)\" using b_expr a_value_final by simp\n  have b_value_final: \"b = 7 + 4\" using b_value by simp\n  thus \"b = 11 \\<and> a = (-4)\" using a_value_final b_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "general_linear_equations": {"skill_name": "general_linear_equations", "marker": "lemma general_linear_equations:\n  fixes a b c d :: complex\n  assumes h0: \"a + b = c\"\n    and h1: \"2 * a + b = d\"\n  shows \"b = c - a \\<and> a = (d - c) / 1\"\nproof -\n  have b_expr: \"b = c - a\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * a + (c - a) = d\" using b_expr h1 by simp\n  have eq_simplified: \"a + c = d\" using eq_substituted by simp\n  then have a_value: \"a = d - c\" by (simp add: field_simps)\n  thus ?thesis using b_expr a_value by auto\nqed", "description": "-", "full_code": "lemma general_linear_equations:\n  fixes a b c d :: complex\n  assumes h0: \"a + b = c\"\n    and h1: \"2 * a + b = d\"\n  shows \"b = c - a \\<and> a = (d - c) / 1\"\nproof -\n  have b_expr: \"b = c - a\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * a + (c - a) = d\" using b_expr h1 by simp\n  have eq_simplified: \"a + c = d\" using eq_substituted by simp\n  then have a_value: \"a = d - c\" by (simp add: field_simps)\n  thus ?thesis using b_expr a_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "mathd_algebra_109_simpler": {"skill_name": "mathd_algebra_109_simpler", "marker": "lemma mathd_algebra_109_simpler:\n  fixes a b :: real\n  assumes h0: \"3*a + 2*b = 12\"\n    and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  hence \"12 + 2 * b = 12\" by simp\n  thus \"b = 0\" by auto\nqed", "description": "-", "full_code": "lemma mathd_algebra_109_simpler:\n  fixes a b :: real\n  assumes h0: \"3*a + 2*b = 12\"\n    and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  hence \"12 + 2 * b = 12\" by simp\n  thus \"b = 0\" by auto\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_generalization": {"skill_name": "mathd_algebra_109_generalization", "marker": "theorem mathd_algebra_109_generalization:\n  fixes a b c d :: real\n  assumes h0: \"3*a + 2*b + c + d = 12\"\n    and h1: \"a = 4\"\n    and h2: \"c + d = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b + c + d = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b + c + d = 12\" using h1 eq by simp\n  have \"12 + c + d = 12\" by (metis add.commute add_cancel_left_right add_scale_eq_noteq group_cancel.add1 h2 mult_delta_right real_add_minus_iff semiring_norm(3) semiring_norm(5) zero_neq_numeral)\n  have \"c + d = 0\" using h2 by simp\n  thus \"b = 0\" using `12 + c + d = 12` by (smt (verit) h0 h1)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalization:\n  fixes a b c d :: real\n  assumes h0: \"3*a + 2*b + c + d = 12\"\n    and h1: \"a = 4\"\n    and h2: \"c + d = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b + c + d = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b + c + d = 12\" using h1 eq by simp\n  have \"12 + c + d = 12\" by (metis add.commute add_cancel_left_right add_scale_eq_noteq group_cancel.add1 h2 mult_delta_right real_add_minus_iff semiring_norm(3) semiring_norm(5) zero_neq_numeral)\n  have \"c + d = 0\" using h2 by simp\n  thus \"b = 0\" using `12 + c + d = 12` by (smt (verit) h0 h1)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "cross_multiplication_inequalityV3": {"skill_name": "cross_multiplication_inequalityV3", "marker": "theorem cross_multiplication_inequality:\n  fixes a b c d :: real\n  assumes \"c \\<noteq> 0\" \"d \\<noteq> 0\" \n      and \"a / c = b / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a / c = b / d\" using assms(3) by simp\n  then have \"a * d = b * (c / d * d)\" using assms(1) by (simp add: field_simps)\n  then show ?thesis by (metis assms(1) assms(2) assms(3) frac_eq_eq)\nqed", "description": "-", "full_code": "theorem cross_multiplication_inequality:\n  fixes a b c d :: real\n  assumes \"c \\<noteq> 0\" \"d \\<noteq> 0\" \n      and \"a / c = b / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a / c = b / d\" using assms(3) by simp\n  then have \"a * d = b * (c / d * d)\" using assms(1) by (simp add: field_simps)\n  then show ?thesis by (metis assms(1) assms(2) assms(3) frac_eq_eq)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "linear_congruence": {"skill_name": "linear_congruence", "marker": "lemma linear_congruence:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c < b\"\n  shows \"\\<exists>x. x mod b = c\"\nproof -\n  let ?x = \"c\"\n  have \"0 \\<le> c\" using assms(2) by simp\n  have \"?x mod b = c\" by (simp add: assms(2))\n  then show \"\\<exists>x. x mod b = c\" by (rule exI[of _ ?x])\nqed", "description": "-", "full_code": "lemma linear_congruence:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c < b\"\n  shows \"\\<exists>x. x mod b = c\"\nproof -\n  let ?x = \"c\"\n  have \"0 \\<le> c\" using assms(2) by simp\n  have \"?x mod b = c\" by (simp add: assms(2))\n  then show \"\\<exists>x. x mod b = c\" by (rule exI[of _ ?x])\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV7": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV7", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  hence \"x = 3 - 7\" by (metis add.commute add_diff_cancel add_minus_cancel diff_add_eq eq_simplified group_cancel.add2 group_cancel.sub1 minus_add_cancel mult.commute mult_2_right numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  hence x_value: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value by simp\n  hence e_value_final: \"e = 7 + 4\" by simp\n  thus ?thesis using x_value e_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  hence \"x = 3 - 7\" by (metis add.commute add_diff_cancel add_minus_cancel diff_add_eq eq_simplified group_cancel.add2 group_cancel.sub1 minus_add_cancel mult.commute mult_2_right numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  hence x_value: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value by simp\n  hence e_value_final: \"e = 7 + 4\" by simp\n  thus ?thesis using x_value e_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV8": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV8", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  let ?e = \"7 - x\"\n  have \"e = ?e\" using h0 by (auto simp: field_simps)\n  have \"2 * x + ?e = 3\" using h1 by (metis \\<open>e = 7 - x\\<close>)\n  then have \"2 * x + (7 - x) = 3\" by simp\n  have \"x + 7 = 3\" using `2 * x + (7 - x) = 3` by (simp add: field_simps)\n  have \"x = 3 - 7\" using `x + 7 = 3` by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral)\n  then have \"x = -4\" by simp\n  have \"e = 7 - (-4)\" using `e = ?e` `x = -4` by simp\n  thus ?thesis using `e = 7 - (-4)` by (metis \\<open>x = - 4\\<close> add.commute diff_minus_eq_add numeral_Bit0 numeral_eq_iff numeral_plus_numeral semiring_norm(7))\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  let ?e = \"7 - x\"\n  have \"e = ?e\" using h0 by (auto simp: field_simps)\n  have \"2 * x + ?e = 3\" using h1 by (metis \\<open>e = 7 - x\\<close>)\n  then have \"2 * x + (7 - x) = 3\" by simp\n  have \"x + 7 = 3\" using `2 * x + (7 - x) = 3` by (simp add: field_simps)\n  have \"x = 3 - 7\" using `x + 7 = 3` by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral)\n  then have \"x = -4\" by simp\n  have \"e = 7 - (-4)\" using `e = ?e` `x = -4` by simp\n  thus ?thesis using `e = 7 - (-4)` by (metis \\<open>x = - 4\\<close> add.commute diff_minus_eq_add numeral_Bit0 numeral_eq_iff numeral_plus_numeral semiring_norm(7))\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "minus_thirteen_x": {"skill_name": "minus_thirteen_x", "marker": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  also have \"... = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  finally show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" by auto\nqed", "description": "-", "full_code": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  also have \"... = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  finally show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" by auto\nqed", "origin": "do_request", "update_count": 0}, "minus_thirteen_xV2": {"skill_name": "minus_thirteen_xV2", "marker": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  then have \"-13 * x = (-13 * (13 - sqrt 131)) / 4\" by simp\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  finally show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  then have \"-13 * x = (-13 * (13 - sqrt 131)) / 4\" by simp\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  finally show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_generalizedV6": {"skill_name": "mathd_algebra_109_generalizedV6", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  then have \"12 + 2 * b = c\" by simp\n  thus ?thesis \n  proof -\n    have \"2 * b = c - 12\" using `12 + 2 * b = c` by simp\n    thus \"b = (c - 12) / 2\" by auto\n  qed\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  then have \"12 + 2 * b = c\" by simp\n  thus ?thesis \n  proof -\n    have \"2 * b = c - 12\" using `12 + 2 * b = c` by simp\n    thus \"b = (c - 12) / 2\" by auto\n  qed\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolvedV8": {"skill_name": "mathd_algebra_109_evolvedV8", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by simp\n  thus ?thesis \n  proof -\n    have \"2 * b = 0\" using `12 + 2 * b = 12` by simp\n    thus \"b = 0\" by simp\n  qed\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by simp\n  thus ?thesis \n  proof -\n    have \"2 * b = 0\" using `12 + 2 * b = 12` by simp\n    thus \"b = 0\" by simp\n  qed\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_congruenceV2": {"skill_name": "linear_congruenceV2", "marker": "lemma linear_congruence:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c < b\"\n  shows \"\\<exists>x. x mod b = c\"\nproof -\n  have \"c < b\" by (simp add: assms(2))\n  have \"c + 0 * b = c\" by simp\n  then show ?thesis using assms by (metis mod_less)\nqed", "description": "-", "full_code": "lemma linear_congruence:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c < b\"\n  shows \"\\<exists>x. x mod b = c\"\nproof -\n  have \"c < b\" by (simp add: assms(2))\n  have \"c + 0 * b = c\" by simp\n  then show ?thesis using assms by (metis mod_less)\nqed", "origin": "do_request", "update_count": 0}, "minus_thirteen_xV3": {"skill_name": "minus_thirteen_xV3", "marker": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  then have \"-13 * x = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  finally show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" \n  proof -\n    have \"-(169 - 13 * sqrt 131) = -169 + 13 * sqrt 131\" by simp\n    thus ?thesis by (metis \\<open>- 13 * (13 - sqrt 131) / 4 = (- 169 + 13 * sqrt 131) / 4\\<close> \\<open>- 13 * x = - 13 * (13 - sqrt 131) / 4\\<close>)\n  qed\nqed", "description": "-", "full_code": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  then have \"-13 * x = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  finally show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" \n  proof -\n    have \"-(169 - 13 * sqrt 131) = -169 + 13 * sqrt 131\" by simp\n    thus ?thesis by (metis \\<open>- 13 * (13 - sqrt 131) / 4 = (- 169 + 13 * sqrt 131) / 4\\<close> \\<open>- 13 * x = - 13 * (13 - sqrt 131) / 4\\<close>)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "minus_thirteen_xV4": {"skill_name": "minus_thirteen_xV4", "marker": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  also have \"... = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  also have \"... = -(169 - 13 * sqrt 131) / 4\" by (simp add: field_simps)\n  finally show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" by simp\nqed", "description": "-", "full_code": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  also have \"... = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  also have \"... = -(169 - 13 * sqrt 131) / 4\" by (simp add: field_simps)\n  finally show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" by simp\nqed", "origin": "do_request", "update_count": 0}, "minus_thirteen_xV5": {"skill_name": "minus_thirteen_xV5", "marker": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  also have \"... = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by (simp add: distrib_right)\n  finally show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" \n  proof -\n    have \"-(169 - 13 * sqrt 131) = -169 + 13 * sqrt 131\" by simp\n    thus ?thesis by (metis \\<open>- 13 * ((13 - sqrt 131) / 4) = - 13 * (13 - sqrt 131) / 4\\<close> \\<open>- 13 * (13 - sqrt 131) / 4 = (- 169 + 13 * sqrt 131) / 4\\<close> assms)\n  qed\nqed", "description": "-", "full_code": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  also have \"... = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by (simp add: distrib_right)\n  finally show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" \n  proof -\n    have \"-(169 - 13 * sqrt 131) = -169 + 13 * sqrt 131\" by simp\n    thus ?thesis by (metis \\<open>- 13 * ((13 - sqrt 131) / 4) = - 13 * (13 - sqrt 131) / 4\\<close> \\<open>- 13 * (13 - sqrt 131) / 4 = (- 169 + 13 * sqrt 131) / 4\\<close> assms)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "minus_thirteen_xV6": {"skill_name": "minus_thirteen_xV6", "marker": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  also have \"... = -(13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = -(169 - 13 * sqrt 131) / 4\" \n    by (simp) \n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * x = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  also have \"... = -(13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = -(169 - 13 * sqrt 131) / 4\" \n    by (simp) \n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "minus_thirteen_xV7": {"skill_name": "minus_thirteen_xV7", "marker": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"(-13 * x) = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  also have \"... = (-13 * (13 - sqrt 131)) / 4\" by (simp add: algebra_simps)\n  then have \"... = (-169 + 13 * sqrt 131) / 4\" by (simp add: distrib_right)\n  then show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" by (metis \\<open>- 13 * ((13 - sqrt 131) / 4) = - 13 * (13 - sqrt 131) / 4\\<close> assms dbl_inc_simps(3) dbl_inc_simps(5) dbl_simps(3) dbl_simps(5) minus_diff_eq mult.commute uminus_add_conv_diff)\nqed", "description": "-", "full_code": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"(-13 * x) = -13 * ((13 - sqrt 131) / 4)\" using assms by simp\n  also have \"... = (-13 * (13 - sqrt 131)) / 4\" by (simp add: algebra_simps)\n  then have \"... = (-169 + 13 * sqrt 131) / 4\" by (simp add: distrib_right)\n  then show \"-13 * x = -(169 - 13 * sqrt 131) / 4\" by (metis \\<open>- 13 * ((13 - sqrt 131) / 4) = - 13 * (13 - sqrt 131) / 4\\<close> assms dbl_inc_simps(3) dbl_inc_simps(5) dbl_simps(3) dbl_simps(5) minus_diff_eq mult.commute uminus_add_conv_diff)\nqed", "origin": "do_request", "update_count": 0}, "minus_thirteen_xV8": {"skill_name": "minus_thirteen_xV8", "marker": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  from assms have \"x * 4 = 13 - sqrt 131\" by simp\n  then have \"-13 * x * 4 = -13 * (13 - sqrt 131)\" by (simp add: algebra_simps)\n  hence \"-13 * x * 4 = -169 + 13 * sqrt 131\" by simp\n  then have \"-13 * x = (-169 + 13 * sqrt 131) / 4\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma minus_thirteen_x:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"-13 * x = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  from assms have \"x * 4 = 13 - sqrt 131\" by simp\n  then have \"-13 * x * 4 = -13 * (13 - sqrt 131)\" by (simp add: algebra_simps)\n  hence \"-13 * x * 4 = -169 + 13 * sqrt 131\" by simp\n  then have \"-13 * x = (-169 + 13 * sqrt 131) / 4\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_equality": {"skill_name": "sqrt_equality", "marker": "lemma sqrt_equality:\n  fixes a b :: real\n  assumes \"sqrt a = sqrt b\" \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = sqrt b * sqrt b\" \n    using assms(1) by (metis real_sqrt_mult)\n  also have \"sqrt a * sqrt a = a\" \n    using assms(2) by auto\n  also have \"sqrt b * sqrt b = b\" \n    using assms(3) by auto\n  finally have \"a = b\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_equality:\n  fixes a b :: real\n  assumes \"sqrt a = sqrt b\" \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = sqrt b * sqrt b\" \n    using assms(1) by (metis real_sqrt_mult)\n  also have \"sqrt a * sqrt a = a\" \n    using assms(2) by auto\n  also have \"sqrt b * sqrt b = b\" \n    using assms(3) by auto\n  finally have \"a = b\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebraic_manipulation": {"skill_name": "algebraic_manipulation", "marker": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \" (a - b)^2 = (a - b) * (a - b)\"\n    by (simp add: power2_eq_square)\n  also have \"... = a * a - a * b - b * a + b * b\"\n    by sos\n  also have \"... = a^2 - 2 * a * b + b^2\"\n    by sos\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \" (a - b)^2 = (a - b) * (a - b)\"\n    by (simp add: power2_eq_square)\n  also have \"... = a * a - a * b - b * a + b * b\"\n    by sos\n  also have \"... = a^2 - 2 * a * b + b^2\"\n    by sos\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "algebraic_manipulationV2": {"skill_name": "algebraic_manipulationV2", "marker": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a - b) * (a - b)\"\n    by (simp add: power2_eq_square)\n  also have \"... = a * a - 2 * a * b + b * b\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by sos\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a - b) * (a - b)\"\n    by (simp add: power2_eq_square)\n  also have \"... = a * a - 2 * a * b + b * b\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by sos\nqed", "origin": "do_request", "update_count": 0}, "count_terms_in_sum": {"skill_name": "count_terms_in_sum", "marker": "lemma count_terms_in_sum:\n  fixes n m :: nat\n  assumes \"m + n = total_terms\"\n  shows \"m + n = total_terms\"\nproof -\n  have \"m + n = total_terms\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms_in_sum:\n  fixes n m :: nat\n  assumes \"m + n = total_terms\"\n  shows \"m + n = total_terms\"\nproof -\n  have \"m + n = total_terms\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_root": {"skill_name": "simplify_square_root", "marker": "lemma simplify_square_root:\n  fixes x :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) * sqrt(x^2) = x^2\" \n    by (metis abs_if_raw abs_of_neg abs_of_pos neg_0_less_iff_less power2_eq_square real_sqrt_abs real_sqrt_abs2 real_sqrt_eq_iff)\n  then have \"sqrt(x^2) = abs x\"\n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root:\n  fixes x :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) * sqrt(x^2) = x^2\" \n    by (metis abs_if_raw abs_of_neg abs_of_pos neg_0_less_iff_less power2_eq_square real_sqrt_abs real_sqrt_abs2 real_sqrt_eq_iff)\n  then have \"sqrt(x^2) = abs x\"\n    by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_rootV2": {"skill_name": "simplify_square_rootV2", "marker": "lemma simplify_square_root:\n  fixes x :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) = sqrt((if x \\<ge> 0 then x^2 else x^2))\"\n    by (metis abs_if)\n  moreover have \"if x \\<ge> 0 then sqrt(x^2) = x else sqrt(x^2) = -x\"\n    by auto\n  ultimately show ?thesis\n    by (auto simp add: abs_if)\nqed", "description": "-", "full_code": "lemma simplify_square_root:\n  fixes x :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) = sqrt((if x \\<ge> 0 then x^2 else x^2))\"\n    by (metis abs_if)\n  moreover have \"if x \\<ge> 0 then sqrt(x^2) = x else sqrt(x^2) = -x\"\n    by auto\n  ultimately show ?thesis\n    by (auto simp add: abs_if)\nqed", "origin": "do_request", "update_count": 0}, "product_prime": {"skill_name": "product_prime", "marker": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"b = 1\" using assms prime_def by (metis less_not_refl2 prime_product)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = 1\" using assms prime_def by (metis less_not_refl2 prime_product)\n  }\n  thus \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"b = 1\" using assms prime_def by (metis less_not_refl2 prime_product)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = 1\" using assms prime_def by (metis less_not_refl2 prime_product)\n  }\n  thus \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_rootV3": {"skill_name": "simplify_square_rootV3", "marker": "lemma simplify_square_root:\n  fixes x :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) = sqrt((if x \\<ge> 0 then x^2 else x^2))\" by auto\n  also have \"sqrt((if x \\<ge> 0 then x^2 else x^2)) = (if x \\<ge> 0 then x else -x)\" \n    by auto\n  also have \"(if x \\<ge> 0 then x else -x) = abs x\" by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma simplify_square_root:\n  fixes x :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) = sqrt((if x \\<ge> 0 then x^2 else x^2))\" by auto\n  also have \"sqrt((if x \\<ge> 0 then x^2 else x^2)) = (if x \\<ge> 0 then x else -x)\" \n    by auto\n  also have \"(if x \\<ge> 0 then x else -x) = abs x\" by auto\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_rootV4": {"skill_name": "simplify_square_rootV4", "marker": "lemma simplify_square_root:\n  fixes x :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"x^2 \\<ge> 0\" by auto\n  then have \"sqrt(x^2) = sqrt(abs x^2)\" \n    by auto\n  also have \"sqrt(abs x^2) = abs x\" \n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root:\n  fixes x :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"x^2 \\<ge> 0\" by auto\n  then have \"sqrt(x^2) = sqrt(abs x^2)\" \n    by auto\n  also have \"sqrt(abs x^2) = abs x\" \n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_rootV5": {"skill_name": "simplify_square_rootV5", "marker": "lemma simplify_square_root:\n  fixes x :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) = sqrt((if x \\<ge> 0 then x^2 else x^2))\"\n    by auto\n  then have \"sqrt(x^2) = (if x \\<ge> 0 then x else -x)\"\n    by auto\n  moreover have \"abs x = (if x \\<ge> 0 then x else -x)\"\n    by auto\n  ultimately show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma simplify_square_root:\n  fixes x :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) = sqrt((if x \\<ge> 0 then x^2 else x^2))\"\n    by auto\n  then have \"sqrt(x^2) = (if x \\<ge> 0 then x else -x)\"\n    by auto\n  moreover have \"abs x = (if x \\<ge> 0 then x else -x)\"\n    by auto\n  ultimately show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "product_primeV2": {"skill_name": "product_primeV2", "marker": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"prime (a * b) \\<longrightarrow> a * b = a * 1\" \n      using prime_def by (metis assms dvd_triv_left mult.right_neutral nat_neq_iff prime_nat_iff)\n    hence \"b = 1\" by (metis \\<open>1 < a\\<close> assms less_numeral_extra(4) prime_product)\n  }\n  {\n    assume \"b > 1\"\n    then have \"prime (a * b) \\<longrightarrow> a * b = 1 * b\" \n      using prime_def by (metis assms dvd_triv_right nat_mult_1 nat_neq_iff prime_nat_iff)\n    hence \"a = 1\" by (metis assms mult.right_neutral nat_1_eq_mult_iff prime_product)\n  }\n  then show \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"prime (a * b) \\<longrightarrow> a * b = a * 1\" \n      using prime_def by (metis assms dvd_triv_left mult.right_neutral nat_neq_iff prime_nat_iff)\n    hence \"b = 1\" by (metis \\<open>1 < a\\<close> assms less_numeral_extra(4) prime_product)\n  }\n  {\n    assume \"b > 1\"\n    then have \"prime (a * b) \\<longrightarrow> a * b = 1 * b\" \n      using prime_def by (metis assms dvd_triv_right nat_mult_1 nat_neq_iff prime_nat_iff)\n    hence \"a = 1\" by (metis assms mult.right_neutral nat_1_eq_mult_iff prime_product)\n  }\n  then show \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "product_primeV3": {"skill_name": "product_primeV3", "marker": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\" \n      using prime_def by (metis assms(1) dvd_triv_left mult.right_neutral nat_neq_iff prime_nat_iff)\n    hence \"b = 1\" by (metis assms mult_delta_left mult_left_cancel prime_prime_factor prime_product)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\" \n      using prime_def by (metis assms(1) dvd_triv_right mult_1 nat_neq_iff prime_nat_iff)\n    hence \"a = 1\" by (metis assms mult_delta_right mult_right_cancel prime_prime_factor prime_product)\n  }\n  thus \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\" \n      using prime_def by (metis assms(1) dvd_triv_left mult.right_neutral nat_neq_iff prime_nat_iff)\n    hence \"b = 1\" by (metis assms mult_delta_left mult_left_cancel prime_prime_factor prime_product)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\" \n      using prime_def by (metis assms(1) dvd_triv_right mult_1 nat_neq_iff prime_nat_iff)\n    hence \"a = 1\" by (metis assms mult_delta_right mult_right_cancel prime_prime_factor prime_product)\n  }\n  thus \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "product_primeV4": {"skill_name": "product_primeV4", "marker": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"prime (a * b) \\<Longrightarrow> b = 1\"\n    proof -\n      have \"a * b = a * 1\" using assms by (metis \\<open>1 < a\\<close> dvd_triv_left nat_mult_1_right nat_neq_iff prime_nat_iff)\n      thus \"b = 1\" by (metis assms mult_delta_left mult_left_cancel prime_prime_factor prime_product)\n    qed\n  }\n  {\n    assume \"b > 1\"\n    then have \"prime (a * b) \\<Longrightarrow> a = 1\"\n    proof -\n      have \"a * b = 1 * b\" using assms by (metis \\<open>1 < b\\<close> dvd_triv_right nat_mult_1 nat_neq_iff prime_nat_iff)\n      thus \"a = 1\" by (metis assms mult_delta_right mult_right_cancel prime_prime_factor prime_product)\n    qed\n  }\n  then show \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> assms less_one mult_is_0 not_less_iff_gr_or_eq not_one_less_zero)\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"prime (a * b) \\<Longrightarrow> b = 1\"\n    proof -\n      have \"a * b = a * 1\" using assms by (metis \\<open>1 < a\\<close> dvd_triv_left nat_mult_1_right nat_neq_iff prime_nat_iff)\n      thus \"b = 1\" by (metis assms mult_delta_left mult_left_cancel prime_prime_factor prime_product)\n    qed\n  }\n  {\n    assume \"b > 1\"\n    then have \"prime (a * b) \\<Longrightarrow> a = 1\"\n    proof -\n      have \"a * b = 1 * b\" using assms by (metis \\<open>1 < b\\<close> dvd_triv_right nat_mult_1 nat_neq_iff prime_nat_iff)\n      thus \"a = 1\" by (metis assms mult_delta_right mult_right_cancel prime_prime_factor prime_product)\n    qed\n  }\n  then show \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> assms less_one mult_is_0 not_less_iff_gr_or_eq not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "product_primeV5": {"skill_name": "product_primeV5", "marker": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"b = 1\" \n      using assms prime_def by (metis nat_neq_iff prime_product)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = 1\" \n      using assms prime_def by (metis nat_neq_iff prime_product)\n  }\n  thus \"a = 1 \\<or> b = 1\" using `a * b > 1` by (metis less_one mult_is_0 not_less_iff_gr_or_eq not_one_less_zero)\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"b = 1\" \n      using assms prime_def by (metis nat_neq_iff prime_product)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = 1\" \n      using assms prime_def by (metis nat_neq_iff prime_product)\n  }\n  thus \"a = 1 \\<or> b = 1\" using `a * b > 1` by (metis less_one mult_is_0 not_less_iff_gr_or_eq not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_extendedV9": {"skill_name": "mathd_algebra_109_extendedV9", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 2 * a + b\"\n  shows \"c = 8\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  hence \"b = 0\" by simp\n  have \"c = 2 * a + b\" using h2 by simp\n  thus \"c = 8\" using h1 `b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 2 * a + b\"\n  shows \"c = 8\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  hence \"b = 0\" by simp\n  have \"c = 2 * a + b\" using h2 by simp\n  thus \"c = 8\" using h1 `b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "congruence_properties": {"skill_name": "congruence_properties", "marker": "lemma congruence_properties:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" and \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" using assms(1) by (auto)\n  have \"c = d + m * (c div m)\" using assms(2) by (auto)\n  then have \"a + c = (b + m * (a div m)) + (d + m * (c div m))\"\n    by (metis \\<open>a = b + m * (a div m)\\<close>)\n  then have \"a + c = (b + d) + m * ((a div m) + (c div m))\" \n    by (simp add: algebra_simps)\n  then have \"(a + c) mod m = ((b + d) + m * ((a div m) + (c div m))) mod m\"\n    by simp\n  also have \"... = (b + d) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma congruence_properties:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" and \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" using assms(1) by (auto)\n  have \"c = d + m * (c div m)\" using assms(2) by (auto)\n  then have \"a + c = (b + m * (a div m)) + (d + m * (c div m))\"\n    by (metis \\<open>a = b + m * (a div m)\\<close>)\n  then have \"a + c = (b + d) + m * ((a div m) + (c div m))\" \n    by (simp add: algebra_simps)\n  then have \"(a + c) mod m = ((b + d) + m * ((a div m) + (c div m))) mod m\"\n    by simp\n  also have \"... = (b + d) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_evolved": {"skill_name": "mathd_algebra_evolved", "marker": "theorem mathd_algebra_evolved:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = 4\"\n    and h2: \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 h2 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_evolved:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = 4\"\n    and h2: \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 h2 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "amc12a_2013_p8_generalizedV2": {"skill_name": "amc12a_2013_p8_generalizedV2", "marker": "theorem amc12a_2013_p8_generalized:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\" and h4: \"x\\<noteq>z\" and h5: \"y\\<noteq>z\"\n    and h6 : \"x + 2/x = y + 2/y\"\n    and h7 : \"x + 2/x = z + 2/z\"\n  shows \"x * y = 2 \\<and> x * z = 2 \\<and> y * z = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h6 by simp\n  have \"x + 2/x = z + 2/z\" using h7 by simp\n  have rearranged_y: \"x - y = (2/y - 2/x)\" by (smt (verit) h6)\n  have rearranged_z: \"x - z = (2/z - 2/x)\" by (smt (verit) h7)\n  have cross_mult_y: \"(x - y) * x * y = 2 * (x - y)\"\n    using rearranged_y by sos\n  have cross_mult_z: \"(x - z) * x * z = 2 * (x - z)\"\n    using rearranged_z by sos\n  have \"x * y = 2\" using h2 cross_mult_y by (metis amc12a_2013_p8_evolved h0 h1 h3 h6)\n  have \"x * z = 2\" using h0 cross_mult_z by (metis amc12a_2013_p8_evolved h2 h4 h7)\n  then show \"x * y = 2 \\<and> x * z = 2 \\<and> y * z = 2\" \n    using h1 h2 h5 by (metis \\<open>x * y = 2\\<close> amc12a_2013_p8_evolved h6 h7)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have rearranged: \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\"\n    using rearranged by sos\n  then have \"x * y = 2\" \n    using h2 by sos\n  thus ?thesis by simp\nqed\n\ntheorem amc12a_2013_p8_generalized:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\" and h4: \"x\\<noteq>z\" and h5: \"y\\<noteq>z\"\n    and h6 : \"x + 2/x = y + 2/y\"\n    and h7 : \"x + 2/x = z + 2/z\"\n  shows \"x * y = 2 \\<and> x * z = 2 \\<and> y * z = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h6 by simp\n  have \"x + 2/x = z + 2/z\" using h7 by simp\n  have rearranged_y: \"x - y = (2/y - 2/x)\" by (smt (verit) h6)\n  have rearranged_z: \"x - z = (2/z - 2/x)\" by (smt (verit) h7)\n  have cross_mult_y: \"(x - y) * x * y = 2 * (x - y)\"\n    using rearranged_y by sos\n  have cross_mult_z: \"(x - z) * x * z = 2 * (x - z)\"\n    using rearranged_z by sos\n  have \"x * y = 2\" using h2 cross_mult_y by (metis amc12a_2013_p8_evolved h0 h1 h3 h6)\n  have \"x * z = 2\" using h0 cross_mult_z by (metis amc12a_2013_p8_evolved h2 h4 h7)\n  then show \"x * y = 2 \\<and> x * z = 2 \\<and> y * z = 2\" \n    using h1 h2 h5 by (metis \\<open>x * y = 2\\<close> amc12a_2013_p8_evolved h6 h7)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_generalizedV3": {"skill_name": "amc12a_2013_p8_generalizedV3", "marker": "theorem amc12a_2013_p8_generalized:\n  fixes x y z :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"z \\<noteq> 0\"\n    and h3 : \"x \\<noteq> y\" and h4 : \"y \\<noteq> z\" and h5 : \"x \\<noteq> z\"\n    and h6 : \"x + 2/x = y + 2/y\" and h7 : \"y + 2/y = z + 2/z\"\n  shows \"x * z = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h6 by simp\n  have \"y + 2/y = z + 2/z\" using h7 by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" by (smt (verit) h6)\n  have rearranged2: \"y - z = (2/z - 2/y)\" by (smt (verit) h7)\n  have cross_mult1: \"(x - y) * x * y = 2 * (x - y)\"\n    using rearranged1 by sos\n  have cross_mult2: \"(y - z) * y * z = 2 * (y - z)\"\n    using rearranged2 by sos\n  have \"x * z = 2\"\n    using h2 cross_mult1 cross_mult2 by (metis amc12a_2013_p8_evolved h0 h5 h6 h7)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\"\n    using rearranged by sos\n  have \"x * y = 2\"\n    using h2 cross_mult by sos\n  thus ?thesis by simp\nqed\n\ntheorem amc12a_2013_p8_generalized:\n  fixes x y z :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"z \\<noteq> 0\"\n    and h3 : \"x \\<noteq> y\" and h4 : \"y \\<noteq> z\" and h5 : \"x \\<noteq> z\"\n    and h6 : \"x + 2/x = y + 2/y\" and h7 : \"y + 2/y = z + 2/z\"\n  shows \"x * z = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h6 by simp\n  have \"y + 2/y = z + 2/z\" using h7 by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" by (smt (verit) h6)\n  have rearranged2: \"y - z = (2/z - 2/y)\" by (smt (verit) h7)\n  have cross_mult1: \"(x - y) * x * y = 2 * (x - y)\"\n    using rearranged1 by sos\n  have cross_mult2: \"(y - z) * y * z = 2 * (y - z)\"\n    using rearranged2 by sos\n  have \"x * z = 2\"\n    using h2 cross_mult1 cross_mult2 by (metis amc12a_2013_p8_evolved h0 h5 h6 h7)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "sqrt_limit_generalV3": {"skill_name": "sqrt_limit_generalV3", "marker": "lemma sqrt_limit_general:\n  fixes x y :: real\n  assumes \"y = sqrt(x + y)\" \"y > 0\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms(1) by (metis assms(2) less_eq_real_def real_sqrt_eq_iff real_sqrt_unique)\n  thus ?thesis by (simp add: assms(2) field_simps)\nqed", "description": "-", "full_code": "lemma sqrt_limit_general:\n  fixes x y :: real\n  assumes \"y = sqrt(x + y)\" \"y > 0\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms(1) by (metis assms(2) less_eq_real_def real_sqrt_eq_iff real_sqrt_unique)\n  thus ?thesis by (simp add: assms(2) field_simps)\nqed", "origin": "sqrt_limit", "update_count": 0}, "inequality_bounds": {"skill_name": "inequality_bounds", "marker": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n >= 7\" \"n <= 7\"\n  shows \"n = 7\"\nproof -\n  from assms(1) have \"n >= 7\" by simp\n  from assms(2) have \"n <= 7\" by simp\n  hence \"n = 7\" using le_antisym by (metis assms(1) nle_le)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n >= 7\" \"n <= 7\"\n  shows \"n = 7\"\nproof -\n  from assms(1) have \"n >= 7\" by simp\n  from assms(2) have \"n <= 7\" by simp\n  hence \"n = 7\" using le_antisym by (metis assms(1) nle_le)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "inequality_boundsV2": {"skill_name": "inequality_boundsV2", "marker": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n >= 7\" \"n <= 7\"\n  shows \"n = 7\"\nproof -\n  have \"n >= 7\" using assms by simp\n  hence \"n = 7\" using assms(2) by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n >= 7\" \"n <= 7\"\n  shows \"n = 7\"\nproof -\n  have \"n >= 7\" using assms by simp\n  hence \"n = 7\" using assms(2) by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "inequality_boundsV3": {"skill_name": "inequality_boundsV3", "marker": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n >= 7\" \"n <= 7\"\n  shows \"n = 7\"\nproof -\n  have \"n >= 7\" using assms(1) by simp\n  have \"n <= 7\" using assms(2) by simp\n  hence \"n = 7\" using Nat.le_eq_less_or_eq by (metis assms(1) nle_le)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n >= 7\" \"n <= 7\"\n  shows \"n = 7\"\nproof -\n  have \"n >= 7\" using assms(1) by simp\n  have \"n <= 7\" using assms(2) by simp\n  hence \"n = 7\" using Nat.le_eq_less_or_eq by (metis assms(1) nle_le)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "inequality_boundsV4": {"skill_name": "inequality_boundsV4", "marker": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n >= 7\" \"n <= 7\"\n  shows \"n = 7\"\nproof -\n  have \"n >= 7\" using assms(1) by simp\n  have \"n <= 7\" using assms(2) by simp\n  then show ?thesis using `n >= 7` by auto\nqed", "description": "-", "full_code": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n >= 7\" \"n <= 7\"\n  shows \"n = 7\"\nproof -\n  have \"n >= 7\" using assms(1) by simp\n  have \"n <= 7\" using assms(2) by simp\n  then show ?thesis using `n >= 7` by auto\nqed", "origin": "do_request", "update_count": 0}, "inequality_boundsV5": {"skill_name": "inequality_boundsV5", "marker": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n >= 7\" \"n <= 7\"\n  shows \"n = 7\"\nproof -\n  from assms have \"7 \\<le> n\" and \"n \\<le> 7\" by auto\n  then show ?thesis using le_antisym by blast\nqed", "description": "-", "full_code": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n >= 7\" \"n <= 7\"\n  shows \"n = 7\"\nproof -\n  from assms have \"7 \\<le> n\" and \"n \\<le> 7\" by auto\n  then show ?thesis using le_antisym by blast\nqed", "origin": "do_request", "update_count": 0}, "inequality_boundsV6": {"skill_name": "inequality_boundsV6", "marker": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n \\<ge> 7\" \"n \\<le> 7\"\n  shows \"n = 7\"\nproof -\n  from assms(1) have \"n \\<ge> 7\" by simp\n  from assms(2) have \"n \\<le> 7\" by simp\n  then have \"n = 7\" using `n \\<ge> 7` by (metis le_antisym)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n \\<ge> 7\" \"n \\<le> 7\"\n  shows \"n = 7\"\nproof -\n  from assms(1) have \"n \\<ge> 7\" by simp\n  from assms(2) have \"n \\<le> 7\" by simp\n  then have \"n = 7\" using `n \\<ge> 7` by (metis le_antisym)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "inequality_boundsV7": {"skill_name": "inequality_boundsV7", "marker": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n \\<ge> 7\" \"n \\<le> 7\"\n  shows \"n = 7\"\nproof -\n  from assms have \"7 \\<le> n\" by auto\n  from assms have \"n \\<le> 7\" by simp\n  thus ?thesis using `7 \\<le> n` `n \\<le> 7` by auto\nqed", "description": "-", "full_code": "lemma inequality_bounds:\n  fixes n :: nat\n  assumes \"n \\<ge> 7\" \"n \\<le> 7\"\n  shows \"n = 7\"\nproof -\n  from assms have \"7 \\<le> n\" by auto\n  from assms have \"n \\<le> 7\" by simp\n  thus ?thesis using `7 \\<le> n` `n \\<le> 7` by auto\nqed", "origin": "do_request", "update_count": 0}, "amc12a_2013_p8_3d": {"skill_name": "amc12a_2013_p8_3d", "marker": "theorem amc12a_2013_p8_3d:\n  fixes x y z :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"z \\<noteq> 0\"\n    and h3 : \"x \\<noteq> y\"\n    and h4 : \"x \\<noteq> z\"\n    and h5 : \"y \\<noteq> z\"\n    and h6 : \"x + 2/x = y + 2/y\"\n    and h7 : \"x + 2/x = z + 2/z\"\n  shows \"x * y * z = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h6 by simp\n  have \"x + 2/x = z + 2/z\" using h7 by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" by (smt (verit) h6)\n  have rearranged2: \"x - z = (2/z - 2/x)\" by (smt (verit) h7)\n  have cross_mult_y: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged1 by sos\n  have cross_mult_z: \"(x - z) * x * z = 2 * (x - z)\" \n    using rearranged2 by sos\n  have \"x * y = 2\" using h3 cross_mult_y by sos\n  have \"x * z = 2\" using h4 cross_mult_z by sos\n  then show ?thesis \n    using `x * y = 2` by (metis add.commute add_diff_cancel_left' add_divide_eq_if_simps(1) dbl_simps(3) eq_divide_eq h1 h2 h5 h6 h7)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_3d:\n  fixes x y z :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"z \\<noteq> 0\"\n    and h3 : \"x \\<noteq> y\"\n    and h4 : \"x \\<noteq> z\"\n    and h5 : \"y \\<noteq> z\"\n    and h6 : \"x + 2/x = y + 2/y\"\n    and h7 : \"x + 2/x = z + 2/z\"\n  shows \"x * y * z = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h6 by simp\n  have \"x + 2/x = z + 2/z\" using h7 by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" by (smt (verit) h6)\n  have rearranged2: \"x - z = (2/z - 2/x)\" by (smt (verit) h7)\n  have cross_mult_y: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged1 by sos\n  have cross_mult_z: \"(x - z) * x * z = 2 * (x - z)\" \n    using rearranged2 by sos\n  have \"x * y = 2\" using h3 cross_mult_y by sos\n  have \"x * z = 2\" using h4 cross_mult_z by sos\n  then show ?thesis \n    using `x * y = 2` by (metis add.commute add_diff_cancel_left' add_divide_eq_if_simps(1) dbl_simps(3) eq_divide_eq h1 h2 h5 h6 h7)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_complex": {"skill_name": "amc12a_2013_p8_complex", "marker": "theorem amc12a_2013_p8_complex:\n  fixes x y :: complex\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) add_diff_cancel_left add_diff_cancel_right h3)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by (smt (verit) add_diff_cancel_left' add_implies_diff diff_diff_eq2 diff_divide_eq_iff diff_eq_diff_eq diff_frac_eq divide_cancel_left eq_divide_imp eq_iff_diff_eq_0 frac_eq_eq h0 h1 h2 h3 left_diff_distrib' mult.commute no_zero_divisors nonzero_mult_div_cancel_left right_diff_distrib')\n  have \"x * y = 2\" \n    using h2 cross_mult by (smt (verit) add_implies_diff diff_add_cancel diff_add_eq divide_eq_eq eq_iff_diff_eq_0 h0 h1 no_zero_divisors nonzero_mult_div_cancel_left nonzero_mult_divide_mult_cancel_right2 rearranged)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_complex:\n  fixes x y :: complex\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) add_diff_cancel_left add_diff_cancel_right h3)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by (smt (verit) add_diff_cancel_left' add_implies_diff diff_diff_eq2 diff_divide_eq_iff diff_eq_diff_eq diff_frac_eq divide_cancel_left eq_divide_imp eq_iff_diff_eq_0 frac_eq_eq h0 h1 h2 h3 left_diff_distrib' mult.commute no_zero_divisors nonzero_mult_div_cancel_left right_diff_distrib')\n  have \"x * y = 2\" \n    using h2 cross_mult by (smt (verit) add_implies_diff diff_add_cancel diff_add_eq divide_eq_eq eq_iff_diff_eq_0 h0 h1 no_zero_divisors nonzero_mult_div_cancel_left nonzero_mult_divide_mult_cancel_right2 rearranged)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "product_sum_relation": {"skill_name": "product_sum_relation", "marker": "lemma product_sum_relation:\n  fixes x y :: real\n  assumes h0: \"x + y = s\" and h1: \"x * y = p\"\n  shows \"x^2 + y^2 = s^2 - 2 * p\"\nproof -\n  have \"x^2 + y^2 = (x + y)^2 - 2 * x * y\" by sos\n  then show ?thesis using h0 h1 by auto\nqed", "description": "-", "full_code": "lemma product_sum_relation:\n  fixes x y :: real\n  assumes h0: \"x + y = s\" and h1: \"x * y = p\"\n  shows \"x^2 + y^2 = s^2 - 2 * p\"\nproof -\n  have \"x^2 + y^2 = (x + y)^2 - 2 * x * y\" by sos\n  then show ?thesis using h0 h1 by auto\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "sqrt_square": {"skill_name": "sqrt_square", "marker": "lemma sqrt_square:\n  fixes x :: real\n  assumes \"y = sqrt(x)\" and \"x >= 0\"\n  shows \"y^2 = x\"\nproof -\n  have \"y^2 = (sqrt x)^2\" using assms by simp\n  then show ?thesis by (metis assms(2) power2_eq_iff_nonneg real_sqrt_eq_iff real_sqrt_power real_sqrt_unique zero_le_power2)\nqed", "description": "-", "full_code": "lemma sqrt_square:\n  fixes x :: real\n  assumes \"y = sqrt(x)\" and \"x >= 0\"\n  shows \"y^2 = x\"\nproof -\n  have \"y^2 = (sqrt x)^2\" using assms by simp\n  then show ?thesis by (metis assms(2) power2_eq_iff_nonneg real_sqrt_eq_iff real_sqrt_power real_sqrt_unique zero_le_power2)\nqed", "origin": "sqrt_limit", "update_count": 0}, "square_expansion": {"skill_name": "square_expansion", "marker": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  by sos", "description": "", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  by sos", "origin": "data/full_data/debug/valid_rand/mathd_algebra_116.json_v15", "update_count": -1}, "algebra_2var_linear_combined": {"skill_name": "algebra_2var_linear_combined", "marker": "theorem algebra_2var_linear_combined:\n  fixes x y e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"y = 3 * x + 2\"\n  shows \"e = 11 \\<and> x = -4 \\<and> y = -10\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by simp\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  obtain y_value: \"y = 3 * (-4) + 2\" using h2 by (metis dbl_inc_simps(3) dbl_simps(3) x_value_final)\n  then have y_value_final: \"y = -12 + 2\" by simp\n  then show ?thesis using x_value_final e_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2var_linear_combined:\n  fixes x y e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"y = 3 * x + 2\"\n  shows \"e = 11 \\<and> x = -4 \\<and> y = -10\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by simp\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  obtain y_value: \"y = 3 * (-4) + 2\" using h2 by (metis dbl_inc_simps(3) dbl_simps(3) x_value_final)\n  then have y_value_final: \"y = -12 + 2\" by simp\n  then show ?thesis using x_value_final e_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlinear_eq": {"skill_name": "algebra_2varlinear_eq", "marker": "theorem algebra_2varlinear_eq:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  hence \"e = 7 + 4\" by simp\n  thus ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlinear_eq:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  hence \"e = 7 + 4\" by simp\n  thus ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "floor_function_properties": {"skill_name": "floor_function_properties", "marker": "lemma floor_function_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor (x + 1) = floor x + 1\" \n  proof (cases \"x \\<in> \\<int>\")\n    case True\n    then have \"floor x = x\" by auto\n    hence \"floor (x + 1) = x + 1\" by auto\n    thus ?thesis by (simp add: True)\n  next\n    case False\n    then have \"floor x < x\" by (metis Ints_of_int dual_order.strict_iff_order of_int_floor_le)\n    then have \"floor x + 1 > x\" by auto\n    then have \"floor (x + 1) = floor x + 1\" using floor_add[of x 1] by simp\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_function_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor (x + 1) = floor x + 1\" \n  proof (cases \"x \\<in> \\<int>\")\n    case True\n    then have \"floor x = x\" by auto\n    hence \"floor (x + 1) = x + 1\" by auto\n    thus ?thesis by (simp add: True)\n  next\n    case False\n    then have \"floor x < x\" by (metis Ints_of_int dual_order.strict_iff_order of_int_floor_le)\n    then have \"floor x + 1 > x\" by auto\n    then have \"floor (x + 1) = floor x + 1\" using floor_add[of x 1] by simp\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_additionV3": {"skill_name": "mod_additionV3", "marker": "lemma mod_addition:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  from assms have \"a = 10 * (a div 10)\" \n    by auto\n  from assms have \"b = 6 + 10 * (b div 10)\" \n    by presburger\n  then have \"a + b = (10 * (a div 10)) + (6 + 10 * (b div 10))\"\n    by (metis \\<open>a = 10 * (a div 10)\\<close>)\n  then have \"a + b = 6 + 10 * ((a div 10) + (b div 10))\" \n    by (simp add: algebra_simps)\n  hence \"(a + b) mod 10 = (6 + 10 * ((a div 10) + (b div 10))) mod 10\"\n    by presburger\n  also have \"... = 6 mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  from assms have \"a = 10 * (a div 10)\" \n    by auto\n  from assms have \"b = 6 + 10 * (b div 10)\" \n    by presburger\n  then have \"a + b = (10 * (a div 10)) + (6 + 10 * (b div 10))\"\n    by (metis \\<open>a = 10 * (a div 10)\\<close>)\n  then have \"a + b = 6 + 10 * ((a div 10) + (b div 10))\" \n    by (simp add: algebra_simps)\n  hence \"(a + b) mod 10 = (6 + 10 * ((a div 10) + (b div 10))) mod 10\"\n    by presburger\n  also have \"... = 6 mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_additionV4": {"skill_name": "mod_additionV4", "marker": "lemma mod_addition:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = 10 * (a div 10)\" using assms(1) by auto\n  have \"b = 6 + 10 * (b div 10)\" using assms(2) by presburger\n  then have \"a + b = (10 * (a div 10)) + (6 + 10 * (b div 10))\"\n    by (metis \\<open>a = 10 * (a div 10)\\<close>)\n  hence \"a + b = (10 * (a div 10 + b div 10)) + 6\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = 6\" \n    using mod_add_eq by presburger\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = 10 * (a div 10)\" using assms(1) by auto\n  have \"b = 6 + 10 * (b div 10)\" using assms(2) by presburger\n  then have \"a + b = (10 * (a div 10)) + (6 + 10 * (b div 10))\"\n    by (metis \\<open>a = 10 * (a div 10)\\<close>)\n  hence \"a + b = (10 * (a div 10 + b div 10)) + 6\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = 6\" \n    using mod_add_eq by presburger\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpler": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpler", "marker": "lemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpler:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" by (metis add.commute add_diff_cancel dbl_inc_simps(3) eq_simplified h0)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  have x_value: \"x = 3 - 7\" by (metis \\<open>x + 7 = 3\\<close> add.commute add_diff_cancel dbl_inc_simps(3) h0)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed\n\nlemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpler:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" by (metis add.commute add_diff_cancel dbl_inc_simps(3) eq_simplified h0)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "double_variable_equation": {"skill_name": "double_variable_equation", "marker": "lemma double_variable_equation:\n  fixes x y :: complex\n  assumes h0: \"x + y = a\"\n  and h1: \"2 * x + y = b\"\n  shows \"y = b - 2 * (a - y)\"\nproof -\n  have \"2 * x + y = b\" using h1 by auto\n  hence \"2 * (a - y) + y = b\" using h0 by auto\n  then show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma double_variable_equation:\n  fixes x y :: complex\n  assumes h0: \"x + y = a\"\n  and h1: \"2 * x + y = b\"\n  shows \"y = b - 2 * (a - y)\"\nproof -\n  have \"2 * x + y = b\" using h1 by auto\n  hence \"2 * (a - y) + y = b\" using h0 by auto\n  then show ?thesis by (simp add: field_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "mathd_algebra_109_generalizedV7": {"skill_name": "mathd_algebra_109_generalizedV7", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have \"3 * a + 2 * b = c\" using h0 by simp\n  then have \"3 * 4 + 2 * b = c\" using h1 by simp\n  then have \"12 + 2 * b = c\" by simp\n  thus \"b = (c - 12) / 2\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have \"3 * a + 2 * b = c\" using h0 by simp\n  then have \"3 * 4 + 2 * b = c\" using h1 by simp\n  then have \"12 + 2 * b = c\" by simp\n  thus \"b = (c - 12) / 2\" by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolvedV9": {"skill_name": "mathd_algebra_109_evolvedV9", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"3 * 4 + 2 * b = 12\" using h1 by simp\n  then have \"12 + 2 * b = 12\" by simp\n  thus \"b = 0\" using `12 + 2 * b = 12` by (simp add: add_cancel_right_right)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"3 * 4 + 2 * b = 12\" using h1 by simp\n  then have \"12 + 2 * b = 12\" by simp\n  thus \"b = 0\" using `12 + 2 * b = 12` by (simp add: add_cancel_right_right)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_110V2": {"skill_name": "mathd_algebra_110V2", "marker": "theorem mathd_algebra_110:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  have \"2 * b = c - 12\" by (metis \\<open>12 + 2 * b = c\\<close> add.left_commute add_diff_cancel_left add_minus_cancel equation_minus_iff is_num_normalize(1) minus_add_cancel minus_real_def mult.commute mult_2_right numeral_neq_neg_numeral numeral_times_minus_swap square_eq_iff uminus_add_conv_diff)\n  thus ?thesis using `2 * b = c - 12` by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_110:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  have \"2 * b = c - 12\" by (metis \\<open>12 + 2 * b = c\\<close> add.left_commute add_diff_cancel_left add_minus_cancel equation_minus_iff is_num_normalize(1) minus_add_cancel minus_real_def mult.commute mult_2_right numeral_neq_neg_numeral numeral_times_minus_swap square_eq_iff uminus_add_conv_diff)\n  thus ?thesis using `2 * b = c - 12` by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_system_solutionV3": {"skill_name": "linear_system_solutionV3", "marker": "theorem linear_system_solution:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"  \n    and h1 : \"2 * x + e = b\"  \n  shows \"e = a - x \\<and> x = (b - a) / 1\"  \nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = (b - a)\" by simp\n  have e_value: \"e = a - (b - a)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem linear_system_solution:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"  \n    and h1 : \"2 * x + e = b\"  \n  shows \"e = a - x \\<and> x = (b - a) / 1\"  \nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = (b - a)\" by simp\n  have e_value: \"e = a - (b - a)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "mathd_algebra_109_evolvedV10": {"skill_name": "mathd_algebra_109_evolvedV10", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  also have \"3 * 4 + 2 * b = 12\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  hence \"12 + 2 * b = 12\" by simp\n  thus \"b = 0\" using `12 + 2 * b = 12` by auto\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  also have \"3 * 4 + 2 * b = 12\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  hence \"12 + 2 * b = 12\" by simp\n  thus \"b = 0\" using `12 + 2 * b = 12` by auto\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_generalizedV8": {"skill_name": "mathd_algebra_109_generalizedV8", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"k * a + m * b = n\"\n    and h1 : \"a = p\"\n    and h2 : \"m > 0\"\n  shows \"b = (n - k * p) / m\"\nproof -\n  have eq: \"k * a + m * b = n\" using h0 by simp\n  have \"k * p + m * b = n\" using h1 eq by simp\n  thus ?thesis by (metis add_0_iff add_diff_cancel_left' add_right_imp_eq diff_eq_diff_less diff_zero distrib_left divide_eq_imp eq_diff_eq' h0 h1 h2 mult.commute mult_delta_left sum_squares_gt_zero_iff)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"k * a + m * b = n\"\n    and h1 : \"a = p\"\n    and h2 : \"m > 0\"\n  shows \"b = (n - k * p) / m\"\nproof -\n  have eq: \"k * a + m * b = n\" using h0 by simp\n  have \"k * p + m * b = n\" using h1 eq by simp\n  thus ?thesis by (metis add_0_iff add_diff_cancel_left' add_right_imp_eq diff_eq_diff_less diff_zero distrib_left divide_eq_imp eq_diff_eq' h0 h1 h2 mult.commute mult_delta_left sum_squares_gt_zero_iff)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "square_difference": {"skill_name": "square_difference", "marker": "lemma square_difference:\n  fixes a b :: complex\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (-b + a)^2\" by (simp)\n  also have \"... = a^2 - 2*a*b + b^2\" by (smt (verit) calculation diff_add_eq power2_diff)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_difference:\n  fixes a b :: complex\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (-b + a)^2\" by (simp)\n  also have \"... = a^2 - 2*a*b + b^2\" by (smt (verit) calculation diff_add_eq power2_diff)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "non_negative_sum_of_squares": {"skill_name": "non_negative_sum_of_squares", "marker": "lemma non_negative_sum_of_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2 + b^2\"\n  by (simp)", "description": "-", "full_code": "lemma non_negative_sum_of_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2 + b^2\"\n  by (simp)", "origin": "square_expansion", "update_count": 0}, "square_expansionV2": {"skill_name": "square_expansionV2", "marker": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  by (simp add: power2_eq_square algebra_simps)", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  by (simp add: power2_eq_square algebra_simps)", "origin": "square_expansion", "update_count": 0}, "non_negative_sum_of_squaresV2": {"skill_name": "non_negative_sum_of_squaresV2", "marker": "lemma non_negative_sum_of_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2 + b^2\"\nproof -\n  have \"a^2 \\<ge> 0\" and \"b^2 \\<ge> 0\" by (simp_all add: power2_eq_square)\n  then show ?thesis by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma non_negative_sum_of_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2 + b^2\"\nproof -\n  have \"a^2 \\<ge> 0\" and \"b^2 \\<ge> 0\" by (simp_all add: power2_eq_square)\n  then show ?thesis by (simp add: add_nonneg_nonneg)\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansionV3": {"skill_name": "square_expansionV3", "marker": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(-b + a)^2 = (-b)^2 + 2 * (-b) * a + a^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  also have \"... = b^2 - 2*b*a + a^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(-b + a)^2 = (-b)^2 + 2 * (-b) * a + a^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  also have \"... = b^2 - 2*b*a + a^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "algebra_solution": {"skill_name": "algebra_solution", "marker": "theorem algebra_solution:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"2 * b = 12 - 3 * a\" using eq by simp\n  then show ?thesis using h1 by simp\nqed", "description": "-", "full_code": "theorem algebra_solution:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"2 * b = 12 - 3 * a\" using eq by simp\n  then show ?thesis using h1 by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "inequality_manipulation": {"skill_name": "inequality_manipulation", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"a * c < b * c\"\n  proof -\n    from assms(1) have \"b - a > 0\" by (simp add: less_diff_conv)\n    moreover from assms(2) have \"c > 0\" by assumption\n    ultimately have \"b - a > 0\" and \"c > 0\" by simp_all\n    then show ?thesis \n      using mult_strict_mono by auto\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"a * c < b * c\"\n  proof -\n    from assms(1) have \"b - a > 0\" by (simp add: less_diff_conv)\n    moreover from assms(2) have \"c > 0\" by assumption\n    ultimately have \"b - a > 0\" and \"c > 0\" by simp_all\n    then show ?thesis \n      using mult_strict_mono by auto\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_limit_generalizedV2": {"skill_name": "sqrt_limit_generalizedV2", "marker": "lemma sqrt_limit_generalized:\n  fixes x :: real\n  assumes \"k = sqrt(x + k)\" \"k > 0\"\n  shows \"x = k^2 - k\"\nproof -\n  have \"k^2 = x + k\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  hence \"x = k^2 - k\" by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_limit_generalized:\n  fixes x :: real\n  assumes \"k = sqrt(x + k)\" \"k > 0\"\n  shows \"x = k^2 - k\"\nproof -\n  have \"k^2 = x + k\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  hence \"x = k^2 - k\" by simp\n  thus ?thesis by auto\nqed", "origin": "sqrt_limit", "update_count": 0}, "substitution_in_linear_equationV2": {"skill_name": "substitution_in_linear_equationV2", "marker": "lemma substitution_in_linear_equation:\n  fixes a b :: real\n  assumes h0 : \"c * a + d * b = e\"\n    and h1 : \"a = f\"\n  shows \"c * f + d * b = e\"\nproof -\n  have \"c * a + d * b = e\" using h0 by simp\n  then have \"c * f + d * b = e\" using h1 by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma substitution_in_linear_equation:\n  fixes a b :: real\n  assumes h0 : \"c * a + d * b = e\"\n    and h1 : \"a = f\"\n  shows \"c * f + d * b = e\"\nproof -\n  have \"c * a + d * b = e\" using h0 by simp\n  then have \"c * f + d * b = e\" using h1 by simp\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "product_even_prime": {"skill_name": "product_even_prime", "marker": "lemma product_even_prime:\n  fixes a b :: nat\n  assumes \"a * b = 2\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms by simp\n  have \"a = 0 \\<or> a = 1 \\<or> a = 2\" \n  proof (cases \"a = 0\")\n    case True\n    then have \"b = 2\" using `a * b = 2` by simp\n    then show ?thesis by (metis True nat_neq_iff)\n  next\n    case False\n    then show ?thesis \n    proof (cases \"a = 1\")\n      case True\n      then show ?thesis by (metis `a * b = 2` mult_eq_0_iff nat_neq_iff)\n    next\n      case False\n      hence \"a \\<ge> 2\" by (metis Suc_1 Suc_eq_plus1_left Suc_le_D add_diff_cancel_left' add_diff_cancel_right' assms diff_Suc_1 diff_Suc_Suc diff_le_self diff_mult_distrib dual_order.refl le_SucE le_add_diff nat_le_linear not_less_eq_eq verit_la_disequality)\n      then have \"a = 2\" using `a * b = 2` by (smt (verit) One_nat_def fact_2 fact_ge_Suc_0_nat mult.comm_neutral mult_le_mono2 nle_le one_le_mult_iff)\n      then show ?thesis by (metis `a * b = 2` mult_eq_0_iff nat_neq_iff)\n    qed\n  qed\n  thus ?thesis by (metis assms mult_eq_self_implies_10 mult_zero_left nat_mult_1 zero_neq_numeral)\nqed", "description": "-", "full_code": "lemma product_even_prime:\n  fixes a b :: nat\n  assumes \"a * b = 2\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms by simp\n  have \"a = 0 \\<or> a = 1 \\<or> a = 2\" \n  proof (cases \"a = 0\")\n    case True\n    then have \"b = 2\" using `a * b = 2` by simp\n    then show ?thesis by (metis True nat_neq_iff)\n  next\n    case False\n    then show ?thesis \n    proof (cases \"a = 1\")\n      case True\n      then show ?thesis by (metis `a * b = 2` mult_eq_0_iff nat_neq_iff)\n    next\n      case False\n      hence \"a \\<ge> 2\" by (metis Suc_1 Suc_eq_plus1_left Suc_le_D add_diff_cancel_left' add_diff_cancel_right' assms diff_Suc_1 diff_Suc_Suc diff_le_self diff_mult_distrib dual_order.refl le_SucE le_add_diff nat_le_linear not_less_eq_eq verit_la_disequality)\n      then have \"a = 2\" using `a * b = 2` by (smt (verit) One_nat_def fact_2 fact_ge_Suc_0_nat mult.comm_neutral mult_le_mono2 nle_le one_le_mult_iff)\n      then show ?thesis by (metis `a * b = 2` mult_eq_0_iff nat_neq_iff)\n    qed\n  qed\n  thus ?thesis by (metis assms mult_eq_self_implies_10 mult_zero_left nat_mult_1 zero_neq_numeral)\nqed", "origin": "do_request", "update_count": 0}, "divisibility_propertiesV2": {"skill_name": "divisibility_propertiesV2", "marker": "lemma divisibility_properties:\n  fixes a b :: nat\n  assumes \"a mod b = 0\"\n  shows \"\\<exists>k. a = b * k\" \nproof -\n  obtain k where \"a = b * k\" and \"a mod b = 0\" using assms by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma divisibility_properties:\n  fixes a b :: nat\n  assumes \"a mod b = 0\"\n  shows \"\\<exists>k. a = b * k\" \nproof -\n  obtain k where \"a = b * k\" and \"a mod b = 0\" using assms by auto\n  then show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_arithmetic": {"skill_name": "mod_arithmetic", "marker": "lemma mod_arithmetic:\n  fixes x y :: nat\n  assumes \"x mod n = a\" \"y mod n = b\"\n  shows \"(x + y) mod n = (a + b) mod n\"\nproof -\n  have \"x = a + n * (x div n)\" \n    using assms(1) by auto\n  have \"y = b + n * (y div n)\" \n    using assms(2) by auto\n  then have \"x + y = (a + n * (x div n)) + (b + n * (y div n))\"\n    by (metis \\<open>x = a + n * (x div n)\\<close>)\n  then have \"x + y = (a + b) + n * ((x div n) + (y div n))\"\n    by (simp add: algebra_simps)\n  then have \"(x + y) mod n = ((a + b) + n * ((x div n) + (y div n))) mod n\"\n    by simp\n  also have \"... = (a + b) mod n\"\n    by (simp add: mod_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes x y :: nat\n  assumes \"x mod n = a\" \"y mod n = b\"\n  shows \"(x + y) mod n = (a + b) mod n\"\nproof -\n  have \"x = a + n * (x div n)\" \n    using assms(1) by auto\n  have \"y = b + n * (y div n)\" \n    using assms(2) by auto\n  then have \"x + y = (a + n * (x div n)) + (b + n * (y div n))\"\n    by (metis \\<open>x = a + n * (x div n)\\<close>)\n  then have \"x + y = (a + b) + n * ((x div n) + (y div n))\"\n    by (simp add: algebra_simps)\n  then have \"(x + y) mod n = ((a + b) + n * ((x div n) + (y div n))) mod n\"\n    by simp\n  also have \"... = (a + b) mod n\"\n    by (simp add: mod_simps)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV5": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV5", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e d :: complex\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n    and h2: \"d = e + 5\"  \n  shows \"e = 11 \\<and> x = -4 \\<and> d = 16\"  \nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then have e_final: \"e = 11\" by simp\n  have d_value: \"d = e + 5\" using h2 by simp\n  then have d_final: \"d = 11 + 5\" by (simp add: e_final)\n  thus ?thesis using x_value_final e_final d_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e d :: complex\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n    and h2: \"d = e + 5\"  \n  shows \"e = 11 \\<and> x = -4 \\<and> d = 16\"  \nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then have e_final: \"e = 11\" by simp\n  have d_value: \"d = e + 5\" using h2 by simp\n  then have d_final: \"d = 11 + 5\" by (simp add: e_final)\n  thus ?thesis using x_value_final e_final d_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "product_of_integers": {"skill_name": "product_of_integers", "marker": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  then show \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms prime_def by (metis less_irrefl_nat prime_product)\n    thus ?thesis by (metis assms(1) mult.right_neutral)\n  next\n    case False\n    then have \"b > 1\" using assms(1) by (metis \\<open>1 < a * b\\<close> less_one mult.right_neutral mult_is_0 not_less_iff_gr_or_eq not_one_less_zero)\n    then have \"a = 1\" using assms prime_def by (metis False less_one linorder_neqE_nat mult_eq_0_iff not_prime_0)\n    thus ?thesis by (metis assms(1) comm_monoid_mult_class.mult_1)\n  qed\nqed", "description": "-", "full_code": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  then show \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms prime_def by (metis less_irrefl_nat prime_product)\n    thus ?thesis by (metis assms(1) mult.right_neutral)\n  next\n    case False\n    then have \"b > 1\" using assms(1) by (metis \\<open>1 < a * b\\<close> less_one mult.right_neutral mult_is_0 not_less_iff_gr_or_eq not_one_less_zero)\n    then have \"a = 1\" using assms prime_def by (metis False less_one linorder_neqE_nat mult_eq_0_iff not_prime_0)\n    thus ?thesis by (metis assms(1) comm_monoid_mult_class.mult_1)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_of_integersV2": {"skill_name": "product_of_integersV2", "marker": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(2) by (metis assms(1) prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"b = p div a\"\n      using assms(1) by auto\n    moreover have \"p div a < p\"\n      using `a * b > 1` assms(1) by (metis \\<open>1 < a\\<close> assms(2) div_less_dividend not_prime_0 zero_less_iff_neq_zero)\n    ultimately have \"b < p\" by auto\n    then have \"b = 1\" \n      using assms(2) prime_def by (metis assms(1) dvd_triv_right gcd_nat.order_iff_strict gcd_nat.trans prime_nat_not_dvd)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = p div b\"\n      using assms(1) by auto\n    moreover have \"p div b < p\"\n      using `a * b > 1` assms(1) by (metis Primes.prime_nat_def \\<open>1 < b\\<close> assms(2) calculation div_le_dividend dual_order.strict_iff_order gr_zeroI less_not_refl mult_1 mult_eq_self_implies_10 not_prime_0 prime_product)\n    ultimately have \"a < p\" by auto\n    then have \"a = 1\" \n      using assms(2) prime_def by (metis \\<open>1 < b\\<close> assms(1) less_irrefl_nat mult.commute mult_delta_right prime_product)\n  }\n  thus \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\" \n    by (metis assms(1) assms(2) comm_monoid_mult_class.mult_1 mult_cancel_right nat.distinct(1) nat_mult_1_right prime_product)\nqed", "description": "-", "full_code": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(2) by (metis assms(1) prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"b = p div a\"\n      using assms(1) by auto\n    moreover have \"p div a < p\"\n      using `a * b > 1` assms(1) by (metis \\<open>1 < a\\<close> assms(2) div_less_dividend not_prime_0 zero_less_iff_neq_zero)\n    ultimately have \"b < p\" by auto\n    then have \"b = 1\" \n      using assms(2) prime_def by (metis assms(1) dvd_triv_right gcd_nat.order_iff_strict gcd_nat.trans prime_nat_not_dvd)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = p div b\"\n      using assms(1) by auto\n    moreover have \"p div b < p\"\n      using `a * b > 1` assms(1) by (metis Primes.prime_nat_def \\<open>1 < b\\<close> assms(2) calculation div_le_dividend dual_order.strict_iff_order gr_zeroI less_not_refl mult_1 mult_eq_self_implies_10 not_prime_0 prime_product)\n    ultimately have \"a < p\" by auto\n    then have \"a = 1\" \n      using assms(2) prime_def by (metis \\<open>1 < b\\<close> assms(1) less_irrefl_nat mult.commute mult_delta_right prime_product)\n  }\n  thus \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\" \n    by (metis assms(1) assms(2) comm_monoid_mult_class.mult_1 mult_cancel_right nat.distinct(1) nat_mult_1_right prime_product)\nqed", "origin": "do_request", "update_count": 0}, "square_modulo_4": {"skill_name": "square_modulo_4", "marker": "lemma square_modulo_4:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\nproof -\n  assume \"a mod 4 = 0\"\n  then have \"a = 4 * (a div 4)\" by auto\n  have \"a^2 = (4 * (a div 4))^2\" by (metis \\<open>a = 4 * (a div 4)\\<close>)\n  also have \"... = 16 * (a div 4)^2\" by (simp add: power2_eq_square)\n  finally have \"a^2 = 16 * (a div 4)^2\" .\n  then have \"a^2 mod 4 = (16 * (a div 4)^2) mod 4\" by simp\n  also have \"... = 0 mod 4\" by (simp add: mod_mult_right_eq)\n  finally show \"a^2 mod 4 = 0\" by simp\nqed", "description": "-", "full_code": "lemma square_modulo_4:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\nproof -\n  assume \"a mod 4 = 0\"\n  then have \"a = 4 * (a div 4)\" by auto\n  have \"a^2 = (4 * (a div 4))^2\" by (metis \\<open>a = 4 * (a div 4)\\<close>)\n  also have \"... = 16 * (a div 4)^2\" by (simp add: power2_eq_square)\n  finally have \"a^2 = 16 * (a div 4)^2\" .\n  then have \"a^2 mod 4 = (16 * (a div 4)^2) mod 4\" by simp\n  also have \"... = 0 mod 4\" by (simp add: mod_mult_right_eq)\n  finally show \"a^2 mod 4 = 0\" by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_limit_multi": {"skill_name": "sqrt_limit_multi", "marker": "lemma sqrt_limit_multi:\n  fixes x :: real\n  assumes \"n > 0\" \n    and \"n = sqrt(x + n)\"\n  shows \"x = n^2 - n\"\nproof -\n  have \"n^2 = x + n\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  have \"x = n^2 - n\" by (metis \\<open>n^2 = x + n\\<close> add_diff_cancel semiring_norm(3) semiring_norm(5))\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_limit_multi:\n  fixes x :: real\n  assumes \"n > 0\" \n    and \"n = sqrt(x + n)\"\n  shows \"x = n^2 - n\"\nproof -\n  have \"n^2 = x + n\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  have \"x = n^2 - n\" by (metis \\<open>n^2 = x + n\\<close> add_diff_cancel semiring_norm(3) semiring_norm(5))\n  then show ?thesis by simp\nqed", "origin": "sqrt_limit", "update_count": 0}, "square_expansion_extended": {"skill_name": "square_expansion_extended", "marker": "lemma square_expansion_extended:\n  fixes a b :: \"'a::{real_normed_field}\"\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b) * (a - b) = a * a - 2 * a * b + b * b\" by (simp add: algebra_simps)\n  then show ?thesis by (metis mult_2 numeral_2_eq_2 power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_expansion_extended:\n  fixes a b :: \"'a::{real_normed_field}\"\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b) * (a - b) = a * a - 2 * a * b + b * b\" by (simp add: algebra_simps)\n  then show ?thesis by (metis mult_2 numeral_2_eq_2 power2_eq_square)\nqed", "origin": "square_expansion", "update_count": 0}, "product_even": {"skill_name": "product_even", "marker": "lemma product_even:\n  assumes \"even a\" \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k1 k2 where \"a = 2 * k1\" and \"b = 2 * k2\" using assms by blast\n  then have \"a * b = (2 * k1) * (2 * k2)\" by simp\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma product_even:\n  assumes \"even a\" \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k1 k2 where \"a = 2 * k1\" and \"b = 2 * k2\" using assms by blast\n  then have \"a * b = (2 * k1) * (2 * k2)\" by simp\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "non_negativity_of_squaresV7": {"skill_name": "non_negativity_of_squaresV7", "marker": "lemma non_negativity_of_squares:\n  fixes x y :: real\n  shows \"x^2 >= 0\" and \"y^2 >= 0\" and \"x^2 * y^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  then show \"x^2 >= 0\" \n    using mult_nonneg_nonneg[of x x] \n    by auto\n  have \"y^2 = y * y\" by sos\n  then show \"y^2 >= 0\" \n    using mult_nonneg_nonneg[of y y] \n    by auto\n  have \"x^2 * y^2 = (x * x) * (y * y)\" by sos\n  then show \"x^2 * y^2 >= 0\" \n    using mult_nonneg_nonneg[of \"x^2\" \"y^2\"] \n    by auto\nqed", "description": "-", "full_code": "lemma non_negativity_of_squares:\n  fixes x y :: real\n  shows \"x^2 >= 0\" and \"y^2 >= 0\" and \"x^2 * y^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  then show \"x^2 >= 0\" \n    using mult_nonneg_nonneg[of x x] \n    by auto\n  have \"y^2 = y * y\" by sos\n  then show \"y^2 >= 0\" \n    using mult_nonneg_nonneg[of y y] \n    by auto\n  have \"x^2 * y^2 = (x * x) * (y * y)\" by sos\n  then show \"x^2 * y^2 >= 0\" \n    using mult_nonneg_nonneg[of \"x^2\" \"y^2\"] \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "non_negativity_of_squaresV8": {"skill_name": "non_negativity_of_squaresV8", "marker": "lemma non_negativity_of_squares:\n  fixes x y :: real\n  shows \"x^2 >= 0\" and \"y^2 >= 0\" and \"x^2 * y^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  moreover have \"y^2 = y * y\" by sos\n  then have \"x^2 >= 0\" \n  proof (cases \"x = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x \\<noteq> 0\" by simp\n    then have \"x > 0 \\<or> x < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"x > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"x < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  moreover have \"y^2 >= 0\"\n  proof (cases \"y = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"y \\<noteq> 0\" by simp\n    then have \"y > 0 \\<or> y < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"y > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"y < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  ultimately show \"x^2 >= 0\" and \"y^2 >= 0\" by blast+\n  have \"x^2 * y^2 >= 0\"\n  proof (cases \"x^2 = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x^2 > 0\" by simp\n    then have \"y^2 = 0 \\<or> y^2 > 0\" by (cases \"y^2 = 0\") auto\n    thus ?thesis\n    proof\n      assume \"y^2 > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"y^2 = 0\"\n      then show ?thesis by simp\n    qed\n  qed\n  thus \"x^2 * y^2 >= 0\" by simp\nqed", "description": "-", "full_code": "lemma non_negativity_of_squares:\n  fixes x y :: real\n  shows \"x^2 >= 0\" and \"y^2 >= 0\" and \"x^2 * y^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  moreover have \"y^2 = y * y\" by sos\n  then have \"x^2 >= 0\" \n  proof (cases \"x = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x \\<noteq> 0\" by simp\n    then have \"x > 0 \\<or> x < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"x > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"x < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  moreover have \"y^2 >= 0\"\n  proof (cases \"y = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"y \\<noteq> 0\" by simp\n    then have \"y > 0 \\<or> y < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"y > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"y < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  ultimately show \"x^2 >= 0\" and \"y^2 >= 0\" by blast+\n  have \"x^2 * y^2 >= 0\"\n  proof (cases \"x^2 = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x^2 > 0\" by simp\n    then have \"y^2 = 0 \\<or> y^2 > 0\" by (cases \"y^2 = 0\") auto\n    thus ?thesis\n    proof\n      assume \"y^2 > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"y^2 = 0\"\n      then show ?thesis by simp\n    qed\n  qed\n  thus \"x^2 * y^2 >= 0\" by simp\nqed", "origin": "do_request", "update_count": 0}, "product_evenV2": {"skill_name": "product_evenV2", "marker": "lemma product_even:\n  assumes \"even a\" \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k1 k2 where \"a = 2 * k1\" \"b = 2 * k2\" \n    using assms by blast\n  then have \"a * b = (2 * k1) * (2 * k2)\" \n    by (simp)\n  also have \"... = 4 * (k1 * k2)\" \n    by (simp)\n  finally have \"a * b = 2 * (2 * (k1 * k2))\" \n    by auto\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma product_even:\n  assumes \"even a\" \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k1 k2 where \"a = 2 * k1\" \"b = 2 * k2\" \n    using assms by blast\n  then have \"a * b = (2 * k1) * (2 * k2)\" \n    by (simp)\n  also have \"... = 4 * (k1 * k2)\" \n    by (simp)\n  finally have \"a * b = 2 * (2 * (k1 * k2))\" \n    by auto\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "product_evenV3": {"skill_name": "product_evenV3", "marker": "lemma product_even:\n  assumes \"even a\" \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain m n where \"a = 2 * m\" and \"b = 2 * n\" \n    using assms by blast\n  have \"a * b = (2 * m) * (2 * n)\" by (metis `a = 2 * m` `b = 2 * n` mult.commute)\n  hence \"a * b = 4 * (m * n)\" by (simp add: mult.assoc)\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma product_even:\n  assumes \"even a\" \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain m n where \"a = 2 * m\" and \"b = 2 * n\" \n    using assms by blast\n  have \"a * b = (2 * m) * (2 * n)\" by (metis `a = 2 * m` `b = 2 * n` mult.commute)\n  hence \"a * b = 4 * (m * n)\" by (simp add: mult.assoc)\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_property": {"skill_name": "sqrt_property", "marker": "lemma sqrt_property:\n  fixes x :: real\n  assumes \"x = a^2\" and \"a >= 0\"\n  shows \"sqrt(x) = a\"\nproof -\n  have \"sqrt(x) = sqrt(a^2)\" using assms by simp\n  then show ?thesis using assms by (metis real_sqrt_unique zero_le_numeral)\nqed", "description": "-", "full_code": "lemma sqrt_property:\n  fixes x :: real\n  assumes \"x = a^2\" and \"a >= 0\"\n  shows \"sqrt(x) = a\"\nproof -\n  have \"sqrt(x) = sqrt(a^2)\" using assms by simp\n  then show ?thesis using assms by (metis real_sqrt_unique zero_le_numeral)\nqed", "origin": "sqrt_limit", "update_count": 0}, "mod_add": {"skill_name": "mod_add", "marker": "lemma mod_add:\n  fixes a b c d :: nat\n  assumes \"a mod b = c\" \"d mod b = e\"\n  shows \"(a + d) mod b = (c + e) mod b\"\nproof -\n  have \"a = c + b * (a div b)\" using assms(1) by auto\n  have \"d = e + b * (d div b)\" using assms(2) by auto\n  then have \"a + d = (c + b * (a div b)) + (e + b * (d div b))\" \n    by (metis \\<open>a = c + b * (a div b)\\<close>)\n  then have \"a + d = (c + e) + b * ((a div b) + (d div b))\" \n    by (simp add: algebra_simps)\n  then have \"(a + d) mod b = ((c + e) + b * ((a div b) + (d div b))) mod b\" \n    by presburger\n  also have \"... = (c + e) mod b\" \n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c d :: nat\n  assumes \"a mod b = c\" \"d mod b = e\"\n  shows \"(a + d) mod b = (c + e) mod b\"\nproof -\n  have \"a = c + b * (a div b)\" using assms(1) by auto\n  have \"d = e + b * (d div b)\" using assms(2) by auto\n  then have \"a + d = (c + b * (a div b)) + (e + b * (d div b))\" \n    by (metis \\<open>a = c + b * (a div b)\\<close>)\n  then have \"a + d = (c + e) + b * ((a div b) + (d div b))\" \n    by (simp add: algebra_simps)\n  then have \"(a + d) mod b = ((c + e) + b * ((a div b) + (d div b))) mod b\" \n    by presburger\n  also have \"... = (c + e) mod b\" \n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_expansionV4": {"skill_name": "square_expansionV4", "marker": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(-b)^2 = b^2\" by simp\n  have \"(-2 * a * b) = -2 * a * b\" by simp\n  have \"a^2 + (-2 * a * b) + b^2 = a^2 - 2 * a * b + b^2\" by simp\n  show ?thesis using power2_eq_square by (smt (verit) diff_add_eq power2_diff)\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(-b)^2 = b^2\" by simp\n  have \"(-2 * a * b) = -2 * a * b\" by simp\n  have \"a^2 + (-2 * a * b) + b^2 = a^2 - 2 * a * b + b^2\" by simp\n  show ?thesis using power2_eq_square by (smt (verit) diff_add_eq power2_diff)\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansionV5": {"skill_name": "square_expansionV5", "marker": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + (-b))^2\" by (simp)\n  also have \"... = a^2 + 2 * a * (-b) + (-b)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = a^2 - 2 * a * b + b^2\" by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + (-b))^2\" by (simp)\n  also have \"... = a^2 + 2 * a * (-b) + (-b)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = a^2 - 2 * a * b + b^2\" by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "sum_of_squares_nonnegativeV2": {"skill_name": "sum_of_squares_nonnegativeV2", "marker": "lemma sum_of_squares_nonnegative:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 \\<ge> 0\" and \"b^2 \\<ge> 0\" by (simp_all add: power2_eq_square)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_of_squares_nonnegative:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 \\<ge> 0\" and \"b^2 \\<ge> 0\" by (simp_all add: power2_eq_square)\n  then show ?thesis by auto\nqed", "origin": "square_expansion", "update_count": 0}, "mod_addV2": {"skill_name": "mod_addV2", "marker": "lemma mod_add:\n  fixes a b c d :: nat\n  assumes \"a mod b = c\" \"d mod b = e\"\n  shows \"(a + d) mod b = (c + e) mod b\"\nproof -\n  have \"a = c + b * (a div b)\" using assms(1) by auto\n  have \"d = e + b * (d div b)\" using assms(2) by auto\n  then have \"a + d = (c + b * (a div b)) + (e + b * (d div b))\" \n    by (metis \\<open>a = c + b * (a div b)\\<close>)\n  then have \"a + d = (c + e) + b * ((a div b) + (d div b))\" \n    by (simp add: algebra_simps)\n  then show \"(a + d) mod b = (c + e) mod b\" \n    by auto\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c d :: nat\n  assumes \"a mod b = c\" \"d mod b = e\"\n  shows \"(a + d) mod b = (c + e) mod b\"\nproof -\n  have \"a = c + b * (a div b)\" using assms(1) by auto\n  have \"d = e + b * (d div b)\" using assms(2) by auto\n  then have \"a + d = (c + b * (a div b)) + (e + b * (d div b))\" \n    by (metis \\<open>a = c + b * (a div b)\\<close>)\n  then have \"a + d = (c + e) + b * ((a div b) + (d div b))\" \n    by (simp add: algebra_simps)\n  then show \"(a + d) mod b = (c + e) mod b\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_addV3": {"skill_name": "mod_addV3", "marker": "lemma mod_add:\n  fixes a b c d :: nat\n  assumes \"a mod b = c\" \"d mod b = e\"\n  shows \"(a + d) mod b = (c + e) mod b\"\nproof -\n  obtain k1 where \"a = c + k1 * b\" using assms(1) by (metis mod_mult_div_eq mult.commute)\n  obtain k2 where \"d = e + k2 * b\" using assms(2) by (metis mod_eq_nat1E mod_less_eq_dividend mod_mod_trivial mult.commute)\n  have \"a + d = (c + k1 * b) + (e + k2 * b)\"\n    by (simp add: `a = c + k1 * b` `d = e + k2 * b`)\n  then have \"a + d = (c + e) + (k1 + k2) * b\"\n    by (simp add: algebra_simps)\n  then have \"(a + d) mod b = ((c + e) + (k1 + k2) * b) mod b\"\n    by simp\n  also have \"... = (c + e) mod b\"\n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c d :: nat\n  assumes \"a mod b = c\" \"d mod b = e\"\n  shows \"(a + d) mod b = (c + e) mod b\"\nproof -\n  obtain k1 where \"a = c + k1 * b\" using assms(1) by (metis mod_mult_div_eq mult.commute)\n  obtain k2 where \"d = e + k2 * b\" using assms(2) by (metis mod_eq_nat1E mod_less_eq_dividend mod_mod_trivial mult.commute)\n  have \"a + d = (c + k1 * b) + (e + k2 * b)\"\n    by (simp add: `a = c + k1 * b` `d = e + k2 * b`)\n  then have \"a + d = (c + e) + (k1 + k2) * b\"\n    by (simp add: algebra_simps)\n  then have \"(a + d) mod b = ((c + e) + (k1 + k2) * b) mod b\"\n    by simp\n  also have \"... = (c + e) mod b\"\n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_differenceV2": {"skill_name": "square_differenceV2", "marker": "lemma square_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof - \n  have \"(a - b)^2 = (a + (-b))^2\" by (simp add: algebra_simps)\n  then have \"... = a^2 + 2 * a * (-b) + (-b)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = a^2 - 2 * a * b + b^2\" by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof - \n  have \"(a - b)^2 = (a + (-b))^2\" by (simp add: algebra_simps)\n  then have \"... = a^2 + 2 * a * (-b) + (-b)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = a^2 - 2 * a * b + b^2\" by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansionV6": {"skill_name": "square_expansionV6", "marker": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(-b + a)^2 = (-b)^2 + 2*(-b)*a + a^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = b^2 - 2*a*b + a^2\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(-b + a)^2 = (-b)^2 + 2*(-b)*a + a^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = b^2 - 2*a*b + a^2\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "inequality_floorV3": {"skill_name": "inequality_floorV3", "marker": "lemma inequality_floor:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto \n  have \"r < n + 1\" using assms\n    by auto \n  thus ?thesis by (metis \\<open>real_of_int n \\<le> r\\<close> add.commute assms floor_add_int floor_less_cancel floor_one less_add_same_cancel2 less_numeral_extra(1))\nqed", "description": "-", "full_code": "lemma inequality_floor:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto \n  have \"r < n + 1\" using assms\n    by auto \n  thus ?thesis by (metis \\<open>real_of_int n \\<le> r\\<close> add.commute assms floor_add_int floor_less_cancel floor_one less_add_same_cancel2 less_numeral_extra(1))\nqed", "origin": "do_request", "update_count": 0}, "sqrt_propertiesV4": {"skill_name": "sqrt_propertiesV4", "marker": "lemma sqrt_properties:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x * y) = sqrt(x) * sqrt(y)\"\nproof -\n  have \"x * y \\<ge> 0\" \n    using assms by auto\n  then have \"sqrt(x * y) = sqrt(x) * sqrt(y)\"\n    using assms real_sqrt_mult by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_properties:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x * y) = sqrt(x) * sqrt(y)\"\nproof -\n  have \"x * y \\<ge> 0\" \n    using assms by auto\n  then have \"sqrt(x * y) = sqrt(x) * sqrt(y)\"\n    using assms real_sqrt_mult by auto\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "manipulate_equationV3": {"skill_name": "manipulate_equationV3", "marker": "lemma manipulate_equation:\n  fixes a b c d :: real\n  assumes \"a + c = b + d\"\n  shows \"a - b = d - c\"\nproof -\n  have \"a + c - b = d\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma manipulate_equation:\n  fixes a b c d :: real\n  assumes \"a + c = b + d\"\n  shows \"a - b = d - c\"\nproof -\n  have \"a + c - b = d\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "simplify_expressionV3": {"skill_name": "simplify_expressionV3", "marker": "lemma simplify_expression:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\n    unfolding power2_diff by auto\n  show ?thesis\n    using left_side by simp\nqed", "description": "-", "full_code": "lemma simplify_expression:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\n    unfolding power2_diff by auto\n  show ?thesis\n    using left_side by simp\nqed", "origin": "do_request", "update_count": 0}, "rearrangement_of_equationsV3": {"skill_name": "rearrangement_of_equationsV3", "marker": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  from assms have \"c = a + b\" by simp\n  have \"c - b = a + b - b\" by (simp add: `c = a + b`)\n  then have \"c - b = a\" by (simp)\n  thus \"a = c - b\" by simp\nqed", "description": "-", "full_code": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  from assms have \"c = a + b\" by simp\n  have \"c - b = a + b - b\" by (simp add: `c = a + b`)\n  then have \"c - b = a\" by (simp)\n  thus \"a = c - b\" by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_evolvedV11": {"skill_name": "mathd_algebra_109_evolvedV11", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\" and h2: \"c = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b + c = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b + 0 = 12\" using h1 h2 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b + 0 = 12\\<close>)\n  have \"2 * b = 0\" by (metis `12 + 2 * b = 12` add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\" and h2: \"c = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b + c = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b + 0 = 12\" using h1 h2 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b + 0 = 12\\<close>)\n  have \"2 * b = 0\" by (metis `12 + 2 * b = 12` add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_solutionV7": {"skill_name": "linear_equation_solutionV7", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"3 * 4 + 2 * b = 12\" using h1 by simp\n  then have \"12 + 2 * b = 12\" by simp\n  have \"2 * b = 0\" using `12 + 2 * b = 12` by (simp add: add_cancel_right_right)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"3 * 4 + 2 * b = 12\" using h1 by simp\n  then have \"12 + 2 * b = 12\" by simp\n  have \"2 * b = 0\" using `12 + 2 * b = 12` by (simp add: add_cancel_right_right)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sqrt_convergenceV2": {"skill_name": "sqrt_convergenceV2", "marker": "lemma sqrt_convergence:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x = 0 \\<longleftrightarrow> x = 0\"\nproof -\n  have \"sqrt x = 0 \\<Longrightarrow> x = 0\" \n  proof -\n    assume \"sqrt x = 0\"\n    then have \"x = (sqrt x)^2\" by auto\n    thus ?thesis using `sqrt x = 0` by (simp add: power2_eq_iff_nonneg)\n  qed\n  have \"x = 0 \\<Longrightarrow> sqrt x = 0\" \n  proof -\n    assume \"x = 0\"\n    thus ?thesis by simp\n  qed\n  show \"sqrt x = 0 \\<longleftrightarrow> x = 0\" \n    by (metis `x >= 0` `sqrt x = 0 \\<Longrightarrow> x = 0` `x = 0 \\<Longrightarrow> sqrt x = 0`)\nqed", "description": "-", "full_code": "lemma sqrt_convergence:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x = 0 \\<longleftrightarrow> x = 0\"\nproof -\n  have \"sqrt x = 0 \\<Longrightarrow> x = 0\" \n  proof -\n    assume \"sqrt x = 0\"\n    then have \"x = (sqrt x)^2\" by auto\n    thus ?thesis using `sqrt x = 0` by (simp add: power2_eq_iff_nonneg)\n  qed\n  have \"x = 0 \\<Longrightarrow> sqrt x = 0\" \n  proof -\n    assume \"x = 0\"\n    thus ?thesis by simp\n  qed\n  show \"sqrt x = 0 \\<longleftrightarrow> x = 0\" \n    by (metis `x >= 0` `sqrt x = 0 \\<Longrightarrow> x = 0` `x = 0 \\<Longrightarrow> sqrt x = 0`)\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_evolvedV12": {"skill_name": "mathd_algebra_109_evolvedV12", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"c = 3 * a + 2 * b\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"c = 3 * a + 2 * b\" using h0 by simp\n  have \"12 = 3 * 4 + 2 * b\" using h1 h2 eq by simp\n  have \"12 = 12 + 2 * b\" by (smt (verit) \\<open>12 = 3 * 4 + 2 * b\\<close>)\n  have \"2 * b = 0\" by (metis `12 = 12 + 2 * b` add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"c = 3 * a + 2 * b\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"c = 3 * a + 2 * b\" using h0 by simp\n  have \"12 = 3 * 4 + 2 * b\" using h1 h2 eq by simp\n  have \"12 = 12 + 2 * b\" by (smt (verit) \\<open>12 = 3 * 4 + 2 * b\\<close>)\n  have \"2 * b = 0\" by (metis `12 = 12 + 2 * b` add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolvedV13": {"skill_name": "mathd_algebra_109_evolvedV13", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" using h2 by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  have \"12 + 2 * b = 12\" using h2 by (metis \\<open>12 + 2 * b = c\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" using h2 by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  have \"12 + 2 * b = 12\" using h2 by (metis \\<open>12 + 2 * b = c\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "rearrangement_of_equationsV4": {"skill_name": "rearrangement_of_equationsV4", "marker": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b = a + b - b\" using assms by simp\n  have \"c - b = a + (b - b)\" by (metis add.commute add_cancel_right_right assms cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0 neg_equal_iff_equal)\n  have \"c - b = a + 0\" by (metis add.commute add_cancel_left_right add_scale_eq_noteq assms cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0)\n  thus \"a = c - b\" by simp\nqed", "description": "-", "full_code": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b = a + b - b\" using assms by simp\n  have \"c - b = a + (b - b)\" by (metis add.commute add_cancel_right_right assms cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0 neg_equal_iff_equal)\n  have \"c - b = a + 0\" by (metis add.commute add_cancel_left_right add_scale_eq_noteq assms cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0)\n  thus \"a = c - b\" by simp\nqed", "origin": "do_request", "update_count": 0}, "rearrangement_of_equationsV5": {"skill_name": "rearrangement_of_equationsV5", "marker": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  from assms have \"c - b = a + b - b\" by (simp add: field_simps)\n  then show \"a = c - b\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  from assms have \"c - b = a + b - b\" by (simp add: field_simps)\n  then show \"a = c - b\" by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "rearrangement_of_equationsV6": {"skill_name": "rearrangement_of_equationsV6", "marker": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b = (a + b) - b\" using assms by simp\n  then have \"c - b = a + (b - b)\" by (simp add: algebra_simps)\n  then show \"a = c - b\" by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma rearrangement_of_equations:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b = (a + b) - b\" using assms by simp\n  then have \"c - b = a + (b - b)\" by (simp add: algebra_simps)\n  then show \"a = c - b\" by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "mod_properties": {"skill_name": "mod_properties", "marker": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a = (a mod c) + c * (a div c)\" using assms by auto\n  have \"b = (b mod c) + c * (b div c)\" using assms by auto\n  then have \"a + b = ((a mod c) + c * (a div c)) + ((b mod c) + c * (b div c))\"\n    by (metis \\<open>a = (a mod c) + c * (a div c)\\<close>)\n  then have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + c * ((a div c) + (b div c))) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a = (a mod c) + c * (a div c)\" using assms by auto\n  have \"b = (b mod c) + c * (b div c)\" using assms by auto\n  then have \"a + b = ((a mod c) + c * (a div c)) + ((b mod c) + c * (b div c))\"\n    by (metis \\<open>a = (a mod c) + c * (a div c)\\<close>)\n  then have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + c * ((a div c) + (b div c))) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_propertiesV2": {"skill_name": "mod_propertiesV2", "marker": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a = (a mod c) + c * (a div c)\" using assms by (metis mod_mult_div_eq)\n  have \"b = (b mod c) + c * (b div c)\" using assms by (metis mod_mult_div_eq)\n  then have \"a + b = ((a mod c) + c * (a div c)) + ((b mod c) + c * (b div c))\" \n    by auto\n  then have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + c * ((a div c) + (b div c))) mod c\" \n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\" \n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a = (a mod c) + c * (a div c)\" using assms by (metis mod_mult_div_eq)\n  have \"b = (b mod c) + c * (b div c)\" using assms by (metis mod_mult_div_eq)\n  then have \"a + b = ((a mod c) + c * (a div c)) + ((b mod c) + c * (b div c))\" \n    by auto\n  then have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + c * ((a div c) + (b div c))) mod c\" \n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\" \n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV6": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV6", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have eq_rearranged: \"x + 7 = 3\" by (metis add.commute add_diff_cancel dbl_def dbl_inc_simps(3) dbl_simps(3) eq_simplified h0 mult_2)\n  have x_value: \"x = 3 - 7\" using eq_rearranged by (metis add.commute add_diff_cancel add_minus_cancel diff_add_eq eq_simplified group_cancel.add2 group_cancel.sub1 minus_add_cancel mult.commute mult_2_right numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have eq_rearranged: \"x + 7 = 3\" by (metis add.commute add_diff_cancel dbl_def dbl_inc_simps(3) dbl_simps(3) eq_simplified h0 mult_2)\n  have x_value: \"x = 3 - 7\" using eq_rearranged by (metis add.commute add_diff_cancel add_minus_cancel diff_add_eq eq_simplified group_cancel.add2 group_cancel.sub1 minus_add_cancel mult.commute mult_2_right numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebraic_manipulationV3": {"skill_name": "algebraic_manipulationV3", "marker": "lemma algebraic_manipulation:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a - b) * (a - b)\"\n    by (simp add: power2_eq_square)\n  also have \"... = a^2 - 2 * a * b + b^2\"\n  proof -\n    have \"a^2 - 2 * a * b + b^2 = a * a - a * b - b * a + b * b\"\n      by sos\n    thus ?thesis\n      by sos\n  qed\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a - b) * (a - b)\"\n    by (simp add: power2_eq_square)\n  also have \"... = a^2 - 2 * a * b + b^2\"\n  proof -\n    have \"a^2 - 2 * a * b + b^2 = a * a - a * b - b * a + b * b\"\n      by sos\n    thus ?thesis\n      by sos\n  qed\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "algebraic_manipulationV4": {"skill_name": "algebraic_manipulationV4", "marker": "lemma algebraic_manipulation:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a - b) * (a - b)\"\n    by (simp add: power2_eq_square)\n  also have \"... = a * a - a * b - b * a + b * b\"\n    by (simp add: algebra_simps)\n  also have \"... = a^2 - (a * b + b * a) + b^2\"\n    by sos\n  also have \"... = a^2 - 2 * a * b + b^2\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have left_side: \"(a - b)^2 = (a - b) * (a - b)\"\n    by (simp add: power2_eq_square)\n  also have \"... = a * a - a * b - b * a + b * b\"\n    by (simp add: algebra_simps)\n  also have \"... = a^2 - (a * b + b * a) + b^2\"\n    by sos\n  also have \"... = a^2 - 2 * a * b + b^2\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_propertiesV3": {"skill_name": "mod_propertiesV3", "marker": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a = (a mod c) + (a div c) * c\" using assms by (auto)\n  have \"b = (b mod c) + (b div c) * c\" using assms by (auto)\n  then have \"a + b = ((a mod c) + (a div c) * c) + ((b mod c) + (b div c) * c)\"\n    by (metis \\<open>a = (a mod c) + (a div c) * c\\<close>)\n  then have \"a + b = (a mod c) + (b mod c) + (a div c + b div c) * c\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + (a div c + b div c) * c) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a = (a mod c) + (a div c) * c\" using assms by (auto)\n  have \"b = (b mod c) + (b div c) * c\" using assms by (auto)\n  then have \"a + b = ((a mod c) + (a div c) * c) + ((b mod c) + (b div c) * c)\"\n    by (metis \\<open>a = (a mod c) + (a div c) * c\\<close>)\n  then have \"a + b = (a mod c) + (b mod c) + (a div c + b div c) * c\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + (a div c + b div c) * c) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_nvarlineareqV2": {"skill_name": "algebra_nvarlineareqV2", "marker": "theorem algebra_nvarlineareq:\n  fixes x :: \"complex list\" and e :: complex\n  assumes h0 : \"\\<forall>i < length x. x!i + e = 7\" \n    and h1 : \"\\<forall>i < length x. 2 * x!i + e = 3\"\n  shows \"\\<forall>i < length x. e = 11 \\<and> x!i = (-4)\"\nproof -\n  have e_expr: \"\\<forall>i < length x. e = 7 - x!i\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"\\<forall>i < length x. 2 * x!i + (7 - x!i) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"\\<forall>i < length x. x!i + 7 = 3\" using eq_substituted by simp\n  have x_value: \"\\<forall>i < length x. x!i = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"\\<forall>i < length x. x!i = -4\" by simp\n  have e_value: \"\\<forall>i < length x. e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"\\<forall>i < length x. e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_nvarlineareq:\n  fixes x :: \"complex list\" and e :: complex\n  assumes h0 : \"\\<forall>i < length x. x!i + e = 7\" \n    and h1 : \"\\<forall>i < length x. 2 * x!i + e = 3\"\n  shows \"\\<forall>i < length x. e = 11 \\<and> x!i = (-4)\"\nproof -\n  have e_expr: \"\\<forall>i < length x. e = 7 - x!i\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"\\<forall>i < length x. 2 * x!i + (7 - x!i) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"\\<forall>i < length x. x!i + 7 = 3\" using eq_substituted by simp\n  have x_value: \"\\<forall>i < length x. x!i = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"\\<forall>i < length x. x!i = -4\" by simp\n  have e_value: \"\\<forall>i < length x. e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"\\<forall>i < length x. e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "floor_sum_properties": {"skill_name": "floor_sum_properties", "marker": "lemma floor_sum_properties:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\"\nproof -\n  have \"floor a + floor b \\<le> floor (a + b)\" using floor_add[of a b] by simp\n  moreover have \"floor (a + b) < floor a + floor b + 1\" \n  proof -\n    have \"floor a + floor b + 1 > a + b\" \n      using assms by auto\n    thus ?thesis by (simp add: floor_le_iff)\n  qed\n  ultimately show ?thesis \n    by (simp add: le_less_trans)\nqed", "description": "-", "full_code": "lemma floor_sum_properties:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\"\nproof -\n  have \"floor a + floor b \\<le> floor (a + b)\" using floor_add[of a b] by simp\n  moreover have \"floor (a + b) < floor a + floor b + 1\" \n  proof -\n    have \"floor a + floor b + 1 > a + b\" \n      using assms by auto\n    thus ?thesis by (simp add: floor_le_iff)\n  qed\n  ultimately show ?thesis \n    by (simp add: le_less_trans)\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_propertiesV2": {"skill_name": "floor_sum_propertiesV2", "marker": "lemma floor_sum_properties:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\"\nproof -\n  have \"floor a + floor b \\<le> a + b\" \n    by auto\n  also have \"... < floor a + floor b + 1\" \n    using assms by auto\n  hence \"floor a + floor b < floor a + floor b + 1\" by simp\n  then have \"a + b < floor a + floor b + 1\" using `floor a + floor b \\<le> a + b` by auto\n  have \"floor (a + b) = floor a + floor b\" \n    by auto\n  hence \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\" \n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_sum_properties:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\"\nproof -\n  have \"floor a + floor b \\<le> a + b\" \n    by auto\n  also have \"... < floor a + floor b + 1\" \n    using assms by auto\n  hence \"floor a + floor b < floor a + floor b + 1\" by simp\n  then have \"a + b < floor a + floor b + 1\" using `floor a + floor b \\<le> a + b` by auto\n  have \"floor (a + b) = floor a + floor b\" \n    by auto\n  hence \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\" \n    by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_propertiesV3": {"skill_name": "floor_sum_propertiesV3", "marker": "lemma floor_sum_properties:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\"\nproof -\n  have \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\"\n  proof (cases \"a + b < floor a + floor b + 1\")\n    case True\n    then have \"floor (a + b) = floor a + floor b\" \n      using floor_add[of a b] assms by auto\n    thus ?thesis \n      by (simp add: True)\n  next\n    case False\n    hence \"a + b \\<ge> floor a + floor b + 1\" by simp\n    then have \"floor (a + b) = floor a + floor b\" \n      using floor_add[of a b] assms by auto\n    thus ?thesis \n      by (simp add: False)\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_sum_properties:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\"\nproof -\n  have \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\"\n  proof (cases \"a + b < floor a + floor b + 1\")\n    case True\n    then have \"floor (a + b) = floor a + floor b\" \n      using floor_add[of a b] assms by auto\n    thus ?thesis \n      by (simp add: True)\n  next\n    case False\n    hence \"a + b \\<ge> floor a + floor b + 1\" by simp\n    then have \"floor (a + b) = floor a + floor b\" \n      using floor_add[of a b] assms by auto\n    thus ?thesis \n      by (simp add: False)\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_111": {"skill_name": "mathd_algebra_111", "marker": "theorem mathd_algebra_111:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\" \"b = 0\"\n  shows \"c = 0\"\nproof -\n  have eq: \"3 * a + 2 * b + c = 12\" using h0 by simp\n  have \"3 * 4 + 2 * 0 + c = 12\" using h1 eq by simp\n  have \"12 + c = 12\" by (smt (verit) `3 * 4 + 2 * 0 + c = 12`)\n  hence \"c = 0\" by (metis add_cancel_right_right)\n  show ?thesis using `c = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_111:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\" \"b = 0\"\n  shows \"c = 0\"\nproof -\n  have eq: \"3 * a + 2 * b + c = 12\" using h0 by simp\n  have \"3 * 4 + 2 * 0 + c = 12\" using h1 eq by simp\n  have \"12 + c = 12\" by (smt (verit) `3 * 4 + 2 * 0 + c = 12`)\n  hence \"c = 0\" by (metis add_cancel_right_right)\n  show ?thesis using `c = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "average_value": {"skill_name": "average_value", "marker": "lemma average_value:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  using assms by simp", "description": "", "full_code": "lemma average_value:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  using assms by simp", "origin": "data/full_data/debug/valid_rand/aime_1991_p6.json_v19", "update_count": -1}, "floor_sum_propertiesV4": {"skill_name": "floor_sum_propertiesV4", "marker": "lemma floor_sum_properties:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\"\nproof -\n  have \"floor a + floor b \\<le> a + b\" \n    by auto\n  have \"a + b < floor a + floor b + 1\" \n    using assms by auto\n  have \"floor (a + b) = floor a + floor b\" \n    using floor_add assms by auto\n  have \"floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1) = \n        floor a + floor b + (if a + b < floor a + floor b + 1 then 0 else 1)\" \n    by auto\n  show ?thesis \n  proof (cases \"a + b < floor a + floor b + 1\")\n    case True\n    then have \"floor a + floor b = floor (a + b) + 0\" \n      by auto\n    thus ?thesis by simp\n  next\n    case False\n    then have \"floor a + floor b = floor (a + b) + 1\" \n      by auto\n    thus ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma floor_sum_properties:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1)\"\nproof -\n  have \"floor a + floor b \\<le> a + b\" \n    by auto\n  have \"a + b < floor a + floor b + 1\" \n    using assms by auto\n  have \"floor (a + b) = floor a + floor b\" \n    using floor_add assms by auto\n  have \"floor (a + b) + (if a + b < floor a + floor b + 1 then 0 else 1) = \n        floor a + floor b + (if a + b < floor a + floor b + 1 then 0 else 1)\" \n    by auto\n  show ?thesis \n  proof (cases \"a + b < floor a + floor b + 1\")\n    case True\n    then have \"floor a + floor b = floor (a + b) + 0\" \n      by auto\n    thus ?thesis by simp\n  next\n    case False\n    then have \"floor a + floor b = floor (a + b) + 1\" \n      by auto\n    thus ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "floor_relationship": {"skill_name": "floor_relationship", "marker": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  have \"r < n + 1\" using assms\n  proof -\n    have \"n \\<le> r\" using assms by auto\n    have \"r < floor r + 1\" using assms by auto\n    thus \"r < n + 1\" by (simp add: assms)\n  qed\n  thus ?thesis by (simp add: `n \\<le> r` `r < n + 1`)\nqed", "description": "-", "full_code": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  have \"r < n + 1\" using assms\n  proof -\n    have \"n \\<le> r\" using assms by auto\n    have \"r < floor r + 1\" using assms by auto\n    thus \"r < n + 1\" by (simp add: assms)\n  qed\n  thus ?thesis by (simp add: `n \\<le> r` `r < n + 1`)\nqed", "origin": "do_request", "update_count": 0}, "floor_relationshipV2": {"skill_name": "floor_relationshipV2", "marker": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  have \"r < n + 1\" using assms\n    by auto\n  thus ?thesis by (simp add: `n \\<le> r` `r < n + 1`)\nqed", "description": "-", "full_code": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  have \"r < n + 1\" using assms\n    by auto\n  thus ?thesis by (simp add: `n \\<le> r` `r < n + 1`)\nqed", "origin": "do_request", "update_count": 0}, "rearrangement_inequality": {"skill_name": "rearrangement_inequality", "marker": "lemma rearrangement_inequality:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma rearrangement_inequality:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiplicationV2": {"skill_name": "cross_multiplicationV2", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> c\" \"a * b = d * c\"\n  shows \"a * (b - c) = d * (b - c) \\<Longrightarrow> a = d\"\nproof -\n  assume \"a * (b - c) = d * (b - c)\"\n  then have \"b - c \\<noteq> 0\" using assms(1) by auto\n  thus ?thesis by (metis \\<open>a * (b - c) = d * (b - c)\\<close> mult_cancel_right)\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> c\" \"a * b = d * c\"\n  shows \"a * (b - c) = d * (b - c) \\<Longrightarrow> a = d\"\nproof -\n  assume \"a * (b - c) = d * (b - c)\"\n  then have \"b - c \\<noteq> 0\" using assms(1) by auto\n  thus ?thesis by (metis \\<open>a * (b - c) = d * (b - c)\\<close> mult_cancel_right)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiplicationV3": {"skill_name": "cross_multiplicationV3", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\" and \"a - c \\<noteq> 0\"\n  shows \"(a - c) * b * d = (b * d) * (a - c)\"\n  using assms by simp", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\" and \"a - c \\<noteq> 0\"\n  shows \"(a - c) * b * d = (b * d) * (a - c)\"\n  using assms by simp", "origin": "amc12a_2013_p8", "update_count": 0}, "sqrt_limit_extendedV3": {"skill_name": "sqrt_limit_extendedV3", "marker": "lemma sqrt_limit_extended:\n  fixes x y :: real\n  assumes \"y = sqrt(x + y)\" \"y > 0\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms(1) by (metis assms(2) less_eq_real_def real_sqrt_eq_iff real_sqrt_unique)\n  then have \"x = y^2 - y\" by (simp add: add_diff_cancel)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_limit_extended:\n  fixes x y :: real\n  assumes \"y = sqrt(x + y)\" \"y > 0\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms(1) by (metis assms(2) less_eq_real_def real_sqrt_eq_iff real_sqrt_unique)\n  then have \"x = y^2 - y\" by (simp add: add_diff_cancel)\n  thus ?thesis by auto\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_and_square": {"skill_name": "sqrt_and_square", "marker": "lemma sqrt_and_square:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt(x^2) = x\"\nproof -\n  have \"x^2 >= 0\" by (simp add: assms)\n  then show ?thesis by (metis assms real_sqrt_unique)\nqed", "description": "-", "full_code": "lemma sqrt_and_square:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt(x^2) = x\"\nproof -\n  have \"x^2 >= 0\" by (simp add: assms)\n  then show ?thesis by (metis assms real_sqrt_unique)\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_limit_extendedV4": {"skill_name": "sqrt_limit_extendedV4", "marker": "lemma sqrt_limit_extended:\n  fixes y :: real\n  assumes \"sqrt(y) = 9\"\n  shows \"y = 81\"\nproof -\n  have \"9^2 = y\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_limit_extended:\n  fixes y :: real\n  assumes \"sqrt(y) = 9\"\n  shows \"y = 81\"\nproof -\n  have \"9^2 = y\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus ?thesis by auto\nqed", "origin": "sqrt_limit", "update_count": 0}, "floor_relationshipV3": {"skill_name": "floor_relationshipV3", "marker": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms by auto\n  moreover have \"r < n + 1\"\n  proof -\n    have \"r < floor r + 1\" using assms by auto\n    thus ?thesis by (simp add: assms)\n  qed\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms by auto\n  moreover have \"r < n + 1\"\n  proof -\n    have \"r < floor r + 1\" using assms by auto\n    thus ?thesis by (simp add: assms)\n  qed\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_relationshipV4": {"skill_name": "floor_relationshipV4", "marker": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  moreover have \"r < n + 1\"\n  proof -\n    have \"n \\<le> r\" using assms by auto\n    then have \"r < n + 1\" using assms by auto\n    thus ?thesis by auto\n  qed\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  moreover have \"r < n + 1\"\n  proof -\n    have \"n \\<le> r\" using assms by auto\n    then have \"r < n + 1\" using assms by auto\n    thus ?thesis by auto\n  qed\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_generalizedV9": {"skill_name": "mathd_algebra_109_generalizedV9", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = c\" \n      and h1: \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  have \"12 + 2 * b = c\" by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  hence \"2 * b = c - 12\" by (simp add: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = c\" \n      and h1: \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  have \"12 + 2 * b = c\" by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  hence \"2 * b = c - 12\" by (simp add: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "non_negative_property": {"skill_name": "non_negative_property", "marker": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 \\<ge> 0\" and \"b^2 \\<ge> 0\" by (simp_all add: power2_eq_square) \n  then show ?thesis by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 \\<ge> 0\" and \"b^2 \\<ge> 0\" by (simp_all add: power2_eq_square) \n  then show ?thesis by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "average_value_with_sum": {"skill_name": "average_value_with_sum", "marker": "lemma average_value_with_sum:\n  fixes f :: \"nat \\<Rightarrow> real\" and n :: nat\n  assumes \"n > 0\"\n  shows \"(\\<Sum>k=0..n-1. f k) / real n = (\\<Sum>k = 0..n-1. f k) / (real_of_nat n)\"\nproof -\n  have \"(\\<Sum>k = 0..n-1. f k) / real n = (\\<Sum>k = 0..n-1. f k) / (real_of_nat n)\"\n    using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma average_value_with_sum:\n  fixes f :: \"nat \\<Rightarrow> real\" and n :: nat\n  assumes \"n > 0\"\n  shows \"(\\<Sum>k=0..n-1. f k) / real n = (\\<Sum>k = 0..n-1. f k) / (real_of_nat n)\"\nproof -\n  have \"(\\<Sum>k = 0..n-1. f k) / real n = (\\<Sum>k = 0..n-1. f k) / (real_of_nat n)\"\n    using assms by auto\n  thus ?thesis by simp\nqed", "origin": "average_value", "update_count": 0}, "average_of_sum": {"skill_name": "average_of_sum", "marker": "lemma average_of_sum:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / (real_of_nat count) = (1 / real_of_nat count) * total\"\nproof -\n  have \"total / (real_of_nat count) = (1 / real_of_nat count) * total\" by (simp add: field_simps)\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma average_of_sum:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / (real_of_nat count) = (1 / real_of_nat count) * total\"\nproof -\n  have \"total / (real_of_nat count) = (1 / real_of_nat count) * total\" by (simp add: field_simps)\n  thus ?thesis .\nqed", "origin": "average_value", "update_count": 0}, "square_of_fraction": {"skill_name": "square_of_fraction", "marker": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" by (simp add: divide_inverse)\n  also have \"... = a^2 * (1 / b)^2\" by (auto simp: field_simps)\n  also have \"... = a^2 / (b^2)\" by (simp add: power2_eq_square)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" by (simp add: divide_inverse)\n  also have \"... = a^2 * (1 / b)^2\" by (auto simp: field_simps)\n  also have \"... = a^2 / (b^2)\" by (simp add: power2_eq_square)\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "square_of_fractionV2": {"skill_name": "square_of_fractionV2", "marker": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" by (simp add: power2_eq_square)\n  also have \"... = a^2 * (1 / b)^2\" by (simp add: power2_eq_square)\n  also have \"... = a^2 / (b * b)\" by sos\n  also have \"... = a^2 / b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" by (simp add: power2_eq_square)\n  also have \"... = a^2 * (1 / b)^2\" by (simp add: power2_eq_square)\n  also have \"... = a^2 / (b * b)\" by sos\n  also have \"... = a^2 / b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_of_fractionV3": {"skill_name": "square_of_fractionV3", "marker": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a / b) * (a / b)\" by sos\n  also have \"... = a * a / (b * b)\" by (simp add: divide_simps)\n  also have \"... = a^2 / b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a / b) * (a / b)\" by sos\n  also have \"... = a * a / (b * b)\" by (simp add: divide_simps)\n  also have \"... = a^2 / b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_difference": {"skill_name": "sqrt_difference", "marker": "lemma sqrt_difference:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt a - sqrt b = (a - b) / (sqrt a + sqrt b)\"\nproof -\n  have \"sqrt a - sqrt b = (sqrt a + sqrt b) * (sqrt a - sqrt b) / (sqrt a + sqrt b)\"\n    by (metis add.left_cancel add_cancel_right_right add_le_same_cancel2 assms(1) assms(2) cancel_comm_monoid_add_class.diff_cancel dual_order.eq_iff eq_divide_eq mult.commute nonzero_mult_div_cancel_right real_sqrt_eq_zero_cancel_iff real_sqrt_ge_0_iff real_sqrt_le_0_iff real_sqrt_zero)\n  also have \"... = (a - b) / (sqrt a + sqrt b)\"\n    by (smt (verit) assms(1) assms(2) divide_cancel_right real_sqrt_le_mono real_sqrt_less_mono real_sqrt_mult_self square_diff_square_factored)\n  finally show ?thesis\n    by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma sqrt_difference:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt a - sqrt b = (a - b) / (sqrt a + sqrt b)\"\nproof -\n  have \"sqrt a - sqrt b = (sqrt a + sqrt b) * (sqrt a - sqrt b) / (sqrt a + sqrt b)\"\n    by (metis add.left_cancel add_cancel_right_right add_le_same_cancel2 assms(1) assms(2) cancel_comm_monoid_add_class.diff_cancel dual_order.eq_iff eq_divide_eq mult.commute nonzero_mult_div_cancel_right real_sqrt_eq_zero_cancel_iff real_sqrt_ge_0_iff real_sqrt_le_0_iff real_sqrt_zero)\n  also have \"... = (a - b) / (sqrt a + sqrt b)\"\n    by (smt (verit) assms(1) assms(2) divide_cancel_right real_sqrt_le_mono real_sqrt_less_mono real_sqrt_mult_self square_diff_square_factored)\n  finally show ?thesis\n    by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "average_value_extended": {"skill_name": "average_value_extended", "marker": "lemma average_value_extended:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  and \"total / real count > 0 \\<longleftrightarrow> total > 0\"\nproof -\n  have \"total / real count = (total / (real_of_nat count))\" using assms by simp\n  moreover have \"total / real count > 0 \\<longleftrightarrow> total > 0\"\n    using assms by (auto simp: field_simps)\n  ultimately show \"total / real count = (total / (real_of_nat count))\" \n    and \"total / real count > 0 \\<longleftrightarrow> total > 0\" by auto\nqed", "description": "-", "full_code": "lemma average_value_extended:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  and \"total / real count > 0 \\<longleftrightarrow> total > 0\"\nproof -\n  have \"total / real count = (total / (real_of_nat count))\" using assms by simp\n  moreover have \"total / real count > 0 \\<longleftrightarrow> total > 0\"\n    using assms by (auto simp: field_simps)\n  ultimately show \"total / real count = (total / (real_of_nat count))\" \n    and \"total / real count > 0 \\<longleftrightarrow> total > 0\" by auto\nqed", "origin": "average_value", "update_count": 0}, "sqrt_combined_limit": {"skill_name": "sqrt_combined_limit", "marker": "lemma sqrt_combined_limit:\n  fixes x y :: real\n  assumes \"9 = sqrt(x + y)\" and \"x = 72\"\n  shows \"y = 9\"\nproof -\n  from assms(1) have \"x + y = 81\" by (metis sqrt_sum_limit)\n  with assms(2) show \"y = 9\" by auto\nqed", "description": "-", "full_code": "lemma sqrt_sum_limit:\n  fixes x y :: real\n  assumes \"9 = sqrt(x + y)\"\n  shows \"x + y = 81\"\nproof -\n  have \"9^2 = x + y\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then show ?thesis by simp\nqed\n\nlemma sqrt_combined_limit:\n  fixes x y :: real\n  assumes \"9 = sqrt(x + y)\" and \"x = 72\"\n  shows \"y = 9\"\nproof -\n  from assms(1) have \"x + y = 81\" by (metis sqrt_sum_limit)\n  with assms(2) show \"y = 9\" by auto\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_sum_squares": {"skill_name": "sqrt_sum_squares", "marker": "fun sqrt_sum_squares :: \"real list \\<Rightarrow> real\" where\n  \"sqrt_sum_squares [] = 0\" |\n  \"sqrt_sum_squares (x # xs) = sqrt(x^2 + sqrt_sum_squares xs^2)\"", "description": "-", "full_code": "fun sqrt_sum_squares :: \"real list \\<Rightarrow> real\" where\n  \"sqrt_sum_squares [] = 0\" |\n  \"sqrt_sum_squares (x # xs) = sqrt(x^2 + sqrt_sum_squares xs^2)\"", "origin": "sqrt_limit", "update_count": 0}, "square_of_fractionV4": {"skill_name": "square_of_fractionV4", "marker": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" by (simp add: field_simps)\n  also have \"... = a^2 * (1 / b)^2\" by (simp add: power2_eq_square)\n  also have \"... = a^2 / b^2\" by (simp add: power2_eq_square assms)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" by (simp add: field_simps)\n  also have \"... = a^2 * (1 / b)^2\" by (simp add: power2_eq_square)\n  also have \"... = a^2 / b^2\" by (simp add: power2_eq_square assms)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_expansion_extendedV2": {"skill_name": "square_expansion_extendedV2", "marker": "lemma square_expansion_extended:\n  fixes a b c :: real\n  shows \"(a - b)^2 + c^2 = a^2 - 2*a*b + b^2 + c^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by sos\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion_extended:\n  fixes a b c :: real\n  shows \"(a - b)^2 + c^2 = a^2 - 2*a*b + b^2 + c^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by sos\n  then show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_coefficients": {"skill_name": "square_expansion_with_coefficients", "marker": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(c * a - d * b)^2 = c^2 * a^2 - 2 * c * d * a * b + d^2 * b^2\"\nproof -\n  have \"(c * a - d * b)^2 = (c * a)^2 - 2 * (c * a) * (d * b) + (d * b)^2\" by sos\n  also have \"... = c^2 * a^2 - 2 * c * d * a * b + d^2 * b^2\" by (simp add: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(c * a - d * b)^2 = c^2 * a^2 - 2 * c * d * a * b + d^2 * b^2\"\nproof -\n  have \"(c * a - d * b)^2 = (c * a)^2 - 2 * (c * a) * (d * b) + (d * b)^2\" by sos\n  also have \"... = c^2 * a^2 - 2 * c * d * a * b + d^2 * b^2\" by (simp add: field_simps)\n  finally show ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_generalized": {"skill_name": "square_expansion_generalized", "marker": "lemma square_expansion_generalized:\n  fixes a b c d :: real\n  shows \"(a - b + c - d)^2 = a^2 - 2*a*b + b^2 + c^2 - 2*c*d + d^2 + 2*(a - b)*(c - d)\"\nproof -\n  have \"(a - b + c - d)^2 = (a - b)^2 + (c - d)^2 + 2*(a - b)*(c - d)\"\n    by sos\n  also have \"... = (a^2 - 2*a*b + b^2) + (c^2 - 2*c*d + d^2) + 2*(a - b)*(c - d)\"\n    by sos\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion_generalized:\n  fixes a b c d :: real\n  shows \"(a - b + c - d)^2 = a^2 - 2*a*b + b^2 + c^2 - 2*c*d + d^2 + 2*(a - b)*(c - d)\"\nproof -\n  have \"(a - b + c - d)^2 = (a - b)^2 + (c - d)^2 + 2*(a - b)*(c - d)\"\n    by sos\n  also have \"... = (a^2 - 2*a*b + b^2) + (c^2 - 2*c*d + d^2) + 2*(a - b)*(c - d)\"\n    by sos\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "mathd_algebra_system": {"skill_name": "mathd_algebra_system", "marker": "theorem mathd_algebra_system:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 2 * b + 5\"\n  shows \"b = 0 \\<and> c = 5\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  hence \"b = 0\" by simp\n  from this have \"c = 2 * 0 + 5\" using h2 by simp\n  thus ?thesis by (metis \\<open>2 * b = 0\\<close> \\<open>b = 0\\<close> add.group_left_neutral dbl_inc_simps(5) dbl_simps(3) h2)\nqed", "description": "-", "full_code": "theorem mathd_algebra_system:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 2 * b + 5\"\n  shows \"b = 0 \\<and> c = 5\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  hence \"b = 0\" by simp\n  from this have \"c = 2 * 0 + 5\" using h2 by simp\n  thus ?thesis by (metis \\<open>2 * b = 0\\<close> \\<open>b = 0\\<close> add.group_left_neutral dbl_inc_simps(5) dbl_simps(3) h2)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_421_extended": {"skill_name": "mathd_algebra_421_extended", "marker": "theorem mathd_algebra_421_extended:\n  fixes a b c d :: real\n  assumes h0 : \"b = a^2 + 4 * a + 6\"\n    and h1 : \"b = 1 / 2 * a^2 + a + 6\"\n    and h2 : \"d = c^2 + 4 * c + 6\"\n    and h3 : \"d = 1 / 2 * c^2 + c + 6\"\n    and h4 : \"a < c\"\n  shows \"c - a = 6\"\nproof -\n  have \"a^2 + 4 * a + 6 = 1 / 2 * a^2 + a + 6\" using h0 h1 by simp\n  hence \"a^2 + 4 * a = 1 / 2 * a^2 + a\" by auto\n  thus \"c - a = 6\" using h2 h3 h4\n    by sos\nqed", "description": "-", "full_code": "theorem mathd_algebra_421_extended:\n  fixes a b c d :: real\n  assumes h0 : \"b = a^2 + 4 * a + 6\"\n    and h1 : \"b = 1 / 2 * a^2 + a + 6\"\n    and h2 : \"d = c^2 + 4 * c + 6\"\n    and h3 : \"d = 1 / 2 * c^2 + c + 6\"\n    and h4 : \"a < c\"\n  shows \"c - a = 6\"\nproof -\n  have \"a^2 + 4 * a + 6 = 1 / 2 * a^2 + a + 6\" using h0 h1 by simp\n  hence \"a^2 + 4 * a = 1 / 2 * a^2 + a\" by auto\n  thus \"c - a = 6\" using h2 h3 h4\n    by sos\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV7": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV7", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e y :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"y + e = 10\"  \n  shows \"e = 11 \\<and> x = -4 \\<and> y = -1\"  \nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  have y_value: \"y = 10 - e\" using h2 by (auto simp: field_simps)\n  then have y_value_final: \"y = 10 - 11\" using e_value_final by simp\n  then show ?thesis using x_value_final e_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e y :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"y + e = 10\"  \n  shows \"e = 11 \\<and> x = -4 \\<and> y = -1\"  \nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  have y_value: \"y = 10 - e\" using h2 by (auto simp: field_simps)\n  then have y_value_final: \"y = 10 - 11\" using e_value_final by simp\n  then show ?thesis using x_value_final e_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "find_max_n": {"skill_name": "find_max_n", "marker": "lemma find_max_n:\n  fixes n :: nat\n  assumes \"n = 7\" \"m = 35\"\n  shows \"n * 5 = m\"\nproof -\n  have \"n * 5 = 7 * 5\" using assms(1) by simp\n  also have \"... = 35\" by simp\n  finally show \"n * 5 = m\" using assms(2) by simp\nqed", "description": "-", "full_code": "lemma find_max_n:\n  fixes n :: nat\n  assumes \"n = 7\" \"m = 35\"\n  shows \"n * 5 = m\"\nproof -\n  have \"n * 5 = 7 * 5\" using assms(1) by simp\n  also have \"... = 35\" by simp\n  finally show \"n * 5 = m\" using assms(2) by simp\nqed", "origin": "do_request", "update_count": 0}, "sum_floor_terms_count": {"skill_name": "sum_floor_terms_count", "marker": "lemma sum_floor_terms_count:\n  shows \"card {19::nat..<92} = 73\"\nproof -\n  have \"card {19::nat..<92} = 92 - 19\" \n    by auto\n  also have \"... = 73\" \n    by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_floor_terms_count:\n  shows \"card {19::nat..<92} = 73\"\nproof -\n  have \"card {19::nat..<92} = 92 - 19\" \n    by auto\n  also have \"... = 73\" \n    by simp\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_and_sqrt": {"skill_name": "square_and_sqrt", "marker": "lemma square_and_sqrt:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt(x^2) = x\"\nproof -\n  have \"sqrt(x^2) = sqrt(x * x)\" by simp\n  then show ?thesis using assms by (metis real_sqrt_eq_iff real_sqrt_unique)\nqed", "description": "-", "full_code": "lemma square_and_sqrt:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt(x^2) = x\"\nproof -\n  have \"sqrt(x^2) = sqrt(x * x)\" by simp\n  then show ?thesis using assms by (metis real_sqrt_eq_iff real_sqrt_unique)\nqed", "origin": "sqrt_limit", "update_count": 0}, "division_by_nat": {"skill_name": "division_by_nat", "marker": "lemma division_by_nat:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = total / (real_of_nat count)\"\nproof -\n  have \"real count = real_of_nat count\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma division_by_nat:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = total / (real_of_nat count)\"\nproof -\n  have \"real count = real_of_nat count\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "average_value", "update_count": 0}, "algebra_2varlinear_eqs": {"skill_name": "algebra_2varlinear_eqs", "marker": "theorem algebra_2varlinear_eqs:\n  fixes x y :: complex\n  assumes h0 : \"x + y = 7\"\n    and h1 : \"2 * x + y = 3\"\n  shows \"y = 11 \\<and> x = -4\"\nproof -\n  have y_expr: \"y = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using y_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have y_value: \"y = 7 - (-4)\" using y_expr x_value_final by simp\n  have y_value_final: \"y = 7 + 4\" using y_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlinear_eqs:\n  fixes x y :: complex\n  assumes h0 : \"x + y = 7\"\n    and h1 : \"2 * x + y = 3\"\n  shows \"y = 11 \\<and> x = -4\"\nproof -\n  have y_expr: \"y = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using y_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have y_value: \"y = 7 - (-4)\" using y_expr x_value_final by simp\n  have y_value_final: \"y = 7 + 4\" using y_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV9": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolvedV9", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  let ?e = \"7 - x\"\n  have e_expr: \"e = ?e\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + ?e = 3\" using h1 by (metis e_expr)\n  have eq_simplified: \"2 * x + (7 - x) = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" by (smt (verit) h0 h1 left_add_twice)\n  then have x_value: \"x = 3 - 7\" by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by (simp add: e_value)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  let ?e = \"7 - x\"\n  have e_expr: \"e = ?e\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + ?e = 3\" using h1 by (metis e_expr)\n  have eq_simplified: \"2 * x + (7 - x) = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" by (smt (verit) h0 h1 left_add_twice)\n  then have x_value: \"x = 3 - 7\" by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by (simp add: e_value)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "average_value_nat": {"skill_name": "average_value_nat", "marker": "lemma average_value_nat:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = total / (real_of_nat count)\"\nproof -\n  have \"real count = real_of_nat count\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma average_value_nat:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = total / (real_of_nat count)\"\nproof -\n  have \"real count = real_of_nat count\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "average_value", "update_count": 0}, "average_value_sum": {"skill_name": "average_value_sum", "marker": "lemma average_value_sum:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" and \"total = sum f {0..count-1}\"\n  shows \"total / real count = (sum f {0..count-1}) / (real_of_nat count)\"\n  using assms by simp", "description": "-", "full_code": "lemma average_value_sum:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" and \"total = sum f {0..count-1}\"\n  shows \"total / real count = (sum f {0..count-1}) / (real_of_nat count)\"\n  using assms by simp", "origin": "average_value", "update_count": 0}, "division_by_natV2": {"skill_name": "division_by_natV2", "marker": "lemma division_by_nat:\n  fixes x :: real and n :: nat\n  assumes \"n > 0\"\n  shows \"x / real n = x / (real_of_nat n)\"\n  using assms by simp", "description": "-", "full_code": "lemma division_by_nat:\n  fixes x :: real and n :: nat\n  assumes \"n > 0\"\n  shows \"x / real n = x / (real_of_nat n)\"\n  using assms by simp", "origin": "average_value", "update_count": 0}, "sqrt_limit_generalV4": {"skill_name": "sqrt_limit_generalV4", "marker": "lemma sqrt_limit_general:\n  fixes x :: real\n  assumes \"c = sqrt(x + a)\" \"a > 0\" \"c > 0\"\n  shows \"x = c^2 - a\"\nproof -\n  have \"c^2 = x + a\" using assms(1) by (smt (verit) assms(3) less_eq_real_def real_sqrt_le_iff real_sqrt_pow2_iff real_sqrt_zero)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_limit_general:\n  fixes x :: real\n  assumes \"c = sqrt(x + a)\" \"a > 0\" \"c > 0\"\n  shows \"x = c^2 - a\"\nproof -\n  have \"c^2 = x + a\" using assms(1) by (smt (verit) assms(3) less_eq_real_def real_sqrt_le_iff real_sqrt_pow2_iff real_sqrt_zero)\n  thus ?thesis by simp\nqed", "origin": "sqrt_limit", "update_count": 0}, "lcm_properties": {"skill_name": "lcm_properties", "marker": "lemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\" \n    by (simp add: lcm_gcd)\n  then have \"lcm a b = (a * b) div gcd a b\"\n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\" \n    by (simp add: lcm_gcd)\n  then have \"lcm a b = (a * b) div gcd a b\"\n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "lcm_propertiesV2": {"skill_name": "lcm_propertiesV2", "marker": "lemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b = (a * b) div (gcd a b)\"\n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b = (a * b) div (gcd a b)\"\n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "lcm_propertiesV3": {"skill_name": "lcm_propertiesV3", "marker": "lemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\" by (simp add: lcm_gcd)\n  then show \"lcm a b = (a * b) div gcd a b\" by (metis lcm_nat_def)\nqed", "description": "-", "full_code": "lemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\" by (simp add: lcm_gcd)\n  then show \"lcm a b = (a * b) div gcd a b\" by (metis lcm_nat_def)\nqed", "origin": "do_request", "update_count": 0}, "linear_congruenceV3": {"skill_name": "linear_congruenceV3", "marker": "lemma linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  have b_less_m: \"b < m\" using assms(2) by (metis assms(1) mod_less_divisor)\n  let ?k = \"a div m\"  \n  have \"a = ?k * m + (a mod m)\" by auto\n  then show \"\\<exists>k. a = k * m + b\" \n    using b_less_m by (metis assms(2) mult.commute mult_div_mod_eq)\nqed", "description": "-", "full_code": "lemma linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  have b_less_m: \"b < m\" using assms(2) by (metis assms(1) mod_less_divisor)\n  let ?k = \"a div m\"  \n  have \"a = ?k * m + (a mod m)\" by auto\n  then show \"\\<exists>k. a = k * m + b\" \n    using b_less_m by (metis assms(2) mult.commute mult_div_mod_eq)\nqed", "origin": "do_request", "update_count": 0}, "linear_congruenceV4": {"skill_name": "linear_congruenceV4", "marker": "lemma linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by auto\n  then have \"a = ?k * m + b\" using assms(2) by simp\n  then show \"\\<exists>k. a = k * m + b\" by (rule exI[of _ ?k])\nqed", "description": "-", "full_code": "lemma linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by auto\n  then have \"a = ?k * m + b\" using assms(2) by simp\n  then show \"\\<exists>k. a = k * m + b\" by (rule exI[of _ ?k])\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_generalizedV10": {"skill_name": "mathd_algebra_109_generalizedV10", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0: \"3*a + 2*b = c\"\n  shows \"b = (c - 3*a) / 2\"\nproof -\n  have \"b = (c - 3*a) / 2\" using h0 by (simp add: algebra_simps)\n  show ?thesis by (metis \\<open>b = (c - 3 * a) / 2\\<close>)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0: \"3*a + 2*b = c\"\n  shows \"b = (c - 3*a) / 2\"\nproof -\n  have \"b = (c - 3*a) / 2\" using h0 by (simp add: algebra_simps)\n  show ?thesis by (metis \\<open>b = (c - 3 * a) / 2\\<close>)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_extendedV10": {"skill_name": "mathd_algebra_109_extendedV10", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  hence \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (metis add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  hence \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (metis add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "average_non_negative": {"skill_name": "average_non_negative", "marker": "lemma average_non_negative:\n  fixes f :: \"nat \\<Rightarrow> real\" and n :: nat\n  assumes \"n > 0\"\n  shows \"(\\<Sum>k \\<in> {0..n-1}. f k) / real n = (1 / real n) * (\\<Sum>k \\<in> {0..n-1}. f k)\"\nproof -\n  have \"(\\<Sum>k \\<in> {0..n-1}. f k) / real n = 1 / real n * (\\<Sum>k \\<in> {0..n-1}. f k)\" by (simp)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma average_non_negative:\n  fixes f :: \"nat \\<Rightarrow> real\" and n :: nat\n  assumes \"n > 0\"\n  shows \"(\\<Sum>k \\<in> {0..n-1}. f k) / real n = (1 / real n) * (\\<Sum>k \\<in> {0..n-1}. f k)\"\nproof -\n  have \"(\\<Sum>k \\<in> {0..n-1}. f k) / real n = 1 / real n * (\\<Sum>k \\<in> {0..n-1}. f k)\" by (simp)\n  thus ?thesis by simp\nqed", "origin": "average_value", "update_count": 0}, "real_division": {"skill_name": "real_division", "marker": "lemma real_division:\n  fixes a :: real and n :: nat\n  assumes \"n > 0\"\n  shows \"a / real_of_nat n = a / (real n)\"\n  using assms by simp", "description": "-", "full_code": "lemma real_division:\n  fixes a :: real and n :: nat\n  assumes \"n > 0\"\n  shows \"a / real_of_nat n = a / (real n)\"\n  using assms by simp", "origin": "average_value", "update_count": 0}, "find_max_nV2": {"skill_name": "find_max_nV2", "marker": "lemma find_max_n:\n  fixes n :: nat\n  assumes \"n = 7\" \"m = 35\"\n  shows \"n = 7\"\nproof -\n  have \"n = 7\" using assms(1) by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma find_max_n:\n  fixes n :: nat\n  assumes \"n = 7\" \"m = 35\"\n  shows \"n = 7\"\nproof -\n  have \"n = 7\" using assms(1) by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_relationshipV5": {"skill_name": "floor_relationshipV5", "marker": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  have \"r < n + 1\" using assms\n  proof -\n    have \"r < floor r + 1\" using assms\n      by auto\n    thus \"r < n + 1\" by (simp add: assms)\n  qed\n  thus ?thesis by (simp add: `n \\<le> r`)\nqed", "description": "-", "full_code": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  have \"r < n + 1\" using assms\n  proof -\n    have \"r < floor r + 1\" using assms\n      by auto\n    thus \"r < n + 1\" by (simp add: assms)\n  qed\n  thus ?thesis by (simp add: `n \\<le> r`)\nqed", "origin": "do_request", "update_count": 0}, "average_of_sumV2": {"skill_name": "average_of_sumV2", "marker": "lemma average_of_sum:\n  fixes a b :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"(a + b) / real count = (a / real count) + (b / real count)\"\nproof -\n  have \"real count > 0\" using assms by simp\n  thus ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma average_of_sum:\n  fixes a b :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"(a + b) / real count = (a / real count) + (b / real count)\"\nproof -\n  have \"real count > 0\" using assms by simp\n  thus ?thesis by (auto simp: field_simps)\nqed", "origin": "average_value", "update_count": 0}, "floor_relationshipV6": {"skill_name": "floor_relationshipV6", "marker": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  have \"r < n + 1\" using assms\n  proof -\n    have \"n \\<le> r\" using assms by auto\n    also have \"r < n + 1\" by (metis add.commute assms floor_less_iff less_add_same_cancel2 less_numeral_extra(1))\n    ultimately show \"r < n + 1\" by auto\n  qed\n  thus ?thesis by (simp add: `n \\<le> r`)\nqed", "description": "-", "full_code": "lemma floor_relationship:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n \\<le> r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  have \"r < n + 1\" using assms\n  proof -\n    have \"n \\<le> r\" using assms by auto\n    also have \"r < n + 1\" by (metis add.commute assms floor_less_iff less_add_same_cancel2 less_numeral_extra(1))\n    ultimately show \"r < n + 1\" by auto\n  qed\n  thus ?thesis by (simp add: `n \\<le> r`)\nqed", "origin": "do_request", "update_count": 0}, "non_negative_square_difference": {"skill_name": "non_negative_square_difference", "marker": "lemma non_negative_square_difference:\n  fixes a b :: real\n  shows \"0 \\<le> (a - b)^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by (simp add: square_expansion)\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  by (simp add: power2_eq_square algebra_simps)\n\nlemma non_negative_square_difference:\n  fixes a b :: real\n  shows \"0 \\<le> (a - b)^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by (simp add: square_expansion)\n  then show ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "square_difference_inequality": {"skill_name": "square_difference_inequality", "marker": "lemma square_difference_inequality:\n  fixes a b :: real\n  assumes \"a > b\"\n  shows \"(a - b)^2 > 0\"\nproof -\n  have \"a - b > 0\" using assms by simp\n  then show ?thesis by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_difference_inequality:\n  fixes a b :: real\n  assumes \"a > b\"\n  shows \"(a - b)^2 > 0\"\nproof -\n  have \"a - b > 0\" using assms by simp\n  then show ?thesis by (simp add: power2_eq_square)\nqed", "origin": "square_expansion", "update_count": 0}, "linear_congruenceV5": {"skill_name": "linear_congruenceV5", "marker": "lemma linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by auto\n  then show \"\\<exists>k. a = k * m + b\" \n    using assms(2) by (metis mod_less)\nqed", "description": "-", "full_code": "lemma linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by auto\n  then show \"\\<exists>k. a = k * m + b\" \n    using assms(2) by (metis mod_less)\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_421_extendedV2": {"skill_name": "mathd_algebra_421_extendedV2", "marker": "theorem mathd_algebra_421_extended:\n  fixes a b c d :: real\n  assumes h0 : \"b = a^2 + 4 * a + 6\"\n    and h1 : \"b = 1 / 2 * a^2 + a + 6\"\n    and h2 : \"d = c^2 + 4 * c + 6\"\n    and h3 : \"d = 1 / 2 * c^2 + c + 6\"\n    and h4 : \"a < c\"\n  shows \"c - a = 6\"\nproof -\n  have \"a^2 + 4 * a + 6 = 1/2 * a^2 + a + 6\" using h0 h1 by simp\n  hence \"a^2 + 4 * a = 1/2 * a^2 + a\" by (simp add: add.commute)\n  then have \"a^2 - 1/2 * a^2 + 4 * a - a = 0\" by auto\n  hence \"1/2 * a^2 + 3 * a = 0\" by (simp add: field_simps)\n  thus \"c - a = 6\" using h2 h3 h4 by sos\nqed", "description": "-", "full_code": "theorem mathd_algebra_421_extended:\n  fixes a b c d :: real\n  assumes h0 : \"b = a^2 + 4 * a + 6\"\n    and h1 : \"b = 1 / 2 * a^2 + a + 6\"\n    and h2 : \"d = c^2 + 4 * c + 6\"\n    and h3 : \"d = 1 / 2 * c^2 + c + 6\"\n    and h4 : \"a < c\"\n  shows \"c - a = 6\"\nproof -\n  have \"a^2 + 4 * a + 6 = 1/2 * a^2 + a + 6\" using h0 h1 by simp\n  hence \"a^2 + 4 * a = 1/2 * a^2 + a\" by (simp add: add.commute)\n  then have \"a^2 - 1/2 * a^2 + 4 * a - a = 0\" by auto\n  hence \"1/2 * a^2 + 3 * a = 0\" by (simp add: field_simps)\n  thus \"c - a = 6\" using h2 h3 h4 by sos\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "cancel_divV3": {"skill_name": "cancel_divV3", "marker": "lemma cancel_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then have \"x * a + b = c * x\"\n    using assms(1) by (simp add: mult.commute)\n  show ?thesis by (metis \\<open>x * a + b = c * x\\<close> frac_eq_eq mult.commute mult_eq_0_iff)\nqed", "description": "-", "full_code": "lemma cancel_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then have \"x * a + b = c * x\"\n    using assms(1) by (simp add: mult.commute)\n  show ?thesis by (metis \\<open>x * a + b = c * x\\<close> frac_eq_eq mult.commute mult_eq_0_iff)\nqed", "origin": "do_request", "update_count": 0}, "average_value_multi": {"skill_name": "average_value_multi", "marker": "lemma average_value_multi:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count)) \\<and> \n         (\\<forall>n. n > 0 \\<longrightarrow> total / real (count * n) = (total / (real_of_nat (count * n))))\"\n  using assms \n  by auto", "description": "-", "full_code": "lemma average_value:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  using assms by simp\n\nlemma average_value_multi:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count)) \\<and> \n         (\\<forall>n. n > 0 \\<longrightarrow> total / real (count * n) = (total / (real_of_nat (count * n))))\"\n  using assms \n  by auto", "origin": "average_value", "update_count": 0}, "average_value_extendedV2": {"skill_name": "average_value_extendedV2", "marker": "lemma average_value_extended:\n  fixes total :: real and count :: nat and scale :: real\n  assumes \"count > 0\" and \"scale > 0\"\n  shows \"total / (scale * real count) = (total / scale) / (real_of_nat count)\"\n  using assms by (simp add: field_simps)", "description": "-", "full_code": "lemma average_value_extended:\n  fixes total :: real and count :: nat and scale :: real\n  assumes \"count > 0\" and \"scale > 0\"\n  shows \"total / (scale * real count) = (total / scale) / (real_of_nat count)\"\n  using assms by (simp add: field_simps)", "origin": "average_value", "update_count": 0}, "inequality_manipulationV2": {"skill_name": "inequality_manipulationV2", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"a * c < b * c\" \n  proof -\n    from assms(1) have \"b - a > 0\" by (simp add: less_diff_conv)\n    then have \"b - a = (b - a) * 1\" by (simp)\n    moreover from assms(2) have \"c > 0\" by assumption\n    ultimately show ?thesis \n      using mult_strict_mono by (metis assms(1) mult_less_cancel_right_disj)\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"a * c < b * c\" \n  proof -\n    from assms(1) have \"b - a > 0\" by (simp add: less_diff_conv)\n    then have \"b - a = (b - a) * 1\" by (simp)\n    moreover from assms(2) have \"c > 0\" by assumption\n    ultimately show ?thesis \n      using mult_strict_mono by (metis assms(1) mult_less_cancel_right_disj)\n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "average_value_ndim": {"skill_name": "average_value_ndim", "marker": "lemma average_value_ndim:\n  fixes total :: \"real list\" and count :: nat\n  assumes \"count > 0\" \"length total = count\"\n  shows \"complex_sum total / real count = (complex_sum total / (real_of_nat count))\"\n  using assms by auto", "description": "-", "full_code": "lemma average_value_ndim:\n  fixes total :: \"real list\" and count :: nat\n  assumes \"count > 0\" \"length total = count\"\n  shows \"complex_sum total / real count = (complex_sum total / (real_of_nat count))\"\n  using assms by auto", "origin": "average_value", "update_count": 0}, "average_value_n_dimensions": {"skill_name": "average_value_n_dimensions", "marker": "lemma average_value_n_dimensions:\n  fixes total :: \"real list\" and count :: nat\n  assumes \"count > 0\" and \"length total = count\"\n  shows \"complex_sum total / real count = (complex_sum total) / (real_of_nat count)\"\n  using assms\nproof -\n  have \"complex_sum total / real count = (complex_sum (map (\\<lambda>x. x) total)) / (real_of_nat count)\"\n    by auto\n  also have \"... = complex_sum total / (real_of_nat count)\"\n    by (simp)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma average_value_n_dimensions:\n  fixes total :: \"real list\" and count :: nat\n  assumes \"count > 0\" and \"length total = count\"\n  shows \"complex_sum total / real count = (complex_sum total) / (real_of_nat count)\"\n  using assms\nproof -\n  have \"complex_sum total / real count = (complex_sum (map (\\<lambda>x. x) total)) / (real_of_nat count)\"\n    by auto\n  also have \"... = complex_sum total / (real_of_nat count)\"\n    by (simp)\n  finally show ?thesis .\nqed", "origin": "average_value", "update_count": 0}, "product_difference_condition": {"skill_name": "product_difference_condition", "marker": "lemma product_difference_condition:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\" \"x * y = c\" \n  shows \"x - y \\<noteq> 0\"\nproof -\n  have \"x - y \\<noteq> 0\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma product_difference_condition:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\" \"x * y = c\" \n  shows \"x - y \\<noteq> 0\"\nproof -\n  have \"x - y \\<noteq> 0\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "algebra_2varlineareq_simple": {"skill_name": "algebra_2varlineareq_simple", "marker": "theorem algebra_2varlineareq_simple:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  thus ?thesis using eq_simplified e_expr by (metis add.commute algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 h0 h1)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e=11 \\<and> x= (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  have x_value: \"x = 3 - 7\" by (metis \\<open>x + 7 = 3\\<close> add.commute add_diff_cancel dbl_inc_simps(3) h0)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then have e_value_final: \"e = 7 + 4\" by simp\n  thus ?thesis using x_value_final by auto\nqed\n\ntheorem algebra_2varlineareq_simple:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  thus ?thesis using eq_simplified e_expr by (metis add.commute algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 h0 h1)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "limit_of_sqrt": {"skill_name": "limit_of_sqrt", "marker": "lemma limit_of_sqrt:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" by (simp add: power2_eq_square)\n  then have \"x = 81 - 9\" by (simp add: add_diff_cancel)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma limit_of_sqrt:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" by (simp add: power2_eq_square)\n  then have \"x = 81 - 9\" by (simp add: add_diff_cancel)\n  then show ?thesis by auto\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_limit_unique": {"skill_name": "sqrt_limit_unique", "marker": "lemma sqrt_limit_unique:\n  fixes x y :: real\n  assumes \"y = sqrt(x + 9)\" and \"y = 9\"\n  shows \"x = 72\"\nproof -\n  have \"y^2 = x + 9\" using assms(1) by (metis abs_numeral assms(2) dbl_inc_simps(3) numeral_sqr one_add_one power2_eq_square real_sqrt_abs2 real_sqrt_eq_iff real_sqrt_mult semiring_norm(2) semiring_norm(4) sqr.simps(1) sqr.simps(3))\n  then have \"9^2 = x + 9\" using assms(2) by simp\n  have \"81 = x + 9\" by (metis abs_numeral add.commute add_One_commute assms(1) assms(2) num_double numeral_Bit0 numeral_Bit1 numeral_times_numeral real_sqrt_abs2 real_sqrt_eq_iff semiring_norm(3) semiring_norm(6) sqr.simps(2) sqr.simps(3) sqr_conv_mult)\n  then show ?thesis by (simp add: add_diff_cancel)\nqed", "description": "-", "full_code": "lemma sqrt_limit_unique:\n  fixes x y :: real\n  assumes \"y = sqrt(x + 9)\" and \"y = 9\"\n  shows \"x = 72\"\nproof -\n  have \"y^2 = x + 9\" using assms(1) by (metis abs_numeral assms(2) dbl_inc_simps(3) numeral_sqr one_add_one power2_eq_square real_sqrt_abs2 real_sqrt_eq_iff real_sqrt_mult semiring_norm(2) semiring_norm(4) sqr.simps(1) sqr.simps(3))\n  then have \"9^2 = x + 9\" using assms(2) by simp\n  have \"81 = x + 9\" by (metis abs_numeral add.commute add_One_commute assms(1) assms(2) num_double numeral_Bit0 numeral_Bit1 numeral_times_numeral real_sqrt_abs2 real_sqrt_eq_iff semiring_norm(3) semiring_norm(6) sqr.simps(2) sqr.simps(3) sqr_conv_mult)\n  then show ?thesis by (simp add: add_diff_cancel)\nqed", "origin": "sqrt_limit", "update_count": 0}, "product_of_integersV3": {"skill_name": "product_of_integersV3", "marker": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(2) by (metis assms(1) prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"b = p div a\" using assms(1) by auto\n    moreover have \"p div a < p\" using `a * b > 1` assms(1) \n      by (metis \\<open>1 < a\\<close> assms(2) div_less_dividend not_prime_0 zero_less_iff_neq_zero)\n    ultimately have \"b < p\" by auto\n    then have \"b = 1\" using assms(2) prime_def by (metis assms(1) dvd_triv_right gcd_nat.order_iff_strict gcd_nat.trans prime_nat_not_dvd)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = p div b\" using assms(1) by auto\n    moreover have \"p div b < p\" using `a * b > 1` assms(1) \n      by (metis Primes.prime_nat_def \\<open>1 < b\\<close> assms(2) calculation div_le_dividend dual_order.strict_iff_order gr_zeroI less_not_refl mult_1 mult_eq_self_implies_10 not_prime_0 prime_product)\n    ultimately have \"a < p\" by auto\n    then have \"a = 1\" using assms(2) prime_def by (metis `b > 1` assms(1) less_irrefl_nat mult.commute mult_delta_right prime_product)\n  }\n  thus \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\" \n    by (metis assms(1) assms(2) comm_monoid_mult_class.mult_1 mult_cancel_right nat.distinct(1) nat_mult_1_right prime_product)\nqed", "description": "-", "full_code": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(2) by (metis assms(1) prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"b = p div a\" using assms(1) by auto\n    moreover have \"p div a < p\" using `a * b > 1` assms(1) \n      by (metis \\<open>1 < a\\<close> assms(2) div_less_dividend not_prime_0 zero_less_iff_neq_zero)\n    ultimately have \"b < p\" by auto\n    then have \"b = 1\" using assms(2) prime_def by (metis assms(1) dvd_triv_right gcd_nat.order_iff_strict gcd_nat.trans prime_nat_not_dvd)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = p div b\" using assms(1) by auto\n    moreover have \"p div b < p\" using `a * b > 1` assms(1) \n      by (metis Primes.prime_nat_def \\<open>1 < b\\<close> assms(2) calculation div_le_dividend dual_order.strict_iff_order gr_zeroI less_not_refl mult_1 mult_eq_self_implies_10 not_prime_0 prime_product)\n    ultimately have \"a < p\" by auto\n    then have \"a = 1\" using assms(2) prime_def by (metis `b > 1` assms(1) less_irrefl_nat mult.commute mult_delta_right prime_product)\n  }\n  thus \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\" \n    by (metis assms(1) assms(2) comm_monoid_mult_class.mult_1 mult_cancel_right nat.distinct(1) nat_mult_1_right prime_product)\nqed", "origin": "do_request", "update_count": 0}, "product_of_integersV4": {"skill_name": "product_of_integersV4", "marker": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(2) by (metis assms(1) prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"b = p div a\"\n      using assms(1) by auto\n    moreover have \"b < p\"\n      using `a * b > 1` assms(1) assms(2) by (metis Primes.prime_nat_def \\<open>1 < a\\<close> less_numeral_extra(4) nat_mult_1_right prime_product)\n    ultimately have \"b = 1\" \n      using assms(2) prime_def by (metis \\<open>1 < a\\<close> assms(1) less_irrefl_nat mult.commute mult_delta_right prime_product)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = p div b\"\n      using assms(1) by auto\n    moreover have \"a < p\"\n      using `a * b > 1` assms(1) assms(2) by (metis Primes.prime_nat_def \\<open>1 < b\\<close> less_not_refl mult_1 prime_product)\n    ultimately have \"a = 1\" \n      using assms(2) prime_def by (metis \\<open>1 < b\\<close> assms(1) dual_order.irrefl mult.commute mult_delta_right prime_product)\n  }\n  thus \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\" \n    by (metis assms(1) assms(2) comm_monoid_mult_class.mult_1 mult_cancel_right nat.distinct(1) nat_mult_1_right prime_product)\nqed", "description": "-", "full_code": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(2) by (metis assms(1) prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"b = p div a\"\n      using assms(1) by auto\n    moreover have \"b < p\"\n      using `a * b > 1` assms(1) assms(2) by (metis Primes.prime_nat_def \\<open>1 < a\\<close> less_numeral_extra(4) nat_mult_1_right prime_product)\n    ultimately have \"b = 1\" \n      using assms(2) prime_def by (metis \\<open>1 < a\\<close> assms(1) less_irrefl_nat mult.commute mult_delta_right prime_product)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = p div b\"\n      using assms(1) by auto\n    moreover have \"a < p\"\n      using `a * b > 1` assms(1) assms(2) by (metis Primes.prime_nat_def \\<open>1 < b\\<close> less_not_refl mult_1 prime_product)\n    ultimately have \"a = 1\" \n      using assms(2) prime_def by (metis \\<open>1 < b\\<close> assms(1) dual_order.irrefl mult.commute mult_delta_right prime_product)\n  }\n  thus \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\" \n    by (metis assms(1) assms(2) comm_monoid_mult_class.mult_1 mult_cancel_right nat.distinct(1) nat_mult_1_right prime_product)\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3V2": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3V2", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  from h0 have e_expr: \"e = 7 - x\" by (simp add: field_simps)\n  from h1 have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (simp add: field_simps)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then have e_value_final: \"e = 7 + 4\" by simp\n  thus ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  from h0 have e_expr: \"e = 7 - x\" by (simp add: field_simps)\n  from h1 have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (simp add: field_simps)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then have e_value_final: \"e = 7 + 4\" by simp\n  thus ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "simplify_sqrtV2": {"skill_name": "simplify_sqrtV2", "marker": "lemma simplify_sqrt:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt(a) * sqrt(b) = sqrt(a * b)\"\nproof -\n  have \"sqrt(a) * sqrt(b) = sqrt(a * b) * sqrt(1)\"\n    by (metis mult_cancel_left2 real_sqrt_eq_1_iff real_sqrt_mult)\n  also have \"... = sqrt(a * b)\"\n    by (simp add: real_sqrt_eq_1_iff)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma simplify_sqrt:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt(a) * sqrt(b) = sqrt(a * b)\"\nproof -\n  have \"sqrt(a) * sqrt(b) = sqrt(a * b) * sqrt(1)\"\n    by (metis mult_cancel_left2 real_sqrt_eq_1_iff real_sqrt_mult)\n  also have \"... = sqrt(a * b)\"\n    by (simp add: real_sqrt_eq_1_iff)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "generalized_square_expansion": {"skill_name": "generalized_square_expansion", "marker": "lemma generalized_square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\n  by (simp add: power2_diff)", "description": "-", "full_code": "lemma generalized_square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\n  by (simp add: power2_diff)", "origin": "square_expansion", "update_count": 0}, "sqrt_equalityV2": {"skill_name": "sqrt_equalityV2", "marker": "lemma sqrt_equality:\n  fixes a b :: real\n  assumes \"sqrt a = sqrt b\" \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = sqrt b ^ 2\" \n    using assms(1) by (simp add: power2_eq_square)\n  then have \"a = b\" \n    using assms(2) assms(3) by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_equality:\n  fixes a b :: real\n  assumes \"sqrt a = sqrt b\" \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = sqrt b ^ 2\" \n    using assms(1) by (simp add: power2_eq_square)\n  then have \"a = b\" \n    using assms(2) assms(3) by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "substitution_in_linear_equationV3": {"skill_name": "substitution_in_linear_equationV3", "marker": "lemma substitution_in_linear_equation:\n  fixes a b :: real\n  assumes \"m * a + n * b = c\" \n    and \"a = k\"\n  shows \"m * k + n * b = c\"\nproof -\n  have \"m * a + n * b = c\" using assms(1) by simp\n  also have \"m * k + n * b = c\" using assms(2) by (metis calculation)\n  finally show ?thesis by (metis \\<open>m * k + n * b = c\\<close>)\nqed", "description": "-", "full_code": "lemma substitution_in_linear_equation:\n  fixes a b :: real\n  assumes \"m * a + n * b = c\" \n    and \"a = k\"\n  shows \"m * k + n * b = c\"\nproof -\n  have \"m * a + n * b = c\" using assms(1) by simp\n  also have \"m * k + n * b = c\" using assms(2) by (metis calculation)\n  finally show ?thesis by (metis \\<open>m * k + n * b = c\\<close>)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "average_value_weighted": {"skill_name": "average_value_weighted", "marker": "lemma average_value_weighted:\n  fixes total1 total2 :: real and count1 count2 :: nat\n  assumes \"count1 > 0\" \"count2 > 0\"\n  shows \"(total1 + total2) / (real (count1 + count2)) = \n         (total1 / real count1 * (real count1 / real (count1 + count2))) + \n         (total2 / real count2 * (real count2 / real (count1 + count2)))\"\nproof -\n  have \"total1 + total2 = (total1 / real count1) * real count1 + (total2 / real count2) * real count2\"\n    by (smt (verit) assms(1) assms(2) nat_less_le nonzero_eq_divide_eq of_nat_0_eq_iff)\n  then show ?thesis \n    using assms by (smt (verit) add_divide_distrib divide_eq_eq of_nat_0_eq_iff order_less_imp_not_eq times_divide_eq_right)\nqed", "description": "-", "full_code": "lemma average_value_weighted:\n  fixes total1 total2 :: real and count1 count2 :: nat\n  assumes \"count1 > 0\" \"count2 > 0\"\n  shows \"(total1 + total2) / (real (count1 + count2)) = \n         (total1 / real count1 * (real count1 / real (count1 + count2))) + \n         (total2 / real count2 * (real count2 / real (count1 + count2)))\"\nproof -\n  have \"total1 + total2 = (total1 / real count1) * real count1 + (total2 / real count2) * real count2\"\n    by (smt (verit) assms(1) assms(2) nat_less_le nonzero_eq_divide_eq of_nat_0_eq_iff)\n  then show ?thesis \n    using assms by (smt (verit) add_divide_distrib divide_eq_eq of_nat_0_eq_iff order_less_imp_not_eq times_divide_eq_right)\nqed", "origin": "average_value", "update_count": 0}, "mod_square": {"skill_name": "mod_square", "marker": "lemma mod_square:\n  fixes a :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^2) mod m = ((a mod m)^2) mod m\"\nproof -\n  have \"a^2 = a * a\" by (metis power2_eq_square)\n  then have \"(a^2) mod m = (a * a) mod m\" by simp\n  also have \"... = (a mod m * a mod m) mod m\" using assms \n    by (metis mod_mod_trivial mod_mult_left_eq)\n  also have \"... = (a mod m)^2 mod m\" by (metis calculation power_mod)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^2) mod m = ((a mod m)^2) mod m\"\nproof -\n  have \"a^2 = a * a\" by (metis power2_eq_square)\n  then have \"(a^2) mod m = (a * a) mod m\" by simp\n  also have \"... = (a mod m * a mod m) mod m\" using assms \n    by (metis mod_mod_trivial mod_mult_left_eq)\n  also have \"... = (a mod m)^2 mod m\" by (metis calculation power_mod)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_squareV2": {"skill_name": "mod_squareV2", "marker": "lemma mod_square:\n  fixes a :: nat and m :: nat\n  shows \"(a^2) mod m = ((a mod m)^2) mod m\"\nproof -\n  have \"(a^2) mod m = (a * a) mod m\" by (metis power2_eq_square)\n  also have \"... = ((a mod m) * (a mod m)) mod m\" \n    using mod_mult_eq by metis\n  also have \"... = (a mod m)^2 mod m\" by (metis calculation power_mod)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a :: nat and m :: nat\n  shows \"(a^2) mod m = ((a mod m)^2) mod m\"\nproof -\n  have \"(a^2) mod m = (a * a) mod m\" by (metis power2_eq_square)\n  also have \"... = ((a mod m) * (a mod m)) mod m\" \n    using mod_mult_eq by metis\n  also have \"... = (a mod m)^2 mod m\" by (metis calculation power_mod)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "cross_multiplicationV4": {"skill_name": "cross_multiplicationV4", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\" and \"a - c \\<noteq> 0\"\n  shows \"(a - c) * b * d = d * (a - c) * b\"\nproof -\n  have \"b * (a - c) = b * (a - c)\" by simp\n  hence \"b * (a - c) * d = d * (a - c) * b\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\" and \"a - c \\<noteq> 0\"\n  shows \"(a - c) * b * d = d * (a - c) * b\"\nproof -\n  have \"b * (a - c) = b * (a - c)\" by simp\n  hence \"b * (a - c) * d = d * (a - c) * b\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "mathd_algebra_generalizedV4": {"skill_name": "mathd_algebra_generalizedV4", "marker": "theorem mathd_algebra_generalized:\n  fixes a b c :: real\n  assumes h0 : \"c * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - c * 4) / 2\"\nproof -\n  have eq: \"c * a + 2 * b = 12\" using h0 by simp\n  have \"c * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"2 * b = 12 - c * 4\" by (smt (verit) \\<open>c * 4 + 2 * b = 12\\<close>)\n  show ?thesis using `2 * b = 12 - c * 4` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_generalized:\n  fixes a b c :: real\n  assumes h0 : \"c * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - c * 4) / 2\"\nproof -\n  have eq: \"c * a + 2 * b = 12\" using h0 by simp\n  have \"c * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"2 * b = 12 - c * 4\" by (smt (verit) \\<open>c * 4 + 2 * b = 12\\<close>)\n  show ?thesis using `2 * b = 12 - c * 4` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "average_value_n_dims": {"skill_name": "average_value_n_dims", "marker": "lemma average_value_n_dims:\n  fixes totals :: \"real list\" and count :: nat\n  assumes \"count > 0\" and \"length totals = count\"\n  shows \"sum_list totals / real count = (sum_list totals / (real_of_nat count))\"\nproof -\n  have \"sum_list totals / real count = sum_list totals / (real_of_nat count)\"\n    by (simp add: assms)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma average_value_n_dims:\n  fixes totals :: \"real list\" and count :: nat\n  assumes \"count > 0\" and \"length totals = count\"\n  shows \"sum_list totals / real count = (sum_list totals / (real_of_nat count))\"\nproof -\n  have \"sum_list totals / real count = sum_list totals / (real_of_nat count)\"\n    by (simp add: assms)\n  then show ?thesis by simp\nqed", "origin": "average_value", "update_count": 0}, "average_value_with_weight": {"skill_name": "average_value_with_weight", "marker": "lemma average_value_with_weight:\n  fixes total :: real and count :: nat and weight :: real\n  assumes \"count > 0\" and \"weight > 0\"\n  shows \"total / (weight * real count) = (total / (weight * real_of_nat count))\"\n  using assms by simp", "description": "-", "full_code": "lemma average_value_with_weight:\n  fixes total :: real and count :: nat and weight :: real\n  assumes \"count > 0\" and \"weight > 0\"\n  shows \"total / (weight * real count) = (total / (weight * real_of_nat count))\"\n  using assms by simp", "origin": "average_value", "update_count": 0}, "chinese_remainder": {"skill_name": "chinese_remainder", "marker": "theorem chinese_remainder:\n  fixes a m1 m2 r1 r2 :: nat\n  assumes \"a mod m1 = r1\" and \"a mod m2 = r2\"\n  shows \"\\<exists>k. a = r1 + k * m1\"\nproof -\n  obtain k1 where \"a = r1 + k1 * m1\" \n    using assms(1) by (metis mod_div_mult_eq)\n  thus \"\\<exists>k. a = r1 + k * m1\" \n    by (rule exI[where x=k1])\nqed", "description": "-", "full_code": "theorem chinese_remainder:\n  fixes a m1 m2 r1 r2 :: nat\n  assumes \"a mod m1 = r1\" and \"a mod m2 = r2\"\n  shows \"\\<exists>k. a = r1 + k * m1\"\nproof -\n  obtain k1 where \"a = r1 + k1 * m1\" \n    using assms(1) by (metis mod_div_mult_eq)\n  thus \"\\<exists>k. a = r1 + k * m1\" \n    by (rule exI[where x=k1])\nqed", "origin": "do_request", "update_count": 0}, "chinese_remainderV2": {"skill_name": "chinese_remainderV2", "marker": "theorem chinese_remainder:\n  fixes a b m1 m2 r1 r2 :: nat\n  assumes \"a mod m1 = r1\" and \"a mod m2 = r2\"\n  shows \"\\<exists>k. a = r1 + k * m1\"\nproof -\n  let ?k = \"a div m1\"\n  have \"a = r1 + (a div m1) * m1\"\n    by (metis add.assoc add.commute add_right_imp_eq assms(1) mult.commute mult_div_mod_eq)\n  thus \"\\<exists>k. a = r1 + k * m1\" \n    by auto \nqed", "description": "-", "full_code": "theorem chinese_remainder:\n  fixes a b m1 m2 r1 r2 :: nat\n  assumes \"a mod m1 = r1\" and \"a mod m2 = r2\"\n  shows \"\\<exists>k. a = r1 + k * m1\"\nproof -\n  let ?k = \"a div m1\"\n  have \"a = r1 + (a div m1) * m1\"\n    by (metis add.assoc add.commute add_right_imp_eq assms(1) mult.commute mult_div_mod_eq)\n  thus \"\\<exists>k. a = r1 + k * m1\" \n    by auto \nqed", "origin": "do_request", "update_count": 0}, "chinese_remainderV3": {"skill_name": "chinese_remainderV3", "marker": "theorem chinese_remainder:\n  fixes a r1 r2 m1 m2 :: nat\n  assumes \"a mod m1 = r1\" and \"a mod m2 = r2\"\n  shows \"\\<exists>k. a = r1 + k * m1\"\nproof -\n  let ?k = \"a div m1\"  \n  have \"a = r1 + (a div m1) * m1\"\n    using assms(1) by auto\n  show \"\\<exists>k. a = r1 + k * m1\" \n    by (metis \\<open>a = r1 + a div m1 * m1\\<close>)\nqed", "description": "-", "full_code": "theorem chinese_remainder:\n  fixes a r1 r2 m1 m2 :: nat\n  assumes \"a mod m1 = r1\" and \"a mod m2 = r2\"\n  shows \"\\<exists>k. a = r1 + k * m1\"\nproof -\n  let ?k = \"a div m1\"  \n  have \"a = r1 + (a div m1) * m1\"\n    using assms(1) by auto\n  show \"\\<exists>k. a = r1 + k * m1\" \n    by (metis \\<open>a = r1 + a div m1 * m1\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "congruence_mod_8": {"skill_name": "congruence_mod_8", "marker": "lemma congruence_mod_8:\n  fixes N :: nat\n  assumes \"N mod 8 = 5\"\n  shows \"\\<exists>k. N = 8 * k + 5\"\nproof -\n  have \"N = 8 * (N div 8) + (N mod 8)\" \n    by auto\n  then have \"N = 8 * (N div 8) + 5\" \n    using assms by simp\n  then show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma congruence_mod_8:\n  fixes N :: nat\n  assumes \"N mod 8 = 5\"\n  shows \"\\<exists>k. N = 8 * k + 5\"\nproof -\n  have \"N = 8 * (N div 8) + (N mod 8)\" \n    by auto\n  then have \"N = 8 * (N div 8) + 5\" \n    using assms by simp\n  then show ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "congruence_mod_8V2": {"skill_name": "congruence_mod_8V2", "marker": "lemma congruence_mod_8:\n  fixes N :: nat\n  assumes \"N mod 8 = 5\"\n  shows \"\\<exists>k. N = 8 * k + 5\"\nproof -\n  obtain k where \"N = 8 * k + (N mod 8)\" using assms by (metis add.commute add.right_neutral div_mod_decomp mod_div_trivial mod_eq_nat2E mod_less_eq_dividend mult.commute mult_zero_right)\n  hence \"N = 8 * k + 5\" by (simp add: assms)\n  thus \"\\<exists>k. N = 8 * k + 5\" by auto\nqed", "description": "-", "full_code": "lemma congruence_mod_8:\n  fixes N :: nat\n  assumes \"N mod 8 = 5\"\n  shows \"\\<exists>k. N = 8 * k + 5\"\nproof -\n  obtain k where \"N = 8 * k + (N mod 8)\" using assms by (metis add.commute add.right_neutral div_mod_decomp mod_div_trivial mod_eq_nat2E mod_less_eq_dividend mult.commute mult_zero_right)\n  hence \"N = 8 * k + 5\" by (simp add: assms)\n  thus \"\\<exists>k. N = 8 * k + 5\" by auto\nqed", "origin": "do_request", "update_count": 0}, "chinese_remainderV4": {"skill_name": "chinese_remainderV4", "marker": "theorem chinese_remainder:\n  fixes a m1 m2 r1 r2 :: nat\n  assumes \"a mod m1 = r1\" and \"a mod m2 = r2\"\n  shows \"\\<exists>k. a = r1 + k * m1\"\nproof -\n  obtain k1 where \"a = r1 + k1 * m1\" using assms(1) \n    by (metis mod_mult_div_eq mult.commute)\n  show \"\\<exists>k. a = r1 + k * m1\" \n    by (metis \\<open>\\<And>thesis. (\\<And>k1. a = r1 + k1 * m1 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>)\nqed", "description": "-", "full_code": "theorem chinese_remainder:\n  fixes a m1 m2 r1 r2 :: nat\n  assumes \"a mod m1 = r1\" and \"a mod m2 = r2\"\n  shows \"\\<exists>k. a = r1 + k * m1\"\nproof -\n  obtain k1 where \"a = r1 + k1 * m1\" using assms(1) \n    by (metis mod_mult_div_eq mult.commute)\n  show \"\\<exists>k. a = r1 + k * m1\" \n    by (metis \\<open>\\<And>thesis. (\\<And>k1. a = r1 + k1 * m1 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "bounds_on_n": {"skill_name": "bounds_on_n", "marker": "lemma bounds_on_n:\n  fixes n :: nat and m :: nat\n  assumes \"n < m\"\n  shows \"n \\<in> {x::nat. x < m}\"\nproof -\n  have \"n < m\" using assms by simp\n  then show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma bounds_on_n:\n  fixes n :: nat and m :: nat\n  assumes \"n < m\"\n  shows \"n \\<in> {x::nat. x < m}\"\nproof -\n  have \"n < m\" using assms by simp\n  then show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "bounds_on_nV2": {"skill_name": "bounds_on_nV2", "marker": "lemma bounds_on_n:\n  fixes n :: nat and m :: nat\n  assumes \"n < m\"\n  shows \"n \\<in> {x::nat. x < m}\"\nproof -\n  have \"n < m\" using assms by simp\n  hence \"n \\<in> {x :: nat. x < m}\" \n    by auto     \n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma bounds_on_n:\n  fixes n :: nat and m :: nat\n  assumes \"n < m\"\n  shows \"n \\<in> {x::nat. x < m}\"\nproof -\n  have \"n < m\" using assms by simp\n  hence \"n \\<in> {x :: nat. x < m}\" \n    by auto     \n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_expansion_with_coefficientsV2": {"skill_name": "square_expansion_with_coefficientsV2", "marker": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(c*a - d*b)^2 = c^2*a^2 - 2*c*d*a*b + d^2*b^2\"\nproof -\n  have \"(c*a - d*b)^2 = (c*a)^2 - 2*(c*a)*(d*b) + (d*b)^2\"\n    by sos\n  also have \"... = c^2*a^2 - 2*c*d*a*b + d^2*b^2\"\n    by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(c*a - d*b)^2 = c^2*a^2 - 2*c*d*a*b + d^2*b^2\"\nproof -\n  have \"(c*a - d*b)^2 = (c*a)^2 - 2*(c*a)*(d*b) + (d*b)^2\"\n    by sos\n  also have \"... = c^2*a^2 - 2*c*d*a*b + d^2*b^2\"\n    by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "generalized_square_expansionV2": {"skill_name": "generalized_square_expansionV2", "marker": "lemma generalized_square_expansion:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2*a*b + b^2 + 2*c*(a - b) + c^2\"\nproof -\n  have \"(a - b + c)^2 = (a - b)^2 + 2*(a - b)*c + c^2\"\n    by sos\n  also have \"... = (a^2 - 2*a*b + b^2) + 2*c*(a - b) + c^2\"\n    by sos\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma generalized_square_expansion:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2*a*b + b^2 + 2*c*(a - b) + c^2\"\nproof -\n  have \"(a - b + c)^2 = (a - b)^2 + 2*(a - b)*c + c^2\"\n    by sos\n  also have \"... = (a^2 - 2*a*b + b^2) + 2*c*(a - b) + c^2\"\n    by sos\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_complex": {"skill_name": "square_expansion_complex", "marker": "lemma square_expansion_complex:\n  fixes z1 z2 :: complex\n  shows \"(z1 - z2)^2 = z1^2 - 2*z1*z2 + z2^2\"\nproof -\n  have \"(z1 - z2)^2 = z1^2 - 2*z1*z2 + z2^2\" \n    by (smt (verit) diff_add_eq power2_diff)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_expansion_complex:\n  fixes z1 z2 :: complex\n  shows \"(z1 - z2)^2 = z1^2 - 2*z1*z2 + z2^2\"\nproof -\n  have \"(z1 - z2)^2 = z1^2 - 2*z1*z2 + z2^2\" \n    by (smt (verit) diff_add_eq power2_diff)\n  thus ?thesis by auto\nqed", "origin": "square_expansion", "update_count": 0}, "amc12a_2013_p8_extendedV4": {"skill_name": "amc12a_2013_p8_extendedV4", "marker": "theorem amc12a_2013_p8_extended:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\" \n    and h1: \"y \\<noteq> 0\" \n    and h2: \"x \\<noteq> y\" \n    and h3: \"x + 2 / x = y + 2 / y\" \n    and h4: \"x > 0\" \n    and h5: \"y > 0\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2 / x = y + 2 / y\" using h3 by simp\n  thus ?thesis\n  proof (cases \"x = y\")\n    case True\n    then show ?thesis using h2 by contradiction\n  next\n    case False\n    then have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n    have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n      using rearranged by sos\n    then have \"x * y = 2\" \n      using h2 cross_mult by sos\n    thus ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_extended:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\" \n    and h1: \"y \\<noteq> 0\" \n    and h2: \"x \\<noteq> y\" \n    and h3: \"x + 2 / x = y + 2 / y\" \n    and h4: \"x > 0\" \n    and h5: \"y > 0\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2 / x = y + 2 / y\" using h3 by simp\n  thus ?thesis\n  proof (cases \"x = y\")\n    case True\n    then show ?thesis using h2 by contradiction\n  next\n    case False\n    then have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n    have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n      using rearranged by sos\n    then have \"x * y = 2\" \n      using h2 cross_mult by sos\n    thus ?thesis by simp\n  qed\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2015_p10_generalized": {"skill_name": "amc12a_2015_p10_generalized", "marker": "theorem amc12a_2015_p10_generalized:\n  fixes x y z :: real\n  assumes h0 : \"y > 0\"\n    and h1 : \"y < x\"\n    and h2 : \"x + z + (x * z) = 80\"\n    and h3 : \"z > 0\"\n  shows \"x = (80 - z) / (1 + z)\"\nproof -\n  have rearranged: \"x * (1 + z) = 80 - z\" using h2 by sos\n  hence \"x = (80 - z) / (1 + z)\" using h3 by (simp add: field_simps)\n  thus ?thesis by (simp)\nqed", "description": "-", "full_code": "theorem amc12a_2015_p10_generalized:\n  fixes x y z :: real\n  assumes h0 : \"y > 0\"\n    and h1 : \"y < x\"\n    and h2 : \"x + z + (x * z) = 80\"\n    and h3 : \"z > 0\"\n  shows \"x = (80 - z) / (1 + z)\"\nproof -\n  have rearranged: \"x * (1 + z) = 80 - z\" using h2 by sos\n  hence \"x = (80 - z) / (1 + z)\" using h3 by (simp add: field_simps)\n  thus ?thesis by (simp)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "bounds_on_r": {"skill_name": "bounds_on_r", "marker": "lemma bounds_on_r:\n  fixes r :: real\n  assumes \"8 \\<le> r + 0.57\" \"r + 0.57 < 8.01\"\n  shows \"7.43 \\<le> r \\<and> r < 7.44\"\nproof -\n  have \"8 - 0.57 \\<le> r\" using assms(1) by simp\n  hence \"7.43 \\<le> r\" by simp\n  have \"r < 8.01 - 0.57\" using assms(2) by simp\n  hence \"r < 7.44\" by simp\n  show ?thesis using `7.43 \\<le> r` and `r < 7.44` by auto\nqed", "description": "-", "full_code": "lemma bounds_on_r:\n  fixes r :: real\n  assumes \"8 \\<le> r + 0.57\" \"r + 0.57 < 8.01\"\n  shows \"7.43 \\<le> r \\<and> r < 7.44\"\nproof -\n  have \"8 - 0.57 \\<le> r\" using assms(1) by simp\n  hence \"7.43 \\<le> r\" by simp\n  have \"r < 8.01 - 0.57\" using assms(2) by simp\n  hence \"r < 7.44\" by simp\n  show ?thesis using `7.43 \\<le> r` and `r < 7.44` by auto\nqed", "origin": "do_request", "update_count": 0}, "amc12a_2013_p8_simplifiedV2": {"skill_name": "amc12a_2013_p8_simplifiedV2", "marker": "theorem amc12a_2013_p8_simplified:\n  fixes x y :: real\n  assumes h0 : \"x > 0\"\n    and h1 : \"y > 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then have \"(x - y) * x * y = 2 * (x - y)\" \n    using h0 h1 h2 by (auto simp: field_simps)\n  thus ?thesis by (metis amc12a_2013_p8_evolved h0 h1 h2 h3 less_numeral_extra(3))\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  hence \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  hence rearranged: \"(x - y) * x * y = 2 * (x - y)\"\n    using h0 h1 h2 by (auto simp: field_simps)\n  have \"x * y = 2\"\n    using h2 rearranged by sos\n  thus ?thesis by simp\nqed\n\ntheorem amc12a_2013_p8_simplified:\n  fixes x y :: real\n  assumes h0 : \"x > 0\"\n    and h1 : \"y > 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then have \"(x - y) * x * y = 2 * (x - y)\" \n    using h0 h1 h2 by (auto simp: field_simps)\n  thus ?thesis by (metis amc12a_2013_p8_evolved h0 h1 h2 h3 less_numeral_extra(3))\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_evolvedV3": {"skill_name": "amc12a_2013_p8_evolvedV3", "marker": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  hence \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  hence rearranged: \"(x - y) * x * y = 2 * (x - y)\"\n    using h0 h1 h2 by (auto simp: field_simps)\n  have \"x * y = 2\"\n    using h2 rearranged by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  hence \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  hence rearranged: \"(x - y) * x * y = 2 * (x - y)\"\n    using h0 h1 h2 by (auto simp: field_simps)\n  have \"x * y = 2\"\n    using h2 rearranged by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "non_neg_avg": {"skill_name": "non_neg_avg", "marker": "lemma non_neg_avg:\n  fixes total :: real and count :: nat\n  assumes \"total >= 0\" and \"count > 0\"\n  shows \"total / real count >= 0\"\nproof -\n  have \"total / real count = total / (real_of_nat count)\" using average_value_nat assms by simp\n  then show ?thesis using assms(1) by auto\nqed", "description": "-", "full_code": "lemma average_value_nat:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  using assms by simp\n\nlemma non_neg_avg:\n  fixes total :: real and count :: nat\n  assumes \"total >= 0\" and \"count > 0\"\n  shows \"total / real count >= 0\"\nproof -\n  have \"total / real count = total / (real_of_nat count)\" using average_value_nat assms by simp\n  then show ?thesis using assms(1) by auto\nqed", "origin": "average_value", "update_count": 0}, "count_positive": {"skill_name": "count_positive", "marker": "lemma count_positive:\n  fixes count :: nat\n  assumes \"count > 0\"\n  shows \"real_of_nat count > 0\"\nproof -\n  have \"count > 0\" using assms by simp\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma count_positive:\n  fixes count :: nat\n  assumes \"count > 0\"\n  shows \"real_of_nat count > 0\"\nproof -\n  have \"count > 0\" using assms by simp\n  then show ?thesis by auto\nqed", "origin": "average_value", "update_count": 0}, "mod_pow": {"skill_name": "mod_pow", "marker": "lemma mod_pow:\n  fixes a n k :: nat\n  assumes \"n > 0\"\n  shows \"(a^k) mod n = (a mod n)^k mod n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  then show ?case\n  proof -\n    have \"a ^ Suc k = a * (a ^ k)\" by simp\n    then have \"(a ^ Suc k) mod n = (a * (a ^ k)) mod n\" by simp\n    also have \"... = ((a mod n) * (a ^ k mod n)) mod n\"\n      using assms by (metis mod_mult_eq)\n    also have \"... = ((a mod n) * ((a mod n)^k mod n)) mod n\"\n      by (simp add: Suc.IH)\n    also have \"... = ((a mod n)^(Suc k)) mod n\" by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_pow:\n  fixes a n k :: nat\n  assumes \"n > 0\"\n  shows \"(a^k) mod n = (a mod n)^k mod n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  then show ?case\n  proof -\n    have \"a ^ Suc k = a * (a ^ k)\" by simp\n    then have \"(a ^ Suc k) mod n = (a * (a ^ k)) mod n\" by simp\n    also have \"... = ((a mod n) * (a ^ k mod n)) mod n\"\n      using assms by (metis mod_mult_eq)\n    also have \"... = ((a mod n) * ((a mod n)^k mod n)) mod n\"\n      by (simp add: Suc.IH)\n    also have \"... = ((a mod n)^(Suc k)) mod n\" by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_n_dimensional": {"skill_name": "mathd_algebra_109_n_dimensional", "marker": "lemma mathd_algebra_109_n_dimensional:\n  fixes a b :: \"real list\" \n  assumes h0: \"3 * (a ! 0) + 2 * (b ! 0) = 12\" \n    and h1: \"a ! 0 = 4\"\n  shows \"b ! 0 = 0\"\nproof -\n  have eq: \"3 * (a ! 0) + 2 * (b ! 0) = 12\" using h0 by simp\n  have \"3 * 4 + 2 * (b ! 0) = 12\" using h1 eq by simp\n  have \"12 + 2 * (b ! 0) = 12\" by (smt (verit) \\<open>3 * 4 + 2 * (b ! 0) = 12\\<close>)\n  have \"2 * (b ! 0) = 0\" by (metis \\<open>12 + 2 * (b ! 0) = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * (b ! 0) = 0` by simp\nqed", "description": "-", "full_code": "lemma mathd_algebra_109_n_dimensional:\n  fixes a b :: \"real list\" \n  assumes h0: \"3 * (a ! 0) + 2 * (b ! 0) = 12\" \n    and h1: \"a ! 0 = 4\"\n  shows \"b ! 0 = 0\"\nproof -\n  have eq: \"3 * (a ! 0) + 2 * (b ! 0) = 12\" using h0 by simp\n  have \"3 * 4 + 2 * (b ! 0) = 12\" using h1 eq by simp\n  have \"12 + 2 * (b ! 0) = 12\" by (smt (verit) \\<open>3 * 4 + 2 * (b ! 0) = 12\\<close>)\n  have \"2 * (b ! 0) = 0\" by (metis \\<open>12 + 2 * (b ! 0) = 12\\<close> add_cancel_right_right)\n  show ?thesis using `2 * (b ! 0) = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mod_powV2": {"skill_name": "mod_powV2", "marker": "lemma mod_pow:\n  fixes a n k :: nat\n  assumes \"n > 0\"\n  shows \"(a^k) mod n = (a mod n)^k mod n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  then show ?case\n  proof -\n    have \"a ^ Suc k = a * (a ^ k)\" by simp\n    then have \"(a ^ Suc k) mod n = (a * (a ^ k)) mod n\" by simp\n    also have \"... = ((a mod n) * (a ^ k) mod n) mod n\"\n      using assms by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod n) * ((a ^ k) mod n)) mod n\"\n      by (metis \\<open>a * a ^ k mod n = a mod n * a ^ k mod n mod n\\<close> mod_mult_eq)\n    also have \"... = (a mod n) ^ Suc k mod n\"\n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_pow:\n  fixes a n k :: nat\n  assumes \"n > 0\"\n  shows \"(a^k) mod n = (a mod n)^k mod n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  then show ?case\n  proof -\n    have \"a ^ Suc k = a * (a ^ k)\" by simp\n    then have \"(a ^ Suc k) mod n = (a * (a ^ k)) mod n\" by simp\n    also have \"... = ((a mod n) * (a ^ k) mod n) mod n\"\n      using assms by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod n) * ((a ^ k) mod n)) mod n\"\n      by (metis \\<open>a * a ^ k mod n = a mod n * a ^ k mod n mod n\\<close> mod_mult_eq)\n    also have \"... = (a mod n) ^ Suc k mod n\"\n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_expansion_generalizedV2": {"skill_name": "square_expansion_generalizedV2", "marker": "lemma square_expansion_generalized:\n  fixes a b c :: real\n  shows \"(a - b - c)^2 = a^2 - 2*a*(b + c) + (b + c)^2\"\nproof -\n  have \"(a - b - c)^2 = (a - (b + c))^2\" by sos\n  also have \"... = a^2 - 2*a*(b + c) + (b + c)^2\" by sos\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_expansion_generalized:\n  fixes a b c :: real\n  shows \"(a - b - c)^2 = a^2 - 2*a*(b + c) + (b + c)^2\"\nproof -\n  have \"(a - b - c)^2 = (a - (b + c))^2\" by sos\n  also have \"... = a^2 - 2*a*(b + c) + (b + c)^2\" by sos\n  finally show ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_general": {"skill_name": "square_expansion_general", "marker": "lemma square_expansion_general:\n  fixes a b c :: real\n  shows \"(a - b - c)^2 = a^2 - 2*a*(b + c) + (b + c)^2\"\nproof -\n  have \"(a - (b + c))^2 = a^2 - 2 * a * (b + c) + (b + c)^2\" by (sos)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion_general:\n  fixes a b c :: real\n  shows \"(a - b - c)^2 = a^2 - 2*a*(b + c) + (b + c)^2\"\nproof -\n  have \"(a - (b + c))^2 = a^2 - 2 * a * (b + c) + (b + c)^2\" by (sos)\n  thus ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_triple": {"skill_name": "square_expansion_triple", "marker": "lemma square_expansion_triple:\n  fixes a b c d :: real\n  shows \"(a - b - c - d)^2 = a^2 - 2*a*(b + c + d) + (b + c + d)^2\"\nproof -\n  have \"(a - (b + c + d))^2 = a^2 - 2 * a * (b + c + d) + (b + c + d)^2\" by (sos)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion_triple:\n  fixes a b c d :: real\n  shows \"(a - b - c - d)^2 = a^2 - 2*a*(b + c + d) + (b + c + d)^2\"\nproof -\n  have \"(a - (b + c + d))^2 = a^2 - 2 * a * (b + c + d) + (b + c + d)^2\" by (sos)\n  thus ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "congruence_mod_8V3": {"skill_name": "congruence_mod_8V3", "marker": "lemma congruence_mod_8:\n  fixes N :: nat\n  assumes \"N mod 8 = 5\"\n  shows \"\\<exists>k. N = 8 * k + 5\"\nproof -\n  obtain k where \"N = 8 * (N div 8) + (N mod 8)\" \n    by auto\n  then have \"N = 8 * (N div 8) + 5\" \n    using assms by simp\n  then show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma congruence_mod_8:\n  fixes N :: nat\n  assumes \"N mod 8 = 5\"\n  shows \"\\<exists>k. N = 8 * k + 5\"\nproof -\n  obtain k where \"N = 8 * (N div 8) + (N mod 8)\" \n    by auto\n  then have \"N = 8 * (N div 8) + 5\" \n    using assms by simp\n  then show ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "average_value_sumV2": {"skill_name": "average_value_sumV2", "marker": "lemma average_value_sum:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" \"total = a + b\"\n  shows \"total / real count = (a / real count) + (b / real count)\"\n  using assms by (simp add: field_simps)", "description": "-", "full_code": "lemma average_value_sum:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" \"total = a + b\"\n  shows \"total / real count = (a / real count) + (b / real count)\"\n  using assms by (simp add: field_simps)", "origin": "average_value", "update_count": 0}, "average_value_nonneg": {"skill_name": "average_value_nonneg", "marker": "lemma average_value_nonneg:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" \"total \\<ge> 0\"\n  shows \"total / real count \\<ge> 0\"\nproof -\n  have \"total / real count = (total / (real_of_nat count))\" using assms(1) by simp\n  also have \"... \\<ge> 0\" using assms(2) by auto\n  finally show ?thesis by (metis \\<open>0 \\<le> total / real count\\<close>)\nqed", "description": "-", "full_code": "lemma average_value_nonneg:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" \"total \\<ge> 0\"\n  shows \"total / real count \\<ge> 0\"\nproof -\n  have \"total / real count = (total / (real_of_nat count))\" using assms(1) by simp\n  also have \"... \\<ge> 0\" using assms(2) by auto\n  finally show ?thesis by (metis \\<open>0 \\<le> total / real count\\<close>)\nqed", "origin": "average_value", "update_count": 0}, "algebra_2varlineareq_parameterized": {"skill_name": "algebra_2varlineareq_parameterized", "marker": "theorem algebra_2varlineareq_parameterized:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel)\n  then have x_value_final: \"x = (b - a)\" by simp\n  have e_value: \"e = a - (b - a)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_parameterized:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel)\n  then have x_value_final: \"x = (b - a)\" by simp\n  have e_value: \"e = a - (b - a)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "find_valid_n": {"skill_name": "find_valid_n", "marker": "lemma find_valid_N:\n  fixes N :: nat and m :: nat\n  assumes \"N < 50\" and \"m < 2\"\n  shows \"N < 50\"\nproof -\n  have \"N < 50\" using assms(1) by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma find_valid_N:\n  fixes N :: nat and m :: nat\n  assumes \"N < 50\" and \"m < 2\"\n  shows \"N < 50\"\nproof -\n  have \"N < 50\" using assms(1) by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "find_valid_nV2": {"skill_name": "find_valid_nV2", "marker": "lemma find_valid_N:\n  fixes N :: nat and m :: nat\n  assumes \"N < 50\" and \"m < 2\"\n  shows \"N < 50 \\<and> m < 2\"\nproof -\n  have \"N < 50\" using assms(1) by simp\n  have \"m < 2\" using assms(2) by simp\n  thus ?thesis \n    by (simp add: \\<open>N < 50\\<close> \\<open>m < 2\\<close>)\nqed", "description": "-", "full_code": "lemma find_valid_N:\n  fixes N :: nat and m :: nat\n  assumes \"N < 50\" and \"m < 2\"\n  shows \"N < 50 \\<and> m < 2\"\nproof -\n  have \"N < 50\" using assms(1) by simp\n  have \"m < 2\" using assms(2) by simp\n  thus ?thesis \n    by (simp add: \\<open>N < 50\\<close> \\<open>m < 2\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "average_value_extendedV3": {"skill_name": "average_value_extendedV3", "marker": "lemma average_value_extended:\n  fixes total :: real and count :: nat and dimensions :: nat\n  assumes \"count > 0\" and \"dimensions > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  using assms by simp", "description": "-", "full_code": "lemma average_value_extended:\n  fixes total :: real and count :: nat and dimensions :: nat\n  assumes \"count > 0\" and \"dimensions > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  using assms by simp", "origin": "average_value", "update_count": 0}, "linear_equation_solutionV8": {"skill_name": "linear_equation_solutionV8", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = q\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*q) / n\"\nproof -\n  have \"n*b = p - m*q\" using h0 h1 by simp\n  then have \"b = (p - m*q) / n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = q\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*q) / n\"\nproof -\n  have \"n*b = p - m*q\" using h0 h1 by simp\n  then have \"b = (p - m*q) / n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_solutionV9": {"skill_name": "linear_equation_solutionV9", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_val\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a_val) / n\"\nproof -\n  have \"n*b = p - m*a\"\n    using h0 by simp\n  then have \"b = (p - m*a_val) / n\"\n    by (metis h1 h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_val\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a_val) / n\"\nproof -\n  have \"n*b = p - m*a\"\n    using h0 by simp\n  then have \"b = (p - m*a_val) / n\"\n    by (metis h1 h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "square_expansion_generalizedV3": {"skill_name": "square_expansion_generalizedV3", "marker": "lemma square_expansion_generalized:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\n  by (simp add: power2_diff)", "description": "-", "full_code": "lemma square_expansion_generalized:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\n  by (simp add: power2_diff)", "origin": "square_expansion", "update_count": 0}, "express_n": {"skill_name": "express_n", "marker": "lemma express_N:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\"\n    by (simp add: assms)\n  also have \"... = (8 * k mod 8 + 5 mod 8)\"\n    by auto\n  also have \"... = (0 + 5 mod 8)\"\n    by auto\n  also have \"... = 5\"\n    by auto\n  finally show \"N mod 8 = 5\" .\nqed", "description": "-", "full_code": "lemma express_N:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\"\n    by (simp add: assms)\n  also have \"... = (8 * k mod 8 + 5 mod 8)\"\n    by auto\n  also have \"... = (0 + 5 mod 8)\"\n    by auto\n  also have \"... = 5\"\n    by auto\n  finally show \"N mod 8 = 5\" .\nqed", "origin": "do_request", "update_count": 0}, "express_nV2": {"skill_name": "express_nV2", "marker": "lemma express_N:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5) mod 8\" by auto\n  also have \"... = 5\" by simp\n  finally show \"N mod 8 = 5\" by simp\nqed", "description": "-", "full_code": "lemma express_N:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5) mod 8\" by auto\n  also have \"... = 5\" by simp\n  finally show \"N mod 8 = 5\" by simp\nqed", "origin": "do_request", "update_count": 0}, "average_combination": {"skill_name": "average_combination", "marker": "lemma average_combination:\n  fixes total1 total2 :: real and count1 count2 :: nat\n  assumes \"count1 > 0\" \"count2 > 0\"\n  shows \"(total1 + total2) / (real count1 + real count2) = \n         (total1 / real count1) * (count1 / (count1 + count2)) + \n         (total2 / real count2) * (count2 / (count1 + count2))\"\nproof -\n  have \"real (count1 + count2) = real count1 + real count2\" by simp\n  also have \"... > 0\" using assms by simp\n  then show ?thesis\n    by (smt (verit) add_divide_distrib assms(1) assms(2) calculation divide_eq_eq of_nat_0_eq_iff order_less_imp_not_eq times_divide_eq_right)\nqed", "description": "-", "full_code": "lemma average_combination:\n  fixes total1 total2 :: real and count1 count2 :: nat\n  assumes \"count1 > 0\" \"count2 > 0\"\n  shows \"(total1 + total2) / (real count1 + real count2) = \n         (total1 / real count1) * (count1 / (count1 + count2)) + \n         (total2 / real count2) * (count2 / (count1 + count2))\"\nproof -\n  have \"real (count1 + count2) = real count1 + real count2\" by simp\n  also have \"... > 0\" using assms by simp\n  then show ?thesis\n    by (smt (verit) add_divide_distrib assms(1) assms(2) calculation divide_eq_eq of_nat_0_eq_iff order_less_imp_not_eq times_divide_eq_right)\nqed", "origin": "average_value", "update_count": 0}, "average_contribution": {"skill_name": "average_contribution", "marker": "lemma average_contribution:\n  fixes total_sum :: real and total_count :: nat\n  assumes \"total_count > 0\"\n  shows \"total_sum / real total_count = (total_sum / (real_of_nat total_count))\"\n  using assms by auto", "description": "-", "full_code": "lemma average_contribution:\n  fixes total_sum :: real and total_count :: nat\n  assumes \"total_count > 0\"\n  shows \"total_sum / real total_count = (total_sum / (real_of_nat total_count))\"\n  using assms by auto", "origin": "average_value", "update_count": 0}, "solve_linear_equationV3": {"skill_name": "solve_linear_equationV3", "marker": "lemma solve_linear_equation:\n  fixes a b :: real\n  assumes \"a + b = 0\"\n  shows \"b = -a\"\nproof -\n  have \"b = -a\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma solve_linear_equation:\n  fixes a b :: real\n  assumes \"a + b = 0\"\n  shows \"b = -a\"\nproof -\n  have \"b = -a\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_extendedV11": {"skill_name": "mathd_algebra_109_extendedV11", "marker": "lemma mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes \"3 * a + 2 * b = 12\" \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using assms(1) by simp\n  have \"3 * 4 + 2 * b = 12\" using assms(2) by (metis assms(1) dbl_inc_simps(3) dbl_simps(3))\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis `12 + 2 * b = 12` add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "lemma mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes \"3 * a + 2 * b = 12\" \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using assms(1) by simp\n  have \"3 * 4 + 2 * b = 12\" using assms(2) by (metis assms(1) dbl_inc_simps(3) dbl_simps(3))\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis `12 + 2 * b = 12` add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "extended_square_expansion": {"skill_name": "extended_square_expansion", "marker": "lemma extended_square_expansion:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2*a*b + b^2 + 2*a*c - 2*b*c + c^2\"\nproof -\n  have \"(a - b + c)^2 = (a - b)^2 + 2*(a - b)*c + c^2\"\n    by sos\n  also have \"... = (a^2 - 2*a*b + b^2) + 2*(a - b)*c + c^2\" \n    by sos\n  also have \"... = a^2 - 2*a*b + b^2 + 2*a*c - 2*b*c + c^2\" \n    by sos\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma extended_square_expansion:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2*a*b + b^2 + 2*a*c - 2*b*c + c^2\"\nproof -\n  have \"(a - b + c)^2 = (a - b)^2 + 2*(a - b)*c + c^2\"\n    by sos\n  also have \"... = (a^2 - 2*a*b + b^2) + 2*(a - b)*c + c^2\" \n    by sos\n  also have \"... = a^2 - 2*a*b + b^2 + 2*a*c - 2*b*c + c^2\" \n    by sos\n  finally show ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "mod_simplification": {"skill_name": "mod_simplification", "marker": "lemma mod_simplification:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  have \"(a + c) mod m = (b + m * (a div m) + c) mod m\"\n    by (metis \\<open>a = b + m * (a div m)\\<close> add.commute add.left_commute group_cancel.add1 mod_add_cong)\n  also have \"... = (b + c + m * (a div m)) mod m\"\n    by (simp add: algebra_simps)\n  also have \"... = (b + c) mod m\" \n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_simplification:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  have \"(a + c) mod m = (b + m * (a div m) + c) mod m\"\n    by (metis \\<open>a = b + m * (a div m)\\<close> add.commute add.left_commute group_cancel.add1 mod_add_cong)\n  also have \"... = (b + c + m * (a div m)) mod m\"\n    by (simp add: algebra_simps)\n  also have \"... = (b + c) mod m\" \n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_evolvedV14": {"skill_name": "mathd_algebra_109_evolvedV14", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  hence \"2 * b = 0\" by (metis add_cancel_right_right)\n  thus ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  hence \"2 * b = 0\" by (metis add_cancel_right_right)\n  thus ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_system_of_equations": {"skill_name": "solve_system_of_equations", "marker": "lemma solve_system_of_equations:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = 12\"\n    and h1: \"a = 4\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have \"b = (12 - 3 * a) / 2\" using h0 by (simp add: h1)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma solve_system_of_equations:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = 12\"\n    and h1: \"a = 4\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have \"b = (12 - 3 * a) / 2\" using h0 by (simp add: h1)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "integer_divisibility": {"skill_name": "integer_divisibility", "marker": "lemma integer_divisibility:\n  fixes a b :: int\n  assumes \"b > 0\" \"a mod b = 0\"\n  shows \"\\<exists>k. a = k * b\"\nproof -\n  obtain k where \"a = k * b + 0\" \n    using assms(2) by fastforce\n  then have \"a = k * b\" by (simp add: add_0)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma integer_divisibility:\n  fixes a b :: int\n  assumes \"b > 0\" \"a mod b = 0\"\n  shows \"\\<exists>k. a = k * b\"\nproof -\n  obtain k where \"a = k * b + 0\" \n    using assms(2) by fastforce\n  then have \"a = k * b\" by (simp add: add_0)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "integer_divisibilityV2": {"skill_name": "integer_divisibilityV2", "marker": "lemma integer_divisibility:\n  fixes a b :: int\n  assumes \"b > 0\" \"a mod b = 0\"\n  shows \"\\<exists>k. a = k * b\"\nproof -\n  obtain k where \"a = k * b + (a mod b)\" \n    by (metis add_cancel_left_right assms(2) mult.commute zmod_eq_0D)\n  then have \"a mod b = 0\" by (metis assms(2))\n  hence \"a = k * b\" using assms(2) by (metis \\<open>a = k * b + a mod b\\<close> add.commute add.left_commute add_cancel_right_right add_left_imp_eq add_right_imp_eq mult.commute)\n  thus ?thesis by (metis assms(2) mod_eq_0_iff_dvd)\nqed", "description": "-", "full_code": "lemma integer_divisibility:\n  fixes a b :: int\n  assumes \"b > 0\" \"a mod b = 0\"\n  shows \"\\<exists>k. a = k * b\"\nproof -\n  obtain k where \"a = k * b + (a mod b)\" \n    by (metis add_cancel_left_right assms(2) mult.commute zmod_eq_0D)\n  then have \"a mod b = 0\" by (metis assms(2))\n  hence \"a = k * b\" using assms(2) by (metis \\<open>a = k * b + a mod b\\<close> add.commute add.left_commute add_cancel_right_right add_left_imp_eq add_right_imp_eq mult.commute)\n  thus ?thesis by (metis assms(2) mod_eq_0_iff_dvd)\nqed", "origin": "do_request", "update_count": 0}, "square_expansionV7": {"skill_name": "square_expansionV7", "marker": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (a)^2 - 2*a*b + (b)^2\" by (simp add: power2_eq_square algebra_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (a)^2 - 2*a*b + (b)^2\" by (simp add: power2_eq_square algebra_simps)\n  then show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "integer_divisibilityV3": {"skill_name": "integer_divisibilityV3", "marker": "lemma integer_divisibility:\n  fixes a b :: int\n  assumes \"b > 0\" \"a mod b = 0\"\n  shows \"\\<exists>k. a = k * b\"\nproof -\n  let ?k = \"a div b\"  \n  have \"a = ?k * b + (a mod b)\" by (metis div_mult_mod_eq)\n  from assms(2) have \"a mod b = 0\" by simp\n  then have \"a = ?k * b + 0\" by auto\n  thus ?thesis by auto  \nqed", "description": "-", "full_code": "lemma integer_divisibility:\n  fixes a b :: int\n  assumes \"b > 0\" \"a mod b = 0\"\n  shows \"\\<exists>k. a = k * b\"\nproof -\n  let ?k = \"a div b\"  \n  have \"a = ?k * b + (a mod b)\" by (metis div_mult_mod_eq)\n  from assms(2) have \"a mod b = 0\" by simp\n  then have \"a = ?k * b + 0\" by auto\n  thus ?thesis by auto  \nqed", "origin": "do_request", "update_count": 0}, "integer_divisibilityV4": {"skill_name": "integer_divisibilityV4", "marker": "lemma integer_divisibility:\n  fixes a b :: int\n  assumes \"b > 0\" \"a mod b = 0\"\n  shows \"\\<exists>k. a = k * b\"\nproof -\n  have \"a mod b = 0 \\<Longrightarrow> \\<exists>k. a = k * b\" \n    by auto\n  then obtain k where \"a = k * b\" using assms(2) by blast\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma integer_divisibility:\n  fixes a b :: int\n  assumes \"b > 0\" \"a mod b = 0\"\n  shows \"\\<exists>k. a = k * b\"\nproof -\n  have \"a mod b = 0 \\<Longrightarrow> \\<exists>k. a = k * b\" \n    by auto\n  then obtain k where \"a = k * b\" using assms(2) by blast\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "integer_divisibilityV5": {"skill_name": "integer_divisibilityV5", "marker": "lemma integer_divisibility:\n  fixes a b :: int\n  assumes \"b > 0\" \"a mod b = 0\"\n  shows \"\\<exists>k. a = k * b\"\nproof -\n  obtain k where \"a = k * b + a mod b\" by (metis add_cancel_left_right assms(2) mult.commute zmod_eq_0D)\n  then have \"a = k * b + 0\" using assms(2) by simp\n  thus ?thesis by (metis add_0_right)\nqed", "description": "-", "full_code": "lemma integer_divisibility:\n  fixes a b :: int\n  assumes \"b > 0\" \"a mod b = 0\"\n  shows \"\\<exists>k. a = k * b\"\nproof -\n  obtain k where \"a = k * b + a mod b\" by (metis add_cancel_left_right assms(2) mult.commute zmod_eq_0D)\n  then have \"a = k * b + 0\" using assms(2) by simp\n  thus ?thesis by (metis add_0_right)\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV8": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV8", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: \"'a :: ring_1\"\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e=11 \\<and> x= (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by (metis add.commute add_diff_cancel_left add_diff_cancel_right add_left_imp_eq add_minus_cancel add_right_imp_eq diff_conv_add_uminus group_cancel.add1 group_cancel.add2 group_cancel.sub1 h0 h1 mult_2 mult_minus_right numeral_plus_one one_add_one one_plus_numeral semiring_norm(3) semiring_norm(5) uminus_add_conv_diff)\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: \"'a :: ring_1\"\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e=11 \\<and> x= (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by (metis add.commute add_diff_cancel_left add_diff_cancel_right add_left_imp_eq add_minus_cancel add_right_imp_eq diff_conv_add_uminus group_cancel.add1 group_cancel.add2 group_cancel.sub1 h0 h1 mult_2 mult_minus_right numeral_plus_one one_add_one one_plus_numeral semiring_norm(3) semiring_norm(5) uminus_add_conv_diff)\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "optimization_minimum": {"skill_name": "optimization_minimum", "marker": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 + (x * y)^2 \\<ge> 0\"\n  shows \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\nproof -\n  have \"x^2 + y^2 + (x * y)^2 \\<ge> 0\" using assms by simp\n  then have \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 0 + 1\" \n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 + (x * y)^2 \\<ge> 0\"\n  shows \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\nproof -\n  have \"x^2 + y^2 + (x * y)^2 \\<ge> 0\" using assms by simp\n  then have \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 0 + 1\" \n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "optimization_minimumV2": {"skill_name": "optimization_minimumV2", "marker": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 + (x * y)^2 \\<ge> 0\"\n  shows \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\nproof -\n  have \"x^2 + y^2 + (x * y)^2 + 1 = (x^2 + y^2 + (x * y)^2) + 1\"\n    by simp\n  moreover have \"x^2 + y^2 + (x * y)^2 \\<ge> 0\" using assms by simp\n  ultimately show \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\n    by auto\nqed", "description": "-", "full_code": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 + (x * y)^2 \\<ge> 0\"\n  shows \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\nproof -\n  have \"x^2 + y^2 + (x * y)^2 + 1 = (x^2 + y^2 + (x * y)^2) + 1\"\n    by simp\n  moreover have \"x^2 + y^2 + (x * y)^2 \\<ge> 0\" using assms by simp\n  ultimately show \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "optimization_minimumV3": {"skill_name": "optimization_minimumV3", "marker": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 + (x * y)^2 \\<ge> 0\"\n  shows \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\nproof -\n  have \"x^2 + y^2 + (x * y)^2 \\<ge> 0\" using assms by assumption\n  then have \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 0 + 1\" \n    by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 + (x * y)^2 \\<ge> 0\"\n  shows \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\nproof -\n  have \"x^2 + y^2 + (x * y)^2 \\<ge> 0\" using assms by assumption\n  then have \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 0 + 1\" \n    by simp\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "optimization_minimumV4": {"skill_name": "optimization_minimumV4", "marker": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 + (x * y)^2 \\<ge> 0\"\n  shows \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\nproof -\n  have \"x^2 + y^2 + (x * y)^2 \\<ge> 0\" using assms by auto\n  then show \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\n    by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 + (x * y)^2 \\<ge> 0\"\n  shows \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\nproof -\n  have \"x^2 + y^2 + (x * y)^2 \\<ge> 0\" using assms by auto\n  then show \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\n    by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "optimization_minimumV5": {"skill_name": "optimization_minimumV5", "marker": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 + (x * y)^2 \\<ge> 0\"\n  shows \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\nproof -\n  from assms have \"x^2 + y^2 + (x * y)^2 \\<ge> 0\" \n    by simp\n  then have \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 0 + 1\"\n    by auto\n  thus ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 + (x * y)^2 \\<ge> 0\"\n  shows \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 1\"\nproof -\n  from assms have \"x^2 + y^2 + (x * y)^2 \\<ge> 0\" \n    by simp\n  then have \"x^2 + y^2 + (x * y)^2 + 1 \\<ge> 0 + 1\"\n    by auto\n  thus ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "real_number_properties": {"skill_name": "real_number_properties", "marker": "lemma real_number_properties:\n  fixes x y z :: real\n  shows \"x + y = y + x\" \"x * y = y * x\" \"x + (y + z) = (x + y) + z\"\nproof -\n  show \"x + y = y + x\" by (simp add: add.commute)\n  show \"x * y = y * x\" by (simp add: mult.commute)\n  show \"x + (y + z) = (x + y) + z\" by (simp add: add.assoc)\nqed", "description": "-", "full_code": "lemma real_number_properties:\n  fixes x y z :: real\n  shows \"x + y = y + x\" \"x * y = y * x\" \"x + (y + z) = (x + y) + z\"\nproof -\n  show \"x + y = y + x\" by (simp add: add.commute)\n  show \"x * y = y * x\" by (simp add: mult.commute)\n  show \"x + (y + z) = (x + y) + z\" by (simp add: add.assoc)\nqed", "origin": "do_request", "update_count": 0}, "real_number_propertiesV2": {"skill_name": "real_number_propertiesV2", "marker": "lemma real_number_properties:\n  fixes x y z :: real\n  shows \"x + y = y + x\" \"x * y = y * x\" \"x + (y + z) = (x + y) + z\"\nproof -\n  show \"x + y = y + x\" by auto\n  show \"x * y = y * x\" by auto\n  show \"x + (y + z) = (x + y) + z\" by auto\nqed", "description": "-", "full_code": "lemma real_number_properties:\n  fixes x y z :: real\n  shows \"x + y = y + x\" \"x * y = y * x\" \"x + (y + z) = (x + y) + z\"\nproof -\n  show \"x + y = y + x\" by auto\n  show \"x * y = y * x\" by auto\n  show \"x + (y + z) = (x + y) + z\" by auto\nqed", "origin": "do_request", "update_count": 0}, "amc12a_2013_p8_evolvedV4": {"skill_name": "amc12a_2013_p8_evolvedV4", "marker": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  hence \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using `x - y = (2/y - 2/x)` by sos\n  then have \"x * y * (x - y) = 2 * (x - y)\" by sos\n  then show \"x * y = 2\" \n    using h2 by sos\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  hence \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using `x - y = (2/y - 2/x)` by sos\n  then have \"x * y * (x - y) = 2 * (x - y)\" by sos\n  then show \"x * y = 2\" \n    using h2 by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "algebra_2varlineareqV4": {"skill_name": "algebra_2varlineareqV4", "marker": "theorem algebra_2varlineareq:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (a - x) \\<and> x = (b - a)/1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using eq_simplified by auto\n  then have e_value: \"e = a - (b - a)\" using e_expr x_value by simp\n  then show ?thesis using x_value e_value by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (a - x) \\<and> x = (b - a)/1\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using eq_simplified by auto\n  then have e_value: \"e = a - (b - a)\" using e_expr x_value by simp\n  then show ?thesis using x_value e_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "real_number_propertiesV3": {"skill_name": "real_number_propertiesV3", "marker": "lemma real_number_properties:\n  fixes x y z :: real\n  shows \"x + y = y + x\" \"x * y = y * x\" \"x + (y + z) = (x + y) + z\"\nproof -\n  show \"x + y = y + x\" \n    by auto\n  show \"x * y = y * x\" \n    by auto\n  show \"x + (y + z) = (x + y) + z\"\n    by auto\nqed", "description": "-", "full_code": "lemma real_number_properties:\n  fixes x y z :: real\n  shows \"x + y = y + x\" \"x * y = y * x\" \"x + (y + z) = (x + y) + z\"\nproof -\n  show \"x + y = y + x\" \n    by auto\n  show \"x * y = y * x\" \n    by auto\n  show \"x + (y + z) = (x + y) + z\"\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "solve_linear_equationV4": {"skill_name": "solve_linear_equationV4", "marker": "lemma solve_linear_equation:\n  fixes a b :: real\n  assumes \"a + b = 0\"\n  shows \"b = -a\"\nproof -\n  have \"b = 0 - a\" using assms by simp\n  then show \"b = -a\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma solve_linear_equation:\n  fixes a b :: real\n  assumes \"a + b = 0\"\n  shows \"b = -a\"\nproof -\n  have \"b = 0 - a\" using assms by simp\n  then show \"b = -a\" by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "real_div_nat": {"skill_name": "real_div_nat", "marker": "lemma real_div_nat:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = total / (real_of_nat count)\"\nproof -\n  have \"real count = real_of_nat count\" by (simp)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma real_div_nat:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = total / (real_of_nat count)\"\nproof -\n  have \"real count = real_of_nat count\" by (simp)\n  then show ?thesis by simp\nqed", "origin": "average_value", "update_count": 0}, "division_by_natV3": {"skill_name": "division_by_natV3", "marker": "lemma division_by_nat:\n  fixes x :: real and n :: nat\n  assumes \"n > 0\"\n  shows \"x / real n = x / (real_of_nat n)\"\nproof -\n  have \"real n = real_of_nat n\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma division_by_nat:\n  fixes x :: real and n :: nat\n  assumes \"n > 0\"\n  shows \"x / real n = x / (real_of_nat n)\"\nproof -\n  have \"real n = real_of_nat n\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "average_value", "update_count": 0}, "average_value_with_weightV2": {"skill_name": "average_value_with_weightV2", "marker": "lemma average_value_with_weight:\n  fixes total :: real and count :: nat and weight :: real\n  assumes \"count > 0\" \"weight > 0\"\n  shows \"(total * weight) / real count = (total * weight) / (real_of_nat count)\"\n  using assms by simp", "description": "-", "full_code": "lemma average_value_with_weight:\n  fixes total :: real and count :: nat and weight :: real\n  assumes \"count > 0\" \"weight > 0\"\n  shows \"(total * weight) / real count = (total * weight) / (real_of_nat count)\"\n  using assms by simp", "origin": "average_value", "update_count": 0}, "negative_thirteen_times_x": {"skill_name": "negative_thirteen_times_x", "marker": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  also have \"... = -(169 - 13 * sqrt 131) / 4\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  also have \"... = -(169 - 13 * sqrt 131) / 4\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "negative_thirteen_times_xV2": {"skill_name": "negative_thirteen_times_xV2", "marker": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  finally show \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  finally show \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\" by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "negative_thirteen_times_xV3": {"skill_name": "negative_thirteen_times_xV3", "marker": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" by simp\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by (simp)\n  finally show \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" by simp\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by (simp)\n  finally show \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\" by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "negative_thirteen_times_xV4": {"skill_name": "negative_thirteen_times_xV4", "marker": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"(-13 * ((13 - sqrt 131) / 4)) = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  also have \"... = -(169 - 13 * sqrt 131) / 4\" by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"(-13 * ((13 - sqrt 131) / 4)) = (-13 * (13 - sqrt 131)) / 4\" by (simp add: field_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by simp\n  also have \"... = -(169 - 13 * sqrt 131) / 4\" by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "negative_thirteen_times_xV5": {"skill_name": "negative_thirteen_times_xV5", "marker": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have left_side: \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" by simp\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by (simp add: algebra_simps)\n  finally have \" -13 * ((13 - sqrt 131) / 4) = (-169 + 13 * sqrt 131) / 4\" .\n  have right_side: \"-(169 - 13 * sqrt 131) / 4 = (-169 + 13 * sqrt 131) / 4\" by simp\n  thus ?thesis by (simp add: left_side right_side)\nqed", "description": "-", "full_code": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have left_side: \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" by simp\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" by (simp add: algebra_simps)\n  finally have \" -13 * ((13 - sqrt 131) / 4) = (-169 + 13 * sqrt 131) / 4\" .\n  have right_side: \"-(169 - 13 * sqrt 131) / 4 = (-169 + 13 * sqrt 131) / 4\" by simp\n  thus ?thesis by (simp add: left_side right_side)\nqed", "origin": "do_request", "update_count": 0}, "negative_thirteen_times_xV6": {"skill_name": "negative_thirteen_times_xV6", "marker": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" \n    by (simp add: field_simps)\n  also have \"... = (-13 * 13 + 13 * sqrt 131) / 4\" \n    by (simp add: algebra_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" \n    by simp\n  also have \"... = -(169 - 13 * sqrt 131) / 4\" \n    by (simp add: algebra_simps)\n  finally show \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\" \n    by simp\nqed", "description": "-", "full_code": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" \n    by (simp add: field_simps)\n  also have \"... = (-13 * 13 + 13 * sqrt 131) / 4\" \n    by (simp add: algebra_simps)\n  also have \"... = (-169 + 13 * sqrt 131) / 4\" \n    by simp\n  also have \"... = -(169 - 13 * sqrt 131) / 4\" \n    by (simp add: algebra_simps)\n  finally show \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\" \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "negative_thirteen_times_xV7": {"skill_name": "negative_thirteen_times_xV7", "marker": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have LHS: \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" \n    by (simp add: field_simps)\n  have step1: \"-13 * (13 - sqrt 131) = -169 + 13 * sqrt 131\" \n    by simp\n  have LHS_final: \"(-13 * (13 - sqrt 131)) / 4 = (-169 + 13 * sqrt 131) / 4\" \n    using LHS step1 by simp\n  have RHS: \"-(169 - 13 * sqrt 131) = -169 + 13 * sqrt 131\" \n    by simp\n  have RHS_final: \"-(169 - 13 * sqrt 131) / 4 = (-169 + 13 * sqrt 131) / 4\" \n    by (simp add: RHS)\n  show ?thesis \n    by (simp add: LHS_final RHS_final)\nqed", "description": "-", "full_code": "lemma negative_thirteen_times_x:\n  fixes x :: real\n  shows \"-13 * ((13 - sqrt 131) / 4) = -(169 - 13 * sqrt 131) / 4\"\nproof -\n  have LHS: \"-13 * ((13 - sqrt 131) / 4) = (-13 * (13 - sqrt 131)) / 4\" \n    by (simp add: field_simps)\n  have step1: \"-13 * (13 - sqrt 131) = -169 + 13 * sqrt 131\" \n    by simp\n  have LHS_final: \"(-13 * (13 - sqrt 131)) / 4 = (-169 + 13 * sqrt 131) / 4\" \n    using LHS step1 by simp\n  have RHS: \"-(169 - 13 * sqrt 131) = -169 + 13 * sqrt 131\" \n    by simp\n  have RHS_final: \"-(169 - 13 * sqrt 131) / 4 = (-169 + 13 * sqrt 131) / 4\" \n    by (simp add: RHS)\n  show ?thesis \n    by (simp add: LHS_final RHS_final)\nqed", "origin": "do_request", "update_count": 0}, "sum_of_squares_non_negativity": {"skill_name": "sum_of_squares_non_negativity", "marker": "lemma sum_of_squares_non_negativity:\n  fixes a b :: real\n  shows \"a^2 + b^2 >= 0\"\n  by (simp)", "description": "-", "full_code": "lemma sum_of_squares_non_negativity:\n  fixes a b :: real\n  shows \"a^2 + b^2 >= 0\"\n  by (simp)", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_coefficientsV3": {"skill_name": "square_expansion_with_coefficientsV3", "marker": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(c * a - d * b)^2 = c^2 * a^2 - 2 * c * d * a * b + d^2 * b^2\"\nproof -\n  have \"c^2 * a^2 - 2 * c * d * a * b + d^2 * b^2 = (c * a - d * b)^2\"\n    by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(c * a - d * b)^2 = c^2 * a^2 - 2 * c * d * a * b + d^2 * b^2\"\nproof -\n  have \"c^2 * a^2 - 2 * c * d * a * b + d^2 * b^2 = (c * a - d * b)^2\"\n    by sos\n  thus ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_generalizedV4": {"skill_name": "square_expansion_generalizedV4", "marker": "lemma square_expansion_generalized:\n  fixes a b c :: real\n  shows \"(a + b + c)^2 = a^2 + b^2 + c^2 + 2*(a*b + b*c + c*a)\"\nproof -\n  have \"(a + b + c) * (a + b + c) = (a + b + c)^2\" by sos\n  also have \"... = a^2 + (b + c)^2 + 2*a*(b + c)\" by sos\n  also have \"... = a^2 + (b^2 + 2*b*c + c^2) + 2*a*b + 2*a*c\" by sos\n  finally show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion_generalized:\n  fixes a b c :: real\n  shows \"(a + b + c)^2 = a^2 + b^2 + c^2 + 2*(a*b + b*c + c*a)\"\nproof -\n  have \"(a + b + c) * (a + b + c) = (a + b + c)^2\" by sos\n  also have \"... = a^2 + (b + c)^2 + 2*a*(b + c)\" by sos\n  also have \"... = a^2 + (b^2 + 2*b*c + c^2) + 2*a*b + 2*a*c\" by sos\n  finally show ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "solve_linear_equation_with_fixed_a": {"skill_name": "solve_linear_equation_with_fixed_a", "marker": "lemma solve_linear_equation_with_fixed_a:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = 12\" \n    and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  then have \"2 * b = 0\" by (metis add_cancel_right_right)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma solve_linear_equation_with_fixed_a:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = 12\" \n    and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  then have \"2 * b = 0\" by (metis add_cancel_right_right)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_solve_system": {"skill_name": "mathd_algebra_solve_system", "marker": "theorem mathd_algebra_solve_system:\n  fixes a b :: real\n  assumes h0: \"3*a + 2*b = 12\"\n    and h1: \"a = 4\"\n  shows \"b = (12 - 3*4) / 2\"\nproof -\n  have \"3*a + 2*b = 12\" using h0 by simp\n  then have \"3*4 + 2*b = 12\" using h1 by simp\n  then have \"12 + 2*b = 12\" by (simp add: algebra_simps)\n  then have \"2*b = 0\" by (metis add_cancel_right_right)\n  then show ?thesis using `2*b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_solve_system:\n  fixes a b :: real\n  assumes h0: \"3*a + 2*b = 12\"\n    and h1: \"a = 4\"\n  shows \"b = (12 - 3*4) / 2\"\nproof -\n  have \"3*a + 2*b = 12\" using h0 by simp\n  then have \"3*4 + 2*b = 12\" using h1 by simp\n  then have \"12 + 2*b = 12\" by (simp add: algebra_simps)\n  then have \"2*b = 0\" by (metis add_cancel_right_right)\n  then show ?thesis using `2*b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109V2": {"skill_name": "mathd_algebra_109V2", "marker": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by simp\n  then have \"2 * b = 0\" by (metis add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by simp\n  then have \"2 * b = 0\" by (metis add_cancel_right_right)\n  show ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "substitute_and_solve": {"skill_name": "substitute_and_solve", "marker": "lemma substitute_and_solve:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = k\"\n  shows \"b = (c - 3 * k) / 2\"\nproof -\n  have \"3 * a + 2 * b = c\" using h0 by simp\n  then have \"3 * k + 2 * b = c\" using h1 by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma substitute_and_solve:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = k\"\n  shows \"b = (c - 3 * k) / 2\"\nproof -\n  have \"3 * a + 2 * b = c\" using h0 by simp\n  then have \"3 * k + 2 * b = c\" using h1 by simp\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109V3": {"skill_name": "mathd_algebra_109V3", "marker": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by simp\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sqrt_squareV2": {"skill_name": "sqrt_squareV2", "marker": "lemma sqrt_square:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  then show ?thesis by simp\nqed", "description": "", "full_code": "lemma sqrt_square:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  then show ?thesis by simp\nqed", "origin": "data/full_data/debug/valid_rand/mathd_algebra_31.json_v27", "update_count": -1}, "mod_arithmeticV2": {"skill_name": "mod_arithmeticV2", "marker": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a mod b = c\"\n  shows \"\\<exists>k. a = b * k + c\"\nproof -\n  obtain k where \"a = b * k + c + (a div b) * b\" \n    using assms by fastforce\n  then show ?thesis \n    by (metis assms div_mult_mod_eq mult.commute)\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a mod b = c\"\n  shows \"\\<exists>k. a = b * k + c\"\nproof -\n  obtain k where \"a = b * k + c + (a div b) * b\" \n    using assms by fastforce\n  then show ?thesis \n    by (metis assms div_mult_mod_eq mult.commute)\nqed", "origin": "do_request", "update_count": 0}, "square_expansion_with_constant": {"skill_name": "square_expansion_with_constant", "marker": "lemma square_expansion_with_constant:\n  fixes a b c :: real\n  shows \"(a - (b + c))^2 = a^2 - 2*a*(b + c) + (b + c)^2\"\nproof -\n  have \"a - (b + c) = a - b - c\" by simp\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion_with_constant:\n  fixes a b c :: real\n  shows \"(a - (b + c))^2 = a^2 - 2*a*(b + c) + (b + c)^2\"\nproof -\n  have \"a - (b + c) = a - b - c\" by simp\n  then show ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_factor": {"skill_name": "square_expansion_with_factor", "marker": "lemma square_expansion_with_factor:\n  fixes a b k :: real\n  assumes \"k \\<noteq> 0\"\n  shows \"(k * (a - b))^2 = k^2 * (a^2 - 2*a*b + b^2)\"\nproof -\n  have \"(k * (a - b))^2 = k^2 * (a - b)^2\" by (simp add: power2_eq_square)\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion_with_factor:\n  fixes a b k :: real\n  assumes \"k \\<noteq> 0\"\n  shows \"(k * (a - b))^2 = k^2 * (a^2 - 2*a*b + b^2)\"\nproof -\n  have \"(k * (a - b))^2 = k^2 * (a - b)^2\" by (simp add: power2_eq_square)\n  then show ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "average_value_general": {"skill_name": "average_value_general", "marker": "lemma average_value_general:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = total / (real_of_nat count)\"\nproof -\n  have \"real_of_nat count > 0\" using assms by (simp)\n  then show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma average_value_general:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = total / (real_of_nat count)\"\nproof -\n  have \"real_of_nat count > 0\" using assms by (simp)\n  then show ?thesis by (simp add: field_simps)\nqed", "origin": "average_value", "update_count": 0}, "square_identity": {"skill_name": "square_identity", "marker": "lemma square_identity:\n  fixes a b :: real\n  shows \"a^2 - b^2 = (a - b) * (a + b)\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma square_identity:\n  fixes a b :: real\n  shows \"a^2 - b^2 = (a - b) * (a + b)\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  thus ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "mod_simplificationV2": {"skill_name": "mod_simplificationV2", "marker": "lemma mod_simplification:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  have \"(a + c) mod m = (b + m * (a div m) + c) mod m\"\n    by (metis \\<open>a = b + m * (a div m)\\<close> add.commute add.left_commute mod_add_cong)\n  also have \"... = (b + c + m * (a div m)) mod m\"\n    by (simp add: algebra_simps)\n  also have \"... = (b + c) mod m\" \n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_simplification:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  have \"(a + c) mod m = (b + m * (a div m) + c) mod m\"\n    by (metis \\<open>a = b + m * (a div m)\\<close> add.commute add.left_commute mod_add_cong)\n  also have \"... = (b + c + m * (a div m)) mod m\"\n    by (simp add: algebra_simps)\n  also have \"... = (b + c) mod m\" \n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_evolvedV15": {"skill_name": "mathd_algebra_109_evolvedV15", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = (c - 3*a) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  hence \"12 + 2 * b = c\" by auto\n  have \"2 * b = c - 12\" by (metis \\<open>12 + 2 * b = c\\<close> add.commute add.left_commute add_diff_cancel add_diff_eq add_minus_cancel diff_conv_add_uminus diff_minus_eq_add group_cancel.neg1 h2 minus_diff_eq minus_equation_iff mult.commute mult_2 mult_2_right square_eq_iff uminus_add_conv_diff verit_minus_simplify(4))\n  show ?thesis using `2 * b = c - 12` by (smt (verit) \\<open>12 + 2 * b = c\\<close> add_cancel_right_right add_right_imp_eq diff_divide_distrib h0 h2)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = (c - 3*a) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  hence \"12 + 2 * b = c\" by auto\n  have \"2 * b = c - 12\" by (metis \\<open>12 + 2 * b = c\\<close> add.commute add.left_commute add_diff_cancel add_diff_eq add_minus_cancel diff_conv_add_uminus diff_minus_eq_add group_cancel.neg1 h2 minus_diff_eq minus_equation_iff mult.commute mult_2 mult_2_right square_eq_iff uminus_add_conv_diff verit_minus_simplify(4))\n  show ?thesis using `2 * b = c - 12` by (smt (verit) \\<open>12 + 2 * b = c\\<close> add_cancel_right_right add_right_imp_eq diff_divide_distrib h0 h2)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "simplify_square_root_expressionV4": {"skill_name": "simplify_square_root_expressionV4", "marker": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have left_side: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    by (metis assms(2) nle_le real_sqrt_pow2 verit_comp_simplify1(3))\n  then show ?thesis using left_side by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have left_side: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    by (metis assms(2) nle_le real_sqrt_pow2 verit_comp_simplify1(3))\n  then show ?thesis using left_side by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_root_expressionV5": {"skill_name": "simplify_square_root_expressionV5", "marker": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have left_side: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    using assms(2) by auto\n  then have final_eq: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    using left_side by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have left_side: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    using assms(2) by auto\n  then have final_eq: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    using left_side by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_root_expressionV6": {"skill_name": "simplify_square_root_expressionV6", "marker": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have left_side: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (simp add: power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    by (metis assms(2) nle_le real_sqrt_pow2 verit_comp_simplify1(3))\n  then have \"a^2 - 2*a*sqrt b + (sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    by simp\n  then show ?thesis \n    using left_side by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have left_side: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (simp add: power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    by (metis assms(2) nle_le real_sqrt_pow2 verit_comp_simplify1(3))\n  then have \"a^2 - 2*a*sqrt b + (sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    by simp\n  then show ?thesis \n    using left_side by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_root_expressionV7": {"skill_name": "simplify_square_root_expressionV7", "marker": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have expansion: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    by (metis assms(2) nle_le real_sqrt_pow2 verit_comp_simplify1(3))\n  then have \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    using expansion by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have expansion: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    by (metis assms(2) nle_le real_sqrt_pow2 verit_comp_simplify1(3))\n  then have \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    using expansion by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_root_expressionV8": {"skill_name": "simplify_square_root_expressionV8", "marker": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have \"((a - sqrt b)^2) = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) power2_diff)\n  then have \"(sqrt b)^2 = b\"\n    by (metis assms(2) less_eq_real_def real_sqrt_pow2)\n  then show ?thesis \n    using `((a - sqrt b)^2) = a^2 - 2*a*sqrt b + (sqrt b)^2` by auto\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have \"((a - sqrt b)^2) = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (smt (verit) power2_diff)\n  then have \"(sqrt b)^2 = b\"\n    by (metis assms(2) less_eq_real_def real_sqrt_pow2)\n  then show ?thesis \n    using `((a - sqrt b)^2) = a^2 - 2*a*sqrt b + (sqrt b)^2` by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_square_generalized": {"skill_name": "sqrt_square_generalized", "marker": "lemma sqrt_square_generalized:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a * sqrt a = a\"\nusing assms by auto", "description": "-", "full_code": "lemma sqrt_square_generalized:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a * sqrt a = a\"\nusing assms by auto", "origin": "sqrt_squareV2", "update_count": 0}, "simplify_square_root_expressionV9": {"skill_name": "simplify_square_root_expressionV9", "marker": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have left_side: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (metis diff_add_eq power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    by (metis assms(2) nle_le real_sqrt_pow2 verit_comp_simplify1(3))\n  hence \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    using left_side by simp\n  thus ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have left_side: \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + (sqrt b)^2\"\n    by (metis diff_add_eq power2_diff)\n  have right_side: \"(sqrt b)^2 = b\"\n    by (metis assms(2) nle_le real_sqrt_pow2 verit_comp_simplify1(3))\n  hence \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\n    using left_side by simp\n  thus ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "linear_equation_with_known_variable": {"skill_name": "linear_equation_with_known_variable", "marker": "theorem linear_equation_with_known_variable:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  then have \"2 * b = c - 3 * d\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem linear_equation_with_known_variable:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  then have \"2 * b = c - 3 * d\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "non_negative_square_root": {"skill_name": "non_negative_square_root", "marker": "lemma non_negative_square_root:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a ^ 2 = a\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms by (simp add: power2_eq_square)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_negative_square_root:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a ^ 2 = a\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms by (simp add: power2_eq_square)\n  then show ?thesis by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_product": {"skill_name": "sqrt_product", "marker": "lemma sqrt_product:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a * b) = sqrt a * sqrt b\"\nproof -\n  have \"sqrt (a * b) * sqrt (a * b) = a * b\" using assms by auto\n  then show ?thesis using assms by (metis real_sqrt_mult)\nqed", "description": "-", "full_code": "lemma sqrt_product:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a * b) = sqrt a * sqrt b\"\nproof -\n  have \"sqrt (a * b) * sqrt (a * b) = a * b\" using assms by auto\n  then show ?thesis using assms by (metis real_sqrt_mult)\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_square_positive": {"skill_name": "sqrt_square_positive", "marker": "lemma sqrt_square_positive:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a > 0\" using assms by auto\n  then show ?thesis using sqrt_square_nonneg assms by simp\nqed", "description": "-", "full_code": "lemma sqrt_square_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  thus ?thesis by simp\nqed\n\nlemma sqrt_square_positive:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a > 0\" using assms by auto\n  then show ?thesis using sqrt_square_nonneg assms by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_square_general": {"skill_name": "sqrt_square_general", "marker": "lemma sqrt_square_general:\n  fixes a :: real\n  shows \"sqrt (x^2) = abs x\"\n  by (cases \"x >= 0\") (auto simp: sqrt_square_nonneg)", "description": "-", "full_code": "lemma sqrt_square_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  thus ?thesis by simp\nqed\n\nlemma sqrt_square_general:\n  fixes a :: real\n  shows \"sqrt (x^2) = abs x\"\n  by (cases \"x >= 0\") (auto simp: sqrt_square_nonneg)", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_sum_squaresV2": {"skill_name": "sqrt_sum_squaresV2", "marker": "lemma sqrt_sum_squares:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\"\n  shows \"sqrt (x^2 + y^2) * sqrt (x^2 + y^2) = x^2 + y^2\"\nproof -\n  have \"sqrt (x^2 + y^2) * sqrt (x^2 + y^2) = x^2 + y^2\" using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_sum_squares:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\"\n  shows \"sqrt (x^2 + y^2) * sqrt (x^2 + y^2) = x^2 + y^2\"\nproof -\n  have \"sqrt (x^2 + y^2) * sqrt (x^2 + y^2) = x^2 + y^2\" using assms by auto\n  thus ?thesis by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_productV2": {"skill_name": "sqrt_productV2", "marker": "lemma sqrt_product:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a * b) = sqrt a * sqrt b\"\nproof -\n  have \"sqrt (a * b) = sqrt a * sqrt b\" using assms by (metis real_sqrt_mult)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_product:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a * b) = sqrt a * sqrt b\"\nproof -\n  have \"sqrt (a * b) = sqrt a * sqrt b\" using assms by (metis real_sqrt_mult)\n  thus ?thesis by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_square_with_inequality": {"skill_name": "sqrt_square_with_inequality", "marker": "lemma sqrt_square_with_inequality:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt a * sqrt a = a \\<and> sqrt b * sqrt b = b\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms(1) by simp\n  moreover have \"sqrt b * sqrt b = b\" using assms(2) by simp\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_square_with_inequality:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt a * sqrt a = a \\<and> sqrt b * sqrt b = b\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms(1) by simp\n  moreover have \"sqrt b * sqrt b = b\" using assms(2) by simp\n  ultimately show ?thesis by auto\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_square_difference": {"skill_name": "sqrt_square_difference", "marker": "lemma sqrt_square_difference:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"(sqrt a - sqrt b) ^ 2 = a - 2 * sqrt a * sqrt b + b\"\nproof -\n  have \"(sqrt a - sqrt b) ^ 2 = (sqrt a)^2 - 2 * sqrt a * sqrt b + (sqrt b)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  also have \"... = a - 2 * sqrt a * sqrt b + b\" using assms by simp\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma sqrt_square_difference:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"(sqrt a - sqrt b) ^ 2 = a - 2 * sqrt a * sqrt b + b\"\nproof -\n  have \"(sqrt a - sqrt b) ^ 2 = (sqrt a)^2 - 2 * sqrt a * sqrt b + (sqrt b)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  also have \"... = a - 2 * sqrt a * sqrt b + b\" using assms by simp\n  finally show ?thesis .\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "amc12a_2013_p8_simpler": {"skill_name": "amc12a_2013_p8_simpler", "marker": "lemma amc12a_2013_p8_simpler:\n  fixes x y :: real\n  assumes \"x > 0\" \"y > 0\" \"x \\<noteq> y\" \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"y + 2/y - x - 2/x = 0\" using assms by simp\n  hence \"y - x = 2/x - 2/y\" \n    by (simp add: field_simps)\n  have \"x * y * (y - x) = 2 * (y - x)\" \n    using `y - x = 2/x - 2/y` by sos\n  have \"x * y = 2\" \n    using assms(3) by (metis amc12a_2013_p8_evolved assms(1) assms(2) assms(4) less_numeral_extra(3))\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  hence \"x - y = (2/y - 2/x)\"\n    by auto\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using `x - y = (2/y - 2/x)` by sos\n  have \"x * y = 2\" \n    using h2 cross_mult by sos\n  thus ?thesis by simp\nqed\n\nlemma amc12a_2013_p8_simpler:\n  fixes x y :: real\n  assumes \"x > 0\" \"y > 0\" \"x \\<noteq> y\" \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"y + 2/y - x - 2/x = 0\" using assms by simp\n  hence \"y - x = 2/x - 2/y\" \n    by (simp add: field_simps)\n  have \"x * y * (y - x) = 2 * (y - x)\" \n    using `y - x = 2/x - 2/y` by sos\n  have \"x * y = 2\" \n    using assms(3) by (metis amc12a_2013_p8_evolved assms(1) assms(2) assms(4) less_numeral_extra(3))\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "absolute_value_inequality_general": {"skill_name": "absolute_value_inequality_general", "marker": "lemma absolute_value_inequality_general:\n  fixes a b c :: real\n  assumes h0: \"abs(a - b) < c\"\n  shows \"b - c < a \\<and> a < b + c\"\nproof -\n  have \"a - b < c\" and \"-(a - b) < c\" using assms by auto\n  then have \"b - c < a\" and \"a < b + c\" by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma absolute_value_inequality_general:\n  fixes a b c :: real\n  assumes h0: \"abs(a - b) < c\"\n  shows \"b - c < a \\<and> a < b + c\"\nproof -\n  have \"a - b < c\" and \"-(a - b) < c\" using assms by auto\n  then have \"b - c < a\" and \"a < b + c\" by auto\n  then show ?thesis by auto\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "square_of_sum_and_diff": {"skill_name": "square_of_sum_and_diff", "marker": "lemma square_of_sum_and_diff:\n  fixes a b :: real\n  shows \"(a + b)^2 + (a - b)^2 = 2*a^2 + 2*b^2\"\nproof -\n  have \" (a + b)^2 + (a - b)^2 = (a^2 + 2*a*b + b^2) + (a^2 - 2*a*b + b^2)\" \n    by (simp add: expanded_square_of_sum expanded_square_of_difference)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma expanded_square_of_sum:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2*a*b + b^2\"\n  by sos\n\nlemma expanded_square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  by sos\n\nlemma square_of_sum_and_diff:\n  fixes a b :: real\n  shows \"(a + b)^2 + (a - b)^2 = 2*a^2 + 2*b^2\"\nproof -\n  have \" (a + b)^2 + (a - b)^2 = (a^2 + 2*a*b + b^2) + (a^2 - 2*a*b + b^2)\" \n    by (simp add: expanded_square_of_sum expanded_square_of_difference)\n  thus ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_addition": {"skill_name": "square_expansion_with_addition", "marker": "lemma square_expansion_with_addition:\n  fixes a b c d :: real\n  shows \"(a - b + c)^2 = (a - b)^2 + 2*(a - b)*c + c^2\"\nproof -\n  have \"((a - b) + c)^2 = (a - b)^2 + 2*(a - b)*c + c^2\" \n    by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion_with_addition:\n  fixes a b c d :: real\n  shows \"(a - b + c)^2 = (a - b)^2 + 2*(a - b)*c + c^2\"\nproof -\n  have \"((a - b) + c)^2 = (a - b)^2 + 2*(a - b)*c + c^2\" \n    by sos\n  thus ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "average_value_n_dimensional": {"skill_name": "average_value_n_dimensional", "marker": "lemma average_value_n_dimensional:\n  fixes total :: real and count :: nat and dimensions :: nat\n  assumes \"count > 0\" and \"dimensions > 0\"\n  shows \"total / real (count * dimensions) = (total / (real_of_nat (count * dimensions)))\"\n  using assms by (simp add: algebra_simps)", "description": "-", "full_code": "lemma average_value_n_dimensional:\n  fixes total :: real and count :: nat and dimensions :: nat\n  assumes \"count > 0\" and \"dimensions > 0\"\n  shows \"total / real (count * dimensions) = (total / (real_of_nat (count * dimensions)))\"\n  using assms by (simp add: algebra_simps)", "origin": "average_value", "update_count": 0}, "average_value_n_dimensionsV2": {"skill_name": "average_value_n_dimensionsV2", "marker": "lemma average_value_n_dimensions:\n  fixes total :: real and count :: nat and dimensions :: nat\n  assumes \"count > 0\" and \"dimensions > 0\"\n  shows \"total / (real count * real_of_nat dimensions) = (total / (real_of_nat count * real_of_nat dimensions))\"\nproof -\n  have \"total / (real count * real_of_nat dimensions) = total / (real_of_nat count * real_of_nat dimensions)\" \n    by (simp add: mult.commute)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma average_value_n_dimensions:\n  fixes total :: real and count :: nat and dimensions :: nat\n  assumes \"count > 0\" and \"dimensions > 0\"\n  shows \"total / (real count * real_of_nat dimensions) = (total / (real_of_nat count * real_of_nat dimensions))\"\nproof -\n  have \"total / (real count * real_of_nat dimensions) = total / (real_of_nat count * real_of_nat dimensions)\" \n    by (simp add: mult.commute)\n  thus ?thesis by simp\nqed", "origin": "average_value", "update_count": 0}, "product_equals_prime": {"skill_name": "product_equals_prime", "marker": "lemma product_equals_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\" \n      using assms(2) by (metis assms(1) bigger_prime dvdI dvd_mult_unit_iff' dvd_triv_right gcd_nat.strict_trans2 is_unit_power_iff mult.comm_neutral mult_left_cancel nat_mult_1 nat_mult_eq_cancel1 power_inject_exp power_one power_one_right prime_nat_iff zero_neq_one)\n    hence \"b = 1\" by (metis assms(1) assms(2) mult_delta_left mult_left_cancel not_prime_0)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\" \n      using assms(2) by (metis assms(1) bigger_prime comm_monoid_mult_class.mult_1 dvd_mult_unit_iff' dvd_triv_right gcd_nat.strict_trans2 is_unit_power_iff mult_left_cancel nat_mult_eq_cancel1 power_inject_exp power_one power_one_right prime_nat_iff zero_neq_one)\n    hence \"a = 1\" by (metis assms(1) assms(2) mult_delta_right mult_right_cancel not_prime_0)\n  }\n  thus \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "description": "-", "full_code": "lemma product_equals_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\" \n      using assms(2) by (metis assms(1) bigger_prime dvdI dvd_mult_unit_iff' dvd_triv_right gcd_nat.strict_trans2 is_unit_power_iff mult.comm_neutral mult_left_cancel nat_mult_1 nat_mult_eq_cancel1 power_inject_exp power_one power_one_right prime_nat_iff zero_neq_one)\n    hence \"b = 1\" by (metis assms(1) assms(2) mult_delta_left mult_left_cancel not_prime_0)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\" \n      using assms(2) by (metis assms(1) bigger_prime comm_monoid_mult_class.mult_1 dvd_mult_unit_iff' dvd_triv_right gcd_nat.strict_trans2 is_unit_power_iff mult_left_cancel nat_mult_eq_cancel1 power_inject_exp power_one power_one_right prime_nat_iff zero_neq_one)\n    hence \"a = 1\" by (metis assms(1) assms(2) mult_delta_right mult_right_cancel not_prime_0)\n  }\n  thus \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "origin": "do_request", "update_count": 0}, "square_expansionV8": {"skill_name": "square_expansionV8", "marker": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + (-b))^2\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: power2_eq_square algebra_simps)\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + (-b))^2\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: power2_eq_square algebra_simps)\nqed", "origin": "square_expansion", "update_count": 0}, "square_root_property": {"skill_name": "square_root_property", "marker": "lemma square_root_property:\n  fixes a b :: real\n  assumes \"a = sqrt b\" and \"b >= 0\"\n  shows \"a^2 = b\"\nproof -\n  have \"a^2 = (sqrt b)^2\" using assms(1) by simp\n  then show ?thesis by (metis assms(2) power2_eq_iff_nonneg real_sqrt_eq_iff real_sqrt_power real_sqrt_unique zero_le_power2)\nqed", "description": "-", "full_code": "lemma square_root_property:\n  fixes a b :: real\n  assumes \"a = sqrt b\" and \"b >= 0\"\n  shows \"a^2 = b\"\nproof -\n  have \"a^2 = (sqrt b)^2\" using assms(1) by simp\n  then show ?thesis by (metis assms(2) power2_eq_iff_nonneg real_sqrt_eq_iff real_sqrt_power real_sqrt_unique zero_le_power2)\nqed", "origin": "do_request", "update_count": 0}, "square_root_propertyV2": {"skill_name": "square_root_propertyV2", "marker": "lemma square_root_property:\n  fixes a b :: real\n  assumes \"a = sqrt b\" and \"b >= 0\"\n  shows \"a^2 = b\"\nproof -\n  have \"a^2 = (sqrt b)^2\" using assms(1) by simp\n  also have \"(sqrt b)^2 = b\" using assms(2) by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_root_property:\n  fixes a b :: real\n  assumes \"a = sqrt b\" and \"b >= 0\"\n  shows \"a^2 = b\"\nproof -\n  have \"a^2 = (sqrt b)^2\" using assms(1) by simp\n  also have \"(sqrt b)^2 = b\" using assms(2) by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_root_propertyV3": {"skill_name": "square_root_propertyV3", "marker": "lemma square_root_property:\n  fixes a b :: real\n  assumes \"a = sqrt b\" and \"b >= 0\"\n  shows \"a^2 = b\"\nproof -\n  have \"a^2 = (sqrt b)^2\" using assms(1) by simp\n  also have \"(sqrt b)^2 = b\" using assms(2) by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_root_property:\n  fixes a b :: real\n  assumes \"a = sqrt b\" and \"b >= 0\"\n  shows \"a^2 = b\"\nproof -\n  have \"a^2 = (sqrt b)^2\" using assms(1) by simp\n  also have \"(sqrt b)^2 = b\" using assms(2) by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "solve_linear_equations": {"skill_name": "solve_linear_equations", "marker": "lemma solve_linear_equations:\n  fixes x e :: real\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (a - x) \\<and> x = (b - a) / (2 - 1)\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel)\n  then have x_value_final: \"x = (b - a)\" by simp\n  have e_value: \"e = a - (b - a)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "lemma solve_linear_equations:\n  fixes x e :: real\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (a - x) \\<and> x = (b - a) / (2 - 1)\"\nproof -\n  have e_expr: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (a - x) = b\" using e_expr h1 by simp\n  have eq_simplified: \"x + a = b\" using eq_substituted by simp\n  have x_value: \"x = b - a\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel)\n  then have x_value_final: \"x = (b - a)\" by simp\n  have e_value: \"e = a - (b - a)\" using e_expr x_value_final by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "odd_even_product": {"skill_name": "odd_even_product", "marker": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain m where \"a = 2 * m\" \n    using assms(1) by auto\n  obtain n where \"b = 2 * n + 1\" \n    using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * m) * (2 * n + 1)\" \n    by (metis `a = 2 * m` `b = 2 * n + 1`)\n  hence \"a * b = 2 * m * (2 * n + 1)\" \n    by (simp)\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain m where \"a = 2 * m\" \n    using assms(1) by auto\n  obtain n where \"b = 2 * n + 1\" \n    using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * m) * (2 * n + 1)\" \n    by (metis `a = 2 * m` `b = 2 * n + 1`)\n  hence \"a * b = 2 * m * (2 * n + 1)\" \n    by (simp)\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mod4_squares_cases": {"skill_name": "mod4_squares_cases", "marker": "lemma mod4_squares_cases:\n  fixes a :: int\n  shows \"(a mod 4 = 1) \\<longrightarrow> (a^2 mod 4 = 1) \\<and> (a mod 4 = 2) \\<longrightarrow> (a^2 mod 4 = 0) \\<and> (a mod 4 = 3) \\<longrightarrow> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n    by auto\n  { \n    assume \"a mod 4 = 1\"\n    then have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  } \n  moreover {\n    assume \"a mod 4 = 2\"\n    then have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    then have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_squares_cases:\n  fixes a :: int\n  shows \"(a mod 4 = 1) \\<longrightarrow> (a^2 mod 4 = 1) \\<and> (a mod 4 = 2) \\<longrightarrow> (a^2 mod 4 = 0) \\<and> (a mod 4 = 3) \\<longrightarrow> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n    by auto\n  { \n    assume \"a mod 4 = 1\"\n    then have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  } \n  moreover {\n    assume \"a mod 4 = 2\"\n    then have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    then have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_manipulation": {"skill_name": "sqrt_manipulation", "marker": "lemma sqrt_manipulation:\n  fixes a b :: real\n  assumes \"a = 13 - sqrt 131\"\n  shows \"a^2 = 169 - 26 * sqrt 131 + 131\"\nproof -\n  have \"a^2 = (13 - sqrt 131)^2\"\n    using assms by simp\n  also have \"... = 13^2 - 2 * 13 * sqrt 131 + (sqrt 131)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  also have \"... = 169 - 26 * sqrt 131 + 131\"\n    by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_manipulation:\n  fixes a b :: real\n  assumes \"a = 13 - sqrt 131\"\n  shows \"a^2 = 169 - 26 * sqrt 131 + 131\"\nproof -\n  have \"a^2 = (13 - sqrt 131)^2\"\n    using assms by simp\n  also have \"... = 13^2 - 2 * 13 * sqrt 131 + (sqrt 131)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  also have \"... = 169 - 26 * sqrt 131 + 131\"\n    by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "fraction_combination": {"skill_name": "fraction_combination", "marker": "lemma fraction_combination:\n  fixes a b c d :: real\n  assumes \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have \"a / c + b / d = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (simp add: assms(1) assms(2) divide_simps)\n  also have \"... = (a * d + b * c) / (c * d)\"\n    by (simp add: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma fraction_combination:\n  fixes a b c d :: real\n  assumes \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have \"a / c + b / d = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (simp add: assms(1) assms(2) divide_simps)\n  also have \"... = (a * d + b * c) / (c * d)\"\n    by (simp add: field_simps)\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "square_expansion_with_parametrization": {"skill_name": "square_expansion_with_parametrization", "marker": "lemma square_expansion_with_parametrization:\n  fixes x y :: real\n  assumes \"x = a\" and \"y = b\"\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\n  using assms by sos", "description": "-", "full_code": "lemma square_expansion_with_parametrization:\n  fixes x y :: real\n  assumes \"x = a\" and \"y = b\"\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\n  using assms by sos", "origin": "square_expansion", "update_count": 0}, "enhanced_amc12a_2013_p8": {"skill_name": "enhanced_amc12a_2013_p8", "marker": "lemma enhanced_amc12a_2013_p8:\n  fixes x y z :: real\n  assumes h0 : \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"z \\<noteq> 0\"\n    and h1 : \"x \\<noteq> y\" \"y \\<noteq> z\" \"x \\<noteq> z\"\n    and h2 : \"x + 2/x = y + 2/y\" \n    and h3 : \"y + 2/y = z + 2/z\"\n  shows \"x * y * z = 2 * (x + y + z) / (x + y + z)\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h2 by simp\n  have \"y + 2/y = z + 2/z\" using h3 by simp\n  hence \"x + 2/x = z + 2/z\" using h1 by (metis h2)\n  have rearranged: \"x - z = (2/z - 2/x)\" by (smt (verit) \\<open>x + 2 / x = z + 2 / z\\<close>)\n  have cross_mult: \"(x - z) * x * z = 2 * (x - z)\" \n    using rearranged by sos\n  thus ?thesis \n    using cross_mult h0 h1 h2 h3 by (metis add_cancel_right_left add_cancel_right_right amc12a_2013_p8_extended divide_divide_eq_left' divide_eq_eq eq_divide_eq_1 mult.commute mult.right_neutral mult_1 mult_zero_left mult_zero_right nonzero_divide_mult_cancel_left nonzero_eq_divide_eq nonzero_mult_div_cancel_right nonzero_mult_divide_mult_cancel_right num_double numeral_One one_add_one one_plus_numeral semiring_norm(11) semiring_norm(2) times_divide_eq_left times_divide_eq_right)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_extended:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n    using h2 cross_mult by sos\n  thus ?thesis by simp\nqed\n\nlemma enhanced_amc12a_2013_p8:\n  fixes x y z :: real\n  assumes h0 : \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"z \\<noteq> 0\"\n    and h1 : \"x \\<noteq> y\" \"y \\<noteq> z\" \"x \\<noteq> z\"\n    and h2 : \"x + 2/x = y + 2/y\" \n    and h3 : \"y + 2/y = z + 2/z\"\n  shows \"x * y * z = 2 * (x + y + z) / (x + y + z)\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h2 by simp\n  have \"y + 2/y = z + 2/z\" using h3 by simp\n  hence \"x + 2/x = z + 2/z\" using h1 by (metis h2)\n  have rearranged: \"x - z = (2/z - 2/x)\" by (smt (verit) \\<open>x + 2 / x = z + 2 / z\\<close>)\n  have cross_mult: \"(x - z) * x * z = 2 * (x - z)\" \n    using rearranged by sos\n  thus ?thesis \n    using cross_mult h0 h1 h2 h3 by (metis add_cancel_right_left add_cancel_right_right amc12a_2013_p8_extended divide_divide_eq_left' divide_eq_eq eq_divide_eq_1 mult.commute mult.right_neutral mult_1 mult_zero_left mult_zero_right nonzero_divide_mult_cancel_left nonzero_eq_divide_eq nonzero_mult_div_cancel_right nonzero_mult_divide_mult_cancel_right num_double numeral_One one_add_one one_plus_numeral semiring_norm(11) semiring_norm(2) times_divide_eq_left times_divide_eq_right)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "linear_system_solutionV4": {"skill_name": "linear_system_solutionV4", "marker": "theorem linear_system_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = q\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*q)/n\"\nproof -\n  have eq: \"m*a + n*b = p\" using h0 by simp\n  have \"m*q + n*b = p\" using h1 eq by simp\n  have \"n*b = p - m*q\" by (metis \\<open>m * q + n * b = p\\<close> add_diff_cancel_left' h1 mult_delta_right)\n  then show ?thesis by (metis h2 mult.commute nonzero_mult_div_cancel_right)\nqed", "description": "-", "full_code": "theorem linear_system_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = q\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*q)/n\"\nproof -\n  have eq: \"m*a + n*b = p\" using h0 by simp\n  have \"m*q + n*b = p\" using h1 eq by simp\n  have \"n*b = p - m*q\" by (metis \\<open>m * q + n * b = p\\<close> add_diff_cancel_left' h1 mult_delta_right)\n  then show ?thesis by (metis h2 mult.commute nonzero_mult_div_cancel_right)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "chinese_remainderV5": {"skill_name": "chinese_remainderV5", "marker": "lemma chinese_remainder:\n  fixes a b c m n :: nat\n  assumes \"m > 0\" \"n > 0\" \"a mod m = b\" \"a mod n = c\"\n  shows \"\\<exists>k. a = b + m * k \\<and> a mod n = c\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\"\n    by (metis add.commute add.right_neutral div_mult_mod_eq)\n  then have \"a = ?k * m + b\" using assms(3) by simp\n  hence \"a mod n = (b + m * ?k) mod n\" \n    by (auto simp: field_simps)\n  have \"a mod n = c\" by (simp add: assms(4))\n  thus \"\\<exists>k. a = b + m * k \\<and> a mod n = c\" \n    by (metis \\<open>a = a div m * m + b\\<close> add.commute add_leE assms(3) div_less le_iff_add le_refl less_numeral_extra(3) mod_add_self1 mod_eq_nat1E mod_mod_trivial mult.commute mult_eq_0_iff mult_zero_right verit_comp_simplify1(3) zero_less_iff_neq_zero)\nqed", "description": "-", "full_code": "lemma chinese_remainder:\n  fixes a b c m n :: nat\n  assumes \"m > 0\" \"n > 0\" \"a mod m = b\" \"a mod n = c\"\n  shows \"\\<exists>k. a = b + m * k \\<and> a mod n = c\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\"\n    by (metis add.commute add.right_neutral div_mult_mod_eq)\n  then have \"a = ?k * m + b\" using assms(3) by simp\n  hence \"a mod n = (b + m * ?k) mod n\" \n    by (auto simp: field_simps)\n  have \"a mod n = c\" by (simp add: assms(4))\n  thus \"\\<exists>k. a = b + m * k \\<and> a mod n = c\" \n    by (metis \\<open>a = a div m * m + b\\<close> add.commute add_leE assms(3) div_less le_iff_add le_refl less_numeral_extra(3) mod_add_self1 mod_eq_nat1E mod_mod_trivial mult.commute mult_eq_0_iff mult_zero_right verit_comp_simplify1(3) zero_less_iff_neq_zero)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_manipulationV2": {"skill_name": "sqrt_manipulationV2", "marker": "lemma sqrt_manipulation:\n  fixes a :: real\n  assumes \"a = 13 - sqrt 131\"\n  shows \"a^2 = 169 - 26 * sqrt 131 + 131\"\nproof -\n  have \"a^2 = (13 - sqrt 131)^2\"\n    by (simp add: assms)\n  also have \"... = 13^2 - 2 * 13 * sqrt 131 + (sqrt 131)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  also have \"... = 169 - 2 * 13 * sqrt 131 + 131\"\n    by (simp add: power2_eq_square)\n  also have \"... = 169 + 131 - 26 * sqrt 131\"\n    by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_manipulation:\n  fixes a :: real\n  assumes \"a = 13 - sqrt 131\"\n  shows \"a^2 = 169 - 26 * sqrt 131 + 131\"\nproof -\n  have \"a^2 = (13 - sqrt 131)^2\"\n    by (simp add: assms)\n  also have \"... = 13^2 - 2 * 13 * sqrt 131 + (sqrt 131)^2\"\n    by (smt (verit) diff_add_eq power2_diff)\n  also have \"... = 169 - 2 * 13 * sqrt 131 + 131\"\n    by (simp add: power2_eq_square)\n  also have \"... = 169 + 131 - 26 * sqrt 131\"\n    by simp\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "chinese_remainderV6": {"skill_name": "chinese_remainderV6", "marker": "lemma chinese_remainder:\n  fixes a b c m n :: nat\n  assumes \"m > 0\" \"n > 0\" \"a mod m = b\" \"a mod n = c\"\n  shows \"\\<exists>k. a = b + m * k \\<and> a mod n = c\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by auto\n  then have \"a = ?k * m + b\" using assms(3) by simp\n  moreover have \"a mod n = (?k * m + b) mod n\"\n    by (metis calculation)\n  ultimately show \"\\<exists>k. a = b + m * k \\<and> a mod n = c\" \n    by (metis assms(3) assms(4) mod_div_mult_eq mult.commute)\nqed", "description": "-", "full_code": "lemma chinese_remainder:\n  fixes a b c m n :: nat\n  assumes \"m > 0\" \"n > 0\" \"a mod m = b\" \"a mod n = c\"\n  shows \"\\<exists>k. a = b + m * k \\<and> a mod n = c\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by auto\n  then have \"a = ?k * m + b\" using assms(3) by simp\n  moreover have \"a mod n = (?k * m + b) mod n\"\n    by (metis calculation)\n  ultimately show \"\\<exists>k. a = b + m * k \\<and> a mod n = c\" \n    by (metis assms(3) assms(4) mod_div_mult_eq mult.commute)\nqed", "origin": "do_request", "update_count": 0}, "chinese_remainderV7": {"skill_name": "chinese_remainderV7", "marker": "lemma chinese_remainder:\n  fixes a b c m n :: nat\n  assumes \"m > 0\" \"n > 0\" \"a mod m = b\" \"a mod n = c\"\n  shows \"\\<exists>k. a = b + m * k \\<and> a mod n = c\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by auto\n  then have \"a = ?k * m + b\" using assms(3) by simp\n  moreover have \"a mod n = (b + m * ?k) mod n\" \n    by (metis \\<open>a = a div m * m + a mod m\\<close> add.commute assms(3) mod_add_cong mult.commute)\n  ultimately show \"\\<exists>k. a = b + m * k \\<and> a mod n = c\" \n    by (metis assms(3) assms(4) mod_div_mult_eq mult.commute)\nqed", "description": "-", "full_code": "lemma chinese_remainder:\n  fixes a b c m n :: nat\n  assumes \"m > 0\" \"n > 0\" \"a mod m = b\" \"a mod n = c\"\n  shows \"\\<exists>k. a = b + m * k \\<and> a mod n = c\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by auto\n  then have \"a = ?k * m + b\" using assms(3) by simp\n  moreover have \"a mod n = (b + m * ?k) mod n\" \n    by (metis \\<open>a = a div m * m + a mod m\\<close> add.commute assms(3) mod_add_cong mult.commute)\n  ultimately show \"\\<exists>k. a = b + m * k \\<and> a mod n = c\" \n    by (metis assms(3) assms(4) mod_div_mult_eq mult.commute)\nqed", "origin": "do_request", "update_count": 0}, "floor_add": {"skill_name": "floor_add", "marker": "lemma floor_add:\n  fixes x y :: real\n  shows \"floor (x + y) = floor x + floor y + (if (x - floor x + y - floor y) < 1 then 0 else 1)\"\nproof -\n  let ?fx = \"floor x\"\n  let ?fy = \"floor y\"\n  let ?dx = \"x - ?fx\"\n  let ?dy = \"y - ?fy\"\n  have \"x = ?fx + ?dx\" and \"y = ?fy + ?dy\" by auto\n  from this have \"x + y = ?fx + ?fy + ?dx + ?dy\" by simp\n  have \"floor (x + y) = floor (?fx + ?fy + ?dx + ?dy)\" by simp\n  have \"floor (?fx + ?fy + ?dx + ?dy) = ?fx + ?fy + \n        (if (?dx + ?dy) < 1 then 0 else 1)\"\n  proof (cases \"dx + dy < 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) \\<open>x + y = real_of_int (\\<lfloor>x\\<rfloor> + \\<lfloor>y\\<rfloor>) + (x - real_of_int \\<lfloor>x\\<rfloor>) + (y - real_of_int \\<lfloor>y\\<rfloor>)\\<close> add_cancel_right_right dense floor_add floor_add_int floor_eq_iff floor_one int_add_floor le_floor_add le_floor_iff)\n  next\n    case False\n    then show ?thesis \n      by (smt (verit) \\<open>x + y = real_of_int (\\<lfloor>x\\<rfloor> + \\<lfloor>y\\<rfloor>) + (x - real_of_int \\<lfloor>x\\<rfloor>) + (y - real_of_int \\<lfloor>y\\<rfloor>)\\<close> add_cancel_right_right dense floor_add floor_add_int floor_eq_iff floor_one int_add_floor le_floor_add le_floor_iff)\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_add:\n  fixes x y :: real\n  shows \"floor (x + y) = floor x + floor y + (if (x - floor x + y - floor y) < 1 then 0 else 1)\"\nproof -\n  let ?fx = \"floor x\"\n  let ?fy = \"floor y\"\n  let ?dx = \"x - ?fx\"\n  let ?dy = \"y - ?fy\"\n  have \"x = ?fx + ?dx\" and \"y = ?fy + ?dy\" by auto\n  from this have \"x + y = ?fx + ?fy + ?dx + ?dy\" by simp\n  have \"floor (x + y) = floor (?fx + ?fy + ?dx + ?dy)\" by simp\n  have \"floor (?fx + ?fy + ?dx + ?dy) = ?fx + ?fy + \n        (if (?dx + ?dy) < 1 then 0 else 1)\"\n  proof (cases \"dx + dy < 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) \\<open>x + y = real_of_int (\\<lfloor>x\\<rfloor> + \\<lfloor>y\\<rfloor>) + (x - real_of_int \\<lfloor>x\\<rfloor>) + (y - real_of_int \\<lfloor>y\\<rfloor>)\\<close> add_cancel_right_right dense floor_add floor_add_int floor_eq_iff floor_one int_add_floor le_floor_add le_floor_iff)\n  next\n    case False\n    then show ?thesis \n      by (smt (verit) \\<open>x + y = real_of_int (\\<lfloor>x\\<rfloor> + \\<lfloor>y\\<rfloor>) + (x - real_of_int \\<lfloor>x\\<rfloor>) + (y - real_of_int \\<lfloor>y\\<rfloor>)\\<close> add_cancel_right_right dense floor_add floor_add_int floor_eq_iff floor_one int_add_floor le_floor_add le_floor_iff)\n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_manipulationV3": {"skill_name": "sqrt_manipulationV3", "marker": "lemma sqrt_manipulation:\n  fixes a b :: real\n  assumes \"a = 13 - sqrt 131\"\n  shows \"a^2 = 169 - 26 * sqrt 131 + 131\"\nproof -\n  have \"a^2 = (13 - sqrt 131)^2\" using assms by simp\n  then have \"a^2 = 13^2 - 2 * 13 * sqrt 131 + (sqrt 131)^2\" \n    by (simp add: power2_diff)\n  then have \"a^2 = 169 - 26 * sqrt 131 + 131\" \n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_manipulation:\n  fixes a b :: real\n  assumes \"a = 13 - sqrt 131\"\n  shows \"a^2 = 169 - 26 * sqrt 131 + 131\"\nproof -\n  have \"a^2 = (13 - sqrt 131)^2\" using assms by simp\n  then have \"a^2 = 13^2 - 2 * 13 * sqrt 131 + (sqrt 131)^2\" \n    by (simp add: power2_diff)\n  then have \"a^2 = 169 - 26 * sqrt 131 + 131\" \n    by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "average_value_extendedV4": {"skill_name": "average_value_extendedV4", "marker": "lemma average_value_extended:\n  fixes total :: real and count :: nat and dimension :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\nproof -\n  have \"real count = real_of_nat count\" by simp\n  thus ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma average_value_extended:\n  fixes total :: real and count :: nat and dimension :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\nproof -\n  have \"real count = real_of_nat count\" by simp\n  thus ?thesis using assms by simp\nqed", "origin": "average_value", "update_count": 0}, "average_value_generalized": {"skill_name": "average_value_generalized", "marker": "lemma average_value_generalized:\n  fixes total :: real and count :: nat and d :: nat\n  assumes \"count > 0\" \"d > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  and \"total / real count = (total / (real_of_nat (count * d))) * d\"\n  using assms by auto", "description": "-", "full_code": "lemma average_value_generalized:\n  fixes total :: real and count :: nat and d :: nat\n  assumes \"count > 0\" \"d > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  and \"total / real count = (total / (real_of_nat (count * d))) * d\"\n  using assms by auto", "origin": "average_value", "update_count": 0}, "min_value_of_expressionV2": {"skill_name": "min_value_of_expressionV2", "marker": "lemma min_value_of_expression:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\"\n    by auto\n  have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  then have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  also have \"... \\<ge> 1\"\n  proof (cases \"((x * y) - 1)^2 + (x + y)^2 < 1\")\n    case True\n    then show ?thesis \n      by sos\n  next\n    case False\n    then have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\n      by simp\n    then show ?thesis \n      by simp\n  qed\n  thus ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma min_value_of_expression:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\"\n    by auto\n  have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  then have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  also have \"... \\<ge> 1\"\n  proof (cases \"((x * y) - 1)^2 + (x + y)^2 < 1\")\n    case True\n    then show ?thesis \n      by sos\n  next\n    case False\n    then have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\n      by simp\n    then show ?thesis \n      by simp\n  qed\n  thus ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "min_value_of_expressionV3": {"skill_name": "min_value_of_expressionV3", "marker": "lemma min_value_of_expression:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\" \n    by auto\n  have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  moreover have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by sos\n  ultimately have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\" \n    (is \"_ \\<ge> 1\")\n  proof -\n    have \"((x * y) - 1)^2 \\<ge> 0\" \n      by auto\n    have \"(x + y)^2 + ((x * y) - 1)^2 \\<ge> 0 + 0\"\n      by (simp add: add_nonneg_nonneg)\n    then have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0\"\n      by simp\n    moreover have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n      by sos\n    then have \"x^2 + 2 * x * y + y^2 = (x + y)^2\"\n      by (simp add: power2_eq_square)\n    thus ?thesis \n      by sos\n  qed\n  thus ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma min_value_of_expression:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\" \n    by auto\n  have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  moreover have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by sos\n  ultimately have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\" \n    (is \"_ \\<ge> 1\")\n  proof -\n    have \"((x * y) - 1)^2 \\<ge> 0\" \n      by auto\n    have \"(x + y)^2 + ((x * y) - 1)^2 \\<ge> 0 + 0\"\n      by (simp add: add_nonneg_nonneg)\n    then have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0\"\n      by simp\n    moreover have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n      by sos\n    then have \"x^2 + 2 * x * y + y^2 = (x + y)^2\"\n      by (simp add: power2_eq_square)\n    thus ?thesis \n      by sos\n  qed\n  thus ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "min_value_of_expressionV4": {"skill_name": "min_value_of_expressionV4", "marker": "lemma min_value_of_expression:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\" \n    by auto\n  have \"(x + y)^2 \\<ge> 0\" \n    by auto\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y) - 1)^2 + (x + y)^2 + 0\" \n      by simp\n    consider (case1) \"((x * y) - 1) = 0\" | (case2) \"((x * y) - 1) \\<noteq> 0\" \n      by auto\n    then show ?thesis\n    proof cases\n      case case1\n      then have \"x * y = 1\" by simp\n      hence \"0 + (x + y)^2 \\<ge> 0\" by auto\n      thus ?thesis by sos\n    next\n      case case2\n      then have \"((x * y) - 1)^2 > 0\" by auto\n      thus ?thesis using case2 by sos\n    qed\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma min_value_of_expression:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\" \n    by auto\n  have \"(x + y)^2 \\<ge> 0\" \n    by auto\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y) - 1)^2 + (x + y)^2 + 0\" \n      by simp\n    consider (case1) \"((x * y) - 1) = 0\" | (case2) \"((x * y) - 1) \\<noteq> 0\" \n      by auto\n    then show ?thesis\n    proof cases\n      case case1\n      then have \"x * y = 1\" by simp\n      hence \"0 + (x + y)^2 \\<ge> 0\" by auto\n      thus ?thesis by sos\n    next\n      case case2\n      then have \"((x * y) - 1)^2 > 0\" by auto\n      thus ?thesis using case2 by sos\n    qed\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "min_value_of_expressionV5": {"skill_name": "min_value_of_expressionV5", "marker": "lemma min_value_of_expression:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\" \n    by auto\n  have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y) - 1)^2 + (x + y)^2 + 1 - 1\"\n    by simp\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1 - 1\"\n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis \n    by sos\nqed", "description": "-", "full_code": "lemma min_value_of_expression:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\" \n    by auto\n  have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y) - 1)^2 + (x + y)^2 + 1 - 1\"\n    by simp\n  have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1 - 1\"\n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis \n    by sos\nqed", "origin": "do_request", "update_count": 0}, "floor_addV2": {"skill_name": "floor_addV2", "marker": "lemma floor_add:\n  fixes x y :: real\n  shows \"floor (x + y) = floor x + floor y + (if (x - floor x + y - floor y) < 1 then 0 else 1)\"\nproof -\n  have \"floor (x + y) = floor (floor x + floor y + (x - floor x) + (y - floor y))\"\n    by auto\n  let ?fx = \"floor x\" and ?fy = \"floor y\"\n  let ?dx = \"x - ?fx\" and ?dy = \"y - ?fy\"\n  have \"floor (x + y) = floor (?fx + ?fy + ?dx + ?dy)\"\n    by (simp add: field_simps)\n  have \"floor (?fx + ?fy + ?dx + ?dy) = ?fx + ?fy + (if ?dx + ?dy < 1 then 0 else 1)\"\n    by (smt (verit) Ints_1 \\<open>\\<lfloor>x + y\\<rfloor> = \\<lfloor>real_of_int (\\<lfloor>x\\<rfloor> + \\<lfloor>y\\<rfloor>) + (x - real_of_int \\<lfloor>x\\<rfloor>) + (y - real_of_int \\<lfloor>y\\<rfloor>)\\<rfloor>\\<close> add_cancel_right_right ceiling_add_of_int ceiling_of_int dense floor_add floor_add2 floor_add_int floor_correct floor_eq_iff floor_le_iff floor_one int_add_floor le_floor_add of_int_1 of_int_add)\n  thus ?thesis\n    by (simp add: add.commute)\nqed", "description": "-", "full_code": "lemma floor_add:\n  fixes x y :: real\n  shows \"floor (x + y) = floor x + floor y + (if (x - floor x + y - floor y) < 1 then 0 else 1)\"\nproof -\n  have \"floor (x + y) = floor (floor x + floor y + (x - floor x) + (y - floor y))\"\n    by auto\n  let ?fx = \"floor x\" and ?fy = \"floor y\"\n  let ?dx = \"x - ?fx\" and ?dy = \"y - ?fy\"\n  have \"floor (x + y) = floor (?fx + ?fy + ?dx + ?dy)\"\n    by (simp add: field_simps)\n  have \"floor (?fx + ?fy + ?dx + ?dy) = ?fx + ?fy + (if ?dx + ?dy < 1 then 0 else 1)\"\n    by (smt (verit) Ints_1 \\<open>\\<lfloor>x + y\\<rfloor> = \\<lfloor>real_of_int (\\<lfloor>x\\<rfloor> + \\<lfloor>y\\<rfloor>) + (x - real_of_int \\<lfloor>x\\<rfloor>) + (y - real_of_int \\<lfloor>y\\<rfloor>)\\<rfloor>\\<close> add_cancel_right_right ceiling_add_of_int ceiling_of_int dense floor_add floor_add2 floor_add_int floor_correct floor_eq_iff floor_le_iff floor_one int_add_floor le_floor_add of_int_1 of_int_add)\n  thus ?thesis\n    by (simp add: add.commute)\nqed", "origin": "do_request", "update_count": 0}, "modulo_addition": {"skill_name": "modulo_addition", "marker": "lemma modulo_addition:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\" by auto\n  then have \"a mod 10 + b mod 10 < 20\" by auto\n  hence \"((a mod 10 + b mod 10) mod 10) = (a mod 10 + b mod 10 - 10 * ((a mod 10 + b mod 10) div 10))\"\n    by (metis minus_div_mult_eq_mod minus_mult_div_eq_mod)\n  have \"a = (a mod 10) + 10 * (a div 10)\" by auto\n  have \"b = (b mod 10) + 10 * (b div 10)\" by auto\n  then have \"a + b = (a mod 10 + b mod 10) + 10 * ((a div 10) + (b div 10))\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((a mod 10 + b mod 10) + 10 * ((a div 10) + (b div 10))) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma modulo_addition:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\" by auto\n  then have \"a mod 10 + b mod 10 < 20\" by auto\n  hence \"((a mod 10 + b mod 10) mod 10) = (a mod 10 + b mod 10 - 10 * ((a mod 10 + b mod 10) div 10))\"\n    by (metis minus_div_mult_eq_mod minus_mult_div_eq_mod)\n  have \"a = (a mod 10) + 10 * (a div 10)\" by auto\n  have \"b = (b mod 10) + 10 * (b div 10)\" by auto\n  then have \"a + b = (a mod 10 + b mod 10) + 10 * ((a div 10) + (b div 10))\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((a mod 10 + b mod 10) + 10 * ((a div 10) + (b div 10))) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "modulo_additionV2": {"skill_name": "modulo_additionV2", "marker": "lemma modulo_addition:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\" by auto\n  then have \"a mod 10 + b mod 10 < 20\" by auto\n  have \"(a + b) = (a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n  proof -\n    have \"((a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)) mod 10 = (a mod 10 + b mod 10) mod 10\"\n      using `a mod 10 + b mod 10 < 20`\n      by presburger\n    thus ?thesis by simp\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma modulo_addition:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\" by auto\n  then have \"a mod 10 + b mod 10 < 20\" by auto\n  have \"(a + b) = (a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n  proof -\n    have \"((a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)) mod 10 = (a mod 10 + b mod 10) mod 10\"\n      using `a mod 10 + b mod 10 < 20`\n      by presburger\n    thus ?thesis by simp\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "modulo_additionV3": {"skill_name": "modulo_additionV3", "marker": "lemma modulo_addition:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a mod 10 < 10\" by (simp add: mod_less)\n  hence \"a mod 10 + b mod 10 < 20\" by auto\n  have \"a = (a mod 10) + 10 * (a div 10)\" by auto\n  have \"b = (b mod 10) + 10 * (b div 10)\" by auto\n  have \"a + b = ((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))\"\n    using `a = (a mod 10) + 10 * (a div 10)` `b = (b mod 10) + 10 * (b div 10)` by auto\n  then have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma modulo_addition:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a mod 10 < 10\" by (simp add: mod_less)\n  hence \"a mod 10 + b mod 10 < 20\" by auto\n  have \"a = (a mod 10) + 10 * (a div 10)\" by auto\n  have \"b = (b mod 10) + 10 * (b div 10)\" by auto\n  have \"a + b = ((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))\"\n    using `a = (a mod 10) + 10 * (a div 10)` `b = (b mod 10) + 10 * (b div 10)` by auto\n  then have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "modulo_additionV4": {"skill_name": "modulo_additionV4", "marker": "lemma modulo_addition:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\" by auto\n  have \"b = (b mod 10) + 10 * (b div 10)\" by auto\n  then have \"a + b = ((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))\" \n    by (simp add: algebra_simps)\n  have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\" \n  proof -\n    have \"10 * ((a div 10) + (b div 10)) mod 10 = 0\" \n      by (simp add: mod_0)\n    thus ?thesis by fastforce\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma modulo_addition:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\" by auto\n  have \"b = (b mod 10) + 10 * (b div 10)\" by auto\n  then have \"a + b = ((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))\" \n    by (simp add: algebra_simps)\n  have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\" \n  proof -\n    have \"10 * ((a div 10) + (b div 10)) mod 10 = 0\" \n      by (simp add: mod_0)\n    thus ?thesis by fastforce\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "lcm_property": {"skill_name": "lcm_property", "marker": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b = (a * b) div (gcd a b)\" \n    by (metis lcm_nat_def)  \n  moreover have \"gcd a b > 0\"\n    using assms by auto  \n  ultimately show \"lcm a b = (a * b) div gcd a b\" \n    by simp  \nqed", "description": "-", "full_code": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b = (a * b) div (gcd a b)\" \n    by (metis lcm_nat_def)  \n  moreover have \"gcd a b > 0\"\n    using assms by auto  \n  ultimately show \"lcm a b = (a * b) div gcd a b\" \n    by simp  \nqed", "origin": "do_request", "update_count": 0}, "lcm_propertyV2": {"skill_name": "lcm_propertyV2", "marker": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  have \"lcm a b = (a * b) div (gcd a b)\"\n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  have \"lcm a b = (a * b) div (gcd a b)\"\n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "modulo_additionV5": {"skill_name": "modulo_additionV5", "marker": "lemma modulo_addition:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\" by auto\n  then have \"a mod 10 + b mod 10 < 20\" by auto\n  let ?k = \"(a mod 10 + b mod 10) div 10\"\n  have \"a + b = (a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n  proof -\n    have \"10 * (a div 10 + b div 10) mod 10 = 0\"\n      by (simp add: mod_mult_eq)\n    thus ?thesis by fastforce\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma modulo_addition:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\" by auto\n  then have \"a mod 10 + b mod 10 < 20\" by auto\n  let ?k = \"(a mod 10 + b mod 10) div 10\"\n  have \"a + b = (a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n  proof -\n    have \"10 * (a div 10 + b div 10) mod 10 = 0\"\n      by (simp add: mod_mult_eq)\n    thus ?thesis by fastforce\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negative_minimum": {"skill_name": "non_negative_minimum", "marker": "lemma non_negative_minimum:\n  fixes a b c :: real\n  assumes \"a = x^2\" \"b = y^2\" \"c = x^2 * y^2\"\n  shows \"a >= 0 \\<and> b >= 0 \\<and> c >= 0 \\<Longrightarrow> a + b + c + 1 >= 1\"\nproof -\n  assume \"a >= 0 \\<and> b >= 0 \\<and> c >= 0\"\n  then have \"a + b + c >= 0 + 0 + 0\" by (simp add: add_nonneg_nonneg)\n  hence \"a + b + c >= 0\" by simp\n  thus \"a + b + c + 1 >= 1\" by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma non_negative_minimum:\n  fixes a b c :: real\n  assumes \"a = x^2\" \"b = y^2\" \"c = x^2 * y^2\"\n  shows \"a >= 0 \\<and> b >= 0 \\<and> c >= 0 \\<Longrightarrow> a + b + c + 1 >= 1\"\nproof -\n  assume \"a >= 0 \\<and> b >= 0 \\<and> c >= 0\"\n  then have \"a + b + c >= 0 + 0 + 0\" by (simp add: add_nonneg_nonneg)\n  hence \"a + b + c >= 0\" by simp\n  thus \"a + b + c + 1 >= 1\" by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "non_negative_minimumV2": {"skill_name": "non_negative_minimumV2", "marker": "lemma non_negative_minimum:\n  fixes a b c :: real\n  assumes \"a = x^2\" \"b = y^2\" \"c = x^2 * y^2\"\n  shows \"a >= 0 \\<and> b >= 0 \\<and> c >= 0 \\<Longrightarrow> a + b + c + 1 >= 1\"\nproof -\n  assume \"a >= 0 \\<and> b >= 0 \\<and> c >= 0\"\n  then have \"a + b + c >= 0 + 0 + 0\" \n    using assms(1) assms(2) \n    by (simp add: add_nonneg_nonneg)\n  then have \"a + b + c + 1 >= 0 + 1\" \n    by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_negative_minimum:\n  fixes a b c :: real\n  assumes \"a = x^2\" \"b = y^2\" \"c = x^2 * y^2\"\n  shows \"a >= 0 \\<and> b >= 0 \\<and> c >= 0 \\<Longrightarrow> a + b + c + 1 >= 1\"\nproof -\n  assume \"a >= 0 \\<and> b >= 0 \\<and> c >= 0\"\n  then have \"a + b + c >= 0 + 0 + 0\" \n    using assms(1) assms(2) \n    by (simp add: add_nonneg_nonneg)\n  then have \"a + b + c + 1 >= 0 + 1\" \n    by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negative_minimumV3": {"skill_name": "non_negative_minimumV3", "marker": "lemma non_negative_minimum:\n  fixes a b c :: real\n  assumes \"a = x^2\" \"b = y^2\" \"c = x^2 * y^2\"\n  shows \"a >= 0 \\<and> b >= 0 \\<and> c >= 0 \\<Longrightarrow> a + b + c + 1 >= 1\"\nproof -\n  assume \"a >= 0 \\<and> b >= 0 \\<and> c >= 0\"\n  then have \"a + b + c >= 0 + 0 + 0\" by simp\n  moreover have \"a + b + c + 1 = (a + b + c) + 1\" by simp\n  ultimately show \"a + b + c + 1 >= 1\" by simp\nqed", "description": "-", "full_code": "lemma non_negative_minimum:\n  fixes a b c :: real\n  assumes \"a = x^2\" \"b = y^2\" \"c = x^2 * y^2\"\n  shows \"a >= 0 \\<and> b >= 0 \\<and> c >= 0 \\<Longrightarrow> a + b + c + 1 >= 1\"\nproof -\n  assume \"a >= 0 \\<and> b >= 0 \\<and> c >= 0\"\n  then have \"a + b + c >= 0 + 0 + 0\" by simp\n  moreover have \"a + b + c + 1 = (a + b + c) + 1\" by simp\n  ultimately show \"a + b + c + 1 >= 1\" by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_generalizedV5": {"skill_name": "mathd_algebra_generalizedV5", "marker": "theorem mathd_algebra_generalized:\n  fixes a b c d :: real\n  assumes h0 : \"c * a + d * b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 3\" \n    and h3 : \"d = 2\"\n  shows \"b = 0\"\nproof -\n  have eq: \"c * a + d * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 h2 eq by (metis h3)\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  thus ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_generalized:\n  fixes a b c d :: real\n  assumes h0 : \"c * a + d * b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 3\" \n    and h3 : \"d = 2\"\n  shows \"b = 0\"\nproof -\n  have eq: \"c * a + d * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 h2 eq by (metis h3)\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  thus ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sqrt_squareV3": {"skill_name": "sqrt_squareV3", "marker": "lemma sqrt_square:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt(x^2) = x\"\nproof -\n  have \"sqrt(x^2) = sqrt((x)^2)\" by simp\n  then show ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_square:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt(x^2) = x\"\nproof -\n  have \"sqrt(x^2) = sqrt((x)^2)\" by simp\n  then show ?thesis using assms by auto\nqed", "origin": "sqrt_limit", "update_count": 0}, "mathd_algebra_109_evolvedV16": {"skill_name": "mathd_algebra_109_evolvedV16", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  thus ?thesis by (simp add: assms)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  thus ?thesis by (simp add: assms)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sqrt_nonneg_squared": {"skill_name": "sqrt_nonneg_squared", "marker": "lemma sqrt_nonneg_squared:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt (a^2) = a\"\nproof -\n  have \"a^2 >= 0\" using assms by simp\n  then have \"sqrt (a^2) * sqrt (a^2) = a^2\" by (metis power2_eq_square real_sqrt_mult real_sqrt_pow2 real_sqrt_power zero_le_square)\n  thus ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg_squared:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt (a^2) = a\"\nproof -\n  have \"a^2 >= 0\" using assms by simp\n  then have \"sqrt (a^2) * sqrt (a^2) = a^2\" by (metis power2_eq_square real_sqrt_mult real_sqrt_pow2 real_sqrt_power zero_le_square)\n  thus ?thesis using assms by auto\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_add_square": {"skill_name": "sqrt_add_square", "marker": "lemma sqrt_add_square:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a + b) \\<le> sqrt a + sqrt b\"\nproof -\n  have \"sqrt (a + b) \\<le> sqrt (a + b) + 0\" by auto\n  also have \"... \\<le> sqrt a + sqrt b\" using assms by (metis add_cancel_right_right sqrt_add_le_add_sqrt)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma sqrt_add_square:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a + b) \\<le> sqrt a + sqrt b\"\nproof -\n  have \"sqrt (a + b) \\<le> sqrt (a + b) + 0\" by auto\n  also have \"... \\<le> sqrt a + sqrt b\" using assms by (metis add_cancel_right_right sqrt_add_le_add_sqrt)\n  finally show ?thesis .\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "square_difference_with_parameter": {"skill_name": "square_difference_with_parameter", "marker": "lemma square_difference_with_parameter:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = (a - b)^2 + 2 * (a - b) * c + c^2\"\nproof -\n  have \"(a - b + c)^2 = (a - b)^2 + 2 * (a - b) * c + c^2\" \n    by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_difference_with_parameter:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = (a - b)^2 + 2 * (a - b) * c + c^2\"\nproof -\n  have \"(a - b + c)^2 = (a - b)^2 + 2 * (a - b) * c + c^2\" \n    by sos\n  thus ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_difference_factorization": {"skill_name": "square_difference_factorization", "marker": "lemma square_difference_factorization:\n  fixes a b :: real\n  shows \"(a - b)^2 = (a - b) * (a - b)\"\n  by sos", "description": "-", "full_code": "lemma square_difference_factorization:\n  fixes a b :: real\n  shows \"(a - b)^2 = (a - b) * (a - b)\"\n  by sos", "origin": "square_expansion", "update_count": 0}, "expanded_square_difference": {"skill_name": "expanded_square_difference", "marker": "lemma expanded_square_difference:\n  fixes a b c :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2 + c * 0\"\n  by sos", "description": "-", "full_code": "lemma expanded_square_difference:\n  fixes a b c :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2 + c * 0\"\n  by sos", "origin": "square_expansion", "update_count": 0}, "expanded_square_differenceV2": {"skill_name": "expanded_square_differenceV2", "marker": "lemma expanded_square_difference:\n  fixes a b c :: real\n  shows \"(a - b - c)^2 = a^2 - 2*a*(b+c) + (b+c)^2\"\nproof -\n  have \"((a - (b + c))^2) = (a^2 - 2*a*(b+c) + (b+c)^2)\" by sos\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma expanded_square_difference:\n  fixes a b c :: real\n  shows \"(a - b - c)^2 = a^2 - 2*a*(b+c) + (b+c)^2\"\nproof -\n  have \"((a - (b + c))^2) = (a^2 - 2*a*(b+c) + (b+c)^2)\" by sos\n  thus ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "lcm_propertyV3": {"skill_name": "lcm_propertyV3", "marker": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have gcd_pos: \"gcd a b > 0\" using assms by (simp add: gcd_pos_nat)\n  have \"lcm a b * gcd a b = a * b\" \n    by (simp add: lcm_gcd)\n  then have \"lcm a b = (a * b) div gcd a b\" \n    by (metis gcd_pos lcm_nat_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have gcd_pos: \"gcd a b > 0\" using assms by (simp add: gcd_pos_nat)\n  have \"lcm a b * gcd a b = a * b\" \n    by (simp add: lcm_gcd)\n  then have \"lcm a b = (a * b) div gcd a b\" \n    by (metis gcd_pos lcm_nat_def)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "lcm_propertyV4": {"skill_name": "lcm_propertyV4", "marker": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\" \n    by (simp add: lcm_gcd) \n  have \"gcd a b > 0\"\n    using assms by auto \n  then show \"lcm a b = (a * b) div gcd a b\" \n    using `lcm a b * gcd a b = a * b` by (metis lcm_nat_def)\nqed", "description": "-", "full_code": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\" \n    by (simp add: lcm_gcd) \n  have \"gcd a b > 0\"\n    using assms by auto \n  then show \"lcm a b = (a * b) div gcd a b\" \n    using `lcm a b * gcd a b = a * b` by (metis lcm_nat_def)\nqed", "origin": "do_request", "update_count": 0}, "sum_and_product_relationship": {"skill_name": "sum_and_product_relationship", "marker": "lemma sum_and_product_relationship:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a + b)^2 = a^2 + 2*a*b + b^2\" \nproof -\n  have \"a + b = -(-a + -b)\" by simp\n  then have \"(-a + -b)^2 = a^2 + 2*a*b + b^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma sum_and_product_relationship:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a + b)^2 = a^2 + 2*a*b + b^2\" \nproof -\n  have \"a + b = -(-a + -b)\" by simp\n  then have \"(-a + -b)^2 = a^2 + 2*a*b + b^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  thus ?thesis by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "logarithmic_relationship": {"skill_name": "logarithmic_relationship", "marker": "lemma logarithmic_relationship:\n  fixes x y :: real\n  assumes \"x > 0\" \"y > 0\"\n  shows \"ln(x) + ln(y) = ln(x * y)\"\nproof -\n  have \"ln(x * y) = ln(x) + ln(y)\" using assms by (simp add: ln_mult)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithmic_relationship:\n  fixes x y :: real\n  assumes \"x > 0\" \"y > 0\"\n  shows \"ln(x) + ln(y) = ln(x * y)\"\nproof -\n  have \"ln(x * y) = ln(x) + ln(y)\" using assms by (simp add: ln_mult)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "algebraic_manipulationV5": {"skill_name": "algebraic_manipulationV5", "marker": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" using assms by simp\n  then have \"a - c = b + (c - c)\" by (simp add: algebra_simps)\n  then show \"b = a - c\" by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" using assms by simp\n  then have \"a - c = b + (c - c)\" by (simp add: algebra_simps)\n  then show \"b = a - c\" by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "algebraic_manipulationV6": {"skill_name": "algebraic_manipulationV6", "marker": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" using assms by simp\n  then show \"b = a - c\" by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" using assms by simp\n  then show \"b = a - c\" by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "algebraic_manipulationV7": {"skill_name": "algebraic_manipulationV7", "marker": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" using assms by (simp)\n  have \"a - c = b + (c - c)\" by (metis add.commute add_cancel_right_right assms cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0 neg_equal_iff_equal)\n  have \"c - c = 0\" by simp\n  have \"a - c = b + 0\" by (metis add.commute add_cancel_right_right add_scale_eq_noteq assms cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0)\n  thus \"b = a - c\" by simp\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" using assms by (simp)\n  have \"a - c = b + (c - c)\" by (metis add.commute add_cancel_right_right assms cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0 neg_equal_iff_equal)\n  have \"c - c = 0\" by simp\n  have \"a - c = b + 0\" by (metis add.commute add_cancel_right_right add_scale_eq_noteq assms cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0)\n  thus \"b = a - c\" by simp\nqed", "origin": "do_request", "update_count": 0}, "algebraic_manipulationV8": {"skill_name": "algebraic_manipulationV8", "marker": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  from assms have \"a - c = (b + c) - c\" by simp\n  also have \"... = b + (c - c)\" by (simp add: algebra_simps)\n  also have \"... = b + 0\" by (simp add: algebra_simps)\n  finally show \"b = a - c\" by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  from assms have \"a - c = (b + c) - c\" by simp\n  also have \"... = b + (c - c)\" by (simp add: algebra_simps)\n  also have \"... = b + 0\" by (simp add: algebra_simps)\n  finally show \"b = a - c\" by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "trivial_inequalityV3": {"skill_name": "trivial_inequalityV3", "marker": "lemma trivial_inequality:\n  fixes a b :: real\n  shows \"0 \\<le> a^2 + b^2\"\nproof -\n  have \"0 \\<le> a^2\" \n    by auto \n  moreover have \"0 \\<le> b^2\" \n    by auto\n  ultimately show ?thesis \n    by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma trivial_inequality:\n  fixes a b :: real\n  shows \"0 \\<le> a^2 + b^2\"\nproof -\n  have \"0 \\<le> a^2\" \n    by auto \n  moreover have \"0 \\<le> b^2\" \n    by auto\n  ultimately show ?thesis \n    by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "trivial_inequalityV4": {"skill_name": "trivial_inequalityV4", "marker": "lemma trivial_inequality:\n  fixes a b :: real\n  shows \"0 \\<le> a^2 + b^2\"\nproof -\n  have \"0 \\<le> a^2\" and \"0 \\<le> b^2\" \n    by auto\n  then have \"0 + 0 \\<le> a^2 + b^2\" \n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma trivial_inequality:\n  fixes a b :: real\n  shows \"0 \\<le> a^2 + b^2\"\nproof -\n  have \"0 \\<le> a^2\" and \"0 \\<le> b^2\" \n    by auto\n  then have \"0 + 0 \\<le> a^2 + b^2\" \n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "fixed_point_sqrt": {"skill_name": "fixed_point_sqrt", "marker": "lemma fixed_point_sqrt:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof\n  show \"sqrt (x + 9) = 9 \\<Longrightarrow> x = 72\"\n  proof -\n    assume \"sqrt (x + 9) = 9\"\n    have \"x + 9 = 9^2\" using `sqrt (x + 9) = 9` by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n    thus ?thesis by simp\n  qed\n  show \"x = 72 \\<Longrightarrow> sqrt (x + 9) = 9\"\n  proof -\n    assume \"x = 72\"\n    have \"x + 9 = 72 + 9\" using `x = 72` by simp\n    also have \"... = 81\" by simp\n    finally have \"sqrt (x + 9) = sqrt 81\" by simp\n    thus ?thesis by (simp add: real_sqrt_unique)\n  qed\nqed", "description": "-", "full_code": "lemma fixed_point_sqrt:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof\n  show \"sqrt (x + 9) = 9 \\<Longrightarrow> x = 72\"\n  proof -\n    assume \"sqrt (x + 9) = 9\"\n    have \"x + 9 = 9^2\" using `sqrt (x + 9) = 9` by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n    thus ?thesis by simp\n  qed\n  show \"x = 72 \\<Longrightarrow> sqrt (x + 9) = 9\"\n  proof -\n    assume \"x = 72\"\n    have \"x + 9 = 72 + 9\" using `x = 72` by simp\n    also have \"... = 81\" by simp\n    finally have \"sqrt (x + 9) = sqrt 81\" by simp\n    thus ?thesis by (simp add: real_sqrt_unique)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "cross_multiply_inequality": {"skill_name": "cross_multiply_inequality", "marker": "lemma cross_multiply_inequality:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \"a / b = c / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a * d = b * c\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma cross_multiply_inequality:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \"a / b = c / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a * d = b * c\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "expand_and_minimize": {"skill_name": "expand_and_minimize", "marker": "lemma expand_and_minimize:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\" \n    by auto\n  moreover have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  ultimately have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2*(x * y) + 1 + (x^2 + 2*x*y + y^2)\"\n    by sos\n  have \"1 + (x * y)^2 - 2*(x * y) + x^2 + 2*x*y + y^2 = 1 + (x^2 + y^2 + (x * y)^2)\"\n    by (simp add: algebra_simps)\n  have \"1 + (x^2 + y^2 + 2*x*y) - 2*(x * y) = 1 + (x^2 + y^2)\"\n    by (simp add: algebra_simps)\n  thus \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\n    by sos\nqed", "description": "-", "full_code": "lemma expand_and_minimize:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 \\<ge> 0\" \n    by auto\n  moreover have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  ultimately have \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2*(x * y) + 1 + (x^2 + 2*x*y + y^2)\"\n    by sos\n  have \"1 + (x * y)^2 - 2*(x * y) + x^2 + 2*x*y + y^2 = 1 + (x^2 + y^2 + (x * y)^2)\"\n    by (simp add: algebra_simps)\n  have \"1 + (x^2 + y^2 + 2*x*y) - 2*(x * y) = 1 + (x^2 + y^2)\"\n    by (simp add: algebra_simps)\n  thus \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\n    by sos\nqed", "origin": "do_request", "update_count": 0}, "expand_and_minimizeV2": {"skill_name": "expand_and_minimizeV2", "marker": "lemma expand_and_minimize:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"1 \\<le> (x * y - 1)^2 + (x + y)^2\" \n  proof -\n    have \"0 \\<le> (x * y - 1)^2\" by auto\n    hence \"0 \\<le> (x * y - 1)^2 + (x + y)^2\" by (simp add: add_nonneg_nonneg)\n    then have \"(x + y)^2 \\<ge> 0\" by auto\n    let ?A = \"(x * y - 1)^2\"\n    let ?B = \"(x + y)^2\"\n    have \"?A + ?B = (x * y)^2 - 2 * (x * y) + 1 + x^2 + 2 * x * y + y^2\"\n      by sos\n    have \"x^2 + 2 * x * y + y^2 = (x + y)^2\" \n      by sos\n    thus ?thesis\n      by sos\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma expand_and_minimize:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"1 \\<le> (x * y - 1)^2 + (x + y)^2\" \n  proof -\n    have \"0 \\<le> (x * y - 1)^2\" by auto\n    hence \"0 \\<le> (x * y - 1)^2 + (x + y)^2\" by (simp add: add_nonneg_nonneg)\n    then have \"(x + y)^2 \\<ge> 0\" by auto\n    let ?A = \"(x * y - 1)^2\"\n    let ?B = \"(x + y)^2\"\n    have \"?A + ?B = (x * y)^2 - 2 * (x * y) + 1 + x^2 + 2 * x * y + y^2\"\n      by sos\n    have \"x^2 + 2 * x * y + y^2 = (x + y)^2\" \n      by sos\n    thus ?thesis\n      by sos\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "linear_system_solutionV5": {"skill_name": "linear_system_solutionV5", "marker": "theorem linear_system_solution:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  then show ?thesis using `2 * b = 0` by (metis add.comm_neutral diff_self div_0 eq_divide_eq h0 one_add_one zero_neq_numeral)\nqed", "description": "-", "full_code": "theorem linear_system_solution:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  then have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right)\n  then show ?thesis using `2 * b = 0` by (metis add.comm_neutral diff_self div_0 eq_divide_eq h0 one_add_one zero_neq_numeral)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "expand_and_minimizeV3": {"skill_name": "expand_and_minimizeV3", "marker": "lemma expand_and_minimize:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\n  proof -\n    let ?z = \"(x * y - 1)\"\n    let ?s = \"(x + y)\"\n    have \"1 \\<le> ?z^2 + ?s^2\"\n      by sos\n    have \"?z^2 \\<ge> 0\" by (simp add: power2_eq_square)\n    have \"?s^2 \\<ge> 0\" by (simp add: power2_eq_square)\n    have \"1 \\<le> ?z^2 + ?s^2\"\n      by sos\n    thus ?thesis\n      by (simp add: power2_eq_square)\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma expand_and_minimize:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  have \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\n  proof -\n    let ?z = \"(x * y - 1)\"\n    let ?s = \"(x + y)\"\n    have \"1 \\<le> ?z^2 + ?s^2\"\n      by sos\n    have \"?z^2 \\<ge> 0\" by (simp add: power2_eq_square)\n    have \"?s^2 \\<ge> 0\" by (simp add: power2_eq_square)\n    have \"1 \\<le> ?z^2 + ?s^2\"\n      by sos\n    thus ?thesis\n      by (simp add: power2_eq_square)\n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "expand_and_minimizeV4": {"skill_name": "expand_and_minimizeV4", "marker": "lemma expand_and_minimize:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  let ?A = \"(x * y - 1)^2\"\n  let ?B = \"(x + y)^2\"\n  have \"?A \\<ge> 0\"\n    by (simp add: power2_eq_square)\n  have \"?B \\<ge> 0\"\n    by (simp add: power2_eq_square)\n  have \"1 \\<le> ?A + ?B\"\n  proof -\n    have \"0 \\<le> ?A\" by (simp add: power2_eq_square)\n    have \"0 \\<le> ?B\" by (simp add: power2_eq_square)\n    hence \"0 + 0 \\<le> ?A + ?B\" by (simp add: add_nonneg_nonneg)\n    then show ?thesis by sos\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma expand_and_minimize:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  let ?A = \"(x * y - 1)^2\"\n  let ?B = \"(x + y)^2\"\n  have \"?A \\<ge> 0\"\n    by (simp add: power2_eq_square)\n  have \"?B \\<ge> 0\"\n    by (simp add: power2_eq_square)\n  have \"1 \\<le> ?A + ?B\"\n  proof -\n    have \"0 \\<le> ?A\" by (simp add: power2_eq_square)\n    have \"0 \\<le> ?B\" by (simp add: power2_eq_square)\n    hence \"0 + 0 \\<le> ?A + ?B\" by (simp add: add_nonneg_nonneg)\n    then show ?thesis by sos\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_square_property": {"skill_name": "sqrt_square_property", "marker": "lemma sqrt_square_property:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt (x^2) = abs x\"\n  using assms by auto", "description": "-", "full_code": "lemma sqrt_square_property:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt (x^2) = abs x\"\n  using assms by auto", "origin": "sqrt_squareV2", "update_count": 0}, "numbertheory_sqmod4in01d": {"skill_name": "numbertheory_sqmod4in01d", "marker": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n    by auto\n  { \n    assume \"a mod 4 = 0\"\n    then have \"a^2 mod 4 = (0^2) mod 4\" by auto\n    hence \"a^2 mod 4 = 0\" by simp\n  } \n  moreover {\n    assume \"a mod 4 = 1\"\n    then have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    then have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    then have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  ultimately show ?thesis by fastforce\nqed", "description": "", "full_code": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n    by auto\n  { \n    assume \"a mod 4 = 0\"\n    then have \"a^2 mod 4 = (0^2) mod 4\" by auto\n    hence \"a^2 mod 4 = 0\" by simp\n  } \n  moreover {\n    assume \"a mod 4 = 1\"\n    then have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    then have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    then have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  ultimately show ?thesis by fastforce\nqed", "origin": "data/full_data/debug/valid_rand/numbertheory_sqmod4in01d.json_v31", "update_count": -1}, "congruence_propertiesV2": {"skill_name": "congruence_propertiesV2", "marker": "lemma congruence_properties:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" and \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  obtain k1 where \"a = b + k1 * m\" using assms(1) by (metis mod_mult_div_eq mult.commute)\n  obtain k2 where \"c = d + k2 * m\" using assms(2) by (metis mod_mult_div_eq mult.commute)\n  have \"a + c = (b + k1 * m) + (d + k2 * m)\"\n    by (metis \\<open>a = b + k1 * m\\<close> \\<open>c = d + k2 * m\\<close> add.commute)\n  then have \"a + c = (b + d) + (k1 + k2) * m\"\n    by (simp add: algebra_simps)\n  then have \"(a + c) mod m = ((b + d) + (k1 + k2) * m) mod m\"\n    by simp\n  also have \"... = (b + d) mod m\"\n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma congruence_properties:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" and \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  obtain k1 where \"a = b + k1 * m\" using assms(1) by (metis mod_mult_div_eq mult.commute)\n  obtain k2 where \"c = d + k2 * m\" using assms(2) by (metis mod_mult_div_eq mult.commute)\n  have \"a + c = (b + k1 * m) + (d + k2 * m)\"\n    by (metis \\<open>a = b + k1 * m\\<close> \\<open>c = d + k2 * m\\<close> add.commute)\n  then have \"a + c = (b + d) + (k1 + k2) * m\"\n    by (simp add: algebra_simps)\n  then have \"(a + c) mod m = ((b + d) + (k1 + k2) * m) mod m\"\n    by simp\n  also have \"... = (b + d) mod m\"\n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_powV3": {"skill_name": "mod_powV3", "marker": "lemma mod_pow:\n  fixes a n k :: nat\n  assumes \"n > 0\"\n  shows \"(a^k) mod n = (a mod n)^k mod n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  then show ?case\n  proof -\n    have \"a ^ Suc k = a * (a ^ k)\" by simp\n    then have \"(a ^ Suc k) mod n = (a * (a ^ k)) mod n\" by simp\n    also have \"... = ((a mod n) * (a ^ k)) mod n\"\n      using assms by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod n) * ((a ^ k) mod n)) mod n\"\n      by (metis mod_mult_right_eq)\n    also have \"... = (a mod n) ^ Suc k mod n\"\n      by (metis Suc calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_pow:\n  fixes a n k :: nat\n  assumes \"n > 0\"\n  shows \"(a^k) mod n = (a mod n)^k mod n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  then show ?case\n  proof -\n    have \"a ^ Suc k = a * (a ^ k)\" by simp\n    then have \"(a ^ Suc k) mod n = (a * (a ^ k)) mod n\" by simp\n    also have \"... = ((a mod n) * (a ^ k)) mod n\"\n      using assms by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod n) * ((a ^ k) mod n)) mod n\"\n      by (metis mod_mult_right_eq)\n    also have \"... = (a mod n) ^ Suc k mod n\"\n      by (metis Suc calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mod_powV4": {"skill_name": "mod_powV4", "marker": "lemma mod_pow:\n  fixes a n k :: nat\n  assumes \"n > 0\"\n  shows \"(a^k) mod n = (a mod n)^k mod n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  then show ?case\n  proof -\n    have \"a ^ Suc k = a * (a ^ k)\" by simp\n    then have \"(a ^ Suc k) mod n = (a * (a ^ k)) mod n\" by simp\n    also have \"... = ((a mod n) * (a ^ k mod n)) mod n\"\n      using assms by (metis mod_mult_eq)\n    also have \"... = ((a mod n) * ((a mod n) ^ k)) mod n\"\n      by (metis Suc \\<open>a * a ^ k mod n = a mod n * (a ^ k mod n) mod n\\<close> \\<open>a ^ Suc k = a * a ^ k\\<close> \\<open>a ^ Suc k mod n = a * a ^ k mod n\\<close> mod_mult_cong mod_mult_left_eq)\n    also have \"... = (a mod n) ^ Suc k mod n\"\n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_pow:\n  fixes a n k :: nat\n  assumes \"n > 0\"\n  shows \"(a^k) mod n = (a mod n)^k mod n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  then show ?case\n  proof -\n    have \"a ^ Suc k = a * (a ^ k)\" by simp\n    then have \"(a ^ Suc k) mod n = (a * (a ^ k)) mod n\" by simp\n    also have \"... = ((a mod n) * (a ^ k mod n)) mod n\"\n      using assms by (metis mod_mult_eq)\n    also have \"... = ((a mod n) * ((a mod n) ^ k)) mod n\"\n      by (metis Suc \\<open>a * a ^ k mod n = a mod n * (a ^ k mod n) mod n\\<close> \\<open>a ^ Suc k = a * a ^ k\\<close> \\<open>a ^ Suc k mod n = a * a ^ k mod n\\<close> mod_mult_cong mod_mult_left_eq)\n    also have \"... = (a mod n) ^ Suc k mod n\"\n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_expansion_with_c": {"skill_name": "square_expansion_with_c", "marker": "lemma square_expansion_with_c:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2*a*b + b^2 + 2*c*(a - b) + c^2\"\nproof -\n  have lhs: \"(a - b + c)^2 = (a - b)^2 + 2*(a - b)*c + c^2\"\n    by sos\n  also have \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n    by sos\n  ultimately show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma square_expansion_with_c:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2*a*b + b^2 + 2*c*(a - b) + c^2\"\nproof -\n  have lhs: \"(a - b + c)^2 = (a - b)^2 + 2*(a - b)*c + c^2\"\n    by sos\n  also have \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n    by sos\n  ultimately show ?thesis by (simp add: algebra_simps)\nqed", "origin": "square_expansion", "update_count": 0}, "expand_expressionV9": {"skill_name": "expand_expressionV9", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have lhs_expanded: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: lhs)\n  have combined_terms: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  have rhs: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: power2_eq_square)\n  show ?thesis\n    by (simp add: combined_terms rhs)\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have lhs_expanded: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: lhs)\n  have combined_terms: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  have rhs: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: power2_eq_square)\n  show ?thesis\n    by (simp add: combined_terms rhs)\nqed", "origin": "do_request", "update_count": 0}, "algebraic_manipulationV9": {"skill_name": "algebraic_manipulationV9", "marker": "lemma algebraic_manipulation:\n  fixes x y z :: nat\n  assumes \"x + y = z\"\n  shows \"y = z - x\"\nproof -\n  have \"z - x = (x + y) - x\" using assms by simp\n  then show \"y = z - x\" by auto\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes x y z :: nat\n  assumes \"x + y = z\"\n  shows \"y = z - x\"\nproof -\n  have \"z - x = (x + y) - x\" using assms by simp\n  then show \"y = z - x\" by auto\nqed", "origin": "do_request", "update_count": 0}, "divisibility_propertiesV3": {"skill_name": "divisibility_propertiesV3", "marker": "lemma divisibility_properties:\n  fixes a b :: nat\n  assumes \"a mod b = 0\"\n  shows \"\\<exists>k. a = b * k\"\nproof -\n  obtain k where \"a = b * k\" \n    using assms by auto \n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma divisibility_properties:\n  fixes a b :: nat\n  assumes \"a mod b = 0\"\n  shows \"\\<exists>k. a = b * k\"\nproof -\n  obtain k where \"a = b * k\" \n    using assms by auto \n  then show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "divisibility_propertiesV4": {"skill_name": "divisibility_propertiesV4", "marker": "lemma divisibility_properties:\n  fixes a b :: nat\n  assumes \"a mod b = 0\"\n  shows \"\\<exists>k. a = b * k\" \nproof -\n  obtain k where \"a = b * k + a mod b\" \n    using assms by auto\n  then have \"a = b * k + 0\" \n    using assms by simp\n  then show ?thesis \n    by (metis add_0_right)\nqed", "description": "-", "full_code": "lemma divisibility_properties:\n  fixes a b :: nat\n  assumes \"a mod b = 0\"\n  shows \"\\<exists>k. a = b * k\" \nproof -\n  obtain k where \"a = b * k + a mod b\" \n    using assms by auto\n  then have \"a = b * k + 0\" \n    using assms by simp\n  then show ?thesis \n    by (metis add_0_right)\nqed", "origin": "do_request", "update_count": 0}, "algebraic_manipulationV10": {"skill_name": "algebraic_manipulationV10", "marker": "lemma algebraic_manipulation:\n  fixes x y z :: nat\n  assumes \"x + y = z\"\n  shows \"y = z - x\"\nproof -\n  have \"y = z - x\" using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes x y z :: nat\n  assumes \"x + y = z\"\n  shows \"y = z - x\"\nproof -\n  have \"y = z - x\" using assms by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebraic_manipulationV11": {"skill_name": "algebraic_manipulationV11", "marker": "lemma algebraic_manipulation:\n  fixes x y z :: nat\n  assumes \"x + y = z\"\n  shows \"y = z - x\"\nproof -\n  have \"z - x = (x + y) - x\" using assms by simp\n  then have \"z - x = y + (x - x)\" by (simp add: algebra_simps)\n  then show \"y = z - x\" by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes x y z :: nat\n  assumes \"x + y = z\"\n  shows \"y = z - x\"\nproof -\n  have \"z - x = (x + y) - x\" using assms by simp\n  then have \"z - x = y + (x - x)\" by (simp add: algebra_simps)\n  then show \"y = z - x\" by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "square_differenceV3": {"skill_name": "square_differenceV3", "marker": "lemma square_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + (-b))^2\" by (simp add: algebra_simps)\n  also have \"... = a^2 + 2*a*(-b) + (-b)^2\" by sos\n  also have \"... = a^2 - 2*a*b + b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + (-b))^2\" by (simp add: algebra_simps)\n  also have \"... = a^2 + 2*a*(-b) + (-b)^2\" by sos\n  also have \"... = a^2 - 2*a*b + b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_root_equation": {"skill_name": "square_root_equation", "marker": "lemma square_root_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9\" using assms by simp\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  hence \"x + 9 = 81\" by (simp add: power2_eq_square)\n  then show ?thesis by (simp add: add_diff_cancel)\nqed", "description": "-", "full_code": "lemma square_root_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9\" using assms by simp\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  hence \"x + 9 = 81\" by (simp add: power2_eq_square)\n  then show ?thesis by (simp add: add_diff_cancel)\nqed", "origin": "do_request", "update_count": 0}, "square_root_equationV2": {"skill_name": "square_root_equationV2", "marker": "lemma square_root_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show ?thesis by (simp add: add_diff_cancel)\nqed", "description": "-", "full_code": "lemma square_root_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show ?thesis by (simp add: add_diff_cancel)\nqed", "origin": "do_request", "update_count": 0}, "average_of_sumV3": {"skill_name": "average_of_sumV3", "marker": "lemma average_of_sum:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"(\\<Sum> k \\<in> {0..count-1}. f k) / real count = (1 / real count) * (\\<Sum> k \\<in> {0..count-1}. f k)\"\n  using assms by (simp add: divide_simps)", "description": "-", "full_code": "lemma average_of_sum:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"(\\<Sum> k \\<in> {0..count-1}. f k) / real count = (1 / real count) * (\\<Sum> k \\<in> {0..count-1}. f k)\"\n  using assms by (simp add: divide_simps)", "origin": "average_value", "update_count": 0}, "sqrt_positive": {"skill_name": "sqrt_positive", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\"\n    using assms by (metis max.absorb_iff2 max.commute)\n  also have \"max x 0 = x\" \n    using assms by (simp add: max_def)\n  finally have \"sqrt x = sqrt x\" by simp\n  thus ?thesis \n    using assms real_sqrt_ge_zero by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\"\n    using assms by (metis max.absorb_iff2 max.commute)\n  also have \"max x 0 = x\" \n    using assms by (simp add: max_def)\n  finally have \"sqrt x = sqrt x\" by simp\n  thus ?thesis \n    using assms real_sqrt_ge_zero by auto\nqed", "origin": "do_request", "update_count": 0}, "optimization_minimumV6": {"skill_name": "optimization_minimumV6", "marker": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x = 0\" \"y = 0\"\n  shows \"1 = ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  from assms have \"x * y = 0\" \n    by simp\n  from assms have \"x + y = 0\" \n    by simp\n  have \"((x * y) - 1)^2 + (x + y)^2 = (0 - 1)^2 + 0^2\" \n    by (simp add: `x * y = 0` `x + y = 0`)\n  then show \"1 = ((x * y) - 1)^2 + (x + y)^2\" \n    by simp\nqed", "description": "-", "full_code": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x = 0\" \"y = 0\"\n  shows \"1 = ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  from assms have \"x * y = 0\" \n    by simp\n  from assms have \"x + y = 0\" \n    by simp\n  have \"((x * y) - 1)^2 + (x + y)^2 = (0 - 1)^2 + 0^2\" \n    by (simp add: `x * y = 0` `x + y = 0`)\n  then show \"1 = ((x * y) - 1)^2 + (x + y)^2\" \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "optimization_minimumV7": {"skill_name": "optimization_minimumV7", "marker": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x = 0\" \"y = 0\"\n  shows \"1 = ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  have \"x * y = 0\" using assms(1) assms(2) by simp\n  have \"x + y = 0\" using assms(1) assms(2) by simp\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"?lhs = (0 - 1)^2 + 0^2\" \n    by (simp add: `x * y = 0` `x + y = 0`)\n  then have \"?lhs = 1^2 + 0\" \n    by simp\n  thus ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x = 0\" \"y = 0\"\n  shows \"1 = ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  have \"x * y = 0\" using assms(1) assms(2) by simp\n  have \"x + y = 0\" using assms(1) assms(2) by simp\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"?lhs = (0 - 1)^2 + 0^2\" \n    by (simp add: `x * y = 0` `x + y = 0`)\n  then have \"?lhs = 1^2 + 0\" \n    by simp\n  thus ?thesis \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_limit_generalizedV3": {"skill_name": "sqrt_limit_generalizedV3", "marker": "lemma sqrt_limit_generalized:\n  fixes x :: real\n  assumes \"b = sqrt (x + c)\" \"c > 0\" \"b > 0\"\n  shows \"x = b^2 - c\"\nproof -\n  have \"b^2 = x + c\" using assms by auto\n  thus ?thesis by (metis \\<open>b\\<^sup>2 = x + c\\<close> add_diff_cancel)\nqed", "description": "-", "full_code": "lemma sqrt_limit_generalized:\n  fixes x :: real\n  assumes \"b = sqrt (x + c)\" \"c > 0\" \"b > 0\"\n  shows \"x = b^2 - c\"\nproof -\n  have \"b^2 = x + c\" using assms by auto\n  thus ?thesis by (metis \\<open>b\\<^sup>2 = x + c\\<close> add_diff_cancel)\nqed", "origin": "sqrt_limit", "update_count": 0}, "average_value_sumV3": {"skill_name": "average_value_sumV3", "marker": "lemma average_value_sum:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" \"total = sum f {1..count}\"\n  shows \"total / real count = (1 / real count) * sum f {1..count}\"\nproof -\n  have \"total / real count = (sum f {1..count}) / real count\" using assms(2) by simp\n  also have \"... = (1 / real count) * sum f {1..count}\" by (simp add: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma average_value_sum:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" \"total = sum f {1..count}\"\n  shows \"total / real count = (1 / real count) * sum f {1..count}\"\nproof -\n  have \"total / real count = (sum f {1..count}) / real count\" using assms(2) by simp\n  also have \"... = (1 / real count) * sum f {1..count}\" by (simp add: field_simps)\n  finally show ?thesis .\nqed", "origin": "average_value", "update_count": 0}, "sqrt_productV3": {"skill_name": "sqrt_productV3", "marker": "lemma sqrt_product:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a * b) = sqrt a * sqrt b\"\nproof -\n  have \"sqrt (a * b) * sqrt (a * b) = a * b\" \n    using assms by auto\n  then show ?thesis \n    using assms by (metis real_sqrt_mult)\nqed", "description": "-", "full_code": "lemma sqrt_product:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a * b) = sqrt a * sqrt b\"\nproof -\n  have \"sqrt (a * b) * sqrt (a * b) = a * b\" \n    using assms by auto\n  then show ?thesis \n    using assms by (metis real_sqrt_mult)\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_propertyV2": {"skill_name": "sqrt_propertyV2", "marker": "lemma sqrt_property:\n  fixes a b :: real\n  assumes \"a = sqrt b\" and \"b >= 0\"\n  shows \"a^2 = b\"\n  using assms by (simp add: power2_eq_square)", "description": "-", "full_code": "lemma sqrt_property:\n  fixes a b :: real\n  assumes \"a = sqrt b\" and \"b >= 0\"\n  shows \"a^2 = b\"\n  using assms by (simp add: power2_eq_square)", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_equationV5": {"skill_name": "sqrt_equationV5", "marker": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  also have \"... = 81\" by simp\n  finally have \"x + 9 = 81\" by simp\n  have \"x = 81 - 9\" by (metis \\<open>x + 9 = 81\\<close> add_diff_cancel_right')\n  thus \"x = 72\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  also have \"... = 81\" by simp\n  finally have \"x + 9 = 81\" by simp\n  have \"x = 81 - 9\" by (metis \\<open>x + 9 = 81\\<close> add_diff_cancel_right')\n  thus \"x = 72\" by simp\nqed", "origin": "do_request", "update_count": 0}, "optimization_minimumV8": {"skill_name": "optimization_minimumV8", "marker": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x = 0\" \"y = 0\"\n  shows \"1 = ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  from assms have \"x * y = 0\" \n    by simp\n  from assms have \"x + y = 0\" \n    by simp\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"?lhs = ((0) - 1)^2 + (0)^2\" \n    by (simp add: `x * y = 0` `x + y = 0`)\n  have \"?lhs = (-1)^2 + 0\" \n    by (metis add_cancel_left_right assms(1) assms(2) diff_0 diff_minus_eq_add diff_zero eq_iff_diff_eq_0 mult_eq_0_iff power2_commute power2_eq_iff power2_eq_square zero_eq_power2)\n  also have \"... = 1\" \n    by simp\n  finally show \"1 = ((x * y) - 1)^2 + (x + y)^2\" \n    by simp\nqed", "description": "-", "full_code": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x = 0\" \"y = 0\"\n  shows \"1 = ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  from assms have \"x * y = 0\" \n    by simp\n  from assms have \"x + y = 0\" \n    by simp\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"?lhs = ((0) - 1)^2 + (0)^2\" \n    by (simp add: `x * y = 0` `x + y = 0`)\n  have \"?lhs = (-1)^2 + 0\" \n    by (metis add_cancel_left_right assms(1) assms(2) diff_0 diff_minus_eq_add diff_zero eq_iff_diff_eq_0 mult_eq_0_iff power2_commute power2_eq_iff power2_eq_square zero_eq_power2)\n  also have \"... = 1\" \n    by simp\n  finally show \"1 = ((x * y) - 1)^2 + (x + y)^2\" \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "optimization_minimumV9": {"skill_name": "optimization_minimumV9", "marker": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x = 0\" \"y = 0\"\n  shows \"1 = ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  have \"x * y = 0 * 0\" using assms by simp\n  then have \"x * y = 0\" by simp\n  have \"x + y = 0 + 0\" using assms by simp\n  then have \"x + y = 0\" by simp\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"?lhs = (0 - 1)^2 + 0^2\" \n    using `x * y = 0` `x + y = 0` by auto\n  have \"?lhs = 1^2 + 0\" by (metis add_0_iff assms(1) assms(2) diff_minus_eq_add diff_zero eq_iff_diff_eq_0 mult_eq_0_iff power2_commute power2_eq_square verit_minus_simplify(3) zero_eq_power2)\n  then have \"?lhs = 1\" by simp\n  thus ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma optimization_minimum:\n  fixes x y :: real\n  assumes \"x = 0\" \"y = 0\"\n  shows \"1 = ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  have \"x * y = 0 * 0\" using assms by simp\n  then have \"x * y = 0\" by simp\n  have \"x + y = 0 + 0\" using assms by simp\n  then have \"x + y = 0\" by simp\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"?lhs = (0 - 1)^2 + 0^2\" \n    using `x * y = 0` `x + y = 0` by auto\n  have \"?lhs = 1^2 + 0\" by (metis add_0_iff assms(1) assms(2) diff_minus_eq_add diff_zero eq_iff_diff_eq_0 mult_eq_0_iff power2_commute power2_eq_square verit_minus_simplify(3) zero_eq_power2)\n  then have \"?lhs = 1\" by simp\n  thus ?thesis \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_111V2": {"skill_name": "mathd_algebra_111V2", "marker": "theorem mathd_algebra_111:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\" and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  then have \"12 + 2 * b = c\" by simp\n  then have \"2 * b = c - 12\" by (simp add: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_111:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\" and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  then have \"12 + 2 * b = c\" by simp\n  then have \"2 * b = c - 12\" by (simp add: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sqrt_sum_of_squares_nonneg": {"skill_name": "sqrt_sum_of_squares_nonneg", "marker": "lemma sqrt_sum_of_squares_nonneg:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a^2 + b^2) * sqrt (a^2 + b^2) = a^2 + b^2\"\nproof -\n  have \"sqrt (a^2 + b^2) * sqrt (a^2 + b^2) = a^2 + b^2\" using assms by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_sum_of_squares_nonneg:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a^2 + b^2) * sqrt (a^2 + b^2) = a^2 + b^2\"\nproof -\n  have \"sqrt (a^2 + b^2) * sqrt (a^2 + b^2) = a^2 + b^2\" using assms by auto\n  then show ?thesis by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_diff_square_nonneg": {"skill_name": "sqrt_diff_square_nonneg", "marker": "lemma sqrt_diff_square_nonneg:\n  fixes a b :: real\n  assumes \"a >= b\" \"b >= 0\"\n  shows \"sqrt (a^2 - b^2) * sqrt (a^2 - b^2) = a^2 - b^2\"\nproof -\n  have \"sqrt (a^2 - b^2) * sqrt (a^2 - b^2) = a^2 - b^2\" using assms by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_diff_square_nonneg:\n  fixes a b :: real\n  assumes \"a >= b\" \"b >= 0\"\n  shows \"sqrt (a^2 - b^2) * sqrt (a^2 - b^2) = a^2 - b^2\"\nproof -\n  have \"sqrt (a^2 - b^2) * sqrt (a^2 - b^2) = a^2 - b^2\" using assms by auto\n  then show ?thesis by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "fixed_point": {"skill_name": "fixed_point", "marker": "lemma fixed_point:\n  fixes f :: \"real \\<Rightarrow> real\"\n  assumes \"f x = x\"\n  shows \"x = f x\"\nproof -\n  have \"f x = x\" by (rule assms)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma fixed_point:\n  fixes f :: \"real \\<Rightarrow> real\"\n  assumes \"f x = x\"\n  shows \"x = f x\"\nproof -\n  have \"f x = x\" by (rule assms)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "equality_condition_for_minimum": {"skill_name": "equality_condition_for_minimum", "marker": "lemma equality_condition_for_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 = 0\"\n  shows \"x = 0 \\<and> y = 0\"\nproof -\n  have \"x^2 >= 0\" by (simp)\n  have \"y^2 >= 0\" by (simp)\n  moreover have \"x^2 + y^2 = 0\" using assms by simp\n  ultimately have \"x^2 = 0\" and \"y^2 = 0\" \n    by auto\n  have \"x = 0\" using `x^2 = 0` by (simp)\n  have \"y = 0\" using `y^2 = 0` by (simp)\n  thus ?thesis by (metis \\<open>x = 0\\<close>)\nqed", "description": "-", "full_code": "lemma equality_condition_for_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 = 0\"\n  shows \"x = 0 \\<and> y = 0\"\nproof -\n  have \"x^2 >= 0\" by (simp)\n  have \"y^2 >= 0\" by (simp)\n  moreover have \"x^2 + y^2 = 0\" using assms by simp\n  ultimately have \"x^2 = 0\" and \"y^2 = 0\" \n    by auto\n  have \"x = 0\" using `x^2 = 0` by (simp)\n  have \"y = 0\" using `y^2 = 0` by (simp)\n  thus ?thesis by (metis \\<open>x = 0\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "equality_condition_for_minimumV2": {"skill_name": "equality_condition_for_minimumV2", "marker": "lemma equality_condition_for_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 = 0\"\n  shows \"x = 0 \\<and> y = 0\"\nproof -\n  have \"x^2 \\<ge> 0\" and \"y^2 \\<ge> 0\" by simp_all\n  then have \"x^2 + y^2 \\<ge> 0\" by simp\n  from assms have \"x^2 + y^2 = 0\" and \"x^2 + y^2 \\<ge> 0\" by simp_all\n  then have \"x^2 + y^2 = 0 \\<Longrightarrow> x^2 = 0 \\<and> y^2 = 0\" \n    by auto\n  thus ?thesis \n    by (metis add_cancel_right_left assms linorder_linear power2_less_eq_zero_iff sum_power2_eq_zero_iff zero_eq_power2)\nqed", "description": "-", "full_code": "lemma equality_condition_for_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 = 0\"\n  shows \"x = 0 \\<and> y = 0\"\nproof -\n  have \"x^2 \\<ge> 0\" and \"y^2 \\<ge> 0\" by simp_all\n  then have \"x^2 + y^2 \\<ge> 0\" by simp\n  from assms have \"x^2 + y^2 = 0\" and \"x^2 + y^2 \\<ge> 0\" by simp_all\n  then have \"x^2 + y^2 = 0 \\<Longrightarrow> x^2 = 0 \\<and> y^2 = 0\" \n    by auto\n  thus ?thesis \n    by (metis add_cancel_right_left assms linorder_linear power2_less_eq_zero_iff sum_power2_eq_zero_iff zero_eq_power2)\nqed", "origin": "do_request", "update_count": 0}, "equality_condition_for_minimumV3": {"skill_name": "equality_condition_for_minimumV3", "marker": "lemma equality_condition_for_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 = 0\"\n  shows \"x = 0 \\<and> y = 0\"\nproof -\n  have \"x^2 \\<ge> 0\" by (simp)\n  have \"y^2 \\<ge> 0\" by (simp)\n  from assms have \"x^2 + y^2 = 0\" \n    by simp\n  then have \"x^2 + y^2 = 0 \\<Longrightarrow> x^2 = 0 \\<and> y^2 = 0\" \n    by auto\n  then show \"x = 0 \\<and> y = 0\" \n    by (metis add_cancel_left_left assms linorder_linear power2_less_eq_zero_iff sum_power2_eq_zero_iff zero_eq_power2)\nqed", "description": "-", "full_code": "lemma equality_condition_for_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 = 0\"\n  shows \"x = 0 \\<and> y = 0\"\nproof -\n  have \"x^2 \\<ge> 0\" by (simp)\n  have \"y^2 \\<ge> 0\" by (simp)\n  from assms have \"x^2 + y^2 = 0\" \n    by simp\n  then have \"x^2 + y^2 = 0 \\<Longrightarrow> x^2 = 0 \\<and> y^2 = 0\" \n    by auto\n  then show \"x = 0 \\<and> y = 0\" \n    by (metis add_cancel_left_left assms linorder_linear power2_less_eq_zero_iff sum_power2_eq_zero_iff zero_eq_power2)\nqed", "origin": "do_request", "update_count": 0}, "equality_condition_for_minimumV4": {"skill_name": "equality_condition_for_minimumV4", "marker": "lemma equality_condition_for_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 = 0\"\n  shows \"x = 0 \\<and> y = 0\"\nproof -\n  have \"x^2 \\<ge> 0\" by simp\n  have \"y^2 \\<ge> 0\" by simp\n  have \"x^2 + y^2 = 0 \\<Longrightarrow> x^2 = 0 \\<and> y^2 = 0\"\n    using assms by auto\n  then have \"x^2 = 0\" by (simp add: assms)\n  then have \"x = 0\" by auto\n  moreover have \"y^2 = 0\" using `x^2 + y^2 = 0` `x^2 = 0` by simp\n  then have \"y = 0\" by auto\n  ultimately show \"x = 0 \\<and> y = 0\" by simp\nqed", "description": "-", "full_code": "lemma equality_condition_for_minimum:\n  fixes x y :: real\n  assumes \"x^2 + y^2 = 0\"\n  shows \"x = 0 \\<and> y = 0\"\nproof -\n  have \"x^2 \\<ge> 0\" by simp\n  have \"y^2 \\<ge> 0\" by simp\n  have \"x^2 + y^2 = 0 \\<Longrightarrow> x^2 = 0 \\<and> y^2 = 0\"\n    using assms by auto\n  then have \"x^2 = 0\" by (simp add: assms)\n  then have \"x = 0\" by auto\n  moreover have \"y^2 = 0\" using `x^2 + y^2 = 0` `x^2 = 0` by simp\n  then have \"y = 0\" by auto\n  ultimately show \"x = 0 \\<and> y = 0\" by simp\nqed", "origin": "do_request", "update_count": 0}, "average_value_of_non_negative": {"skill_name": "average_value_of_non_negative", "marker": "lemma average_value_of_non_negative:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" \"total \\<ge> 0\"\n  shows \"total / real count \\<ge> 0\"\nproof -\n  have \"total / real count = (total / (real_of_nat count))\" using assms by (simp)\n  thus \"total / real count \\<ge> 0\" using assms(2) by (simp)\nqed", "description": "-", "full_code": "lemma average_value_of_non_negative:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" \"total \\<ge> 0\"\n  shows \"total / real count \\<ge> 0\"\nproof -\n  have \"total / real count = (total / (real_of_nat count))\" using assms by (simp)\n  thus \"total / real count \\<ge> 0\" using assms(2) by (simp)\nqed", "origin": "average_value", "update_count": 0}, "non_zero_average_value": {"skill_name": "non_zero_average_value", "marker": "lemma non_zero_average_value:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\nproof -\n  have \"real count = real_of_nat count\" using assms by (simp)\n  thus \"total / real count = (total / (real_of_nat count))\" by simp\nqed", "description": "-", "full_code": "lemma non_zero_average_value:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\nproof -\n  have \"real count = real_of_nat count\" using assms by (simp)\n  thus \"total / real count = (total / (real_of_nat count))\" by simp\nqed", "origin": "average_value", "update_count": 0}, "amc12a_2013_p8_special_case": {"skill_name": "amc12a_2013_p8_special_case", "marker": "lemma amc12a_2013_p8_special_case:\n  fixes x :: real\n  assumes \"x > 0\"\n  shows \"x * (2/x) = 2\"\nproof -\n  have \"x * (2/x) = 2\" by (metis assms divide_numeral_1 frac_eq_eq less_numeral_extra(3) mult.commute mult_numeral_1_right nonzero_divide_eq_eq zero_neq_numeral)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma amc12a_2013_p8_special_case:\n  fixes x :: real\n  assumes \"x > 0\"\n  shows \"x * (2/x) = 2\"\nproof -\n  have \"x * (2/x) = 2\" by (metis assms divide_numeral_1 frac_eq_eq less_numeral_extra(3) mult.commute mult_numeral_1_right nonzero_divide_eq_eq zero_neq_numeral)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_evolvedV5": {"skill_name": "amc12a_2013_p8_evolvedV5", "marker": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n    and h1 : \"x \\<noteq> y\"\n    and h2 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h2 by simp\n  hence \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  have \"x * y * (x - y) = 2 * (x - y)\" \n    using `x + 2/x = y + 2/y` by sos\n  then show \"x * y = 2\" \n    using h1 by sos\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n    and h1 : \"x \\<noteq> y\"\n    and h2 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h2 by simp\n  hence \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  have \"x * y * (x - y) = 2 * (x - y)\" \n    using `x + 2/x = y + 2/y` by sos\n  then show \"x * y = 2\" \n    using h1 by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "sqrt_non_negativeV4": {"skill_name": "sqrt_non_negativeV4", "marker": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\n  using assms by auto", "description": "-", "full_code": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\n  using assms by auto", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_non_negativeV5": {"skill_name": "sqrt_non_negativeV5", "marker": "lemma sqrt_non_negative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  then have \"sqrt a >= 0\" using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_non_negative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  then have \"sqrt a >= 0\" using assms by auto\n  thus ?thesis by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "mathd_algebra_109_with_constraints": {"skill_name": "mathd_algebra_109_with_constraints", "marker": "theorem mathd_algebra_109_with_constraints:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"0 < a\"\n    and h2 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h2 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  hence \"2 * b = 0\" by (metis add_cancel_right_right)\n  thus ?thesis using `2 * b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_with_constraints:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"0 < a\"\n    and h2 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * 4 + 2 * b = 12\" using h2 eq by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  hence \"2 * b = 0\" by (metis add_cancel_right_right)\n  thus ?thesis using `2 * b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_generalizedV11": {"skill_name": "mathd_algebra_109_generalizedV11", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b k :: real\n  assumes h0 : \"k * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - k * 4) / 2\"\nproof -\n  have eq: \"k * a + 2 * b = 12\" using h0 by simp\n  have \"k * 4 + 2 * b = 12\" using h1 eq by simp\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b k :: real\n  assumes h0 : \"k * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - k * 4) / 2\"\nproof -\n  have eq: \"k * a + 2 * b = 12\" using h0 by simp\n  have \"k * 4 + 2 * b = 12\" using h1 eq by simp\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolvedV17": {"skill_name": "mathd_algebra_109_evolvedV17", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\" \n  shows \"b = 0\"\nproof -\n  from h1 have \"3 * a = 3 * 4\" by simp\n  then have eq: \"3 * 4 + 2 * b = 12\" using h0 by simp\n  hence \"12 + 2 * b = 12\" by auto\n  thus ?thesis using eq by (simp add: add_cancel_right_right) \nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\" \n  shows \"b = 0\"\nproof -\n  from h1 have \"3 * a = 3 * 4\" by simp\n  then have eq: \"3 * 4 + 2 * b = 12\" using h0 by simp\n  hence \"12 + 2 * b = 12\" by auto\n  thus ?thesis using eq by (simp add: add_cancel_right_right) \nqed", "origin": "mathd_algebra_109", "update_count": 0}, "nonneg_sqrt_mult": {"skill_name": "nonneg_sqrt_mult", "marker": "lemma nonneg_sqrt_mult:\n  fixes a b :: real\n  assumes \"a >= 0\" and \"b >= 0\"\n  shows \"sqrt a * sqrt b = sqrt (a * b)\"\nproof -\n  have \"sqrt a * sqrt b = sqrt (a * b)\" using assms \n    by (metis real_sqrt_mult)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma nonneg_sqrt_mult:\n  fixes a b :: real\n  assumes \"a >= 0\" and \"b >= 0\"\n  shows \"sqrt a * sqrt b = sqrt (a * b)\"\nproof -\n  have \"sqrt a * sqrt b = sqrt (a * b)\" using assms \n    by (metis real_sqrt_mult)\n  then show ?thesis by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "mathd_algebra_109_generalV4": {"skill_name": "mathd_algebra_109_generalV4", "marker": "theorem mathd_algebra_109_general:\n  fixes a b :: real\n  assumes h0 : \"k * a + m * b = n\" \n    and h1 : \"a = x\"\n    and k: \"k > 0\" and m: \"m > 0\"\n  shows \"b = (n - k * x) / m\"\nproof -\n  have eq: \"k * a + m * b = n\" using h0 by simp\n  have \"k * x + m * b = n\" using h1 eq by simp\n  have \"m * b = n - k * x\" by (metis \\<open>k * x + m * b = n\\<close> add_diff_cancel_left' h1 mult_delta_right)\n  show ?thesis using `m > 0` by (metis \\<open>m * b = n - k * x\\<close> less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_general:\n  fixes a b :: real\n  assumes h0 : \"k * a + m * b = n\" \n    and h1 : \"a = x\"\n    and k: \"k > 0\" and m: \"m > 0\"\n  shows \"b = (n - k * x) / m\"\nproof -\n  have eq: \"k * a + m * b = n\" using h0 by simp\n  have \"k * x + m * b = n\" using h1 eq by simp\n  have \"m * b = n - k * x\" by (metis \\<open>k * x + m * b = n\\<close> add_diff_cancel_left' h1 mult_delta_right)\n  show ?thesis using `m > 0` by (metis \\<open>m * b = n - k * x\\<close> less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sqrt_difference_square": {"skill_name": "sqrt_difference_square", "marker": "lemma sqrt_difference_square:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"a >= b\"\n  shows \"sqrt (a - b) * sqrt (a - b) = a - b\"\nproof -\n  have \"sqrt (a - b) * sqrt (a - b) = a - b\" using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_difference_square:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"a >= b\"\n  shows \"sqrt (a - b) * sqrt (a - b) = a - b\"\nproof -\n  have \"sqrt (a - b) * sqrt (a - b) = a - b\" using assms by auto\n  thus ?thesis by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_sum_square": {"skill_name": "sqrt_sum_square", "marker": "lemma sqrt_sum_square:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a + b) * sqrt (a + b) = a + b\"\nproof -\n  have \"sqrt (a + b) * sqrt (a + b) = a + b\" using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_sum_square:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a + b) * sqrt (a + b) = a + b\"\nproof -\n  have \"sqrt (a + b) * sqrt (a + b) = a + b\" using assms by auto\n  thus ?thesis by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "units_digit_power": {"skill_name": "units_digit_power", "marker": "lemma units_digit_power:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"((a mod 10) ^ n) mod 10 = (a ^ n) mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by (simp add: assms)\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^Suc n = a * (a^n)\" by simp\n    then have \"a^Suc n mod 10 = (a mod 10) * (a^n mod 10) mod 10\"\n      using `a > 0` by (metis mod_mult_eq power_Suc)\n    also have \"... = (a mod 10) * ((a mod 10) ^ n) mod 10\" \n      using Suc.IH by (metis calculation mod_mod_trivial mod_mult_cong mod_mult_left_eq power_Suc power_mod)\n    finally have \"a^Suc n mod 10 = (a mod 10) * ((a mod 10) ^ n) mod 10\" .\n    have \"((a mod 10) ^ Suc n) mod 10 = ((a mod 10) * ((a mod 10) ^ n)) mod 10\" by simp\n    thus ?case using `a > 0` by (metis power_mod)\n  qed\nqed", "description": "-", "full_code": "lemma units_digit_power:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"((a mod 10) ^ n) mod 10 = (a ^ n) mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by (simp add: assms)\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^Suc n = a * (a^n)\" by simp\n    then have \"a^Suc n mod 10 = (a mod 10) * (a^n mod 10) mod 10\"\n      using `a > 0` by (metis mod_mult_eq power_Suc)\n    also have \"... = (a mod 10) * ((a mod 10) ^ n) mod 10\" \n      using Suc.IH by (metis calculation mod_mod_trivial mod_mult_cong mod_mult_left_eq power_Suc power_mod)\n    finally have \"a^Suc n mod 10 = (a mod 10) * ((a mod 10) ^ n) mod 10\" .\n    have \"((a mod 10) ^ Suc n) mod 10 = ((a mod 10) * ((a mod 10) ^ n)) mod 10\" by simp\n    thus ?case using `a > 0` by (metis power_mod)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "units_digit_powerV2": {"skill_name": "units_digit_powerV2", "marker": "lemma units_digit_power:\n  fixes a :: nat\n  fixes n :: nat\n  assumes \"a > 0\"\n  shows \"((a mod 10) ^ n) mod 10 = (a ^ n) mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"((a mod 10) ^ n) mod 10 = (a ^ n) mod 10\" by auto\n  then have \"((a mod 10) ^ Suc n) mod 10 = ((a mod 10) * (a mod 10) ^ n) mod 10\" by simp\n  also have \"... = ((a mod 10) * ((a ^ n) mod 10)) mod 10\" using Suc.IH by (metis mod_mult_eq power_Suc power_mod)\n  also have \"... = ((a mod 10) * (a ^ n) mod 10) mod 10\" by (metis mod_mod_trivial mod_mult_right_eq)\n  finally show ?case using `a > 0` by (metis power_mod)\nqed", "description": "-", "full_code": "lemma units_digit_power:\n  fixes a :: nat\n  fixes n :: nat\n  assumes \"a > 0\"\n  shows \"((a mod 10) ^ n) mod 10 = (a ^ n) mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"((a mod 10) ^ n) mod 10 = (a ^ n) mod 10\" by auto\n  then have \"((a mod 10) ^ Suc n) mod 10 = ((a mod 10) * (a mod 10) ^ n) mod 10\" by simp\n  also have \"... = ((a mod 10) * ((a ^ n) mod 10)) mod 10\" using Suc.IH by (metis mod_mult_eq power_Suc power_mod)\n  also have \"... = ((a mod 10) * (a ^ n) mod 10) mod 10\" by (metis mod_mod_trivial mod_mult_right_eq)\n  finally show ?case using `a > 0` by (metis power_mod)\nqed", "origin": "do_request", "update_count": 0}, "units_digit_powerV3": {"skill_name": "units_digit_powerV3", "marker": "lemma units_digit_power:\n  fixes a :: nat\n  fixes n :: nat\n  assumes \"a > 0\"\n  shows \"((a mod 10) ^ n) mod 10 = (a ^ n) mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"((a mod 10) ^ Suc n) mod 10 = (a mod 10) * ((a mod 10) ^ n) mod 10\"\n    by simp\n  also have \"... = (a mod 10) * ((a ^ n) mod 10) mod 10\"\n    using Suc.IH by (metis mod_mult_eq power_Suc power_mod)\n  also have \"... = (a * (a ^ n)) mod 10\"\n    by (metis mod_mult_eq)\n  also have \"... = (a ^ Suc n) mod 10\"\n    by (simp add: power_Suc)\n  finally show ?case .\nqed", "description": "-", "full_code": "lemma units_digit_power:\n  fixes a :: nat\n  fixes n :: nat\n  assumes \"a > 0\"\n  shows \"((a mod 10) ^ n) mod 10 = (a ^ n) mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"((a mod 10) ^ Suc n) mod 10 = (a mod 10) * ((a mod 10) ^ n) mod 10\"\n    by simp\n  also have \"... = (a mod 10) * ((a ^ n) mod 10) mod 10\"\n    using Suc.IH by (metis mod_mult_eq power_Suc power_mod)\n  also have \"... = (a * (a ^ n)) mod 10\"\n    by (metis mod_mult_eq)\n  also have \"... = (a ^ Suc n) mod 10\"\n    by (simp add: power_Suc)\n  finally show ?case .\nqed", "origin": "do_request", "update_count": 0}, "sqrt_non_negativity": {"skill_name": "sqrt_non_negativity", "marker": "lemma sqrt_non_negativity:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt a + sqrt b >= 0\"\nproof -\n  have \"sqrt a >= 0\" using assms(1) by simp\n  moreover have \"sqrt b >= 0\" using assms(2) by simp\n  ultimately show ?thesis by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma sqrt_non_negativity:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt a + sqrt b >= 0\"\nproof -\n  have \"sqrt a >= 0\" using assms(1) by simp\n  moreover have \"sqrt b >= 0\" using assms(2) by simp\n  ultimately show ?thesis by (simp add: add_nonneg_nonneg)\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "units_digit_powerV4": {"skill_name": "units_digit_powerV4", "marker": "lemma units_digit_power:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"((a mod 10) ^ n) mod 10 = (a ^ n) mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a ^ Suc n = a * (a ^ n)\" by simp\n    then have \"(a ^ Suc n) mod 10 = (a * (a ^ n)) mod 10\" by simp\n    also have \"... = ((a mod 10) * (a ^ n)) mod 10\"\n      by (metis assms mod_mult_left_eq)\n    also have \"... = ((a mod 10) * ((a ^ n) mod 10)) mod 10\"\n      by (metis mod_mult_right_eq)\n    also have \"... = (a mod 10) ^ Suc n mod 10\"\n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "description": "-", "full_code": "lemma units_digit_power:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"((a mod 10) ^ n) mod 10 = (a ^ n) mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a ^ Suc n = a * (a ^ n)\" by simp\n    then have \"(a ^ Suc n) mod 10 = (a * (a ^ n)) mod 10\" by simp\n    also have \"... = ((a mod 10) * (a ^ n)) mod 10\"\n      by (metis assms mod_mult_left_eq)\n    also have \"... = ((a mod 10) * ((a ^ n) mod 10)) mod 10\"\n      by (metis mod_mult_right_eq)\n    also have \"... = (a mod 10) ^ Suc n mod 10\"\n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_expansion_combined": {"skill_name": "square_expansion_combined", "marker": "lemma square_expansion_combined:\n  fixes a b c :: real\n  shows \"(a - (b + c))^2 = a^2 - 2 * a * b - 2 * a * c + b^2 + 2 * b * c + c^2\"\nproof -\n  have \"a^2 - 2 * a * (b + c) + (b + c)^2 = a^2 - 2 * a * b - 2 * a * c + (b^2 + 2 * b * c + c^2)\"\n    by sos\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion_combined:\n  fixes a b c :: real\n  shows \"(a - (b + c))^2 = a^2 - 2 * a * b - 2 * a * c + b^2 + 2 * b * c + c^2\"\nproof -\n  have \"a^2 - 2 * a * (b + c) + (b + c)^2 = a^2 - 2 * a * b - 2 * a * c + (b^2 + 2 * b * c + c^2)\"\n    by sos\n  thus ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_cV2": {"skill_name": "square_expansion_with_cV2", "marker": "lemma square_expansion_with_c:\n  fixes a b c :: real\n  shows \"(a - (b + c))^2 = a^2 - 2 * a * (b + c) + (b + c)^2\"\nproof -\n  have \"(b + c)^2 = b^2 + 2 * b * c + c^2\" by sos\n  thus ?thesis by (simp add: square_expansion_general)\nqed", "description": "-", "full_code": "lemma square_expansion_general:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\n  by sos\n\nlemma square_expansion_with_c:\n  fixes a b c :: real\n  shows \"(a - (b + c))^2 = a^2 - 2 * a * (b + c) + (b + c)^2\"\nproof -\n  have \"(b + c)^2 = b^2 + 2 * b * c + c^2\" by sos\n  thus ?thesis by (simp add: square_expansion_general)\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_cV3": {"skill_name": "square_expansion_with_cV3", "marker": "lemma square_expansion_with_c:\n  fixes a b c :: real\n  shows \"(a - (b + c))^2 = a^2 - 2*a*(b + c) + (b + c)^2\"\nproof -\n  have \"(a - (b + c))^2 = (a - b - c)^2\"\n    by sos\n  also have \"... = a^2 - 2*a*(b+c) + (b+c)^2\"\n    by sos\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion_with_c:\n  fixes a b c :: real\n  shows \"(a - (b + c))^2 = a^2 - 2*a*(b + c) + (b + c)^2\"\nproof -\n  have \"(a - (b + c))^2 = (a - b - c)^2\"\n    by sos\n  also have \"... = a^2 - 2*a*(b+c) + (b+c)^2\"\n    by sos\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_nested": {"skill_name": "square_expansion_nested", "marker": "lemma square_expansion_nested:\n  fixes a b c :: real\n  shows \"(a - (b - c))^2 = a^2 - 2*a*(b - c) + (b - c)^2\"\nproof -\n  have \"(a - (b - c))^2 = (a - b + c)^2\"\n    by sos\n  also have \"... = a^2 - 2*a*(b - c) + (b - c)^2\"\n    by sos\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion_nested:\n  fixes a b c :: real\n  shows \"(a - (b - c))^2 = a^2 - 2*a*(b - c) + (b - c)^2\"\nproof -\n  have \"(a - (b - c))^2 = (a - b + c)^2\"\n    by sos\n  also have \"... = a^2 - 2*a*(b - c) + (b - c)^2\"\n    by sos\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "average_value_with_weightV3": {"skill_name": "average_value_with_weightV3", "marker": "lemma average_value_with_weight:\n  fixes total :: real and count :: nat and weight :: real\n  assumes \"count > 0\" \"weight > 0\"\n  shows \"total / (weight * real count) = (total / weight) / real count\"\nproof -\n  have \"total / (weight * real count) = (total / weight) * (1 / real count)\"\n    by (simp add: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma average_value_with_weight:\n  fixes total :: real and count :: nat and weight :: real\n  assumes \"count > 0\" \"weight > 0\"\n  shows \"total / (weight * real count) = (total / weight) / real count\"\nproof -\n  have \"total / (weight * real count) = (total / weight) * (1 / real count)\"\n    by (simp add: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "average_value", "update_count": 0}, "amc12a_2013_p8V2": {"skill_name": "amc12a_2013_p8V2", "marker": "theorem amc12a_2013_p8:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n  have \"x * y * (x - y) = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n    using h2 by (smt (verit) \\<open>x * y * (x - y) = 2 * (x - y)\\<close> add_divide_distrib add_frac_eq add_nonneg_eq_0_iff divide_cancel_right divide_self_if eq_divide_imp eq_iff_diff_eq_0 field_sum_of_halves h0 h1 mult_2 mult_cancel_right2 no_zero_divisors nonzero_divide_mult_cancel_right nonzero_mult_divide_mult_cancel_left nonzero_mult_divide_mult_cancel_left2 nonzero_mult_divide_mult_cancel_right of_bool_eq(1) of_bool_eq(2) of_bool_eq_0_iff times_divide_times_eq zero_less_eq_of_bool)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  then have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) h3)\n  have \"x * y * (x - y) = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n    using h2 by (smt (verit) \\<open>x * y * (x - y) = 2 * (x - y)\\<close> add_divide_distrib add_frac_eq add_nonneg_eq_0_iff divide_cancel_right divide_self_if eq_divide_imp eq_iff_diff_eq_0 field_sum_of_halves h0 h1 mult_2 mult_cancel_right2 no_zero_divisors nonzero_divide_mult_cancel_right nonzero_mult_divide_mult_cancel_left nonzero_mult_divide_mult_cancel_left2 nonzero_mult_divide_mult_cancel_right of_bool_eq(1) of_bool_eq(2) of_bool_eq_0_iff times_divide_times_eq zero_less_eq_of_bool)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "solve_linear_congruence": {"skill_name": "solve_linear_congruence", "marker": "lemma solve_linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"(\\<exists> k. a = b + k * m)\"\nproof -\n  have b_less_m: \"b < m\" using assms(2) by (metis assms(1) mod_less_divisor)\n  let ?k = \"a div m\"  \n  have \"a = ?k * m + (a mod m)\" by auto\n  then have \"a = ?k * m + b\" using assms(2) by simp\n  then show \"\\<exists>k. a = b + k * m\" by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma solve_linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"(\\<exists> k. a = b + k * m)\"\nproof -\n  have b_less_m: \"b < m\" using assms(2) by (metis assms(1) mod_less_divisor)\n  let ?k = \"a div m\"  \n  have \"a = ?k * m + (a mod m)\" by auto\n  then have \"a = ?k * m + b\" using assms(2) by simp\n  then show \"\\<exists>k. a = b + k * m\" by (auto simp: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_nonneg": {"skill_name": "sqrt_nonneg", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  obtain b where \"a = b^2\" using assms by (metis order_less_le pos2 realpow_pos_nth_unique zero_power2)\n  then show ?thesis by (simp add: sqrt_def)\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  obtain b where \"a = b^2\" using assms by (metis order_less_le pos2 realpow_pos_nth_unique zero_power2)\n  then show ?thesis by (simp add: sqrt_def)\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "solve_linear_congruenceV2": {"skill_name": "solve_linear_congruenceV2", "marker": "lemma solve_linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"(\\<exists> k. a = b + k * m)\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by auto\n  then have \"a = ?k * m + b\" using assms(2) by (metis mod_less)\n  hence \"a = b + (?k * m)\" by (simp add: algebra_simps)\n  thus ?thesis by (metis)\nqed", "description": "-", "full_code": "lemma solve_linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"(\\<exists> k. a = b + k * m)\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by auto\n  then have \"a = ?k * m + b\" using assms(2) by (metis mod_less)\n  hence \"a = b + (?k * m)\" by (simp add: algebra_simps)\n  thus ?thesis by (metis)\nqed", "origin": "do_request", "update_count": 0}, "solve_linear_congruenceV3": {"skill_name": "solve_linear_congruenceV3", "marker": "lemma solve_linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"(\\<exists> k. a = b + k * m)\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by (simp add: div_mult_mod_eq)\n  then have \"a = ?k * m + b\" using assms(2) by simp\n  then show \"\\<exists>k. a = b + k * m\" by (auto simp: field_simps) \nqed", "description": "-", "full_code": "lemma solve_linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a mod m = b\"\n  shows \"(\\<exists> k. a = b + k * m)\"\nproof -\n  let ?k = \"a div m\"\n  have \"a = ?k * m + (a mod m)\" by (simp add: div_mult_mod_eq)\n  then have \"a = ?k * m + b\" using assms(2) by simp\n  then show \"\\<exists>k. a = b + k * m\" by (auto simp: field_simps) \nqed", "origin": "do_request", "update_count": 0}, "generalized_square_expansionV3": {"skill_name": "generalized_square_expansionV3", "marker": "lemma generalized_square_expansion:\n  fixes a b c d :: real\n  shows \"(a - b)^2 + (c - d)^2 = a^2 - 2*a*b + b^2 + c^2 - 2*c*d + d^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by sos\n  have \"(c - d)^2 = c^2 - 2*c*d + d^2\" by sos\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma generalized_square_expansion:\n  fixes a b c d :: real\n  shows \"(a - b)^2 + (c - d)^2 = a^2 - 2*a*b + b^2 + c^2 - 2*c*d + d^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by sos\n  have \"(c - d)^2 = c^2 - 2*c*d + d^2\" by sos\n  thus ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "expand_polynomial": {"skill_name": "expand_polynomial", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\" \n    by sos\n  hence lhs1: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by simp\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  then have lhs2: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    using lhs1 by simp\n  thus \"?lhs = ?rhs\"\n  proof -\n    have \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + x^2 + 2 * x * y + y^2\"\n      by (simp add: lhs2)\n    also have \"... = (x * y)^2 + x^2 + y^2 + 1\"\n      by (simp add: algebra_simps)\n    finally show \"?lhs = ?rhs\" \n      by (simp add: algebra_simps)\n  qed\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\" \n    by sos\n  hence lhs1: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by simp\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  then have lhs2: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    using lhs1 by simp\n  thus \"?lhs = ?rhs\"\n  proof -\n    have \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + x^2 + 2 * x * y + y^2\"\n      by (simp add: lhs2)\n    also have \"... = (x * y)^2 + x^2 + y^2 + 1\"\n      by (simp add: algebra_simps)\n    finally show \"?lhs = ?rhs\" \n      by (simp add: algebra_simps)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sqrt_limit_generalV5": {"skill_name": "sqrt_limit_generalV5", "marker": "lemma sqrt_limit_general:\n  fixes x :: real and c :: real\n  assumes \"c > 0\" and \"c = sqrt(x + c)\"\n  shows \"x = c^2 - c\"\nproof -\n  have \"c^2 = x + c\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma sqrt_limit_general:\n  fixes x :: real and c :: real\n  assumes \"c > 0\" and \"c = sqrt(x + c)\"\n  shows \"x = c^2 - c\"\nproof -\n  have \"c^2 = x + c\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_nonnegV2": {"skill_name": "sqrt_nonnegV2", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt a\" using assms by simp\n  then show ?thesis by (metis assms real_sqrt_ge_zero)\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt a\" using assms by simp\n  then show ?thesis by (metis assms real_sqrt_ge_zero)\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "bound_check": {"skill_name": "bound_check", "marker": "lemma bound_check:\n  fixes N :: nat and m :: nat\n  assumes \"N = 24 * m + 21\" \"N < 50\"\n  shows \"m < 2\"\nproof -\n  from assms(2) have \"24 * m + 21 < 50\" by (metis assms(1))\n  hence \"24 * m < 50 - 21\" by (simp add: algebra_simps)\n  hence \"24 * m < 29\" by simp\n  then have \"m < 29 / 24\" by auto\n  then have \"m < 2\" by (simp add: less_divide_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma bound_check:\n  fixes N :: nat and m :: nat\n  assumes \"N = 24 * m + 21\" \"N < 50\"\n  shows \"m < 2\"\nproof -\n  from assms(2) have \"24 * m + 21 < 50\" by (metis assms(1))\n  hence \"24 * m < 50 - 21\" by (simp add: algebra_simps)\n  hence \"24 * m < 29\" by simp\n  then have \"m < 29 / 24\" by auto\n  then have \"m < 2\" by (simp add: less_divide_eq)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV2": {"skill_name": "expand_polynomialV2", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs_expansion: \"?lhs = (x * y - 1)^2 + (x + y)^2\" \n    by (simp add: power2_eq_square)\n  have first_part: \"(x * y - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\" \n    by sos\n  have second_part: \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  have \"?lhs = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    using first_part second_part by simp\n  have \"?lhs = (x * y)^2 + x^2 + y^2 + (2 * x * y - 2 * (x * y)) + 1\"\n    by sos\n  have \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  show ?thesis\n    using `?lhs = (x * y)^2 + x^2 + y^2 + 1` by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs_expansion: \"?lhs = (x * y - 1)^2 + (x + y)^2\" \n    by (simp add: power2_eq_square)\n  have first_part: \"(x * y - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\" \n    by sos\n  have second_part: \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  have \"?lhs = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    using first_part second_part by simp\n  have \"?lhs = (x * y)^2 + x^2 + y^2 + (2 * x * y - 2 * (x * y)) + 1\"\n    by sos\n  have \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  show ?thesis\n    using `?lhs = (x * y)^2 + x^2 + y^2 + 1` by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV3": {"skill_name": "expand_polynomialV3", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs_expanded: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\" \n    by sos\n  have plus_expanded: \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  have lhs_simplified: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\" \n    using lhs_expanded plus_expanded by simp\n  have lhs_final: \"?lhs = (x * y)^2 + x^2 + y^2 + 1\" \n    by sos\n  show ?thesis \n    using lhs_final by sos\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs_expanded: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\" \n    by sos\n  have plus_expanded: \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  have lhs_simplified: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\" \n    using lhs_expanded plus_expanded by simp\n  have lhs_final: \"?lhs = (x * y)^2 + x^2 + y^2 + 1\" \n    by sos\n  show ?thesis \n    using lhs_final by sos\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV4": {"skill_name": "expand_polynomialV4", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs_exp: \"?lhs = ((x * y) - 1)^2 + (x + y)^2\"\n    by simp\n  have \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have lhs_combined: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: lhs_combined)\n  have \"?lhs = x^2 * y^2 + x^2 + y^2 + 1\"\n    by sos\n  show ?thesis\n    by sos\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs_exp: \"?lhs = ((x * y) - 1)^2 + (x + y)^2\"\n    by simp\n  have \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have lhs_combined: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: lhs_combined)\n  have \"?lhs = x^2 * y^2 + x^2 + y^2 + 1\"\n    by sos\n  show ?thesis\n    by sos\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV5": {"skill_name": "expand_polynomialV5", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs_expanded: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by sos\n  have plus_expanded: \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have lhs: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have lhs_combined: \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  show ?thesis\n  proof -\n    have \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n      using lhs_combined by simp\n    thus ?thesis\n      by sos\n  qed\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs_expanded: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by sos\n  have plus_expanded: \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have lhs: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have lhs_combined: \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  show ?thesis\n  proof -\n    have \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n      using lhs_combined by simp\n    thus ?thesis\n      by sos\n  qed\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV6": {"skill_name": "expand_polynomialV6", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs1: \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  have lhs2: \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  have \"?lhs = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: lhs1 lhs2)\n  also have \"... = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by sos\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs1: \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  have lhs2: \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  have \"?lhs = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    by (simp add: lhs1 lhs2)\n  also have \"... = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by sos\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV7": {"skill_name": "expand_polynomialV7", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have expansion_lhs: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by sos\n  have expansion_rhs: \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have final_lhs: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    using expansion_lhs expansion_rhs by simp\n  have simplified_lhs: \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  show ?thesis\n  proof -\n    have \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n      using final_lhs simplified_lhs by simp\n    thus \"?lhs = ?rhs\"\n      by (simp add: algebra_simps)\n  qed\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have expansion_lhs: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by sos\n  have expansion_rhs: \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  have final_lhs: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    using expansion_lhs expansion_rhs by simp\n  have simplified_lhs: \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n    by sos\n  show ?thesis\n  proof -\n    have \"?lhs = (x * y)^2 + x^2 + y^2 + 1\"\n      using final_lhs simplified_lhs by simp\n    thus \"?lhs = ?rhs\"\n      by (simp add: algebra_simps)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV8": {"skill_name": "expand_polynomialV8", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have rhs: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  show ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n      by (simp add: lhs)\n    also have \"... = (x * y)^2 + (x^2 + y^2) + 1\"\n      by (simp add: algebra_simps)\n    finally show ?thesis\n      using rhs by simp\n  qed\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have rhs: \"x^2 * y^2 + x^2 + y^2 + 1 = (x * y)^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  show ?thesis\n  proof -\n    have \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n      by (simp add: lhs)\n    also have \"... = (x * y)^2 + (x^2 + y^2) + 1\"\n      by (simp add: algebra_simps)\n    finally show ?thesis\n      using rhs by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV9": {"skill_name": "expand_polynomialV9", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  have left_side: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by sos\n  also have \"... = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  also have \"... = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by sos\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  have left_side: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by sos\n  also have \"... = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  also have \"... = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by sos\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV10": {"skill_name": "expand_polynomialV10", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs_expanded: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  then have lhs_final: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    using lhs_expanded by simp\n  have \"?lhs = (x * y)^2 + x^2 + y^2 + 1 + 2 * x * y - 2 * (x * y)\"\n    by (simp add: lhs_final)\n  also have \"... = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: algebra_simps)\n  show \"?lhs = ?rhs\"\n    by sos\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 + x^2 + y^2 + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  let ?rhs = \"x^2 * y^2 + x^2 + y^2 + 1\"\n  have lhs_expanded: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x + y)^2\"\n    by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  then have lhs_final: \"?lhs = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    using lhs_expanded by simp\n  have \"?lhs = (x * y)^2 + x^2 + y^2 + 1 + 2 * x * y - 2 * (x * y)\"\n    by (simp add: lhs_final)\n  also have \"... = (x * y)^2 + x^2 + y^2 + 1\"\n    by (simp add: algebra_simps)\n  show \"?lhs = ?rhs\"\n    by sos\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_extendedV12": {"skill_name": "mathd_algebra_109_extendedV12", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"k * a + m * b = c\"  \n    and h1 : \"a = d\"  \n    and k_pos: \"k > 0\"  \n    and m_pos: \"m > 0\"  \n  shows \"b = (c - k * d) / m\"  \nproof -\n  have eq: \"k * a + m * b = c\" using h0 by simp\n  have \"k * d + m * b = c\" using h1 eq by simp\n  have \"m * b = c - k * d\" by (metis \\<open>k * d + m * b = c\\<close> add_diff_cancel_left' h1 mult_delta_right)\n  then show ?thesis by (metis less_numeral_extra(3) m_pos mult.commute nonzero_mult_div_cancel_right)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"k * a + m * b = c\"  \n    and h1 : \"a = d\"  \n    and k_pos: \"k > 0\"  \n    and m_pos: \"m > 0\"  \n  shows \"b = (c - k * d) / m\"  \nproof -\n  have eq: \"k * a + m * b = c\" using h0 by simp\n  have \"k * d + m * b = c\" using h1 eq by simp\n  have \"m * b = c - k * d\" by (metis \\<open>k * d + m * b = c\\<close> add_diff_cancel_left' h1 mult_delta_right)\n  then show ?thesis by (metis less_numeral_extra(3) m_pos mult.commute nonzero_mult_div_cancel_right)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_generalV5": {"skill_name": "mathd_algebra_109_generalV5", "marker": "theorem mathd_algebra_109_general:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = c\"  \n    and h1 : \"a = d\"                 \n  shows \"b = (c - 3 * d) / 2\"        \nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  then show ?thesis by (simp add: field_simps)  \nqed", "description": "-", "full_code": "theorem mathd_algebra_109_general:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = c\"  \n    and h1 : \"a = d\"                 \n  shows \"b = (c - 3 * d) / 2\"        \nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  then show ?thesis by (simp add: field_simps)  \nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_extendedV13": {"skill_name": "mathd_algebra_109_extendedV13", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = k\"  \n  shows \"b = (12 - 3*k) / 2\" \nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * k + 2 * b = 12\" using h1 eq by simp\n  have \"2 * b = 12 - 3 * k\" by (smt (verit) h0 h1)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = k\"  \n  shows \"b = (12 - 3*k) / 2\" \nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have \"3 * k + 2 * b = 12\" using h1 eq by simp\n  have \"2 * b = 12 - 3 * k\" by (smt (verit) h0 h1)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sqrt_limit_generalV6": {"skill_name": "sqrt_limit_generalV6", "marker": "lemma sqrt_limit_general:\n  fixes x :: real and c :: real\n  assumes \"c > 0\" and \"c = sqrt(x + c)\"\n  shows \"x = c^2 - c\"\nproof -\n  have \"c^2 = x + c\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  have \"x = c^2 - c\" by (metis \\<open>c\\<^sup>2 = x + c\\<close> add_diff_cancel semiring_norm(3) semiring_norm(5))\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_limit_general:\n  fixes x :: real and c :: real\n  assumes \"c > 0\" and \"c = sqrt(x + c)\"\n  shows \"x = c^2 - c\"\nproof -\n  have \"c^2 = x + c\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  have \"x = c^2 - c\" by (metis \\<open>c\\<^sup>2 = x + c\\<close> add_diff_cancel semiring_norm(3) semiring_norm(5))\n  thus ?thesis by auto\nqed", "origin": "sqrt_limit", "update_count": 0}, "square_expansion_with_coefficientsV4": {"skill_name": "square_expansion_with_coefficientsV4", "marker": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(a - b + c*d)^2 = a^2 - 2*a*b + b^2 + 2*(c*d)*(a - b) + (c*d)^2\"\nproof -\n  have \"(a - b + c*d)^2 = ((a - b) + c*d)^2\" by simp\n  also have \"... = (a - b)^2 + 2*(a - b)*(c*d) + (c*d)^2\" by sos\n  also have \"... = (a^2 - 2*a*b + b^2) + 2*(c*d)*(a - b) + (c*d)^2\" by sos\n  finally show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(a - b + c*d)^2 = a^2 - 2*a*b + b^2 + 2*(c*d)*(a - b) + (c*d)^2\"\nproof -\n  have \"(a - b + c*d)^2 = ((a - b) + c*d)^2\" by simp\n  also have \"... = (a - b)^2 + 2*(a - b)*(c*d) + (c*d)^2\" by sos\n  also have \"... = (a^2 - 2*a*b + b^2) + 2*(c*d)*(a - b) + (c*d)^2\" by sos\n  finally show ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_generalizedV5": {"skill_name": "square_expansion_generalizedV5", "marker": "lemma square_expansion_generalized:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2*a*b + b^2 + 2*c*(a - b) + c^2\"\nproof -\n  have \"(a - b + c)^2 = ((a - b) + c)^2\" by simp\n  also have \"... = (a - b)^2 + 2*(a - b)*c + c^2\" by sos\n  also have \"... = (a^2 - 2*a*b + b^2) + 2*(a - b)*c + c^2\" by sos\n  finally show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion_generalized:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2*a*b + b^2 + 2*c*(a - b) + c^2\"\nproof -\n  have \"(a - b + c)^2 = ((a - b) + c)^2\" by simp\n  also have \"... = (a - b)^2 + 2*(a - b)*c + c^2\" by sos\n  also have \"... = (a^2 - 2*a*b + b^2) + 2*(a - b)*c + c^2\" by sos\n  finally show ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_coefficientsV5": {"skill_name": "square_expansion_with_coefficientsV5", "marker": "lemma square_expansion_with_coefficients:\n  fixes a b k :: real\n  shows \"(k*a - b)^2 = k^2 * a^2 - 2*k*a*b + b^2\"\nproof -\n  have \"(k*a - b)^2 = (k*a)^2 - 2*(k*a)*b + b^2\" by sos\n  also have \"... = k^2 * a^2 - 2*k*a*b + b^2\" by (simp add: algebra_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_expansion_with_coefficients:\n  fixes a b k :: real\n  shows \"(k*a - b)^2 = k^2 * a^2 - 2*k*a*b + b^2\"\nproof -\n  have \"(k*a - b)^2 = (k*a)^2 - 2*(k*a)*b + b^2\" by sos\n  also have \"... = k^2 * a^2 - 2*k*a*b + b^2\" by (simp add: algebra_simps)\n  finally show ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_conditions": {"skill_name": "square_expansion_with_conditions", "marker": "lemma square_expansion_with_conditions:\n  fixes a b c :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"(a - b)^2 + (b - c)^2 = a^2 - 2*a*b + b^2 + b^2 - 2*b*c + c^2\"\nproof -\n  have \"(a - b)^2 + (b - c)^2 = (a^2 - 2*a*b + b^2) + (b^2 - 2*b*c + c^2)\"\n    by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion_with_conditions:\n  fixes a b c :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"(a - b)^2 + (b - c)^2 = a^2 - 2*a*b + b^2 + b^2 - 2*b*c + c^2\"\nproof -\n  have \"(a - b)^2 + (b - c)^2 = (a^2 - 2*a*b + b^2) + (b^2 - 2*b*c + c^2)\"\n    by sos\n  thus ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "sqrt_square_multi": {"skill_name": "sqrt_square_multi", "marker": "lemma sqrt_square_multi:\n  fixes a :: \"real set\"\n  assumes \"\\<forall>x \\<in> a. x >= 0\"\n  shows \"\\<forall>x \\<in> a. sqrt x * sqrt x = x\"\nproof -\n  have \"\\<forall>x \\<in> a. sqrt x * sqrt x = x\"\n  proof\n    fix x\n    assume \"x \\<in> a\"\n    then have \"x >= 0\" using assms by auto\n    thus \"sqrt x * sqrt x = x\" by (rule sqrt_square)\n  qed\n  thus ?thesis by blast\nqed", "description": "-", "full_code": "lemma sqrt_square:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  then show ?thesis by simp\nqed\n\nlemma sqrt_square_multi:\n  fixes a :: \"real set\"\n  assumes \"\\<forall>x \\<in> a. x >= 0\"\n  shows \"\\<forall>x \\<in> a. sqrt x * sqrt x = x\"\nproof -\n  have \"\\<forall>x \\<in> a. sqrt x * sqrt x = x\"\n  proof\n    fix x\n    assume \"x \\<in> a\"\n    then have \"x >= 0\" using assms by auto\n    thus \"sqrt x * sqrt x = x\" by (rule sqrt_square)\n  qed\n  thus ?thesis by blast\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "square_expansion_parameterized": {"skill_name": "square_expansion_parameterized", "marker": "lemma square_expansion_parameterized:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\n  by sos", "description": "-", "full_code": "lemma square_expansion_parameterized:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\n  by sos", "origin": "square_expansion", "update_count": 0}, "chinese_remainderV8": {"skill_name": "chinese_remainderV8", "marker": "lemma chinese_remainder:\n  fixes x a b c d :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n    and \"x mod b = a\" \"x mod d = c\"\n  shows \"\\<exists>k. x = a + b * k \\<and> x mod d = c\"\nproof -\n  let ?k = \"x div b\"  \n  have \"x = ?k * b + (x mod b)\" by (metis div_mult_mod_eq)\n  then have \"x = ?k * b + a\" using assms(5) by auto\n  moreover have \"x mod d = (?k * b + a) mod d\"\n    by (metis calculation)\n  ultimately show \"\\<exists>k. x = a + b * k \\<and> x mod d = c\" \n    by (metis assms(5) assms(6) mod_div_mult_eq mult.commute)\nqed", "description": "-", "full_code": "lemma chinese_remainder:\n  fixes x a b c d :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n    and \"x mod b = a\" \"x mod d = c\"\n  shows \"\\<exists>k. x = a + b * k \\<and> x mod d = c\"\nproof -\n  let ?k = \"x div b\"  \n  have \"x = ?k * b + (x mod b)\" by (metis div_mult_mod_eq)\n  then have \"x = ?k * b + a\" using assms(5) by auto\n  moreover have \"x mod d = (?k * b + a) mod d\"\n    by (metis calculation)\n  ultimately show \"\\<exists>k. x = a + b * k \\<and> x mod d = c\" \n    by (metis assms(5) assms(6) mod_div_mult_eq mult.commute)\nqed", "origin": "do_request", "update_count": 0}, "square_mod_n": {"skill_name": "square_mod_n", "marker": "lemma square_mod_n:\n  fixes a :: int\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"(a^2 mod n) \\<in> {0..n-1}\"\nproof -\n  have \"a mod n < n\" by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)\n  then have \"a^2 mod n < n\" by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)\n  moreover have \"a^2 mod n \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_mod_n:\n  fixes a :: int\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"(a^2 mod n) \\<in> {0..n-1}\"\nproof -\n  have \"a mod n < n\" by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)\n  then have \"a^2 mod n < n\" by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)\n  moreover have \"a^2 mod n \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff)\n  ultimately show ?thesis by auto\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "square_difference_expansion": {"skill_name": "square_difference_expansion", "marker": "lemma square_difference_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + (-b))^2\" by simp\n  also have \"... = a^2 + 2*a*(-b) + (-b)^2\" by sos\n  also have \"... = a^2 - 2*a*b + b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_difference_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + (-b))^2\" by simp\n  also have \"... = a^2 + 2*a*(-b) + (-b)^2\" by sos\n  also have \"... = a^2 - 2*a*b + b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "units_digit_of_squareV4": {"skill_name": "units_digit_of_squareV4", "marker": "lemma units_digit_of_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  have \"n = 10 * (n div 10) + (n mod 10)\" by auto\n  then have \"n^2 = (10 * (n div 10) + (n mod 10))^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * (n mod 10) + (n mod 10)^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2\" by (simp add: power2_eq_square)\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2) mod 10\" by simp\n  then have \"... = (n mod 10)^2 mod 10\" using mod_mult_self2[of \"n div 10\" \"100\"] mod_mult_self2[of \"n div 10\" \"20\"] by (metis power_mod)\n  thus ?thesis by (metis power_mod)\nqed", "description": "-", "full_code": "lemma units_digit_of_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  have \"n = 10 * (n div 10) + (n mod 10)\" by auto\n  then have \"n^2 = (10 * (n div 10) + (n mod 10))^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * (n mod 10) + (n mod 10)^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2\" by (simp add: power2_eq_square)\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2) mod 10\" by simp\n  then have \"... = (n mod 10)^2 mod 10\" using mod_mult_self2[of \"n div 10\" \"100\"] mod_mult_self2[of \"n div 10\" \"20\"] by (metis power_mod)\n  thus ?thesis by (metis power_mod)\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_123_natural": {"skill_name": "mathd_algebra_123_natural", "marker": "theorem mathd_algebra_123_natural:\n  fixes a b :: nat\n  assumes h0: \"3 * a + 2 * b = 12\"\n      and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * 4 + 2 * b = 12\" using h1 h0 by simp\n  hence \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (metis add.commute add_cancel_right_left)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_123_natural:\n  fixes a b :: nat\n  assumes h0: \"3 * a + 2 * b = 12\"\n      and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * 4 + 2 * b = 12\" using h1 h0 by simp\n  hence \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (metis add.commute add_cancel_right_left)\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_123_v2": {"skill_name": "mathd_algebra_123_v2", "marker": "theorem mathd_algebra_123_v2:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = 12\"\n      and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * 4 + 2 * b = 12\" using h1 h0 by simp\n  hence \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (metis add.commute add_cancel_right_left)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_123_v2:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = 12\"\n      and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * 4 + 2 * b = 12\" using h1 h0 by simp\n  hence \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 0\" by (metis add.commute add_cancel_right_left)\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "simplify_expressionV4": {"skill_name": "simplify_expressionV4", "marker": "lemma simplify_expression:\n  fixes a b c d :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  using square_expansion by simp", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(-b + a)^2 = a^2 - 2*a*b + b^2\" by (simp add: power2_eq_square algebra_simps)\n  then show ?thesis by (simp add: algebra_simps)\nqed\n\nlemma simplify_expression:\n  fixes a b c d :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  using square_expansion by simp", "origin": "square_expansion", "update_count": 0}, "algebra_2varlineareq_simpler": {"skill_name": "algebra_2varlineareq_simpler", "marker": "lemma algebra_2varlineareq_simpler:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n  shows \"e = 7 - x\"\nproof -\n  show ?thesis by (metis add_diff_cancel_left' diff_minus_eq_add h0 verit_minus_simplify(3))\nqed", "description": "-", "full_code": "lemma algebra_2varlineareq_simpler:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n  shows \"e = 7 - x\"\nproof -\n  show ?thesis by (metis add_diff_cancel_left' diff_minus_eq_add h0 verit_minus_simplify(3))\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_derived": {"skill_name": "algebra_2varlineareq_derived", "marker": "lemma algebra_2varlineareq_derived:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  show ?thesis using eq_simplified by (metis add.commute add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved diff_add_eq diff_minus_eq_add mult.commute mult_2_right verit_minus_simplify(4))\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed\n\nlemma algebra_2varlineareq_derived:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  show ?thesis using eq_simplified by (metis add.commute add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved diff_add_eq diff_minus_eq_add mult.commute mult_2_right verit_minus_simplify(4))\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "square_sum": {"skill_name": "square_sum", "marker": "lemma square_sum:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2*x*y + y^2\"\nproof -\n  have \"(x + y)^2 = (x + y) * (x + y)\" by sos\n  also have \"... = x*x + x*y + y*x + y*y\" by sos\n  also have \"... = x^2 + 2*x*y + y^2\" by sos\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_sum:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2*x*y + y^2\"\nproof -\n  have \"(x + y)^2 = (x + y) * (x + y)\" by sos\n  also have \"... = x*x + x*y + y*x + y*y\" by sos\n  also have \"... = x^2 + 2*x*y + y^2\" by sos\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_sumV2": {"skill_name": "square_sumV2", "marker": "lemma square_sum:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2*x*y + y^2\"\nproof -\n  have \" (x + y)^2 = (x + y) * (x + y)\" by sos\n  also have \" ... = x*x + x*y + y*x + y*y\" by (simp add: algebra_simps)\n  also have \" ... = x^2 + 2*x*y + y^2\" by sos\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_sum:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2*x*y + y^2\"\nproof -\n  have \" (x + y)^2 = (x + y) * (x + y)\" by sos\n  also have \" ... = x*x + x*y + y*x + y*y\" by (simp add: algebra_simps)\n  also have \" ... = x^2 + 2*x*y + y^2\" by sos\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_sumV3": {"skill_name": "square_sumV3", "marker": "lemma square_sum:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2*x*y + y^2\"\nproof -\n  have \"(x + y)^2 = (x + y) * (x + y)\" by sos\n  also have \"... = x * (x + y) + y * (x + y)\" by sos\n  also have \"... = x^2 + x*y + y*x + y^2\" by sos\n  also have \"... = x^2 + 2*x*y + y^2\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_sum:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2*x*y + y^2\"\nproof -\n  have \"(x + y)^2 = (x + y) * (x + y)\" by sos\n  also have \"... = x * (x + y) + y * (x + y)\" by sos\n  also have \"... = x^2 + x*y + y*x + y^2\" by sos\n  also have \"... = x^2 + 2*x*y + y^2\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_sumV4": {"skill_name": "square_sumV4", "marker": "lemma square_sum:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have \"(x + y)^2 = (x + y) * (x + y)\"\n    by sos\n  also have \"... = x * (x + y) + y * (x + y)\"\n    by (simp add: distrib_right)\n  also have \"... = x^2 + x * y + y * x + y^2\"\n    by sos\n  finally show ?thesis \n    by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma square_sum:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have \"(x + y)^2 = (x + y) * (x + y)\"\n    by sos\n  also have \"... = x * (x + y) + y * (x + y)\"\n    by (simp add: distrib_right)\n  also have \"... = x^2 + x * y + y * x + y^2\"\n    by sos\n  finally show ?thesis \n    by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "multi_square_expansion": {"skill_name": "multi_square_expansion", "marker": "lemma multi_square_expansion:\n  fixes x :: \"real list\" and i j :: nat\n  assumes \"length x > max i j\"\n  shows \"(x ! i - x ! j)^2 = (x ! i)^2 - 2 * (x ! i) * (x ! j) + (x ! j)^2\"\n  by (simp add: power2_diff)", "description": "-", "full_code": "lemma multi_square_expansion:\n  fixes x :: \"real list\" and i j :: nat\n  assumes \"length x > max i j\"\n  shows \"(x ! i - x ! j)^2 = (x ! i)^2 - 2 * (x ! i) * (x ! j) + (x ! j)^2\"\n  by (simp add: power2_diff)", "origin": "square_expansion", "update_count": 0}, "square_sumV5": {"skill_name": "square_sumV5", "marker": "lemma square_sum:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2*x*y + y^2\"\nproof -\n  have \"(x + y)^2 = (x + y) * (x + y)\"\n    by sos\n  also have \"... = x * (x + y) + y * (x + y)\"\n    by (simp add: distrib_right)\n  also have \"... = x^2 + x*y + y*x + y^2\"\n    by sos\n  also have \"... = x^2 + 2*x*y + y^2\"\n    by auto\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_sum:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2*x*y + y^2\"\nproof -\n  have \"(x + y)^2 = (x + y) * (x + y)\"\n    by sos\n  also have \"... = x * (x + y) + y * (x + y)\"\n    by (simp add: distrib_right)\n  also have \"... = x^2 + x*y + y*x + y^2\"\n    by sos\n  also have \"... = x^2 + 2*x*y + y^2\"\n    by auto\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "amc12a_2013_p8_extendedV5": {"skill_name": "amc12a_2013_p8_extendedV5", "marker": "theorem amc12a_2013_p8_extended:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"\\<forall>n. (x + 2/x)^n = (y + 2/y)^n\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by (metis add.commute add_left_imp_eq divide_cancel_left numeral_plus_one one_add_one power_one_right zero_neq_numeral)\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) \\<open>x + 2 / x = y + 2 / y\\<close>)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n    using h2 cross_mult by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_extended:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"\\<forall>n. (x + 2/x)^n = (y + 2/y)^n\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by (metis add.commute add_left_imp_eq divide_cancel_left numeral_plus_one one_add_one power_one_right zero_neq_numeral)\n  have rearranged: \"x - y = (2/y - 2/x)\" by (smt (verit) \\<open>x + 2 / x = y + 2 / y\\<close>)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n    using h2 cross_mult by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "square_expansion_multi": {"skill_name": "square_expansion_multi", "marker": "fun square_expansion_multi :: \"real list \\<Rightarrow> real\" where\n  \"square_expansion_multi [] = 0\" |\n  \"square_expansion_multi [x] = x^2\" |\n  \"square_expansion_multi (x # xs) = x^2 + square_expansion_multi xs\"", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  by sos\n\nfun square_expansion_multi :: \"real list \\<Rightarrow> real\" where\n  \"square_expansion_multi [] = 0\" |\n  \"square_expansion_multi [x] = x^2\" |\n  \"square_expansion_multi (x # xs) = x^2 + square_expansion_multi xs\"", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_product": {"skill_name": "square_expansion_with_product", "marker": "lemma square_expansion_with_product:\n  fixes a b c d :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\" \"d >= 0\"\n  shows \"((a - b) * (c - d))^2 = (a^2 - 2*a*b + b^2) * (c^2 - 2*c*d + d^2)\"\nproof -\n  have \"((a - b) * (c - d))^2 = (a - b)^2 * (c - d)^2\" by sos\n  also have \"... = (a^2 - 2*a*b + b^2) * (c^2 - 2*c*d + d^2)\" \n    by sos\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_expansion_with_product:\n  fixes a b c d :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\" \"d >= 0\"\n  shows \"((a - b) * (c - d))^2 = (a^2 - 2*a*b + b^2) * (c^2 - 2*c*d + d^2)\"\nproof -\n  have \"((a - b) * (c - d))^2 = (a - b)^2 * (c - d)^2\" by sos\n  also have \"... = (a^2 - 2*a*b + b^2) * (c^2 - 2*c*d + d^2)\" \n    by sos\n  finally show ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "square_of_difference": {"skill_name": "square_of_difference", "marker": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"a - b = a + -b\" by simp\n  then show ?thesis by sos\nqed", "description": "", "full_code": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"a - b = a + -b\" by simp\n  then show ?thesis by sos\nqed", "origin": "data/full_data/debug/valid_rand/mathd_algebra_116.json_v34", "update_count": -1}, "sqrt_non_negativeV6": {"skill_name": "sqrt_non_negativeV6", "marker": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt x \\<ge> 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" \n    using assms by (simp add: max_def)\n  also have \"max x 0 = x\" \n    using assms by (simp add: max_def)\n  finally have \"sqrt x = sqrt x\" by simp\n  thus ?thesis \n    using assms real_sqrt_ge_zero by auto\nqed", "description": "-", "full_code": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt x \\<ge> 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" \n    using assms by (simp add: max_def)\n  also have \"max x 0 = x\" \n    using assms by (simp add: max_def)\n  finally have \"sqrt x = sqrt x\" by simp\n  thus ?thesis \n    using assms real_sqrt_ge_zero by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_non_negativeV7": {"skill_name": "sqrt_non_negativeV7", "marker": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt x \\<ge> 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\"\n    using assms by (metis max.absorb_iff2 max.commute)\n  also have \"sqrt (max x 0) \\<ge> 0\"\n    using assms by (simp add: real_sqrt_ge_zero)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma sqrt_non_negative:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt x \\<ge> 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\"\n    using assms by (metis max.absorb_iff2 max.commute)\n  also have \"sqrt (max x 0) \\<ge> 0\"\n    using assms by (simp add: real_sqrt_ge_zero)\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "minimum_value": {"skill_name": "minimum_value", "marker": "lemma minimum_value:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  let ?f = \"(x * y - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 \\<ge> 0\"\n    by auto\n  have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  then have \"?f \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  have \"?f = (x * y - 1)^2 + (x + y)^2\"\n  proof -\n    show \"?f = (x * y - 1)^2 + (x + y)^2\" by simp\n  qed\n  have \"?f \\<ge> 1\"\n  proof (cases \"((x * y - 1)^2 + (x + y)^2) < 1\")\n    case True\n    then have \"?f < 1\" \n      by simp\n    then show ?thesis \n      by sos\n  next\n    case False\n    then have \"?f \\<ge> 1\"\n      by simp\n    then show ?thesis \n      by simp\n  qed\n  then show ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma minimum_value:\n  fixes x y :: real\n  shows \"1 \\<le> (x * y - 1)^2 + (x + y)^2\"\nproof -\n  let ?f = \"(x * y - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 \\<ge> 0\"\n    by auto\n  have \"(x + y)^2 \\<ge> 0\"\n    by auto\n  then have \"?f \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  have \"?f = (x * y - 1)^2 + (x + y)^2\"\n  proof -\n    show \"?f = (x * y - 1)^2 + (x + y)^2\" by simp\n  qed\n  have \"?f \\<ge> 1\"\n  proof (cases \"((x * y - 1)^2 + (x + y)^2) < 1\")\n    case True\n    then have \"?f < 1\" \n      by simp\n    then show ?thesis \n      by sos\n  next\n    case False\n    then have \"?f \\<ge> 1\"\n      by simp\n    then show ?thesis \n      by simp\n  qed\n  then show ?thesis \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "square_of_difference_generalized": {"skill_name": "square_of_difference_generalized", "marker": "lemma square_of_difference_generalized:\n  fixes a b c :: real\n  shows \"(a - b - c)^2 = a^2 - 2 * (b + c) * a + (b + c)^2\"\nproof -\n  have \"a - (b + c) = a - b - c\" by simp\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_of_difference_generalized:\n  fixes a b c :: real\n  shows \"(a - b - c)^2 = a^2 - 2 * (b + c) * a + (b + c)^2\"\nproof -\n  have \"a - (b + c) = a - b - c\" by simp\n  then show ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_difference_generalizedV2": {"skill_name": "square_of_difference_generalizedV2", "marker": "lemma square_of_difference_generalized:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2 * a * b + b^2 + 2 * c * (a - b) + c^2\"\nproof -\n  have \"(a - b + c) * (a - b + c) = (a - b)^2 + 2 * c * (a - b) + c^2\"\n    by sos\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_of_difference_generalized:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2 * a * b + b^2 + 2 * c * (a - b) + c^2\"\nproof -\n  have \"(a - b + c) * (a - b + c) = (a - b)^2 + 2 * c * (a - b) + c^2\"\n    by sos\n  then show ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_difference_expanded": {"skill_name": "square_of_difference_expanded", "marker": "lemma square_of_difference_expanded:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b) * (a - b) = a^2 - 2 * a * b + b^2\"\n  proof -\n    have \"a - b = a + -b\" by simp\n    then show ?thesis by sos\n  qed\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_of_difference_expanded:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b) * (a - b) = a^2 - 2 * a * b + b^2\"\n  proof -\n    have \"a - b = a + -b\" by simp\n    then show ?thesis by sos\n  qed\n  thus ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpleV3": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpleV3", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simple:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  then show \"x = -4\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simple:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" using eq_simplified by simp\n  then show \"x = -4\" by (simp add: field_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "extended_equality_properties": {"skill_name": "extended_equality_properties", "marker": "lemma extended_equality_properties:\n  fixes a b c d :: real\n  assumes \"a + b = c\" \"b + d = c\"\n  shows \"a = d\"\nproof -\n  have \"a + b = b + d\" using assms by simp\n  hence \"a = d\" using assms(1) by auto\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma extended_equality_properties:\n  fixes a b c d :: real\n  assumes \"a + b = c\" \"b + d = c\"\n  shows \"a = d\"\nproof -\n  have \"a + b = b + d\" using assms by simp\n  hence \"a = d\" using assms(1) by auto\n  thus ?thesis .\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_multiple_solutions": {"skill_name": "algebra_2varlineareq_multiple_solutions", "marker": "theorem algebra_2varlineareq_multiple_solutions:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 7 - x \\<and> x = (3 - e) / 2\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  hence \"x + 7 = 3\" by (simp add: field_simps)\n  then have \"x = (3 - 7)\" by (simp add: field_simps)\n  thus ?thesis using e_expr by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_multiple_solutions:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 7 - x \\<and> x = (3 - e) / 2\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  hence \"x + 7 = 3\" by (simp add: field_simps)\n  then have \"x = (3 - 7)\" by (simp add: field_simps)\n  thus ?thesis using e_expr by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "non_negative_sumV4": {"skill_name": "non_negative_sumV4", "marker": "lemma non_negative_sum:\n  fixes a b c :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\"\n  shows \"a + b + c >= 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by simp\n  moreover have \"a + b >= 0\"\n  proof -\n    have \"a >= 0\" using assms(1) by simp\n    have \"b >= 0\" using assms(2) by simp\n    then show \"a + b >= 0\" by (metis add_nonneg_nonneg assms(1))\n  qed\n  moreover have \"c >= 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma non_negative_sum:\n  fixes a b c :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\"\n  shows \"a + b + c >= 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by simp\n  moreover have \"a + b >= 0\"\n  proof -\n    have \"a >= 0\" using assms(1) by simp\n    have \"b >= 0\" using assms(2) by simp\n    then show \"a + b >= 0\" by (metis add_nonneg_nonneg assms(1))\n  qed\n  moreover have \"c >= 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "non_negative_sumV5": {"skill_name": "non_negative_sumV5", "marker": "lemma non_negative_sum:\n  fixes a b c :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\"\n  shows \"a + b + c >= 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by simp\n  moreover have \"a + b >= 0\"\n  proof -\n    have \"a >= 0\" using assms(1) by simp\n    have \"b >= 0\" using assms(2) by simp\n    thus \"a + b >= 0\" by (metis add_nonneg_nonneg assms(1))\n  qed\n  moreover have \"c >= 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma non_negative_sum:\n  fixes a b c :: real\n  assumes \"a >= 0\" \"b >= 0\" \"c >= 0\"\n  shows \"a + b + c >= 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by simp\n  moreover have \"a + b >= 0\"\n  proof -\n    have \"a >= 0\" using assms(1) by simp\n    have \"b >= 0\" using assms(2) by simp\n    thus \"a + b >= 0\" by (metis add_nonneg_nonneg assms(1))\n  qed\n  moreover have \"c >= 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "square_of_difference_with_inequalities": {"skill_name": "square_of_difference_with_inequalities", "marker": "lemma square_of_difference_with_inequalities:\n  fixes a b :: real\n  assumes \"a > b\"\n  shows \"(a - b)^2 > 0\"\nproof -\n  have \"a - b > 0\" using assms by simp\n  hence \"(a - b)^2 > 0\" by (simp add: power2_eq_square)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_of_difference_with_inequalities:\n  fixes a b :: real\n  assumes \"a > b\"\n  shows \"(a - b)^2 > 0\"\nproof -\n  have \"a - b > 0\" using assms by simp\n  hence \"(a - b)^2 > 0\" by (simp add: power2_eq_square)\n  thus ?thesis by simp\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_difference_expandedV2": {"skill_name": "square_of_difference_expandedV2", "marker": "lemma square_of_difference_expanded:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b) * (a - b) = a * a - b * a - b * a + b * b\" by sos\n  then show ?thesis by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_of_difference_expanded:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b) * (a - b) = a * a - b * a - b * a + b * b\" by sos\n  then show ?thesis by (simp add: power2_eq_square)\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_difference_expandedV3": {"skill_name": "square_of_difference_expandedV3", "marker": "lemma square_of_difference_expanded:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b) * (a - b) = (a + -b) * (a + -b)\" by (simp add: algebra_simps)\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_of_difference_expanded:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b) * (a - b) = (a + -b) * (a + -b)\" by (simp add: algebra_simps)\n  then show ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_difference_and_sum": {"skill_name": "square_of_difference_and_sum", "marker": "lemma square_of_difference_and_sum:\n  fixes a b :: real\n  shows \"(a - b)^2 + (a + b)^2 = 2 * (a^2 + b^2)\"\nproof -\n  have \"(a - b)^2 = a^2 - 2 * a * b + b^2\" by (simp add: square_of_difference_general)\n  have \"(a + b)^2 = a^2 + 2 * a * b + b^2\" by (simp add: square_of_sum)\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_of_sum:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"(a + b) * (a + b) = a^2 + 2 * a * b + b^2\" by sos\n  thus ?thesis by sos\nqed\n\nlemma square_of_difference_general:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b) * (a - b) = a^2 - 2 * a * b + b^2\" by sos\n  thus ?thesis by sos\nqed\n\nlemma square_of_difference_and_sum:\n  fixes a b :: real\n  shows \"(a - b)^2 + (a + b)^2 = 2 * (a^2 + b^2)\"\nproof -\n  have \"(a - b)^2 = a^2 - 2 * a * b + b^2\" by (simp add: square_of_difference_general)\n  have \"(a + b)^2 = a^2 + 2 * a * b + b^2\" by (simp add: square_of_sum)\n  then show ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_sum": {"skill_name": "square_of_sum", "marker": "lemma square_of_sum:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"(a + b) * (a + b) = a^2 + 2 * a * b + b^2\" by sos\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_of_sum:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"(a + b) * (a + b) = a^2 + 2 * a * b + b^2\" by sos\n  thus ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "algebra_2varlinear_system": {"skill_name": "algebra_2varlinear_system", "marker": "theorem algebra_2varlinear_system:\n  fixes x e :: complex\n  assumes h0: \"x + e = 7\"\n      and h1: \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  hence eq_simplified: \"x + 7 = 3\" by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  thus ?thesis using e_value by (simp add: x_value_final)\nqed", "description": "-", "full_code": "theorem algebra_2varlinear_system:\n  fixes x e :: complex\n  assumes h0: \"x + e = 7\"\n      and h1: \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  hence eq_simplified: \"x + 7 = 3\" by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  thus ?thesis using e_value by (simp add: x_value_final)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "prime": {"skill_name": "prime", "marker": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall>d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall>d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"", "origin": "do_request", "update_count": 0}, "product_primeV6": {"skill_name": "product_primeV6", "marker": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_def)\n  {\n    assume \"a > 1\"\n    then have \"\\<not> prime (a * b) \\<longrightarrow> b = 1\" \n      using assms prime_def by (metis dvd_triv_left mult.right_neutral nat_neq_iff prime_nat_iff)\n    hence \"b = 1\" using assms prime_def by (metis \\<open>1 < a * b\\<close> \\<open>1 < a\\<close> comm_monoid_mult_class.mult_1 dual_order.strict_trans dvd_triv_right le_eq_less_or_eq less_one linordered_nonzero_semiring_class.zero_le_one mult.commute mult_le_less_imp_less nless_le)\n  }\n  {\n    assume \"b > 1\"\n    then have \"\\<not> prime (a * b) \\<longrightarrow> a = 1\" \n      using assms prime_def by (metis dvd_triv_right nat_mult_1 nat_neq_iff prime_nat_iff)\n    hence \"a = 1\" using assms prime_def by (metis \\<open>1 < a * b\\<close> \\<open>1 < a \\<Longrightarrow> b = 1\\<close> \\<open>1 < b\\<close> dvdI nless_le)\n  }\n  thus \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<equiv> p > 1 \\<and> (\\<forall>d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n\nlemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_def)\n  {\n    assume \"a > 1\"\n    then have \"\\<not> prime (a * b) \\<longrightarrow> b = 1\" \n      using assms prime_def by (metis dvd_triv_left mult.right_neutral nat_neq_iff prime_nat_iff)\n    hence \"b = 1\" using assms prime_def by (metis \\<open>1 < a * b\\<close> \\<open>1 < a\\<close> comm_monoid_mult_class.mult_1 dual_order.strict_trans dvd_triv_right le_eq_less_or_eq less_one linordered_nonzero_semiring_class.zero_le_one mult.commute mult_le_less_imp_less nless_le)\n  }\n  {\n    assume \"b > 1\"\n    then have \"\\<not> prime (a * b) \\<longrightarrow> a = 1\" \n      using assms prime_def by (metis dvd_triv_right nat_mult_1 nat_neq_iff prime_nat_iff)\n    hence \"a = 1\" using assms prime_def by (metis \\<open>1 < a * b\\<close> \\<open>1 < a \\<Longrightarrow> b = 1\\<close> \\<open>1 < b\\<close> dvdI nless_le)\n  }\n  thus \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "product_primeV7": {"skill_name": "product_primeV7", "marker": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_def)\n  {\n    assume \"a > 1\"\n    then have \"b = 1\" \n      using assms prime_def by (metis \\<open>1 < a * b\\<close> dvd_triv_right le_eq_less_or_eq less_one mult.commute mult_le_less_imp_less nat_mult_1 nless_le order_less_trans zero_less_one_class.zero_le_one)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = 1\" \n      using assms prime_def by (metis \\<open>1 < a * b\\<close> \\<open>1 < a \\<Longrightarrow> b = 1\\<close> dvdI nless_le)\n  }\n  thus \"a = 1 \\<or> b = 1\" \n    using `a * b > 1` by (metis less_one mult_is_0 not_less_iff_gr_or_eq)\nqed", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n\nlemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_def)\n  {\n    assume \"a > 1\"\n    then have \"b = 1\" \n      using assms prime_def by (metis \\<open>1 < a * b\\<close> dvd_triv_right le_eq_less_or_eq less_one mult.commute mult_le_less_imp_less nat_mult_1 nless_le order_less_trans zero_less_one_class.zero_le_one)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a = 1\" \n      using assms prime_def by (metis \\<open>1 < a * b\\<close> \\<open>1 < a \\<Longrightarrow> b = 1\\<close> dvdI nless_le)\n  }\n  thus \"a = 1 \\<or> b = 1\" \n    using `a * b > 1` by (metis less_one mult_is_0 not_less_iff_gr_or_eq)\nqed", "origin": "do_request", "update_count": 0}, "product_primeV8": {"skill_name": "product_primeV8", "marker": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_def)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\" \n      using assms prime_def by (metis dvd_triv_left mult.right_neutral nat_neq_iff)\n    hence \"b = 1\" by (metis \\<open>1 < a\\<close> less_zeroE mult.comm_neutral mult_delta_right mult_eq_self_implies_10)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\" \n      using assms prime_def by (metis dvd_triv_right mult_1 nat_neq_iff)\n    hence \"a = 1\" by (metis \\<open>1 < b\\<close> gr_implies_not0 mult_right_cancel)\n  }\n  then show \"a = 1 \\<or> b = 1\" \n    using `a * b > 1` by (metis less_one mult_is_0 not_less_iff_gr_or_eq not_one_less_zero)\nqed", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall>d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n\nlemma product_prime:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_def)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\" \n      using assms prime_def by (metis dvd_triv_left mult.right_neutral nat_neq_iff)\n    hence \"b = 1\" by (metis \\<open>1 < a\\<close> less_zeroE mult.comm_neutral mult_delta_right mult_eq_self_implies_10)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\" \n      using assms prime_def by (metis dvd_triv_right mult_1 nat_neq_iff)\n    hence \"a = 1\" by (metis \\<open>1 < b\\<close> gr_implies_not0 mult_right_cancel)\n  }\n  then show \"a = 1 \\<or> b = 1\" \n    using `a * b > 1` by (metis less_one mult_is_0 not_less_iff_gr_or_eq not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "prime_productV3": {"skill_name": "prime_productV3", "marker": "lemma prime_product:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_def)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\" \n      using assms prime_def by (metis \\<open>1 < a * b\\<close> div_less div_mult2_eq div_mult_self1_is_m dual_order.strict_trans dvd_triv_right less_numeral_extra(1) mult.commute mult.right_neutral nat_0_less_mult_iff zero_neq_one)\n    hence \"b = 1\" by (metis assms interactive.prime_def mult_delta_left mult_left_cancel not_one_less_zero)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\" \n      using assms prime_def by (metis \\<open>1 < a * b\\<close> \\<open>1 < a \\<Longrightarrow> b = 1\\<close> bot_nat_0.extremum_strict dual_order.irrefl dvd_triv_right gcd_nat.extremum_uniqueI less_one linorder_less_linear mult.commute mult_1 mult_delta_right nat_mult_1_right)\n    hence \"a = 1\" by (metis \\<open>1 < b\\<close> gr_implies_not0 mult_right_cancel)\n  }\n  then show \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff)\nqed", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n\nlemma prime_product:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_def)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\" \n      using assms prime_def by (metis \\<open>1 < a * b\\<close> div_less div_mult2_eq div_mult_self1_is_m dual_order.strict_trans dvd_triv_right less_numeral_extra(1) mult.commute mult.right_neutral nat_0_less_mult_iff zero_neq_one)\n    hence \"b = 1\" by (metis assms interactive.prime_def mult_delta_left mult_left_cancel not_one_less_zero)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\" \n      using assms prime_def by (metis \\<open>1 < a * b\\<close> \\<open>1 < a \\<Longrightarrow> b = 1\\<close> bot_nat_0.extremum_strict dual_order.irrefl dvd_triv_right gcd_nat.extremum_uniqueI less_one linorder_less_linear mult.commute mult_1 mult_delta_right nat_mult_1_right)\n    hence \"a = 1\" by (metis \\<open>1 < b\\<close> gr_implies_not0 mult_right_cancel)\n  }\n  then show \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff)\nqed", "origin": "do_request", "update_count": 0}, "express_n_mod_6": {"skill_name": "express_n_mod_6", "marker": "lemma express_N_mod_6:\n  fixes N :: nat and m :: nat\n  assumes \"N = 24 * m + 21\"\n  shows \"N mod 6 = 3\"\nproof -\n  have \"N mod 6 = (24 * m + 21) mod 6\" using assms by simp\n  also have \"... = (24 * m mod 6 + 21 mod 6)\" by presburger\n  also have \"... = (0 + 3)\" by auto\n  finally show \"N mod 6 = 3\" by simp\nqed", "description": "", "full_code": "lemma express_N:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5) mod 8\" by auto\n  also have \"... = 5\" by simp\n  finally show \"N mod 8 = 5\" by simp\nqed\n\nlemma express_N_mod_6:\n  fixes N :: nat and m :: nat\n  assumes \"N = 24 * m + 21\"\n  shows \"N mod 6 = 3\"\nproof -\n  have \"N mod 6 = (24 * m + 21) mod 6\" using assms by simp\n  also have \"... = (24 * m mod 6 + 21 mod 6)\" by presburger\n  also have \"... = (0 + 3)\" by auto\n  finally show \"N mod 6 = 3\" by simp\nqed", "origin": "data/full_data/debug/valid_rand/mathd_numbertheory_149.json_v38", "update_count": -1}, "prime_productV4": {"skill_name": "prime_productV4", "marker": "lemma prime_product:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (simp add: prime_def)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\"\n      using assms prime_def by (metis dvd_triv_left mult.right_neutral nat_neq_iff prime_nat_iff)\n    hence \"b = 1\" by (metis assms interactive.prime_def mult_delta_left mult_left_cancel not_one_less_zero)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\"\n      using assms prime_def by (metis dvd_triv_right mult_1 nat_neq_iff prime_nat_iff)\n    hence \"a = 1\" by (metis \\<open>1 < b\\<close> gr_implies_not0 mult_right_cancel)\n  }\n  thus \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n\nlemma prime_product:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (simp add: prime_def)\n  {\n    assume \"a > 1\"\n    then have \"a * b = a * 1\"\n      using assms prime_def by (metis dvd_triv_left mult.right_neutral nat_neq_iff prime_nat_iff)\n    hence \"b = 1\" by (metis assms interactive.prime_def mult_delta_left mult_left_cancel not_one_less_zero)\n  }\n  {\n    assume \"b > 1\"\n    then have \"a * b = 1 * b\"\n      using assms prime_def by (metis dvd_triv_right mult_1 nat_neq_iff prime_nat_iff)\n    hence \"a = 1\" by (metis \\<open>1 < b\\<close> gr_implies_not0 mult_right_cancel)\n  }\n  thus \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "square_of_difference_generalizedV3": {"skill_name": "square_of_difference_generalizedV3", "marker": "lemma square_of_difference_generalized:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"x - y = x + -y\" by simp\n  then show ?thesis by (simp add: power2_diff)\nqed", "description": "-", "full_code": "lemma square_of_difference_generalized:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"x - y = x + -y\" by simp\n  then show ?thesis by (simp add: power2_diff)\nqed", "origin": "square_of_difference", "update_count": 0}, "prime_def_properties": {"skill_name": "prime_def_properties", "marker": "lemma prime_def_properties:\n  shows \"prime p \\<longleftrightarrow> (p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p))\"\n  unfolding prime_def by simp", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n\nlemma prime_def_properties:\n  shows \"prime p \\<longleftrightarrow> (p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p))\"\n  unfolding prime_def by simp", "origin": "do_request", "update_count": 0}, "prime_gt_1_nat": {"skill_name": "prime_gt_1_nat", "marker": "lemma prime_gt_1_nat:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\nproof -\n  have \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n    by (simp add: prime_def_properties)\n  then show ?thesis using assms by blast\nqed", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n\nlemma prime_def_properties:\n  shows \"prime p \\<longleftrightarrow> (p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p))\"\n  unfolding prime_def by simp\n\nlemma prime_gt_1_nat:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\nproof -\n  have \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n    by (simp add: prime_def_properties)\n  then show ?thesis using assms by blast\nqed", "origin": "do_request", "update_count": 0}, "prime_dvd_1_or_self": {"skill_name": "prime_dvd_1_or_self", "marker": "lemma prime_dvd_1_or_self:\n  assumes \"prime p\" \"d dvd p\"\n  shows \"d = 1 \\<or> d = p\"\n  using assms unfolding prime_def by auto", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n\nlemma prime_dvd_1_or_self:\n  assumes \"prime p\" \"d dvd p\"\n  shows \"d = 1 \\<or> d = p\"\n  using assms unfolding prime_def by auto", "origin": "do_request", "update_count": 0}, "prime_gt_1_natV2": {"skill_name": "prime_gt_1_natV2", "marker": "lemma prime_gt_1_nat:\n  assumes \"prime p\"\n  shows \"p > 1\"\n  using assms unfolding prime_def by auto", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall> d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n\nlemma prime_gt_1_nat:\n  assumes \"prime p\"\n  shows \"p > 1\"\n  using assms unfolding prime_def by auto", "origin": "do_request", "update_count": 0}, "mod_equivalence_6": {"skill_name": "mod_equivalence_6", "marker": "lemma mod_equivalence_6:\n  fixes N :: nat and m :: nat\n  assumes \"N = 6 * m + 3\"\n  shows \"N mod 6 = 3\"\nproof -\n  have \"N mod 6 = (6 * m + 3) mod 6\" using assms by simp\n  also have \"... = (6 * m mod 6 + 3 mod 6)\" by auto\n  also have \"... = (0 + 3)\" by auto\n  finally show \"N mod 6 = 3\" by simp\nqed", "description": "-", "full_code": "lemma mod_equivalence:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5) mod 8\" by auto\n  also have \"... = 5\" by simp\n  finally show \"N mod 8 = 5\" by simp\nqed\n\nlemma mod_equivalence_6:\n  fixes N :: nat and m :: nat\n  assumes \"N = 6 * m + 3\"\n  shows \"N mod 6 = 3\"\nproof -\n  have \"N mod 6 = (6 * m + 3) mod 6\" using assms by simp\n  also have \"... = (6 * m mod 6 + 3 mod 6)\" by auto\n  also have \"... = (0 + 3)\" by auto\n  finally show \"N mod 6 = 3\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "mod_equivalence": {"skill_name": "mod_equivalence", "marker": "lemma mod_equivalence:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5) mod 8\" by auto\n  also have \"... = 5\" by simp\n  finally show \"N mod 8 = 5\" by simp\nqed", "description": "-", "full_code": "lemma mod_equivalence:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5) mod 8\" by auto\n  also have \"... = 5\" by simp\n  finally show \"N mod 8 = 5\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "trivial_inequalityV5": {"skill_name": "trivial_inequalityV5", "marker": "lemma trivial_inequality:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b = a + 0 + b\" by simp\n  also have \"... >= 0 + 0\" using assms by (simp add: add_nonneg_nonneg)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma trivial_inequality:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b = a + 0 + b\" by simp\n  also have \"... >= 0 + 0\" using assms by (simp add: add_nonneg_nonneg)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "congruence_mod_8V4": {"skill_name": "congruence_mod_8V4", "marker": "lemma congruence_mod_8:\n  fixes N :: nat\n  assumes \"N mod 8 = 5\"\n  shows \"\\<exists>k. N = 8 * k + 5\"\nproof -\n  have \"N = 8 * (N div 8) + (N mod 8)\" \n    by auto\n  then have \"N = 8 * (N div 8) + 5\" \n    using assms by simp\n  then obtain k where \"k = N div 8\" \n    by auto\n  thus \"\\<exists>k. N = 8 * k + 5\" \n    by (metis \\<open>N = 8 * (N div 8) + 5\\<close>)\nqed", "description": "-", "full_code": "lemma congruence_mod_8:\n  fixes N :: nat\n  assumes \"N mod 8 = 5\"\n  shows \"\\<exists>k. N = 8 * k + 5\"\nproof -\n  have \"N = 8 * (N div 8) + (N mod 8)\" \n    by auto\n  then have \"N = 8 * (N div 8) + 5\" \n    using assms by simp\n  then obtain k where \"k = N div 8\" \n    by auto\n  thus \"\\<exists>k. N = 8 * k + 5\" \n    by (metis \\<open>N = 8 * (N div 8) + 5\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "express_n_multiple_conditions": {"skill_name": "express_n_multiple_conditions", "marker": "lemma express_N_multiple_conditions:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\" \"N = 6 * m + 3\"\n  shows \"N mod 8 = 5 \\<and> N mod 6 = 3\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms(1) by simp\n  also have \"... = 5\" by (simp add: mod_less_divisor)\n  moreover have \"N mod 6 = (6 * (N div 6) + 3) mod 6\" using assms(2) by simp\n  ultimately show \"N mod 8 = 5 \\<and> N mod 6 = 3\" by auto\nqed", "description": "-", "full_code": "lemma express_N_multiple_conditions:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\" \"N = 6 * m + 3\"\n  shows \"N mod 8 = 5 \\<and> N mod 6 = 3\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms(1) by simp\n  also have \"... = 5\" by (simp add: mod_less_divisor)\n  moreover have \"N mod 6 = (6 * (N div 6) + 3) mod 6\" using assms(2) by simp\n  ultimately show \"N mod 8 = 5 \\<and> N mod 6 = 3\" by auto\nqed", "origin": "express_n_mod_6", "update_count": 0}, "bound_check_general": {"skill_name": "bound_check_general", "marker": "lemma bound_check_general:\n  fixes N :: nat and a b :: nat\n  assumes \"N < b\" \"N mod a = c\" \"c < a\"\n  shows \"N \\<in> {x::nat. x < b \\<and> x mod a = c}\"\nproof -\n  have \"N < b\" by (simp add: assms(1))\n  moreover have \"N mod a = c\" by (simp add: assms(2))\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma bound_check_general:\n  fixes N :: nat and a b :: nat\n  assumes \"N < b\" \"N mod a = c\" \"c < a\"\n  shows \"N \\<in> {x::nat. x < b \\<and> x mod a = c}\"\nproof -\n  have \"N < b\" by (simp add: assms(1))\n  moreover have \"N mod a = c\" by (simp add: assms(2))\n  ultimately show ?thesis by auto\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_general": {"skill_name": "express_n_general", "marker": "lemma express_N_general:\n  fixes N :: nat and k :: nat and a b :: nat\n  assumes \"N = a * k + b\" \"a > 0\" \"b < a\"\n  shows \"N mod a = b\"\nproof -\n  have \"N mod a = (a * k + b) mod a\" using assms by simp\n  also have \"... = (a * k mod a + b mod a)\" by auto\n  also have \"... = (0 + b) mod a\" by (simp add: mod_less_divisor)\n  also have \"... = b\" by (metis add_cancel_left_left assms(3) mod_less)\n  finally show \"N mod a = b\" by simp\nqed", "description": "-", "full_code": "lemma express_N_general:\n  fixes N :: nat and k :: nat and a b :: nat\n  assumes \"N = a * k + b\" \"a > 0\" \"b < a\"\n  shows \"N mod a = b\"\nproof -\n  have \"N mod a = (a * k + b) mod a\" using assms by simp\n  also have \"... = (a * k mod a + b mod a)\" by auto\n  also have \"... = (0 + b) mod a\" by (simp add: mod_less_divisor)\n  also have \"... = b\" by (metis add_cancel_left_left assms(3) mod_less)\n  finally show \"N mod a = b\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_mod_d_general": {"skill_name": "express_n_mod_d_general", "marker": "lemma express_N_mod_d_general:\n  fixes N :: nat and k d r :: nat\n  assumes \"d > 0\" \"N = d * k + r\" \"r < d\"\n  shows \"N mod d = r\"\nproof -\n  have \"N mod d = (d * k + r) mod d\" using assms by simp\n  also have \"... = (d * k mod d + r mod d)\" by auto\n  also have \"... = (0 + r)\" by (metis add_0 add_cancel_left_left assms(3) mod_less mod_mult_self1_is_0)\n  finally show \"N mod d = r\" by simp\nqed", "description": "-", "full_code": "lemma express_N_mod_d:\n  fixes N :: nat and k d :: nat\n  assumes \"d > 0\" \"N = d * k + (d - 3)\"\n  shows \"N mod d = (d - 3) mod d\"\nproof -\n  have \"N mod d = (d * k + (d - 3)) mod d\" using assms by simp\n  also have \"... = (d * k mod d + (d - 3) mod d)\" by auto\n  also have \"... = (0 + (d - 3) mod d)\" by auto\n  also have \"... = (d - 3) mod d\" by simp\n  finally show \"N mod d = (d - 3) mod d\" by simp\nqed\n\nlemma express_N_mod_d_general:\n  fixes N :: nat and k d r :: nat\n  assumes \"d > 0\" \"N = d * k + r\" \"r < d\"\n  shows \"N mod d = r\"\nproof -\n  have \"N mod d = (d * k + r) mod d\" using assms by simp\n  also have \"... = (d * k mod d + r mod d)\" by auto\n  also have \"... = (0 + r)\" by (metis add_0 add_cancel_left_left assms(3) mod_less mod_mult_self1_is_0)\n  finally show \"N mod d = r\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_mod_d": {"skill_name": "express_n_mod_d", "marker": "lemma express_N_mod_d:\n  fixes N :: nat and k d :: nat\n  assumes \"d > 0\" \"N = d * k + (d - 3)\"\n  shows \"N mod d = (d - 3) mod d\"\nproof -\n  have \"N mod d = (d * k + (d - 3)) mod d\" using assms by simp\n  also have \"... = (d * k mod d + (d - 3) mod d)\" by auto\n  also have \"... = (0 + (d - 3) mod d)\" by auto\n  also have \"... = (d - 3) mod d\" by simp\n  finally show \"N mod d = (d - 3) mod d\" by simp\nqed", "description": "-", "full_code": "lemma express_N_mod_d:\n  fixes N :: nat and k d :: nat\n  assumes \"d > 0\" \"N = d * k + (d - 3)\"\n  shows \"N mod d = (d - 3) mod d\"\nproof -\n  have \"N mod d = (d * k + (d - 3)) mod d\" using assms by simp\n  also have \"... = (d * k mod d + (d - 3) mod d)\" by auto\n  also have \"... = (0 + (d - 3) mod d)\" by auto\n  also have \"... = (d - 3) mod d\" by simp\n  finally show \"N mod d = (d - 3) mod d\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_generalV2": {"skill_name": "express_n_generalV2", "marker": "lemma express_N_general:\n  fixes N :: nat and k :: nat and d :: nat\n  assumes \"d > 0\" \"N = d * k + (d - 3)\" \n  shows \"N mod d = (d - 3) mod d\"\nproof -\n  have \"N mod d = (d * k + (d - 3)) mod d\" using assms by simp\n  also have \"... = (d * k mod d + (d - 3) mod d)\" by auto\n  also have \"... = (0 + (d - 3) mod d)\" by auto\n  also have \"... = (d - 3)\" by (simp add: assms(1))\n  finally show \"N mod d = (d - 3) mod d\" by (metis assms(2) mod_if mod_mult_self4 mult_eq_if one_add_one one_plus_numeral semiring_norm(3))\nqed", "description": "-", "full_code": "lemma express_N:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5) mod 8\" by auto\n  also have \"... = 5\" by simp\n  finally show \"N mod 8 = 5\" by simp\nqed\n\nlemma express_N_general:\n  fixes N :: nat and k :: nat and d :: nat\n  assumes \"d > 0\" \"N = d * k + (d - 3)\" \n  shows \"N mod d = (d - 3) mod d\"\nproof -\n  have \"N mod d = (d * k + (d - 3)) mod d\" using assms by simp\n  also have \"... = (d * k mod d + (d - 3) mod d)\" by auto\n  also have \"... = (0 + (d - 3) mod d)\" by auto\n  also have \"... = (d - 3)\" by (simp add: assms(1))\n  finally show \"N mod d = (d - 3) mod d\" by (metis assms(2) mod_if mod_mult_self4 mult_eq_if one_add_one one_plus_numeral semiring_norm(3))\nqed", "origin": "express_n_mod_6", "update_count": 0}, "amc12a_2013_p8_evolvedV6": {"skill_name": "amc12a_2013_p8_evolvedV6", "marker": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  hence rearranged: \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  have \"x * y * (x - y) = 2 * (x - y)\" \n  proof (cases \"x - y = 0\")\n    case True\n    then have \"x = y\" by simp\n    with h2 show ?thesis by contradiction\n  next\n    case False\n    then show ?thesis using rearranged by sos\n  qed\n  thus ?thesis using h2 by sos\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x = y + 2/y\" using h3 by simp\n  hence rearranged: \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  have \"x * y * (x - y) = 2 * (x - y)\" \n  proof (cases \"x - y = 0\")\n    case True\n    then have \"x = y\" by simp\n    with h2 show ?thesis by contradiction\n  next\n    case False\n    then show ?thesis using rearranged by sos\n  qed\n  thus ?thesis using h2 by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "average_value_with_variance": {"skill_name": "average_value_with_variance", "marker": "lemma average_value_with_variance:\n  fixes total :: real and count :: nat and squared_total :: real\n  assumes \"count > 0\" \"squared_total = (\\<Sum>i=0..count-1. (total / real count)^2)\"\n  shows \"squared_total / real count = (total^2 / (real_of_nat count)^2)\"\nproof -\n  have \"squared_total = (total / real count) ^ 2 * real_of_nat count\" using assms by (simp add: power2_eq_square)\n  then show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma average_value_with_variance:\n  fixes total :: real and count :: nat and squared_total :: real\n  assumes \"count > 0\" \"squared_total = (\\<Sum>i=0..count-1. (total / real count)^2)\"\n  shows \"squared_total / real count = (total^2 / (real_of_nat count)^2)\"\nproof -\n  have \"squared_total = (total / real count) ^ 2 * real_of_nat count\" using assms by (simp add: power2_eq_square)\n  then show ?thesis by (simp add: field_simps)\nqed", "origin": "average_value", "update_count": 0}, "square_of_sumV2": {"skill_name": "square_of_sumV2", "marker": "lemma square_of_sum:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"a + b = a + b\" by simp\n  hence \"(a + b)^2 = (a + b)^2\" by simp\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_of_sum:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"a + b = a + b\" by simp\n  hence \"(a + b)^2 = (a + b)^2\" by simp\n  thus ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_difference_with_non_negatives": {"skill_name": "square_of_difference_with_non_negatives", "marker": "lemma square_of_difference_with_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b)^2\" by simp\n  also have \"... = a^2 + 2 * a * (-b) + (-b)^2\" by sos\n  also have \"... = a^2 - 2 * a * b + b^2\" by simp\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_of_difference_with_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b)^2\" by simp\n  also have \"... = a^2 + 2 * a * (-b) + (-b)^2\" by sos\n  also have \"... = a^2 - 2 * a * b + b^2\" by simp\n  finally show ?thesis .\nqed", "origin": "square_of_difference", "update_count": 0}, "non_negative_square_rootV2": {"skill_name": "non_negative_square_rootV2", "marker": "lemma non_negative_square_root:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt(a^2) = a\"\nproof -\n  have \"sqrt(a^2) = a\" if \"a >= 0\" for a\n    using that by (simp add: power2_eq_square)\n  thus ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma non_negative_square_root:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt(a^2) = a\"\nproof -\n  have \"sqrt(a^2) = a\" if \"a >= 0\" for a\n    using that by (simp add: power2_eq_square)\n  thus ?thesis using assms by simp\nqed", "origin": "square_of_difference", "update_count": 0}, "square_difference_identity": {"skill_name": "square_difference_identity", "marker": "lemma square_difference_identity:\n  fixes a b :: real\n  shows \"(a - b) * (a + b) = a^2 - b^2\"\nproof -\n  have \"(a - b) * (a + b) = a^2 - b^2\"\n    by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_difference_identity:\n  fixes a b :: real\n  shows \"(a - b) * (a + b) = a^2 - b^2\"\nproof -\n  have \"(a - b) * (a + b) = a^2 - b^2\"\n    by sos\n  thus ?thesis by simp\nqed", "origin": "square_of_difference", "update_count": 0}, "algebra_2varlineareq_complex_constraints": {"skill_name": "algebra_2varlineareq_complex_constraints", "marker": "theorem algebra_2varlineareq_complex_constraints:\n  fixes x e d :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"d = x + e\"\n  shows \"e = 11 \\<and> x = -4 \\<and> d = 7\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then have d_value: \"d = x + e\" using h2 x_value_final e_value_final by simp\n  thus \"e = 11 \\<and> x = -4 \\<and> d = 7\" using x_value_final e_value_final d_value by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_complex_constraints:\n  fixes x e d :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"d = x + e\"\n  shows \"e = 11 \\<and> x = -4 \\<and> d = 7\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then have d_value: \"d = x + e\" using h2 x_value_final e_value_final by simp\n  thus \"e = 11 \\<and> x = -4 \\<and> d = 7\" using x_value_final e_value_final d_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complex": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complex", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complex:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = -4\" using eq_simplified by (metis add.commute add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved diff_add_eq diff_minus_eq_add mult.commute mult_2_right verit_minus_simplify(4))\n  then have e_value: \"e = 11\" using e_expr by simp\n  thus ?thesis by (metis x_value)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed\n\ntheorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complex:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = -4\" using eq_simplified by (metis add.commute add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved diff_add_eq diff_minus_eq_add mult.commute mult_2_right verit_minus_simplify(4))\n  then have e_value: \"e = 11\" using e_expr by simp\n  thus ?thesis by (metis x_value)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "non_negative_squaresV6": {"skill_name": "non_negative_squaresV6", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  have \"0 \\<le> a^2\" \n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"a > 0\"\n      then show ?thesis using mult_nonneg_nonneg[of a a] by auto\n    next\n      assume \"a < 0\"\n      then show ?thesis using mult_nonpos_nonpos[of a a] by auto\n    qed\n  qed\n  moreover have \"0 \\<le> b^2\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"b > 0\"\n      then show ?thesis using mult_nonneg_nonneg[of b b] by auto\n    next\n      assume \"b < 0\"\n      then show ?thesis using mult_nonpos_nonpos[of b b] by auto\n    qed\n  qed\n  ultimately show \"0 \\<le> a^2\" and \"0 \\<le> b^2\" by blast+\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  have \"0 \\<le> a^2\" \n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"a > 0\"\n      then show ?thesis using mult_nonneg_nonneg[of a a] by auto\n    next\n      assume \"a < 0\"\n      then show ?thesis using mult_nonpos_nonpos[of a a] by auto\n    qed\n  qed\n  moreover have \"0 \\<le> b^2\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by auto\n    thus ?thesis \n    proof\n      assume \"b > 0\"\n      then show ?thesis using mult_nonneg_nonneg[of b b] by auto\n    next\n      assume \"b < 0\"\n      then show ?thesis using mult_nonpos_nonpos[of b b] by auto\n    qed\n  qed\n  ultimately show \"0 \\<le> a^2\" and \"0 \\<le> b^2\" by blast+\nqed", "origin": "do_request", "update_count": 0}, "non_negative_squaresV7": {"skill_name": "non_negative_squaresV7", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  have \"0 \\<le> a^2\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof (cases \"a > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n      also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n      finally show ?thesis by simp\n    qed\n  qed\n  moreover have \"0 \\<le> b^2\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by auto\n    thus ?thesis \n    proof (cases \"b > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n      also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n      finally show ?thesis by simp\n    qed\n  qed\n  ultimately show \"0 \\<le> a^2\" and \"0 \\<le> b^2\" by blast+\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  have \"0 \\<le> a^2\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof (cases \"a > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n      also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n      finally show ?thesis by simp\n    qed\n  qed\n  moreover have \"0 \\<le> b^2\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by auto\n    thus ?thesis \n    proof (cases \"b > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n      also have \"... >= 0\" by (simp add: mult_nonneg_nonneg)\n      finally show ?thesis by simp\n    qed\n  qed\n  ultimately show \"0 \\<le> a^2\" and \"0 \\<le> b^2\" by blast+\nqed", "origin": "do_request", "update_count": 0}, "non_negative_squaresV8": {"skill_name": "non_negative_squaresV8", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  then show \"0 \\<le> a^2\" \n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by (auto)\n    thus ?thesis \n    proof\n      assume \"a > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"a < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  then show \"0 \\<le> b^2\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by (auto)\n    thus ?thesis \n    proof\n      assume \"b > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"b < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  then show \"0 \\<le> a^2\" \n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by (auto)\n    thus ?thesis \n    proof\n      assume \"a > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"a < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  then show \"0 \\<le> b^2\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by (auto)\n    thus ?thesis \n    proof\n      assume \"b > 0\"\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      assume \"b < 0\"\n      then show ?thesis by (simp add: mult_nonpos_nonpos)\n    qed\n  qed\nqed", "origin": "do_request", "update_count": 0}, "combine_mod": {"skill_name": "combine_mod", "marker": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  have \"a = x + 10 * (a div 10)\" using assms(1) by auto\n  have \"b = y + 10 * (b div 10)\" using assms(2) by auto\n  then have \"a + b = (x + 10 * (a div 10)) + (y + 10 * (b div 10))\" \n    by (metis \\<open>a = x + 10 * (a div 10)\\<close>)\n  then have \"a + b = (x + y) + 10 * ((a div 10) + (b div 10))\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((x + y) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = (x + y) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  have \"a = x + 10 * (a div 10)\" using assms(1) by auto\n  have \"b = y + 10 * (b div 10)\" using assms(2) by auto\n  then have \"a + b = (x + 10 * (a div 10)) + (y + 10 * (b div 10))\" \n    by (metis \\<open>a = x + 10 * (a div 10)\\<close>)\n  then have \"a + b = (x + y) + 10 * ((a div 10) + (b div 10))\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((x + y) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = (x + y) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_modV2": {"skill_name": "combine_modV2", "marker": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\" \n    by (simp add: nat_eq_iff)\n  have \"b = (b mod 10) + 10 * (b div 10)\" \n    by (simp add: nat_eq_iff)\n  then have \"a + b = (a mod 10) + (b mod 10) + 10 * ((a div 10) + (b div 10))\" \n    by simp\n  have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = ((x + y) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    using assms by auto\n  also have \"... = (x + y) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\" \n    by (simp add: nat_eq_iff)\n  have \"b = (b mod 10) + 10 * (b div 10)\" \n    by (simp add: nat_eq_iff)\n  then have \"a + b = (a mod 10) + (b mod 10) + 10 * ((a div 10) + (b div 10))\" \n    by simp\n  have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    by presburger\n  also have \"... = ((x + y) + 10 * ((a div 10) + (b div 10))) mod 10\" \n    using assms by auto\n  also have \"... = (x + y) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_propertiesV4": {"skill_name": "mod_propertiesV4", "marker": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a = (a mod c) + c * (a div c)\" using assms by (metis mod_mult_div_eq)\n  have \"b = (b mod c) + c * (b div c)\" using assms by (metis mod_mult_div_eq)\n  then have \"a + b = ((a mod c) + c * (a div c)) + ((b mod c) + c * (b div c))\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + c * ((a div c) + (b div c))) mod c\"\n    by auto\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a = (a mod c) + c * (a div c)\" using assms by (metis mod_mult_div_eq)\n  have \"b = (b mod c) + c * (b div c)\" using assms by (metis mod_mult_div_eq)\n  then have \"a + b = ((a mod c) + c * (a div c)) + ((b mod c) + c * (b div c))\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + c * ((a div c) + (b div c))) mod c\"\n    by auto\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_modV3": {"skill_name": "combine_modV3", "marker": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\" \n    by (simp add: nat_eq_iff)\n  have \"b = (b mod 10) + 10 * (b div 10)\" \n    by (simp add: nat_eq_iff)\n  obtain m n where \"a = x + 10 * m\" \"b = y + 10 * n\" \n    using assms by (smt (verit) \\<open>a = a mod 10 + 10 * (a div 10)\\<close> \\<open>b = b mod 10 + 10 * (b div 10)\\<close>)\n  have \"a + b = (x + 10 * m) + (y + 10 * n)\"\n    by (metis \\<open>a = x + 10 * m\\<close> \\<open>b = y + 10 * n\\<close>)\n  then have \"a + b = (x + y) + 10 * (m + n)\"\n    by simp\n  then have \"(a + b) mod 10 = ((x + y) + 10 * (m + n)) mod 10\"\n    by presburger\n  also have \"... = (x + y) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  have \"a = (a mod 10) + 10 * (a div 10)\" \n    by (simp add: nat_eq_iff)\n  have \"b = (b mod 10) + 10 * (b div 10)\" \n    by (simp add: nat_eq_iff)\n  obtain m n where \"a = x + 10 * m\" \"b = y + 10 * n\" \n    using assms by (smt (verit) \\<open>a = a mod 10 + 10 * (a div 10)\\<close> \\<open>b = b mod 10 + 10 * (b div 10)\\<close>)\n  have \"a + b = (x + 10 * m) + (y + 10 * n)\"\n    by (metis \\<open>a = x + 10 * m\\<close> \\<open>b = y + 10 * n\\<close>)\n  then have \"a + b = (x + y) + 10 * (m + n)\"\n    by simp\n  then have \"(a + b) mod 10 = ((x + y) + 10 * (m + n)) mod 10\"\n    by presburger\n  also have \"... = (x + y) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sum_of_non_negativesV5": {"skill_name": "sum_of_non_negativesV5", "marker": "lemma sum_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b >= 0 + 0\" \n    using assms(1) assms(2) by (simp add: add_nonneg_nonneg)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b >= 0 + 0\" \n    using assms(1) assms(2) by (simp add: add_nonneg_nonneg)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_additionV5": {"skill_name": "mod_additionV5", "marker": "lemma mod_addition:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = 10 * (a div 10)\" using assms(1) by auto\n  have \"b = 6 + 10 * (b div 10)\" using assms(2) by presburger\n  then have \"a + b = (10 * (a div 10)) + (6 + 10 * (b div 10))\"\n    by (metis \\<open>a = 10 * (a div 10)\\<close>)\n  then have \"a + b = 10 * (a div 10 + b div 10) + 6\"\n    by (simp add: algebra_simps)\n  hence \"(a + b) mod 10 = (10 * (a div 10 + b div 10) + 6) mod 10\"\n    by presburger\n  also have \"... = 6 mod 10\"\n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = 10 * (a div 10)\" using assms(1) by auto\n  have \"b = 6 + 10 * (b div 10)\" using assms(2) by presburger\n  then have \"a + b = (10 * (a div 10)) + (6 + 10 * (b div 10))\"\n    by (metis \\<open>a = 10 * (a div 10)\\<close>)\n  then have \"a + b = 10 * (a div 10 + b div 10) + 6\"\n    by (simp add: algebra_simps)\n  hence \"(a + b) mod 10 = (10 * (a div 10 + b div 10) + 6) mod 10\"\n    by presburger\n  also have \"... = 6 mod 10\"\n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "linear_congruenceV6": {"skill_name": "linear_congruenceV6", "marker": "lemma linear_congruence:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c < b\"\n  shows \"\\<exists>x. x mod b = c\"\nproof -\n  let ?x = \"c\"\n  have \"c < b\" using assms(2) by simp\n  have \"c mod b = c\" using assms(1) by (metis assms(2) mod_less)\n  show \"\\<exists>x. x mod b = c\" by (metis \\<open>c mod b = c\\<close>)\nqed", "description": "-", "full_code": "lemma linear_congruence:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c < b\"\n  shows \"\\<exists>x. x mod b = c\"\nproof -\n  let ?x = \"c\"\n  have \"c < b\" using assms(2) by simp\n  have \"c mod b = c\" using assms(1) by (metis assms(2) mod_less)\n  show \"\\<exists>x. x mod b = c\" by (metis \\<open>c mod b = c\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "linear_congruenceV7": {"skill_name": "linear_congruenceV7", "marker": "lemma linear_congruence:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c < b\"\n  shows \"\\<exists>x. x mod b = c\"\nproof -\n  let ?x = \"c\"  \n  have \"0 \\<le> c\" using assms(2) by auto\n  have \"c < b\" using assms(2) by simp\n  have \"?x mod b = c mod b\" by (simp add: mod_less)\n  also have \"... = c\" by (metis assms(2) mod_less)\n  finally have \"?x mod b = c\" by (metis \\<open>c mod b = c\\<close>)\n  show ?thesis by (metis \\<open>c mod b = c\\<close>) \nqed", "description": "-", "full_code": "lemma linear_congruence:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c < b\"\n  shows \"\\<exists>x. x mod b = c\"\nproof -\n  let ?x = \"c\"  \n  have \"0 \\<le> c\" using assms(2) by auto\n  have \"c < b\" using assms(2) by simp\n  have \"?x mod b = c mod b\" by (simp add: mod_less)\n  also have \"... = c\" by (metis assms(2) mod_less)\n  finally have \"?x mod b = c\" by (metis \\<open>c mod b = c\\<close>)\n  show ?thesis by (metis \\<open>c mod b = c\\<close>) \nqed", "origin": "do_request", "update_count": 0}, "linear_congruenceV8": {"skill_name": "linear_congruenceV8", "marker": "lemma linear_congruence:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c < b\"\n  shows \"\\<exists>x. x mod b = c\"\nproof -\n  have \"c < b\" by (simp add: assms(2))\n  let ?x = \"c\"  \n  have \"c mod b = c\" by (metis assms(2) mod_less)\n  then show ?thesis using `c < b` by blast\nqed", "description": "-", "full_code": "lemma linear_congruence:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c < b\"\n  shows \"\\<exists>x. x mod b = c\"\nproof -\n  have \"c < b\" by (simp add: assms(2))\n  let ?x = \"c\"  \n  have \"c mod b = c\" by (metis assms(2) mod_less)\n  then show ?thesis using `c < b` by blast\nqed", "origin": "do_request", "update_count": 0}, "express_n_mod_k": {"skill_name": "express_n_mod_k", "marker": "lemma express_N_mod_k:\n  fixes N :: nat and k :: nat and r :: nat\n  assumes \"r < k\"\n  and \"N = k * m + r\"\n  shows \"N mod k = r\"\nproof -\n  have \"N mod k = (k * m + r) mod k\" using assms by simp\n  also have \"... = (k * m mod k + r mod k)\" by auto\n  also have \"... = (0 + r) mod k\" by (simp add: mod_mult_self2)\n  finally show \"N mod k = r\" by (metis \\<open>(k * m + r) mod k = k * m mod k + r mod k\\<close> \\<open>k * m mod k + r mod k = (0 + r) mod k\\<close> assms(1) assms(2) comm_monoid_add_class.add_0 mod_less mult_delta_right)\nqed", "description": "-", "full_code": "lemma express_N_mod_k:\n  fixes N :: nat and k :: nat and r :: nat\n  assumes \"r < k\"\n  and \"N = k * m + r\"\n  shows \"N mod k = r\"\nproof -\n  have \"N mod k = (k * m + r) mod k\" using assms by simp\n  also have \"... = (k * m mod k + r mod k)\" by auto\n  also have \"... = (0 + r) mod k\" by (simp add: mod_mult_self2)\n  finally show \"N mod k = r\" by (metis \\<open>(k * m + r) mod k = k * m mod k + r mod k\\<close> \\<open>k * m mod k + r mod k = (0 + r) mod k\\<close> assms(1) assms(2) comm_monoid_add_class.add_0 mod_less mult_delta_right)\nqed", "origin": "express_n_mod_6", "update_count": 0}, "square_expansion_mult": {"skill_name": "square_expansion_mult", "marker": "lemma square_expansion_mult:\n  fixes a b c :: real\n  shows \"(c * (a - b))^2 = c^2 * (a^2 - 2 * a * b + b^2)\"\nproof -\n  have \"(c * (a - b))^2 = (c * (a - b)) * (c * (a - b))\"\n    by sos\n  also have \"... = c^2 * ((a - b) * (a - b))\" by sos\n  also have \"... = c^2 * (a^2 - 2 * a * b + b^2)\" by sos\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_expansion_mult:\n  fixes a b c :: real\n  shows \"(c * (a - b))^2 = c^2 * (a^2 - 2 * a * b + b^2)\"\nproof -\n  have \"(c * (a - b))^2 = (c * (a - b)) * (c * (a - b))\"\n    by sos\n  also have \"... = c^2 * ((a - b) * (a - b))\" by sos\n  also have \"... = c^2 * (a^2 - 2 * a * b + b^2)\" by sos\n  finally show ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "congruence_mod_6": {"skill_name": "congruence_mod_6", "marker": "lemma congruence_mod_6:\n  fixes N :: nat\n  assumes \"N mod 6 = 3\"\n  shows \"\\<exists>m. N = 6 * m + 3\"\nproof -\n  have \"N = 6 * (N div 6) + (N mod 6)\" \n    by auto\n  then have \"N = 6 * (N div 6) + 3\" \n    using assms by simp\n  then obtain m where \"m = N div 6\" \n    by auto\n  thus \"\\<exists>m. N = 6 * m + 3\" \n    by (metis \\<open>N = 6 * (N div 6) + 3\\<close>)\nqed", "description": "", "full_code": "lemma congruence_mod_6:\n  fixes N :: nat\n  assumes \"N mod 6 = 3\"\n  shows \"\\<exists>m. N = 6 * m + 3\"\nproof -\n  have \"N = 6 * (N div 6) + (N mod 6)\" \n    by auto\n  then have \"N = 6 * (N div 6) + 3\" \n    using assms by simp\n  then obtain m where \"m = N div 6\" \n    by auto\n  thus \"\\<exists>m. N = 6 * m + 3\" \n    by (metis \\<open>N = 6 * (N div 6) + 3\\<close>)\nqed", "origin": "data/full_data/debug/valid_rand/mathd_numbertheory_149.json_v40", "update_count": -1}, "express_n_mod": {"skill_name": "express_n_mod", "marker": "lemma express_N_mod:\n  fixes N :: nat and k :: nat and b :: nat\n  assumes \"b > 0\" \"N = b * k + r\" \"r < b\"\n  shows \"N mod b = r\"\nproof -\n  have \"N mod b = (b * k + r) mod b\" using assms(2) by simp\n  also have \"... = (b * k mod b + r mod b)\" by auto\n  also have \"... = (0 + r)\" by (metis add_0 add_cancel_left_left assms(3) mod_less mod_mult_self1_is_0)\n  finally show \"N mod b = r\" by simp\nqed", "description": "-", "full_code": "lemma express_N_mod:\n  fixes N :: nat and k :: nat and b :: nat\n  assumes \"b > 0\" \"N = b * k + r\" \"r < b\"\n  shows \"N mod b = r\"\nproof -\n  have \"N mod b = (b * k + r) mod b\" using assms(2) by simp\n  also have \"... = (b * k mod b + r mod b)\" by auto\n  also have \"... = (0 + r)\" by (metis add_0 add_cancel_left_left assms(3) mod_less mod_mult_self1_is_0)\n  finally show \"N mod b = r\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_in_different_dimensions": {"skill_name": "express_n_in_different_dimensions", "marker": "lemma express_N_in_different_dimensions:\n  fixes N :: nat and k :: nat and d :: nat\n  assumes \"N = d * k + (d - 1)\"\n  shows \"N mod d = (d - 1)\"\nproof -\n  have \"N mod d = (d * k + (d - 1)) mod d\" using assms by simp\n  also have \"... = (d * k mod d + (d - 1) mod d)\" by auto\n  also have \"... = (0 + (d - 1)) mod d\" by auto\n  also have \"... = (d - 1)\" by (metis add_cancel_right_left diff_less less_numeral_extra(1) mod_by_0 mod_less zero_less_iff_neq_zero)\n  finally show \"N mod d = (d - 1)\" by simp\nqed", "description": "-", "full_code": "lemma express_N:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5) mod 8\" by auto\n  also have \"... = 5\" by simp\n  finally show \"N mod 8 = 5\" by simp\nqed\n\nlemma express_N_in_different_dimensions:\n  fixes N :: nat and k :: nat and d :: nat\n  assumes \"N = d * k + (d - 1)\"\n  shows \"N mod d = (d - 1)\"\nproof -\n  have \"N mod d = (d * k + (d - 1)) mod d\" using assms by simp\n  also have \"... = (d * k mod d + (d - 1) mod d)\" by auto\n  also have \"... = (0 + (d - 1)) mod d\" by auto\n  also have \"... = (d - 1)\" by (metis add_cancel_right_left diff_less less_numeral_extra(1) mod_by_0 mod_less zero_less_iff_neq_zero)\n  finally show \"N mod d = (d - 1)\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "sqrt_equality_general": {"skill_name": "sqrt_equality_general", "marker": "lemma sqrt_equality_general:\n  fixes a b :: real\n  assumes \"sqrt a = sqrt b\" \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms(2) sqrt_square_nonneg by simp\n  have \"sqrt b * sqrt b = b\" using assms(3) sqrt_square_nonneg by simp\n  then have \"sqrt a * sqrt a = sqrt b * sqrt b\" using assms(1) by simp\n  then show ?thesis by (metis assms(1) real_sqrt_eq_iff)\nqed", "description": "-", "full_code": "lemma sqrt_square_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  then show ?thesis by simp\nqed\n\nlemma sqrt_equality_general:\n  fixes a b :: real\n  assumes \"sqrt a = sqrt b\" \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms(2) sqrt_square_nonneg by simp\n  have \"sqrt b * sqrt b = b\" using assms(3) sqrt_square_nonneg by simp\n  then have \"sqrt a * sqrt a = sqrt b * sqrt b\" using assms(1) by simp\n  then show ?thesis by (metis assms(1) real_sqrt_eq_iff)\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "square_non_negativeV6": {"skill_name": "square_non_negativeV6", "marker": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\n  using assms by simp", "description": "-", "full_code": "lemma square_non_negative:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\n  using assms by simp", "origin": "square_expansion", "update_count": 0}, "algebra_sqineq_non_neg": {"skill_name": "algebra_sqineq_non_neg", "marker": "lemma algebra_sqineq_non_neg:\n  fixes a b :: real\n  assumes \"a^2 + b^2 >= 0\"\n  shows \"a * b <= (a^2 + b^2) / 2\"\nproof -\n  have \"a^2 + b^2 >= 0\" using assms by simp\n  then have \"2 * a * b <= a^2 + b^2\" using square_expansion by (metis sum_squares_bound)\n  then show ?thesis by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\n  by sos\n\nlemma algebra_sqineq_non_neg:\n  fixes a b :: real\n  assumes \"a^2 + b^2 >= 0\"\n  shows \"a * b <= (a^2 + b^2) / 2\"\nproof -\n  have \"a^2 + b^2 >= 0\" using assms by simp\n  then have \"2 * a * b <= a^2 + b^2\" using square_expansion by (metis sum_squares_bound)\n  then show ?thesis by (simp add: divide_simps)\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_additionV2": {"skill_name": "square_expansion_with_additionV2", "marker": "lemma square_expansion_with_addition:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2 * a * b + b^2 + 2 * a * c - 2 * b * c + c^2\"\nproof -\n  have \"(a - b + c)^2 = (a - b)^2 + 2 * (a - b) * c + c^2\" by sos\n  also have \"... = (a^2 - 2 * a * b + b^2) + 2 * (a - b) * c + c^2\" \n    by sos\n  also have \"... = a^2 - 2 * a * b + b^2 + 2 * a * c - 2 * b * c + c^2\"\n    by sos\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_expansion_with_addition:\n  fixes a b c :: real\n  shows \"(a - b + c)^2 = a^2 - 2 * a * b + b^2 + 2 * a * c - 2 * b * c + c^2\"\nproof -\n  have \"(a - b + c)^2 = (a - b)^2 + 2 * (a - b) * c + c^2\" by sos\n  also have \"... = (a^2 - 2 * a * b + b^2) + 2 * (a - b) * c + c^2\" \n    by sos\n  also have \"... = a^2 - 2 * a * b + b^2 + 2 * a * c - 2 * b * c + c^2\"\n    by sos\n  finally show ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "express_n_mod_8_and_6": {"skill_name": "express_n_mod_8_and_6", "marker": "lemma express_N_mod_8_and_6:\n  fixes N :: nat and k :: nat and m :: nat\n  assumes \"N = 8 * k + 5\" and \"N = 24 * m + 21\"\n  shows \"N mod 8 = 5 \\<and> N mod 6 = 3\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms(1) by simp\n  moreover have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  moreover have \"... = (0 + 5) mod 8\" by auto\n  moreover have \"... = 5\" by simp\n  ultimately have \"N mod 8 = 5\" by simp\n  have \"N mod 6 = (24 * m + 21) mod 6\" using assms(2) by simp\n  moreover have \"... = (24 * m mod 6 + 21 mod 6)\" by presburger\n  moreover have \"... = (0 + 3)\" by auto\n  ultimately have \"N mod 6 = 3\" by simp\n  thus \"N mod 8 = 5 \\<and> N mod 6 = 3\" by (metis \\<open>N mod 8 = 5\\<close>)\nqed", "description": "-", "full_code": "lemma express_N_mod_8_and_6:\n  fixes N :: nat and k :: nat and m :: nat\n  assumes \"N = 8 * k + 5\" and \"N = 24 * m + 21\"\n  shows \"N mod 8 = 5 \\<and> N mod 6 = 3\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms(1) by simp\n  moreover have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  moreover have \"... = (0 + 5) mod 8\" by auto\n  moreover have \"... = 5\" by simp\n  ultimately have \"N mod 8 = 5\" by simp\n  have \"N mod 6 = (24 * m + 21) mod 6\" using assms(2) by simp\n  moreover have \"... = (24 * m mod 6 + 21 mod 6)\" by presburger\n  moreover have \"... = (0 + 3)\" by auto\n  ultimately have \"N mod 6 = 3\" by simp\n  thus \"N mod 8 = 5 \\<and> N mod 6 = 3\" by (metis \\<open>N mod 8 = 5\\<close>)\nqed", "origin": "express_n_mod_6", "update_count": 0}, "product_sum_identity": {"skill_name": "product_sum_identity", "marker": "lemma product_sum_identity:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2*x*y + y^2\"\nproof -\n  have \"(x + y)^2 = x^2 + 2*x*y + y^2\" by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma product_sum_identity:\n  fixes x y :: real\n  shows \"(x + y)^2 = x^2 + 2*x*y + y^2\"\nproof -\n  have \"(x + y)^2 = x^2 + 2*x*y + y^2\" by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "count_terms": {"skill_name": "count_terms", "marker": "lemma count_terms:\n  shows \"card {19::nat..<92} = 73\"\n  by simp", "description": "", "full_code": "lemma count_terms:\n  shows \"card {19::nat..<92} = 73\"\n  by simp", "origin": "data/full_data/debug/valid_rand/aime_1991_p6.json_v41", "update_count": -1}, "express_n_modV2": {"skill_name": "express_n_modV2", "marker": "lemma express_N_mod:\n  fixes N :: nat and k :: nat\n  assumes \"N = a * k + b\" and \"a > 0\" and \"0 \\<le> b \\<and> b < a\"\n  shows \"N mod a = b\"\nproof -\n  have \"N mod a = (a * k + b) mod a\" using assms by simp\n  also have \"... = (a * k mod a + b mod a)\" by auto\n  also have \"... = (0 + b)\" by (metis add_cancel_right_left assms(3) mod_less mod_mult_self1_is_0 plus_nat.add_0)\n  finally show \"N mod a = b\" by simp\nqed", "description": "-", "full_code": "lemma express_N_mod:\n  fixes N :: nat and k :: nat\n  assumes \"N = a * k + b\" and \"a > 0\" and \"0 \\<le> b \\<and> b < a\"\n  shows \"N mod a = b\"\nproof -\n  have \"N mod a = (a * k + b) mod a\" using assms by simp\n  also have \"... = (a * k mod a + b mod a)\" by auto\n  also have \"... = (0 + b)\" by (metis add_cancel_right_left assms(3) mod_less mod_mult_self1_is_0 plus_nat.add_0)\n  finally show \"N mod a = b\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "mod_expression": {"skill_name": "mod_expression", "marker": "lemma mod_expression:\n  fixes N :: nat and k :: nat\n  assumes \"N = m * k + r\" and \"0 \\<le> r\" and \"r < k\"\n  shows \"N mod k = r\"\nproof -\n  have \"N mod k = (m * k + r) mod k\" using assms by simp\n  also have \"... = (m * k mod k + r mod k)\" by auto \n  also have \"... = (0 + r)\" by (metis add_cancel_left_left assms(3) comm_monoid_add_class.add_0 mod_less mod_mult_self2_is_0) \n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_expression:\n  fixes N :: nat and k :: nat\n  assumes \"N = m * k + r\" and \"0 \\<le> r\" and \"r < k\"\n  shows \"N mod k = r\"\nproof -\n  have \"N mod k = (m * k + r) mod k\" using assms by simp\n  also have \"... = (m * k mod k + r mod k)\" by auto \n  also have \"... = (0 + r)\" by (metis add_cancel_left_left assms(3) comm_monoid_add_class.add_0 mod_less mod_mult_self2_is_0) \n  finally show ?thesis by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_modV3": {"skill_name": "express_n_modV3", "marker": "lemma express_N_mod:\n  fixes N :: nat and k :: nat and r :: nat\n  assumes \"N = k * r + d\" and \"d < r\"\n  shows \"N mod r = d\"\nproof -\n  have \"N mod r = (k * r + d) mod r\" using assms by simp\n  also have \"... = (k * r mod r + d mod r)\" by auto\n  also have \"... = (0 + d)\" by (metis add_cancel_right_left assms(2) comm_monoid_add_class.add_0 mod_less mod_mult_self2_is_0)\n  finally show \"N mod r = d\" by simp\nqed", "description": "-", "full_code": "lemma express_N_mod:\n  fixes N :: nat and k :: nat and r :: nat\n  assumes \"N = k * r + d\" and \"d < r\"\n  shows \"N mod r = d\"\nproof -\n  have \"N mod r = (k * r + d) mod r\" using assms by simp\n  also have \"... = (k * r mod r + d mod r)\" by auto\n  also have \"... = (0 + d)\" by (metis add_cancel_right_left assms(2) comm_monoid_add_class.add_0 mod_less mod_mult_self2_is_0)\n  finally show \"N mod r = d\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "congruence_mod_m": {"skill_name": "congruence_mod_m", "marker": "lemma congruence_mod_m:\n  fixes N a b :: nat\n  assumes \"a > 0\" \"N mod a = b\"\n  shows \"\\<exists>m. N = a * m + b\"\nproof -\n  have \"N = a * (N div a) + (N mod a)\" \n    by auto\n  then have \"N = a * (N div a) + b\" \n    using assms by simp\n  then obtain m where \"m = N div a\" \n    by auto\n  thus \"\\<exists>m. N = a * m + b\" \n    by (metis \\<open>N = a * (N div a) + b\\<close>)\nqed", "description": "-", "full_code": "lemma congruence_mod_m:\n  fixes N a b :: nat\n  assumes \"a > 0\" \"N mod a = b\"\n  shows \"\\<exists>m. N = a * m + b\"\nproof -\n  have \"N = a * (N div a) + (N mod a)\" \n    by auto\n  then have \"N = a * (N div a) + b\" \n    using assms by simp\n  then obtain m where \"m = N div a\" \n    by auto\n  thus \"\\<exists>m. N = a * m + b\" \n    by (metis \\<open>N = a * (N div a) + b\\<close>)\nqed", "origin": "congruence_mod_6", "update_count": 0}, "congruence_mod_mV2": {"skill_name": "congruence_mod_mV2", "marker": "lemma congruence_mod_m:\n  fixes N m :: nat\n  assumes \"m > 0\" \"N mod m = r\"\n  shows \"\\<exists>k. N = m * k + r\"\nproof -\n  have \"N = m * (N div m) + (N mod m)\" \n    by auto\n  then have \"N = m * (N div m) + r\" \n    using assms by simp\n  then obtain k where \"k = N div m\" \n    by auto\n  thus \"\\<exists>k. N = m * k + r\" \n    by (metis \\<open>N = m * (N div m) + r\\<close>)\nqed", "description": "-", "full_code": "lemma congruence_mod_m:\n  fixes N m :: nat\n  assumes \"m > 0\" \"N mod m = r\"\n  shows \"\\<exists>k. N = m * k + r\"\nproof -\n  have \"N = m * (N div m) + (N mod m)\" \n    by auto\n  then have \"N = m * (N div m) + r\" \n    using assms by simp\n  then obtain k where \"k = N div m\" \n    by auto\n  thus \"\\<exists>k. N = m * k + r\" \n    by (metis \\<open>N = m * (N div m) + r\\<close>)\nqed", "origin": "congruence_mod_6", "update_count": 0}, "sqrt_positive_square": {"skill_name": "sqrt_positive_square", "marker": "lemma sqrt_positive_square:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a * sqrt a = sqrt (a * a)\" by (simp add: power2_eq_square)\n  also have \"... = sqrt (a^2)\" by simp\n  also have \"... = a\" using assms by auto\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma sqrt_positive_square:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a * sqrt a = sqrt (a * a)\" by (simp add: power2_eq_square)\n  also have \"... = sqrt (a^2)\" by simp\n  also have \"... = a\" using assms by auto\n  finally show ?thesis .\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "linear_combination_equation": {"skill_name": "linear_combination_equation", "marker": "lemma linear_combination_equation:\n  fixes x y e :: complex\n  assumes h0: \"x + y = e\"\n    and h1: \"2 * x + y = 3\"\n  shows \"y = e - x\"\nproof -\n  have \"y = e - x\" using h0 by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma linear_combination_equation:\n  fixes x y e :: complex\n  assumes h0: \"x + y = e\"\n    and h1: \"2 * x + y = 3\"\n  shows \"y = e - x\"\nproof -\n  have \"y = e - x\" using h0 by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "linear_equation_combination": {"skill_name": "linear_equation_combination", "marker": "lemma linear_equation_combination:\n  fixes a b x :: complex\n  assumes h0: \"a + b = x\"\n    and h1: \"2 * a + b = 5\"\n  shows \"b = 5 - 2 * a\"\nproof -\n  have \"b = x - a\" using h0 by (auto simp: field_simps)\n  thus ?thesis using h1 by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma linear_equation_combination:\n  fixes a b x :: complex\n  assumes h0: \"a + b = x\"\n    and h1: \"2 * a + b = 5\"\n  shows \"b = 5 - 2 * a\"\nproof -\n  have \"b = x - a\" using h0 by (auto simp: field_simps)\n  thus ?thesis using h1 by (auto simp: field_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4V4": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4V4", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" by (metis add.commute add_diff_cancel dbl_def dbl_inc_simps(3) dbl_simps(3) eq_simplified h0 mult_2)\n  have x_value: \"x = 3 - 7\" by (metis \\<open>x + 7 = 3\\<close> add.commute add_diff_cancel dbl_inc_simps(3) h0)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then have e_value_final: \"e = 7 + 4\" by simp\n  then show ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have \"x + 7 = 3\" by (metis add.commute add_diff_cancel dbl_def dbl_inc_simps(3) dbl_simps(3) eq_simplified h0 mult_2)\n  have x_value: \"x = 3 - 7\" by (metis \\<open>x + 7 = 3\\<close> add.commute add_diff_cancel dbl_inc_simps(3) h0)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then have e_value_final: \"e = 7 + 4\" by simp\n  then show ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_multiple_solutionsV2": {"skill_name": "algebra_2varlineareq_multiple_solutionsV2", "marker": "theorem algebra_2varlineareq_multiple_solutions:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<or> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" by (smt (verit) h0 h1 left_add_twice)\n  have x_value: \"x = 3 - 7\" by (metis add.commute add_diff_cancel_right' dbl_inc_simps(3) eq_simplified h0)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 11\" using e_value by simp\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_multiple_solutions:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<or> x = -4\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" by (smt (verit) h0 h1 left_add_twice)\n  have x_value: \"x = 3 - 7\" by (metis add.commute add_diff_cancel_right' dbl_inc_simps(3) eq_simplified h0)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 11\" using e_value by simp\n  then show ?thesis by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_simplifiedV2": {"skill_name": "algebra_2varlineareq_simplifiedV2", "marker": "lemma algebra_2varlineareq_simplified:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x = -4 \\<Longrightarrow> e = 11\"\nproof -\n  assume \"x = -4\"\n  then have \"e = 7 - (-4)\" using h0 by simp\n  thus \"e = 11\" by simp\nqed", "description": "-", "full_code": "lemma algebra_2varlineareq_simplified:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x = -4 \\<Longrightarrow> e = 11\"\nproof -\n  assume \"x = -4\"\n  then have \"e = 7 - (-4)\" using h0 by simp\n  thus \"e = 11\" by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_multiple_solutionsV3": {"skill_name": "algebra_2varlineareq_multiple_solutionsV3", "marker": "theorem algebra_2varlineareq_multiple_solutions:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have final_equation: \"x + 7 = 3\" by (metis add.commute add_diff_cancel dbl_def dbl_inc_simps(3) dbl_simps(3) eq_simplified h0 mult_2)\n  have x_value: \"x = 3 - 7\" using final_equation by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then have e_value_final: \"e = 7 + 4\" using e_value by simp\n  thus ?thesis using x_value_final by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_multiple_solutions:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"2 * x - x + 7 = 3\" using eq_substituted by simp\n  have final_equation: \"x + 7 = 3\" by (metis add.commute add_diff_cancel dbl_def dbl_inc_simps(3) dbl_simps(3) eq_simplified h0 mult_2)\n  have x_value: \"x = 3 - 7\" using final_equation by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  then have e_value_final: \"e = 7 + 4\" using e_value by simp\n  thus ?thesis using x_value_final by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "natural_average": {"skill_name": "natural_average", "marker": "lemma natural_average:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = total / (real_of_nat count)\"\nproof -\n  from assms have \"real count = real_of_nat count\" by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma natural_average:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = total / (real_of_nat count)\"\nproof -\n  from assms have \"real count = real_of_nat count\" by simp\n  then show ?thesis by simp\nqed", "origin": "average_value", "update_count": 0}, "count_natural_terms": {"skill_name": "count_natural_terms", "marker": "lemma count_natural_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" \n    by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma count_natural_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" \n    by auto\n  then show ?thesis by auto\nqed", "origin": "count_terms", "update_count": 0}, "sqrt_nonneg_square": {"skill_name": "sqrt_nonneg_square", "marker": "lemma sqrt_nonneg_square:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt (a^2) = a\"\nproof -\n  have \"sqrt (a^2) = sqrt (a * a)\" using assms by simp\n  also have \"... = sqrt a * sqrt a\" by auto\n  finally show ?thesis by (simp add: assms)\nqed", "description": "-", "full_code": "lemma sqrt_nonneg_square:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt (a^2) = a\"\nproof -\n  have \"sqrt (a^2) = sqrt (a * a)\" using assms by simp\n  also have \"... = sqrt a * sqrt a\" by auto\n  finally show ?thesis by (simp add: assms)\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "non_negative_squaresV9": {"skill_name": "non_negative_squaresV9", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  show \"0 \\<le> a^2\" by (simp add: square_expansion)\n  show \"0 \\<le> b^2\" by (simp add: square_expansion)\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by (simp add: power2_eq_square algebra_simps)\n  then show ?thesis by simp\nqed\n\nlemma non_negative_squares:\n  fixes a b :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\"\nproof -\n  show \"0 \\<le> a^2\" by (simp add: square_expansion)\n  show \"0 \\<le> b^2\" by (simp add: square_expansion)\nqed", "origin": "square_expansion", "update_count": 0}, "linear_equation_solutionV10": {"skill_name": "linear_equation_solutionV10", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  have \"3 * d + 2 * b = c\" by (metis h1 eq)\n  then have \"2 * b = c - 3 * d\" by auto\n  show ?thesis using `2 * b = c - 3 * d` by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  have \"3 * d + 2 * b = c\" by (metis h1 eq)\n  then have \"2 * b = c - 3 * d\" by auto\n  show ?thesis using `2 * b = c - 3 * d` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "square_of_differenceV2": {"skill_name": "square_of_differenceV2", "marker": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b)^2\" by simp\n  then have \"(a - b)^2 = a^2 + 2 * a * (-b) + (-b)^2\" by sos\n  also have \"... = a^2 - 2 * a * b + b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b)^2\" by simp\n  then have \"(a - b)^2 = a^2 + 2 * a * (-b) + (-b)^2\" by sos\n  also have \"... = a^2 - 2 * a * b + b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_absolute_value": {"skill_name": "square_of_absolute_value", "marker": "lemma square_of_absolute_value:\n  fixes a :: real\n  shows \"abs(a)^2 = a^2\"\nproof -\n  have \"abs(a) = sqrt(a^2)\" by auto\n  then show ?thesis by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_of_absolute_value:\n  fixes a :: real\n  shows \"abs(a)^2 = a^2\"\nproof -\n  have \"abs(a) = sqrt(a^2)\" by auto\n  then show ?thesis by (simp add: power2_eq_square)\nqed", "origin": "square_of_difference", "update_count": 0}, "express_n_mod_m": {"skill_name": "express_n_mod_m", "marker": "lemma express_N_mod_m:\n  fixes N :: nat and k :: nat and m :: nat\n  assumes \"N = (n * m) + r\" \n      and \"0 \\<le> r\" and \"r < m\"\n  shows \"N mod m = r\"\nproof -\n  have \"N mod m = ((n * m) + r) mod m\" using assms by simp\n  also have \"... = (n * m mod m + r mod m)\" by auto\n  also have \"... = (0 + r) mod m\" by auto\n  also have \"... = r\" by (metis add_cancel_right_left assms(3) mod_less)\n  finally show \"N mod m = r\" by simp\nqed", "description": "-", "full_code": "lemma express_N_mod_m:\n  fixes N :: nat and k :: nat and m :: nat\n  assumes \"N = (n * m) + r\" \n      and \"0 \\<le> r\" and \"r < m\"\n  shows \"N mod m = r\"\nproof -\n  have \"N mod m = ((n * m) + r) mod m\" using assms by simp\n  also have \"... = (n * m mod m + r mod m)\" by auto\n  also have \"... = (0 + r) mod m\" by auto\n  also have \"... = r\" by (metis add_cancel_right_left assms(3) mod_less)\n  finally show \"N mod m = r\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_mod_mV2": {"skill_name": "express_n_mod_mV2", "marker": "lemma express_N_mod_m:\n  fixes N :: nat and k :: nat and m :: nat\n  assumes \"N = (m * k) + r\" and \"r < m\"\n  shows \"N mod m = r\"\nproof -\n  have \"N mod m = ((m * k) + r) mod m\" using assms by simp\n  also have \"... = (m * k mod m + r mod m)\" by auto\n  also have \"... = (0 + r)\" by (metis add_cancel_right_left assms(2) comm_monoid_add_class.add_0 mod_less mod_mult_self1_is_0)\n  finally show \"N mod m = r\" by simp\nqed", "description": "-", "full_code": "lemma express_N_mod_m:\n  fixes N :: nat and k :: nat and m :: nat\n  assumes \"N = (m * k) + r\" and \"r < m\"\n  shows \"N mod m = r\"\nproof -\n  have \"N mod m = ((m * k) + r) mod m\" using assms by simp\n  also have \"... = (m * k mod m + r mod m)\" by auto\n  also have \"... = (0 + r)\" by (metis add_cancel_right_left assms(2) comm_monoid_add_class.add_0 mod_less mod_mult_self1_is_0)\n  finally show \"N mod m = r\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_mod_a": {"skill_name": "express_n_mod_a", "marker": "lemma express_N_mod_a:\n  fixes N :: nat and k :: nat and a :: nat\n  assumes \"N = b * k + c\" and \"b > 0\" and \"c < b\"\n  shows \"N mod b = c\"\nproof -\n  have \"N mod b = (b * k + c) mod b\" using assms by simp\n  also have \"... = (b * k mod b + c mod b)\" by auto\n  also have \"... = (0 + c) mod b\" by auto\n  finally show \"N mod b = c\" by (metis \\<open>(b * k + c) mod b = b * k mod b + c mod b\\<close> \\<open>b * k mod b + c mod b = (0 + c) mod b\\<close> assms(1) assms(3) comm_monoid_add_class.add_0 mod_less mult_delta_right)\nqed", "description": "-", "full_code": "lemma express_N_mod_a:\n  fixes N :: nat and k :: nat and a :: nat\n  assumes \"N = b * k + c\" and \"b > 0\" and \"c < b\"\n  shows \"N mod b = c\"\nproof -\n  have \"N mod b = (b * k + c) mod b\" using assms by simp\n  also have \"... = (b * k mod b + c mod b)\" by auto\n  also have \"... = (0 + c) mod b\" by auto\n  finally show \"N mod b = c\" by (metis \\<open>(b * k + c) mod b = b * k mod b + c mod b\\<close> \\<open>b * k mod b + c mod b = (0 + c) mod b\\<close> assms(1) assms(3) comm_monoid_add_class.add_0 mod_less mult_delta_right)\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_mod_aV2": {"skill_name": "express_n_mod_aV2", "marker": "lemma express_N_mod_a:\n  fixes N :: nat and k :: nat and a :: nat\n  assumes \"N = b * k + c\" and \"a > 0\" and \"b mod a = 0\" and \"0 \\<le> c \\<and> c < a\"\n  shows \"N mod a = c\"\nproof -\n  have \"N mod a = (b * k + c) mod a\" using assms by simp\n  also have \"... = (b * k mod a + c mod a)\" by (smt (verit) add_cancel_left_left assms(3) assms(4) mod_add_eq mod_less mod_mod_trivial mod_mult_left_eq mod_mult_mult2 mod_self)\n  also have \"... = (0 + c)\" using assms(3) by (smt (verit) \\<open>(b * k + c) mod a = b * k mod a + c mod a\\<close> add_cancel_right_left assms(4) mod_add_eq mod_less mod_mult_left_eq mod_mult_mult2 mod_self)\n  finally show \"N mod a = c\" by simp\nqed", "description": "-", "full_code": "lemma express_N_mod_a:\n  fixes N :: nat and k :: nat and a :: nat\n  assumes \"N = b * k + c\" and \"a > 0\" and \"b mod a = 0\" and \"0 \\<le> c \\<and> c < a\"\n  shows \"N mod a = c\"\nproof -\n  have \"N mod a = (b * k + c) mod a\" using assms by simp\n  also have \"... = (b * k mod a + c mod a)\" by (smt (verit) add_cancel_left_left assms(3) assms(4) mod_add_eq mod_less mod_mod_trivial mod_mult_left_eq mod_mult_mult2 mod_self)\n  also have \"... = (0 + c)\" using assms(3) by (smt (verit) \\<open>(b * k + c) mod a = b * k mod a + c mod a\\<close> add_cancel_right_left assms(4) mod_add_eq mod_less mod_mult_left_eq mod_mult_mult2 mod_self)\n  finally show \"N mod a = c\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "square_of_differenceV3": {"skill_name": "square_of_differenceV3", "marker": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"a - b = a + -b\" by simp\n  then have \"(a - b)^2 = (a + -b)^2\" by simp\n  also have \"... = a^2 + 2 * a * (-b) + (-b)^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  also have \"... = a^2 - 2 * a * b + b^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"a - b = a + -b\" by simp\n  then have \"(a - b)^2 = (a + -b)^2\" by simp\n  also have \"... = a^2 + 2 * a * (-b) + (-b)^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  also have \"... = a^2 - 2 * a * b + b^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_differenceV4": {"skill_name": "square_of_differenceV4", "marker": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b)^2\" by simp\n  then show ?thesis by (simp add: power2_eq_square algebra_simps)\nqed", "description": "-", "full_code": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b)^2\" by simp\n  then show ?thesis by (simp add: power2_eq_square algebra_simps)\nqed", "origin": "square_of_difference", "update_count": 0}, "sqrt_limit_generalizedV4": {"skill_name": "sqrt_limit_generalizedV4", "marker": "lemma sqrt_limit_generalized:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\" \"y = sqrt(x + y)\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms(3) by (smt (verit) add_mono assms(1) assms(2) real_sqrt_pow2_iff)\n  thus ?thesis by (simp add: add_diff_cancel)\nqed", "description": "-", "full_code": "lemma sqrt_limit_generalized:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\" \"y = sqrt(x + y)\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms(3) by (smt (verit) add_mono assms(1) assms(2) real_sqrt_pow2_iff)\n  thus ?thesis by (simp add: add_diff_cancel)\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_limit_generalizedV5": {"skill_name": "sqrt_limit_generalizedV5", "marker": "lemma sqrt_limit_generalized:\n  fixes x :: real\n  assumes \"x >= 0\" \"y >= 0\" \"y = sqrt(x + c)\"\n  shows \"x = y^2 - c\"\nproof -\n  have \"y^2 = x + c\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus ?thesis by (simp add: add_diff_cancel)\nqed", "description": "-", "full_code": "lemma sqrt_limit_generalized:\n  fixes x :: real\n  assumes \"x >= 0\" \"y >= 0\" \"y = sqrt(x + c)\"\n  shows \"x = y^2 - c\"\nproof -\n  have \"y^2 = x + c\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus ?thesis by (simp add: add_diff_cancel)\nqed", "origin": "sqrt_limit", "update_count": 0}, "trivial_inequalityV6": {"skill_name": "trivial_inequalityV6", "marker": "lemma trivial_inequality:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\n  by auto", "description": "-", "full_code": "lemma trivial_inequality:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\n  by auto", "origin": "do_request", "update_count": 0}, "absolute_value_inequality": {"skill_name": "absolute_value_inequality", "marker": "lemma absolute_value_inequality:\n  fixes a b :: real\n  assumes h0: \"abs(a - b) < c\"\n  shows \"b - c < a \\<and> a < b + c\"\nproof -\n  have \"a - b < c\" and \"-(a - b) < c\" using assms by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma absolute_value_inequality:\n  fixes a b :: real\n  assumes h0: \"abs(a - b) < c\"\n  shows \"b - c < a \\<and> a < b + c\"\nproof -\n  have \"a - b < c\" and \"-(a - b) < c\" using assms by auto\n  then show ?thesis by auto\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_difference_extended": {"skill_name": "square_of_difference_extended", "marker": "lemma square_of_difference_extended:\n  fixes a b c :: real\n  shows \"(a - b)^2 + (b - c)^2 = a^2 - 2 * a * b + b^2 + b^2 - 2 * b * c + c^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2 * a * b + b^2\" by sos\n  have \"(b - c)^2 = b^2 - 2 * b * c + c^2\" by sos\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_of_difference_extended:\n  fixes a b c :: real\n  shows \"(a - b)^2 + (b - c)^2 = a^2 - 2 * a * b + b^2 + b^2 - 2 * b * c + c^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2 * a * b + b^2\" by sos\n  have \"(b - c)^2 = b^2 - 2 * b * c + c^2\" by sos\n  then show ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_difference_expansion": {"skill_name": "square_of_difference_expansion", "marker": "lemma square_of_difference_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b) * (a + -b)\" by sos\n  also have \"... = a^2 + (-b) * a + a * (-b) + (-b) * (-b)\" by sos\n  also have \"... = a^2 - 2 * a * b + b^2\" by sos\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_of_difference_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b) * (a + -b)\" by sos\n  also have \"... = a^2 + (-b) * a + a * (-b) + (-b) * (-b)\" by sos\n  also have \"... = a^2 - 2 * a * b + b^2\" by sos\n  finally show ?thesis .\nqed", "origin": "square_of_difference", "update_count": 0}, "min_value_of_squaresV4": {"skill_name": "min_value_of_squaresV4", "marker": "lemma min_value_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\nproof -\n  have \"x^2 \\<ge> 0\"\n    by auto\n  have \"y^2 \\<ge> 0\"\n    by auto\n  then have \"x^2 + y^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma min_value_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\nproof -\n  have \"x^2 \\<ge> 0\"\n    by auto\n  have \"y^2 \\<ge> 0\"\n    by auto\n  then have \"x^2 + y^2 \\<ge> 0 + 0\"\n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "min_value_of_non_negativesV3": {"skill_name": "min_value_of_non_negativesV3", "marker": "lemma min_value_of_non_negatives:\n  fixes a b c :: real\n  assumes \"a \\<ge> 0\" and \"b \\<ge> 0\" and \"c \\<ge> 0\"\n  shows \"a + b + c \\<ge> 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by (simp add: add.assoc)\n  moreover have \"a + b \\<ge> 0\" \n  proof -\n    have \"a \\<ge> 0\" using assms(1) by simp\n    have \"b \\<ge> 0\" using assms(2) by simp\n    then show \"a + b \\<ge> 0\" by (metis add_nonneg_nonneg assms(1))\n  qed\n  moreover have \"c \\<ge> 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma min_value_of_non_negatives:\n  fixes a b c :: real\n  assumes \"a \\<ge> 0\" and \"b \\<ge> 0\" and \"c \\<ge> 0\"\n  shows \"a + b + c \\<ge> 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by (simp add: add.assoc)\n  moreover have \"a + b \\<ge> 0\" \n  proof -\n    have \"a \\<ge> 0\" using assms(1) by simp\n    have \"b \\<ge> 0\" using assms(2) by simp\n    then show \"a + b \\<ge> 0\" by (metis add_nonneg_nonneg assms(1))\n  qed\n  moreover have \"c \\<ge> 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "min_value_of_non_negativesV4": {"skill_name": "min_value_of_non_negativesV4", "marker": "lemma min_value_of_non_negatives:\n  fixes a b c :: real\n  assumes \"a \\<ge> 0\" and \"b \\<ge> 0\" and \"c \\<ge> 0\"\n  shows \"a + b + c \\<ge> 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by (simp add: add.assoc)\n  moreover have \"a + b \\<ge> 0\" \n  proof -\n    have \"a \\<ge> 0\" using assms(1) by simp\n    have \"b \\<ge> 0\" using assms(2) by simp\n    thus \"a + b \\<ge> 0\" by (metis add_nonneg_nonneg assms(1))\n  qed\n  moreover have \"c \\<ge> 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma min_value_of_non_negatives:\n  fixes a b c :: real\n  assumes \"a \\<ge> 0\" and \"b \\<ge> 0\" and \"c \\<ge> 0\"\n  shows \"a + b + c \\<ge> 0\"\nproof -\n  have \"a + b + c = (a + b) + c\" by (simp add: add.assoc)\n  moreover have \"a + b \\<ge> 0\" \n  proof -\n    have \"a \\<ge> 0\" using assms(1) by simp\n    have \"b \\<ge> 0\" using assms(2) by simp\n    thus \"a + b \\<ge> 0\" by (metis add_nonneg_nonneg assms(1))\n  qed\n  moreover have \"c \\<ge> 0\" using assms(3) by simp\n  ultimately show ?thesis \n    by (metis add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "linear_combination_solve_for_b_with_values": {"skill_name": "linear_combination_solve_for_b_with_values", "marker": "theorem linear_combination_solve_for_b_with_values:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_val\" \n    and h2 : \"m = 3\" \n    and h3 : \"n = 2\" \n    and h4 : \"p = 12\"\n  shows \"b = (p - m*a)/n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"b = (p - m*a)/n\" by (smt (verit) h3 nonzero_mult_div_cancel_left)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_combination_solve_for_b_with_values:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_val\" \n    and h2 : \"m = 3\" \n    and h3 : \"n = 2\" \n    and h4 : \"p = 12\"\n  shows \"b = (p - m*a)/n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"b = (p - m*a)/n\" by (smt (verit) h3 nonzero_mult_div_cancel_left)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_combination_solve_for_b": {"skill_name": "linear_combination_solve_for_b", "marker": "theorem linear_combination_solve_for_b:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a)/n\"\nproof -\n  have \"n*b = p - m*a\"\n    using h0 by simp\n  then have \"b = (p - m*a)/n\"\n    by (metis h1 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_combination_solve_for_b:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a)/n\"\nproof -\n  have \"n*b = p - m*a\"\n    using h0 by simp\n  then have \"b = (p - m*a)/n\"\n    by (metis h1 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_combination_solve_for_b_with_conditions": {"skill_name": "linear_combination_solve_for_b_with_conditions", "marker": "theorem linear_combination_solve_for_b_with_conditions:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = c\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*c)/n\"\nproof -\n  have \"n*b = p - m*a\"\n    using h0 by simp\n  then have \"b = (p - m*a)/n\"\n    by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  also have \"... = (p - m*c)/n\" using h1 by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_combination_solve_for_b_with_conditions:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = c\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*c)/n\"\nproof -\n  have \"n*b = p - m*a\"\n    using h0 by simp\n  then have \"b = (p - m*a)/n\"\n    by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  also have \"... = (p - m*c)/n\" using h1 by simp\n  finally show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolvedV18": {"skill_name": "mathd_algebra_109_evolvedV18", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" using h2 by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  hence \"12 + 2 * b = 12\" by (metis h2)\n  thus \"b = 0\" using `12 + 2 * b = 12` by (simp add: add_cancel_right_right)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2 * b = c\" using h2 by (smt (verit) \\<open>3 * 4 + 2 * b = c\\<close>)\n  hence \"12 + 2 * b = 12\" by (metis h2)\n  thus \"b = 0\" using `12 + 2 * b = 12` by (simp add: add_cancel_right_right)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_parametrized": {"skill_name": "mathd_algebra_parametrized", "marker": "theorem mathd_algebra_parametrized:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  have \"3 * d + 2 * b = c\" by (metis \\<open>3 * d + 2 * b = c\\<close>)\n  thus ?thesis using `3 * d + 2 * b = c` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_parametrized:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  have \"3 * d + 2 * b = c\" by (metis \\<open>3 * d + 2 * b = c\\<close>)\n  thus ?thesis using `3 * d + 2 * b = c` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "product_equals_primeV2": {"skill_name": "product_equals_primeV2", "marker": "lemma product_equals_prime:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\"\nproof -\n  have \"p > 1\" using assms by (metis prime_gt_1_nat)\n  have \"p = p * 1\" by (metis mult.right_neutral)\n  moreover have \"1 = 1\" by simp\n  ultimately show \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\" \n    using `p = p * 1` `1 = 1` by (metis)\nqed", "description": "-", "full_code": "lemma product_equals_prime:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\"\nproof -\n  have \"p > 1\" using assms by (metis prime_gt_1_nat)\n  have \"p = p * 1\" by (metis mult.right_neutral)\n  moreover have \"1 = 1\" by simp\n  ultimately show \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\" \n    using `p = p * 1` `1 = 1` by (metis)\nqed", "origin": "do_request", "update_count": 0}, "count_termsV2": {"skill_name": "count_termsV2", "marker": "lemma count_terms:\n  shows \"card {19::nat..<92} = 73\"\n  using count_terms_extended[of 19 92] by auto", "description": "-", "full_code": "lemma count_terms_extended:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a..b-1} = b - a\" \n    by (metis Suc_pred' assms bot_nat_0.extremum_strict card_atLeastAtMost zero_less_iff_neq_zero)\n  thus ?thesis by (simp add: assms)\nqed\n\nlemma count_terms:\n  shows \"card {19::nat..<92} = 73\"\n  using count_terms_extended[of 19 92] by auto", "origin": "count_terms", "update_count": 0}, "count_termsV3": {"skill_name": "count_termsV3", "marker": "lemma count_terms:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"card {n::nat..<n+73} = 73\"\n  by simp", "description": "-", "full_code": "lemma count_terms:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"card {n::nat..<n+73} = 73\"\n  by simp", "origin": "count_terms", "update_count": 0}, "count_terms_extended": {"skill_name": "count_terms_extended", "marker": "lemma count_terms_extended:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"card {n::nat..<n+73} = 73\"\nproof -\n  have \"n + 73 - n = 73\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms_extended:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"card {n::nat..<n+73} = 73\"\nproof -\n  have \"n + 73 - n = 73\" by simp\n  thus ?thesis by simp\nqed", "origin": "count_terms", "update_count": 0}, "algebra_2varlineareq_n_dimensions": {"skill_name": "algebra_2varlineareq_n_dimensions", "marker": "theorem algebra_2varlineareq_n_dimensions:\n  fixes x e :: \"complex list\"\n  assumes h0 : \"\\<forall>i. i < size x \\<longrightarrow> x ! i + e ! i = 7\"\n    and h1 : \"\\<forall>i. i < size x \\<longrightarrow> 2 * (x ! i) + e ! i = 3\"\n  shows \"\\<forall>i. i < size x \\<longrightarrow> e ! i = 11 \\<and> x ! i = -4\"\nproof -\n  let ?f = \"\\<lambda>i. 7 - (x ! i)\"\n  let ?g = \"\\<lambda>i. 2 * (x ! i) + (7 - (x ! i))\"\n  have \"\\<forall>i. i < size x \\<longrightarrow> ?f i = 7 - (x ! i)\" by auto\n  hence e_expr: \"\\<forall>i. i < size x \\<longrightarrow> e ! i = ?f i\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"\\<forall>i. i < size x \\<longrightarrow> ?g i = 3\" using e_expr h1 by auto\n  have eq_simplified: \"\\<forall>i. i < size x \\<longrightarrow> (x ! i) + 7 = 3\" using eq_substituted by auto\n  then have x_values: \"\\<forall>i. i < size x \\<longrightarrow> x ! i = -4\" by (smt (verit) algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 h0 h1)\n  hence e_values: \"\\<forall>i. i < size x \\<longrightarrow> e ! i = 7 + 4\" using e_expr x_values by auto\n  then show ?thesis using x_values by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e=11 \\<and> x= (-4)\"\nproof -\n  have e_expr: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (7 - x) = 3\" using e_expr h1 by simp\n  have eq_simplified: \"x + 7 = 3\" using eq_substituted by simp\n  have x_value: \"x = 3 - 7\" using eq_simplified by (metis add.commute add_diff_cancel diff_add_eq minus_add_cancel numeral_neq_neg_numeral square_eq_iff uminus_add_conv_diff)\n  then have x_value_final: \"x = -4\" by simp\n  have e_value: \"e = 7 - (-4)\" using e_expr x_value_final by simp\n  have e_value_final: \"e = 7 + 4\" using e_value by simp\n  then show ?thesis using x_value_final by auto\nqed\n\ntheorem algebra_2varlineareq_n_dimensions:\n  fixes x e :: \"complex list\"\n  assumes h0 : \"\\<forall>i. i < size x \\<longrightarrow> x ! i + e ! i = 7\"\n    and h1 : \"\\<forall>i. i < size x \\<longrightarrow> 2 * (x ! i) + e ! i = 3\"\n  shows \"\\<forall>i. i < size x \\<longrightarrow> e ! i = 11 \\<and> x ! i = -4\"\nproof -\n  let ?f = \"\\<lambda>i. 7 - (x ! i)\"\n  let ?g = \"\\<lambda>i. 2 * (x ! i) + (7 - (x ! i))\"\n  have \"\\<forall>i. i < size x \\<longrightarrow> ?f i = 7 - (x ! i)\" by auto\n  hence e_expr: \"\\<forall>i. i < size x \\<longrightarrow> e ! i = ?f i\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"\\<forall>i. i < size x \\<longrightarrow> ?g i = 3\" using e_expr h1 by auto\n  have eq_simplified: \"\\<forall>i. i < size x \\<longrightarrow> (x ! i) + 7 = 3\" using eq_substituted by auto\n  then have x_values: \"\\<forall>i. i < size x \\<longrightarrow> x ! i = -4\" by (smt (verit) algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 h0 h1)\n  hence e_values: \"\\<forall>i. i < size x \\<longrightarrow> e ! i = 7 + 4\" using e_expr x_values by auto\n  then show ?thesis using x_values by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "product_equals_primeV3": {"skill_name": "product_equals_primeV3", "marker": "lemma product_equals_prime:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\"\nproof -\n  have \"p > 1\" using assms prime_def by simp\n  let ?a = \"1\" and ?b = \"p\"\n  have \"1 * p = p\" by simp\n  moreover have \"1 = 1 \\<or> p = p\" by simp\n  ultimately show \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\" \n    by (metis)\nqed", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<longleftrightarrow> p > 1 \\<and> (\\<forall>d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n\nlemma product_equals_prime:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\"\nproof -\n  have \"p > 1\" using assms prime_def by simp\n  let ?a = \"1\" and ?b = \"p\"\n  have \"1 * p = p\" by simp\n  moreover have \"1 = 1 \\<or> p = p\" by simp\n  ultimately show \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\" \n    by (metis)\nqed", "origin": "do_request", "update_count": 0}, "mod_additionV6": {"skill_name": "mod_additionV6", "marker": "lemma mod_addition:\n  fixes a b c :: nat\n  shows \"((a + b) mod c) = ((a mod c + b mod c) mod c)\"\nproof -\n  have \"a + b = (a mod c + b mod c) + c * ((a div c) + (b div c))\" by (auto simp: field_simps)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b c :: nat\n  shows \"((a + b) mod c) = ((a mod c + b mod c) mod c)\"\nproof -\n  have \"a + b = (a mod c + b mod c) + c * ((a div c) + (b div c))\" by (auto simp: field_simps)\n  thus ?thesis by auto\nqed", "origin": "express_n_mod_6", "update_count": 0}, "nat_inequality": {"skill_name": "nat_inequality", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"c = b - a - 1\" using assms by (metis nat_less_le)\n  have \"c \\<ge> 0\" \n  proof -\n    have \"b - a - 1 \\<ge> 0\" using assms by (simp add: nat_le_iff_add)\n    thus ?thesis by simp\n  qed\n  then have \"a + c < b\" \n    using `c = b - a - 1` by (metis add.commute assms diff_0_eq_0 diff_is_0_eq diff_is_0_eq' diff_less gr_zeroI less_diff_conv less_one verit_sum_simplify)\n  thus ?thesis by (metis)\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"c = b - a - 1\" using assms by (metis nat_less_le)\n  have \"c \\<ge> 0\" \n  proof -\n    have \"b - a - 1 \\<ge> 0\" using assms by (simp add: nat_le_iff_add)\n    thus ?thesis by simp\n  qed\n  then have \"a + c < b\" \n    using `c = b - a - 1` by (metis add.commute assms diff_0_eq_0 diff_is_0_eq diff_is_0_eq' diff_less gr_zeroI less_diff_conv less_one verit_sum_simplify)\n  thus ?thesis by (metis)\nqed", "origin": "do_request", "update_count": 0}, "nat_inequalityV2": {"skill_name": "nat_inequalityV2", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"c = b - a - 1\" using assms by (metis diff_less)\n  have \"a + c < b\" \n  proof -\n    have \"c + a + 1 = b\" using `c = b - a - 1` by (smt (verit) One_nat_def Suc_eq_plus1 Suc_pred add_Suc assms le_add_diff_inverse2 nat_less_le zero_less_diff)\n    then have \"c + a < b\" by simp\n    thus ?thesis using `c = b - a - 1` by simp\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"c = b - a - 1\" using assms by (metis diff_less)\n  have \"a + c < b\" \n  proof -\n    have \"c + a + 1 = b\" using `c = b - a - 1` by (smt (verit) One_nat_def Suc_eq_plus1 Suc_pred add_Suc assms le_add_diff_inverse2 nat_less_le zero_less_diff)\n    then have \"c + a < b\" by simp\n    thus ?thesis using `c = b - a - 1` by simp\n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "nat_inequalityV3": {"skill_name": "nat_inequalityV3", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  from assms obtain c where \"c = b - a\" by auto\n  then have \"a + c = a + (b - a)\" by simp\n  thus ?thesis by (metis assms dual_order.refl nat_le_iff_add)\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  from assms obtain c where \"c = b - a\" by auto\n  then have \"a + c = a + (b - a)\" by simp\n  thus ?thesis by (metis assms dual_order.refl nat_le_iff_add)\nqed", "origin": "do_request", "update_count": 0}, "nat_inequalityV4": {"skill_name": "nat_inequalityV4", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c :: nat where \"b = a + Suc c\"\n    using assms by (metis add_Suc_right less_iff_Suc_add)\n  have \"a + c < a + Suc c\" by simp\n  then show \"\\<exists>c. a + c < b\" using `b = a + Suc c` by auto\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c :: nat where \"b = a + Suc c\"\n    using assms by (metis add_Suc_right less_iff_Suc_add)\n  have \"a + c < a + Suc c\" by simp\n  then show \"\\<exists>c. a + c < b\" using `b = a + Suc c` by auto\nqed", "origin": "do_request", "update_count": 0}, "nat_inequalityV5": {"skill_name": "nat_inequalityV5", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"c = b - a\" using assms by (metis diff_less)\n  then show ?thesis by (metis assms le_refl nat_le_iff_add)\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"c = b - a\" using assms by (metis diff_less)\n  then show ?thesis by (metis assms le_refl nat_le_iff_add)\nqed", "origin": "do_request", "update_count": 0}, "product_equals_primeV4": {"skill_name": "product_equals_primeV4", "marker": "lemma product_equals_prime:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\"\nproof -\n  have \"p > 1\" using assms by (simp add: prime_def)\n  let ?a = \"1\"\n  let ?b = \"p\"\n  have \"1 * p = p\" by simp\n  moreover have \"?a = 1 \\<or> ?b = 1\" by simp\n  ultimately show \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\" \n    by (metis)\nqed", "description": "-", "full_code": "definition prime :: \"nat \\<Rightarrow> bool\" where\n  \"prime p \\<equiv> p > 1 \\<and> (\\<forall>d. d dvd p \\<longrightarrow> d = 1 \\<or> d = p)\"\n\nlemma product_equals_prime:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\"\nproof -\n  have \"p > 1\" using assms by (simp add: prime_def)\n  let ?a = \"1\"\n  let ?b = \"p\"\n  have \"1 * p = p\" by simp\n  moreover have \"?a = 1 \\<or> ?b = 1\" by simp\n  ultimately show \"\\<exists>a b. a * b = p \\<and> (a = 1 \\<or> b = 1)\" \n    by (metis)\nqed", "origin": "do_request", "update_count": 0}, "nat_inequalityV6": {"skill_name": "nat_inequalityV6", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"b = a + Suc c\" using assms by (metis add_Suc_right less_iff_Suc_add)\n  then have \"a + c < a + Suc c\" by simp\n  thus ?thesis by (metis add.right_neutral assms)\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"b = a + Suc c\" using assms by (metis add_Suc_right less_iff_Suc_add)\n  then have \"a + c < a + Suc c\" by simp\n  thus ?thesis by (metis add.right_neutral assms)\nqed", "origin": "do_request", "update_count": 0}, "nat_inequalityV7": {"skill_name": "nat_inequalityV7", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"b = a + Suc c\" using assms by (metis add_Suc_right less_iff_Suc_add)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"b = a + Suc c\" using assms by (metis add_Suc_right less_iff_Suc_add)\n  then show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "square_of_differenceV5": {"skill_name": "square_of_differenceV5", "marker": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b)^2\" by simp\n  also have \"... = a^2 + 2 * a * (-b) + (-b)^2\" using power2_eq_square by (smt (verit) power2_sum)\n  also have \"... = a^2 - 2 * a * b + b^2\" by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b)^2\" by simp\n  also have \"... = a^2 + 2 * a * (-b) + (-b)^2\" using power2_eq_square by (smt (verit) power2_sum)\n  also have \"... = a^2 - 2 * a * b + b^2\" by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_differenceV6": {"skill_name": "square_of_differenceV6", "marker": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(-b)^2 = b^2\" by simp\n  then have \"(a - b)^2 = (a + (-b))^2\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: power2_eq_square algebra_simps)\nqed", "description": "-", "full_code": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(-b)^2 = b^2\" by simp\n  then have \"(a - b)^2 = (a + (-b))^2\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: power2_eq_square algebra_simps)\nqed", "origin": "square_of_difference", "update_count": 0}, "express_n_mod_6_generalized": {"skill_name": "express_n_mod_6_generalized", "marker": "lemma express_N_mod_6_generalized:\n  fixes N :: nat and m :: nat\n  assumes \"N = a * m + c\" and \"a mod b = 0\" and \"c < b\"\n  shows \"N mod b = c\"\nproof -\n  have \"N mod b = (a * m + c) mod b\" using assms(1) by simp\n  also have \"... = (a * m mod b + c mod b)\" by (smt (verit) add_cancel_left_left assms(2) assms(3) mod_add_eq mod_less mod_mod_trivial mod_mult_left_eq mod_mult_mult2 mod_self)\n  also have \"... = (0 + c)\" \n    using assms(2) by (metis add_0 add_cancel_left_left assms(3) mod_less mod_mult_cong mod_mult_self1_is_0 mod_self)\n  also have \"... = c\" by simp\n  finally show \"N mod b = c\" by simp\nqed", "description": "-", "full_code": "lemma express_N_mod:\n  fixes N :: nat and k :: nat and b :: nat\n  assumes \"N = a * k + c\" and \"b * k + c = N\"\n  shows \"N mod b = c mod b\"\nproof -\n  have \"N mod b = (a * k + c) mod b\" using assms(1) by simp\n  also have \"... = (a * k mod b + c mod b)\" by (smt (verit) add_cancel_left_left add_right_imp_eq assms(1) assms(2) mod_mult_self1_is_0 mod_mult_self4)\n  also have \"... = (0 + c mod b)\" \n    using assms(2) by (smt (verit) \\<open>(a * k + c) mod b = a * k mod b + c mod b\\<close> add_cancel_left_left add_right_imp_eq assms(1) mod_add_eq mod_add_right_eq mod_mod_trivial mod_mult_left_eq mod_mult_mult2 mod_self)\n  also have \"... = c mod b\" by simp\n  finally show \"N mod b = c mod b\" by simp\nqed\n\nlemma express_N_mod_6_generalized:\n  fixes N :: nat and m :: nat\n  assumes \"N = a * m + c\" and \"a mod b = 0\" and \"c < b\"\n  shows \"N mod b = c\"\nproof -\n  have \"N mod b = (a * m + c) mod b\" using assms(1) by simp\n  also have \"... = (a * m mod b + c mod b)\" by (smt (verit) add_cancel_left_left assms(2) assms(3) mod_add_eq mod_less mod_mod_trivial mod_mult_left_eq mod_mult_mult2 mod_self)\n  also have \"... = (0 + c)\" \n    using assms(2) by (metis add_0 add_cancel_left_left assms(3) mod_less mod_mult_cong mod_mult_self1_is_0 mod_self)\n  also have \"... = c\" by simp\n  finally show \"N mod b = c\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_modV4": {"skill_name": "express_n_modV4", "marker": "lemma express_N_mod:\n  fixes N :: nat and k :: nat and b :: nat\n  assumes \"N = a * k + c\" and \"b * k + c = N\"\n  shows \"N mod b = c mod b\"\nproof -\n  have \"N mod b = (a * k + c) mod b\" using assms(1) by simp\n  also have \"... = (a * k mod b + c mod b)\" by (smt (verit) add_cancel_left_left add_right_imp_eq assms(1) assms(2) mod_mult_self1_is_0 mod_mult_self4)\n  also have \"... = (0 + c mod b)\" \n    using assms(2) by (smt (verit) \\<open>(a * k + c) mod b = a * k mod b + c mod b\\<close> add_cancel_left_left add_right_imp_eq assms(1) mod_add_eq mod_add_right_eq mod_mod_trivial mod_mult_left_eq mod_mult_mult2 mod_self)\n  also have \"... = c mod b\" by simp\n  finally show \"N mod b = c mod b\" by simp\nqed", "description": "-", "full_code": "lemma express_N_mod:\n  fixes N :: nat and k :: nat and b :: nat\n  assumes \"N = a * k + c\" and \"b * k + c = N\"\n  shows \"N mod b = c mod b\"\nproof -\n  have \"N mod b = (a * k + c) mod b\" using assms(1) by simp\n  also have \"... = (a * k mod b + c mod b)\" by (smt (verit) add_cancel_left_left add_right_imp_eq assms(1) assms(2) mod_mult_self1_is_0 mod_mult_self4)\n  also have \"... = (0 + c mod b)\" \n    using assms(2) by (smt (verit) \\<open>(a * k + c) mod b = a * k mod b + c mod b\\<close> add_cancel_left_left add_right_imp_eq assms(1) mod_add_eq mod_add_right_eq mod_mod_trivial mod_mult_left_eq mod_mult_mult2 mod_self)\n  also have \"... = c mod b\" by simp\n  finally show \"N mod b = c mod b\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_with_k": {"skill_name": "express_n_with_k", "marker": "lemma express_N_with_k:\n  fixes N :: nat and k :: nat\n  assumes \"N = a * k + b\" and \"a > 0\" and \"b < a\"\n  shows \"N mod a = b\"\nproof -\n  have \"N mod a = (a * k + b) mod a\" using assms by simp\n  also have \"... = (a * k mod a + b mod a)\" by auto\n  also have \"... = (0 + b) mod a\" by auto\n  also have \"... = b\" by (metis add_cancel_left_left assms(3) mod_less)\n  finally show \"N mod a = b\" by simp\nqed", "description": "-", "full_code": "lemma express_N_with_k:\n  fixes N :: nat and k :: nat\n  assumes \"N = a * k + b\" and \"a > 0\" and \"b < a\"\n  shows \"N mod a = b\"\nproof -\n  have \"N mod a = (a * k + b) mod a\" using assms by simp\n  also have \"... = (a * k mod a + b mod a)\" by auto\n  also have \"... = (0 + b) mod a\" by auto\n  also have \"... = b\" by (metis add_cancel_left_left assms(3) mod_less)\n  finally show \"N mod a = b\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_with_coefficients": {"skill_name": "express_n_with_coefficients", "marker": "lemma express_N_with_coefficients:\n  fixes N :: nat and k :: nat and m :: nat\n  assumes \"N = a * k + b\" and \"a > 0\" and \"b < a\"\n  shows \"N mod a = b\"\nproof -\n  have \"N mod a = (a * k + b) mod a\" using assms by simp\n  also have \"... = (a * k mod a + b mod a)\" by auto\n  also have \"... = (0 + b)\" using assms by simp\n  also have \"... = b\" by simp\n  finally show \"N mod a = b\" by simp\nqed", "description": "-", "full_code": "lemma express_N_with_coefficients:\n  fixes N :: nat and k :: nat and m :: nat\n  assumes \"N = a * k + b\" and \"a > 0\" and \"b < a\"\n  shows \"N mod a = b\"\nproof -\n  have \"N mod a = (a * k + b) mod a\" using assms by simp\n  also have \"... = (a * k mod a + b mod a)\" by auto\n  also have \"... = (0 + b)\" using assms by simp\n  also have \"... = b\" by simp\n  finally show \"N mod a = b\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "non_negativity": {"skill_name": "non_negativity", "marker": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  have \"a^2 >= 0\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof (cases \"a > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  moreover have \"b^2 >= 0\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by auto\n    thus ?thesis \n    proof (cases \"b > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  moreover have \"a^2 + b^2 >= 0\"\n  proof -\n    have \"a^2 >= 0\" and \"b^2 >= 0\" by (simp_all add: \\<open>a^2 >= 0\\<close> \\<open>b^2 >= 0\\<close>)\n    thus ?thesis by (simp add: add_nonneg_nonneg)\n  qed\n  ultimately show \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\" by blast+\nqed", "description": "-", "full_code": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  have \"a^2 >= 0\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof (cases \"a > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  moreover have \"b^2 >= 0\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by auto\n    thus ?thesis \n    proof (cases \"b > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  moreover have \"a^2 + b^2 >= 0\"\n  proof -\n    have \"a^2 >= 0\" and \"b^2 >= 0\" by (simp_all add: \\<open>a^2 >= 0\\<close> \\<open>b^2 >= 0\\<close>)\n    thus ?thesis by (simp add: add_nonneg_nonneg)\n  qed\n  ultimately show \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\" by blast+\nqed", "origin": "do_request", "update_count": 0}, "non_negativityV2": {"skill_name": "non_negativityV2", "marker": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  hence \"a^2 >= 0\" \n    by auto\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  hence \"b^2 >= 0\" \n    by auto\n  have \"a^2 + b^2 >= 0\"\n  proof -\n    have \"0 <= a^2\" by (simp add: `a^2 >= 0`)\n    moreover have \"0 <= b^2\" by (simp add: `b^2 >= 0`)\n    ultimately show \"a^2 + b^2 >= 0\" \n      by (metis add_nonneg_nonneg)\n  qed\n  thus \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\" \n    by auto\nqed", "description": "-", "full_code": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  hence \"a^2 >= 0\" \n    by auto\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  hence \"b^2 >= 0\" \n    by auto\n  have \"a^2 + b^2 >= 0\"\n  proof -\n    have \"0 <= a^2\" by (simp add: `a^2 >= 0`)\n    moreover have \"0 <= b^2\" by (simp add: `b^2 >= 0`)\n    ultimately show \"a^2 + b^2 >= 0\" \n      by (metis add_nonneg_nonneg)\n  qed\n  thus \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_square_non_neg_general": {"skill_name": "sqrt_square_non_neg_general", "marker": "lemma sqrt_square_non_neg_general:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt (a^2) = a\"\nproof -\n  have \"sqrt (a^2) = sqrt (a * a)\" by (simp add: power2_eq_square)\n  also have \"... = sqrt a * sqrt a\" by (simp add: assms)\n  also have \"... = a\" using assms by (simp add: sqrt_square_non_neg)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma sqrt_square_non_neg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  thus ?thesis by simp\nqed\n\nlemma sqrt_square_non_neg_general:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt (a^2) = a\"\nproof -\n  have \"sqrt (a^2) = sqrt (a * a)\" by (simp add: power2_eq_square)\n  also have \"... = sqrt a * sqrt a\" by (simp add: assms)\n  also have \"... = a\" using assms by (simp add: sqrt_square_non_neg)\n  finally show ?thesis .\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "non_negativityV3": {"skill_name": "non_negativityV3", "marker": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  then show \"a^2 >= 0\" \n  proof (cases \"a >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"a < 0\" by simp\n    hence \"a^2 = (-a) * (-a)\" by sos\n    thus ?thesis by (simp add: mult_nonneg_nonneg)\n  qed\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  then show \"b^2 >= 0\" \n  proof (cases \"b >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"b < 0\" by simp\n    hence \"b^2 = (-b) * (-b)\" by sos\n    thus ?thesis by (simp add: mult_nonneg_nonneg)\n  qed\n  have \"a^2 >= 0\" and \"b^2 >= 0\" by (simp_all add: \\<open>a^2 >= 0\\<close> \\<open>b^2 >= 0\\<close>)\n  thus \"a^2 + b^2 >= 0\" by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  then show \"a^2 >= 0\" \n  proof (cases \"a >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"a < 0\" by simp\n    hence \"a^2 = (-a) * (-a)\" by sos\n    thus ?thesis by (simp add: mult_nonneg_nonneg)\n  qed\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  then show \"b^2 >= 0\" \n  proof (cases \"b >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"b < 0\" by simp\n    hence \"b^2 = (-b) * (-b)\" by sos\n    thus ?thesis by (simp add: mult_nonneg_nonneg)\n  qed\n  have \"a^2 >= 0\" and \"b^2 >= 0\" by (simp_all add: \\<open>a^2 >= 0\\<close> \\<open>b^2 >= 0\\<close>)\n  thus \"a^2 + b^2 >= 0\" by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "non_negativityV4": {"skill_name": "non_negativityV4", "marker": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"a^2 >= 0\"\n  proof (cases \"a >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"a < 0\" by simp\n    hence \"a^2 = (-a) * (-a)\" by sos\n    thus ?thesis by (simp add: mult_nonneg_nonneg)\n  qed\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  have \"b^2 >= 0\"\n  proof (cases \"b >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"b < 0\" by simp\n    hence \"b^2 = (-b) * (-b)\" by sos\n    thus ?thesis by (simp add: mult_nonneg_nonneg)\n  qed\n  have \"a^2 + b^2 >= 0\"\n  proof -\n    have \"a^2 >= 0\" and \"b^2 >= 0\" by (simp_all add: \\<open>a^2 >= 0\\<close> \\<open>b^2 >= 0\\<close>)\n    thus ?thesis by (simp add: add_nonneg_nonneg)\n  qed\n  thus \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\" by auto\nqed", "description": "-", "full_code": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"a^2 >= 0\"\n  proof (cases \"a >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"a < 0\" by simp\n    hence \"a^2 = (-a) * (-a)\" by sos\n    thus ?thesis by (simp add: mult_nonneg_nonneg)\n  qed\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  have \"b^2 >= 0\"\n  proof (cases \"b >= 0\")\n    case True\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  next\n    case False\n    then have \"b < 0\" by simp\n    hence \"b^2 = (-b) * (-b)\" by sos\n    thus ?thesis by (simp add: mult_nonneg_nonneg)\n  qed\n  have \"a^2 + b^2 >= 0\"\n  proof -\n    have \"a^2 >= 0\" and \"b^2 >= 0\" by (simp_all add: \\<open>a^2 >= 0\\<close> \\<open>b^2 >= 0\\<close>)\n    thus ?thesis by (simp add: add_nonneg_nonneg)\n  qed\n  thus \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\" by auto\nqed", "origin": "do_request", "update_count": 0}, "non_negativityV5": {"skill_name": "non_negativityV5", "marker": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  have \"a^2 >= 0\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    have \"a > 0 \\<or> a < 0\" by (metis False not_less_iff_gr_or_eq)\n    thus ?thesis \n    proof (cases \"a > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  moreover have \"b^2 >= 0\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    have \"b > 0 \\<or> b < 0\" by (metis False not_less_iff_gr_or_eq)\n    thus ?thesis \n    proof (cases \"b > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  moreover have \"a^2 + b^2 >= 0\"\n  proof -\n    have \"a^2 >= 0\" and \"b^2 >= 0\" by (simp_all add: \\<open>a^2 >= 0\\<close> \\<open>b^2 >= 0\\<close>)\n    thus ?thesis by (simp add: add_nonneg_nonneg)\n  qed\n  ultimately show \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\" by blast+\nqed", "description": "-", "full_code": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  have \"a^2 >= 0\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    have \"a > 0 \\<or> a < 0\" by (metis False not_less_iff_gr_or_eq)\n    thus ?thesis \n    proof (cases \"a > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  moreover have \"b^2 >= 0\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    have \"b > 0 \\<or> b < 0\" by (metis False not_less_iff_gr_or_eq)\n    thus ?thesis \n    proof (cases \"b > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  moreover have \"a^2 + b^2 >= 0\"\n  proof -\n    have \"a^2 >= 0\" and \"b^2 >= 0\" by (simp_all add: \\<open>a^2 >= 0\\<close> \\<open>b^2 >= 0\\<close>)\n    thus ?thesis by (simp add: add_nonneg_nonneg)\n  qed\n  ultimately show \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\" by blast+\nqed", "origin": "do_request", "update_count": 0}, "non_negativityV6": {"skill_name": "non_negativityV6", "marker": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  then have \"a^2 >= 0\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof (cases \"a > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  then have \"b^2 >= 0\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by auto\n    thus ?thesis \n    proof (cases \"b > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  have \"a^2 + b^2 >= 0\" \n    using `a^2 >= 0` `b^2 >= 0` by (simp add: add_nonneg_nonneg)\n  thus \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\" by auto\nqed", "description": "-", "full_code": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  then have \"a^2 >= 0\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a \\<noteq> 0\" by simp\n    then have \"a > 0 \\<or> a < 0\" by auto\n    thus ?thesis \n    proof (cases \"a > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"a < 0\" by (metis \\<open>a \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"a * a = (-a) * (-a)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  then have \"b^2 >= 0\"\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b \\<noteq> 0\" by simp\n    then have \"b > 0 \\<or> b < 0\" by auto\n    thus ?thesis \n    proof (cases \"b > 0\")\n      case True\n      then show ?thesis by (simp add: mult_nonneg_nonneg)\n    next\n      case False\n      then have \"b < 0\" by (metis \\<open>b \\<noteq> 0\\<close> not_less_iff_gr_or_eq)\n      hence \"b * b = (-b) * (-b)\" by (simp add: mult_neg_neg)\n      thus ?thesis by (simp add: mult_nonneg_nonneg)\n    qed\n  qed\n  have \"a^2 + b^2 >= 0\" \n    using `a^2 >= 0` `b^2 >= 0` by (simp add: add_nonneg_nonneg)\n  thus \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\" by auto\nqed", "origin": "do_request", "update_count": 0}, "non_negativityV7": {"skill_name": "non_negativityV7", "marker": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have a_square_non_neg: \"a^2 >= 0\" \n    by (simp add: mult_nonneg_nonneg) \n  have b_square_non_neg: \"b^2 >= 0\" \n    by (simp add: mult_nonneg_nonneg)\n  have sum_of_squares_non_neg: \"a^2 + b^2 >= 0\"\n    by (simp add: a_square_non_neg b_square_non_neg)\n  show \"a^2 >= 0\" using a_square_non_neg by simp\n  show \"b^2 >= 0\" using b_square_non_neg by simp\n  show \"a^2 + b^2 >= 0\" using sum_of_squares_non_neg by simp\nqed", "description": "-", "full_code": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have a_square_non_neg: \"a^2 >= 0\" \n    by (simp add: mult_nonneg_nonneg) \n  have b_square_non_neg: \"b^2 >= 0\" \n    by (simp add: mult_nonneg_nonneg)\n  have sum_of_squares_non_neg: \"a^2 + b^2 >= 0\"\n    by (simp add: a_square_non_neg b_square_non_neg)\n  show \"a^2 >= 0\" using a_square_non_neg by simp\n  show \"b^2 >= 0\" using b_square_non_neg by simp\n  show \"a^2 + b^2 >= 0\" using sum_of_squares_non_neg by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negativityV8": {"skill_name": "non_negativityV8", "marker": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  then show \"a^2 >= 0\" \n    using mult_nonneg_nonneg[of a a] \n    by auto\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  then show \"b^2 >= 0\" \n    using mult_nonneg_nonneg[of b b] \n    by auto\n  show \"a^2 + b^2 >= 0\" \n    by auto\nqed", "description": "-", "full_code": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  then show \"a^2 >= 0\" \n    using mult_nonneg_nonneg[of a a] \n    by auto\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  then show \"b^2 >= 0\" \n    using mult_nonneg_nonneg[of b b] \n    by auto\n  show \"a^2 + b^2 >= 0\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "linear_system_two_vars": {"skill_name": "linear_system_two_vars", "marker": "theorem linear_system_two_vars:\n  fixes x e :: complex\n  assumes h0 : \"x + e = m\"\n    and h1 : \"2 * x + e = n\"\n  shows \"e = (m - x) \\<and> x = (n - m)\"\nproof -\n  have e_expr: \"e = m - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (m - x) = n\" using e_expr h1 by simp\n  have eq_simplified: \"x + m = n\" using eq_substituted by simp\n  have x_value: \"x = n - m\" using eq_simplified by auto\n  then have e_value: \"e = m - (n - m)\" using e_expr by simp\n  then show ?thesis using x_value by auto\nqed", "description": "-", "full_code": "theorem linear_system_two_vars:\n  fixes x e :: complex\n  assumes h0 : \"x + e = m\"\n    and h1 : \"2 * x + e = n\"\n  shows \"e = (m - x) \\<and> x = (n - m)\"\nproof -\n  have e_expr: \"e = m - x\" using h0 by (auto simp: field_simps)\n  have eq_substituted: \"2 * x + (m - x) = n\" using e_expr h1 by simp\n  have eq_simplified: \"x + m = n\" using eq_substituted by simp\n  have x_value: \"x = n - m\" using eq_simplified by auto\n  then have e_value: \"e = m - (n - m)\" using e_expr by simp\n  then show ?thesis using x_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "non_negativityV9": {"skill_name": "non_negativityV9", "marker": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 >= 0\" and \"b^2 >= 0\" \n    by (simp_all add: power2_eq_square)\n  have \"a^2 + b^2 >= 0\"\n    using `a^2 >= 0` `b^2 >= 0` \n    by (simp add: add_nonneg_nonneg)\n  thus \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\n    by auto\nqed", "description": "-", "full_code": "lemma non_negativity:\n  fixes a b :: real\n  shows \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\nproof -\n  have \"a^2 >= 0\" and \"b^2 >= 0\" \n    by (simp_all add: power2_eq_square)\n  have \"a^2 + b^2 >= 0\"\n    using `a^2 >= 0` `b^2 >= 0` \n    by (simp add: add_nonneg_nonneg)\n  thus \"a^2 >= 0\" \"b^2 >= 0\" \"a^2 + b^2 >= 0\"\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_gen": {"skill_name": "mathd_algebra_109_gen", "marker": "theorem mathd_algebra_109_gen:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = k\" \"k > 0\" \"c > 0\"\n  shows \"b = (c - 3 * k) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * k + 2 * b = c\" using h1(1) eq by simp\n  hence \"2 * b = c - 3 * k\" by auto\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_gen:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = k\" \"k > 0\" \"c > 0\"\n  shows \"b = (c - 3 * k) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * k + 2 * b = c\" using h1(1) eq by simp\n  hence \"2 * b = c - 3 * k\" by auto\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "congruence_mod_8V5": {"skill_name": "congruence_mod_8V5", "marker": "lemma congruence_mod_8:\n  fixes k :: nat\n  assumes \"0 \\<le> k\"\n  shows \"k mod 8 = 5 \\<Longrightarrow> (\\<exists>N. N = 8 * k + 5)\"\nproof -\n  assume \"k mod 8 = 5\"\n  then show \"\\<exists>N. N = 8 * k + 5\" by auto\nqed", "description": "", "full_code": "lemma congruence_mod_8:\n  fixes k :: nat\n  assumes \"0 \\<le> k\"\n  shows \"k mod 8 = 5 \\<Longrightarrow> (\\<exists>N. N = 8 * k + 5)\"\nproof -\n  assume \"k mod 8 = 5\"\n  then show \"\\<exists>N. N = 8 * k + 5\" by auto\nqed", "origin": "data/full_data/debug/valid_rand/mathd_numbertheory_149.json_v44", "update_count": -1}, "square_difference_and_sum_relationship": {"skill_name": "square_difference_and_sum_relationship", "marker": "lemma square_difference_and_sum_relationship:\n  fixes a b :: real\n  shows \"(a - b)^2 + (a + b)^2 = 2 * (a^2 + b^2)\"\nproof -\n  have \"(a - b)^2 + (a + b)^2 = (a^2 - 2 * a * b + b^2) + (a^2 + 2 * a * b + b^2)\" \n    by (simp add: square_of_difference_expanded square_of_sum)\n  also have \"... = 2 * a^2 + 2 * b^2\" by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_of_sum:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"(a + b)^2 = (a + b) * (a + b)\" by sos\n  also have \"... = a^2 + 2 * a * b + b^2\" by sos\n  finally show ?thesis .\nqed\n\nlemma square_of_difference_expanded:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b)^2\" by simp\n  also have \"... = a^2 + 2 * (a * -b) + (-b)^2\" by sos\n  also have \"... = a^2 - 2 * a * b + b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis .\nqed\n\nlemma square_difference_and_sum_relationship:\n  fixes a b :: real\n  shows \"(a - b)^2 + (a + b)^2 = 2 * (a^2 + b^2)\"\nproof -\n  have \"(a - b)^2 + (a + b)^2 = (a^2 - 2 * a * b + b^2) + (a^2 + 2 * a * b + b^2)\" \n    by (simp add: square_of_difference_expanded square_of_sum)\n  also have \"... = 2 * a^2 + 2 * b^2\" by simp\n  finally show ?thesis by simp\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_sumV3": {"skill_name": "square_of_sumV3", "marker": "lemma square_of_sum:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"(a + b)^2 = (a + b) * (a + b)\" by sos\n  also have \"... = a^2 + 2 * a * b + b^2\" by sos\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_of_sum:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"(a + b)^2 = (a + b) * (a + b)\" by sos\n  also have \"... = a^2 + 2 * a * b + b^2\" by sos\n  finally show ?thesis .\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_difference_expandedV4": {"skill_name": "square_of_difference_expandedV4", "marker": "lemma square_of_difference_expanded:\n  fixes a b c :: real\n  shows \"(a - b)^2 + (b - c)^2 = a^2 - 2*a*b + b^2 + b^2 - 2*b*c + c^2\"\nproof -\n  have \"a - b = a + -b\" by simp\n  have \"b - c = b + -c\" by simp\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_of_difference_expanded:\n  fixes a b c :: real\n  shows \"(a - b)^2 + (b - c)^2 = a^2 - 2*a*b + b^2 + b^2 - 2*b*c + c^2\"\nproof -\n  have \"a - b = a + -b\" by simp\n  have \"b - c = b + -c\" by simp\n  then show ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "general_square_identity": {"skill_name": "general_square_identity", "marker": "lemma general_square_identity:\n  fixes a b c :: real\n  shows \"(a + b + c)^2 = a^2 + b^2 + c^2 + 2 * (a*b + b*c + a*c)\"\nproof -\n  have \"(a + b + c) = (a + b) + c\" by simp\n  also have \"... = a + b + c\" by simp\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma general_square_identity:\n  fixes a b c :: real\n  shows \"(a + b + c)^2 = a^2 + b^2 + c^2 + 2 * (a*b + b*c + a*c)\"\nproof -\n  have \"(a + b + c) = (a + b) + c\" by simp\n  also have \"... = a + b + c\" by simp\n  then show ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_difference_generalizedV4": {"skill_name": "square_of_difference_generalizedV4", "marker": "lemma square_of_difference_generalized:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b) * (a - b) = a^2 - 2 * a * b + b^2\" \n    by sos\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_of_difference_generalized:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b) * (a - b) = a^2 - 2 * a * b + b^2\" \n    by sos\n  thus ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_difference_expandedV5": {"skill_name": "square_of_difference_expandedV5", "marker": "lemma square_of_difference_expanded:\n  fixes a b c d :: real\n  shows \"(a - b) * (c - d) = a*c - a*d - b*c + b*d\"\nproof -\n  have \"(a - b) * (c - d) = a * c - a * d - b * c + b * d\" \n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_of_difference_expanded:\n  fixes a b c d :: real\n  shows \"(a - b) * (c - d) = a*c - a*d - b*c + b*d\"\nproof -\n  have \"(a - b) * (c - d) = a * c - a * d - b * c + b * d\" \n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "square_of_difference", "update_count": 0}, "sqrt_eq": {"skill_name": "sqrt_eq", "marker": "lemma sqrt_eq:\n  fixes x :: real\n  assumes \"x >= 0\" and \"y = sqrt x\"\n  shows \"y^2 = x\"\nproof -\n  from assms(1) have \"sqrt x >= 0\" by simp\n  then show ?thesis using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\nqed", "description": "-", "full_code": "lemma sqrt_eq:\n  fixes x :: real\n  assumes \"x >= 0\" and \"y = sqrt x\"\n  shows \"y^2 = x\"\nproof -\n  from assms(1) have \"sqrt x >= 0\" by simp\n  then show ?thesis using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\nqed", "origin": "sqrt_limit", "update_count": 0}, "floor_function_propertiesV2": {"skill_name": "floor_function_propertiesV2", "marker": "lemma floor_function_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"x = floor x + (x - floor x)\" by auto\n  then have \"x + 1 = floor x + (x - floor x) + 1\" by simp\n  then have \"x + 1 = floor x + (x - floor x + 1)\" by (simp add: add.assoc)\n  have \"floor (x + 1) = floor (floor x + (x - floor x + 1))\" by simp\n  have \"x - floor x + 1 < 2\" \n  proof -\n    have \"0 \\<le> (x - floor x)\" by auto\n    thus ?thesis by arith\n  qed\n  then have \"floor (floor x + (x - floor x + 1)) = floor x + (if (x - floor x + 1) < 1 then 0 else 1)\"\n    by (smt (verit) \\<open>x + 1 = real_of_int \\<lfloor>x\\<rfloor> + (x - real_of_int \\<lfloor>x\\<rfloor> + 1)\\<close> add.commute diff_ge_0_iff_ge floor_correct le_add_same_cancel1 one_add_floor verit_comp_simplify1(3))\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_function_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"x = floor x + (x - floor x)\" by auto\n  then have \"x + 1 = floor x + (x - floor x) + 1\" by simp\n  then have \"x + 1 = floor x + (x - floor x + 1)\" by (simp add: add.assoc)\n  have \"floor (x + 1) = floor (floor x + (x - floor x + 1))\" by simp\n  have \"x - floor x + 1 < 2\" \n  proof -\n    have \"0 \\<le> (x - floor x)\" by auto\n    thus ?thesis by arith\n  qed\n  then have \"floor (floor x + (x - floor x + 1)) = floor x + (if (x - floor x + 1) < 1 then 0 else 1)\"\n    by (smt (verit) \\<open>x + 1 = real_of_int \\<lfloor>x\\<rfloor> + (x - real_of_int \\<lfloor>x\\<rfloor> + 1)\\<close> add.commute diff_ge_0_iff_ge floor_correct le_add_same_cancel1 one_add_floor verit_comp_simplify1(3))\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_function_propertiesV3": {"skill_name": "floor_function_propertiesV3", "marker": "lemma floor_function_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor (x + 1) = floor (floor x + (x - floor x) + 1)\"\n    by (simp add: field_simps)\n  let ?fx = \"floor x\"\n  let ?dx = \"x - ?fx\"\n  have \"x + 1 = ?fx + ?dx + 1\" by (simp add: field_simps)\n  have \"floor (?fx + ?dx + 1) = ?fx + 1\"\n  proof (cases \"0 \\<le> ?dx\")\n    case True\n    then have \"?fx + ?dx + 1 = ?fx + 1 + ?dx\" by simp\n    moreover have \"?fx + ?dx + 1 < ?fx + 1 + 1\" \n      by arith\n    ultimately show ?thesis \n      by auto\n  next\n    case False\n    then have \"?dx < 0\" and consequently \"?fx + ?dx + 1 < ?fx + 1\" \n      by auto\n    thus ?thesis \n      by (simp add: floor_le_iff)\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_function_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor (x + 1) = floor (floor x + (x - floor x) + 1)\"\n    by (simp add: field_simps)\n  let ?fx = \"floor x\"\n  let ?dx = \"x - ?fx\"\n  have \"x + 1 = ?fx + ?dx + 1\" by (simp add: field_simps)\n  have \"floor (?fx + ?dx + 1) = ?fx + 1\"\n  proof (cases \"0 \\<le> ?dx\")\n    case True\n    then have \"?fx + ?dx + 1 = ?fx + 1 + ?dx\" by simp\n    moreover have \"?fx + ?dx + 1 < ?fx + 1 + 1\" \n      by arith\n    ultimately show ?thesis \n      by auto\n  next\n    case False\n    then have \"?dx < 0\" and consequently \"?fx + ?dx + 1 < ?fx + 1\" \n      by auto\n    thus ?thesis \n      by (simp add: floor_le_iff)\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_congruence_exists": {"skill_name": "mod_congruence_exists", "marker": "lemma mod_congruence_exists:\n  fixes k :: nat\n  assumes \"k mod 8 = 5\"\n  shows \"(\\<exists>N. N = 8 * k + 5)\"\nproof -\n  show \"\\<exists>N. N = 8 * k + 5\" by auto\nqed", "description": "-", "full_code": "lemma mod_congruence_exists:\n  fixes k :: nat\n  assumes \"k mod 8 = 5\"\n  shows \"(\\<exists>N. N = 8 * k + 5)\"\nproof -\n  show \"\\<exists>N. N = 8 * k + 5\" by auto\nqed", "origin": "congruence_mod_8V5", "update_count": 0}, "substitute_congruence": {"skill_name": "substitute_congruence", "marker": "lemma substitute_congruence:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N = 8 * k + 5\" using assms by simp\n  then show \"N mod 8 = 5\" by (simp add: mod_add_eq)\nqed", "description": "-", "full_code": "lemma substitute_congruence:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N = 8 * k + 5\" using assms by simp\n  then show \"N mod 8 = 5\" by (simp add: mod_add_eq)\nqed", "origin": "congruence_mod_8V5", "update_count": 0}, "sqrt_limit_extendedV5": {"skill_name": "sqrt_limit_extendedV5", "marker": "lemma sqrt_limit_extended:\n  fixes x :: real and n :: nat\n  assumes \"n > 0\" and \"n = sqrt(x + n)\"\n  shows \"x = n^2 - n\"\nproof -\n  have \"n^2 = x + n\" using assms(2) by (smt (verit) assms(1) nat_less_le of_nat_0 of_nat_mono of_nat_power_eq_of_nat_cancel_iff real_sqrt_ge_0_iff real_sqrt_pow2_iff)\n  have \"x = n^2 - n\" by (smt (verit) \\<open>real (n\\<^sup>2) = x + real n\\<close> le_add_diff_inverse of_nat_add of_nat_le_iff of_nat_mult power2_eq_square power2_nat_le_eq_le power2_nat_le_imp_le)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_limit_extended:\n  fixes x :: real and n :: nat\n  assumes \"n > 0\" and \"n = sqrt(x + n)\"\n  shows \"x = n^2 - n\"\nproof -\n  have \"n^2 = x + n\" using assms(2) by (smt (verit) assms(1) nat_less_le of_nat_0 of_nat_mono of_nat_power_eq_of_nat_cancel_iff real_sqrt_ge_0_iff real_sqrt_pow2_iff)\n  have \"x = n^2 - n\" by (smt (verit) \\<open>real (n\\<^sup>2) = x + real n\\<close> le_add_diff_inverse of_nat_add of_nat_le_iff of_nat_mult power2_eq_square power2_nat_le_eq_le power2_nat_le_imp_le)\n  thus ?thesis by simp\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_limit_extendedV6": {"skill_name": "sqrt_limit_extendedV6", "marker": "lemma sqrt_limit_extended:\n  fixes x :: real and n :: nat\n  assumes \"n > 0\" \"n = 9\"\n  shows \"n = sqrt(x + n) \\<Longrightarrow> x = (n^2 - n)\"\nproof -\n  assume \"n = sqrt(x + n)\"\n  hence \"n^2 = x + n\" by (smt (verit) assms(1) less_or_eq_imp_le of_nat_0 of_nat_le_iff of_nat_power_eq_of_nat_cancel_iff real_sqrt_ge_0_iff real_sqrt_pow2_iff)\n  then show \"x = (n^2 - n)\" by (smt (verit) assms(2) le_add_diff_inverse le_square of_nat_add of_nat_mult power2_eq_square)\nqed", "description": "-", "full_code": "lemma sqrt_limit_extended:\n  fixes x :: real and n :: nat\n  assumes \"n > 0\" \"n = 9\"\n  shows \"n = sqrt(x + n) \\<Longrightarrow> x = (n^2 - n)\"\nproof -\n  assume \"n = sqrt(x + n)\"\n  hence \"n^2 = x + n\" by (smt (verit) assms(1) less_or_eq_imp_le of_nat_0 of_nat_le_iff of_nat_power_eq_of_nat_cancel_iff real_sqrt_ge_0_iff real_sqrt_pow2_iff)\n  then show \"x = (n^2 - n)\" by (smt (verit) assms(2) le_add_diff_inverse le_square of_nat_add of_nat_mult power2_eq_square)\nqed", "origin": "sqrt_limit", "update_count": 0}, "congruence_mod_n": {"skill_name": "congruence_mod_n", "marker": "lemma congruence_mod_n:\n  fixes N :: nat and n :: nat\n  assumes \"N mod n = r\" and \"r < n\"\n  shows \"\\<exists>m. N = n * m + r\"\nproof -\n  have \"N = n * (N div n) + (N mod n)\" \n    by auto\n  then have \"N = n * (N div n) + r\" \n    using assms by simp\n  then obtain m where \"m = N div n\" \n    by auto\n  thus \"\\<exists>m. N = n * m + r\" \n    by (metis \\<open>N = n * (N div n) + r\\<close>)\nqed", "description": "-", "full_code": "lemma congruence_mod_n:\n  fixes N :: nat and n :: nat\n  assumes \"N mod n = r\" and \"r < n\"\n  shows \"\\<exists>m. N = n * m + r\"\nproof -\n  have \"N = n * (N div n) + (N mod n)\" \n    by auto\n  then have \"N = n * (N div n) + r\" \n    using assms by simp\n  then obtain m where \"m = N div n\" \n    by auto\n  thus \"\\<exists>m. N = n * m + r\" \n    by (metis \\<open>N = n * (N div n) + r\\<close>)\nqed", "origin": "congruence_mod_6", "update_count": 0}, "congruence_mod": {"skill_name": "congruence_mod", "marker": "lemma congruence_mod:\n  fixes N m :: nat\n  assumes \"N mod m = r\"\n  shows \"\\<exists>k. N = m * k + r\"\nproof -\n  have \"N = m * (N div m) + (N mod m)\"\n    by auto\n  then obtain k where \"k = N div m\" \n    by auto\n  then have \"N = m * k + r\"\n    using assms by auto\n  thus \"\\<exists>k. N = m * k + r\" \n    by auto\nqed", "description": "-", "full_code": "lemma congruence_mod:\n  fixes N m :: nat\n  assumes \"N mod m = r\"\n  shows \"\\<exists>k. N = m * k + r\"\nproof -\n  have \"N = m * (N div m) + (N mod m)\"\n    by auto\n  then obtain k where \"k = N div m\" \n    by auto\n  then have \"N = m * k + r\"\n    using assms by auto\n  thus \"\\<exists>k. N = m * k + r\" \n    by auto\nqed", "origin": "congruence_mod_6", "update_count": 0}, "congruence_modV2": {"skill_name": "congruence_modV2", "marker": "lemma congruence_mod:\n  fixes N m :: nat\n  assumes \"N mod m = r\"\n  shows \"\\<exists>k. N = m * k + r\"\nproof -\n  have \"N = m * (N div m) + (N mod m)\"\n    by auto\n  then obtain k where \"k = N div m\"\n    by auto\n  then show \"\\<exists>k. N = m * k + r\"\n    using assms by (metis mult.commute mult_div_mod_eq)\nqed", "description": "-", "full_code": "lemma congruence_mod:\n  fixes N m :: nat\n  assumes \"N mod m = r\"\n  shows \"\\<exists>k. N = m * k + r\"\nproof -\n  have \"N = m * (N div m) + (N mod m)\"\n    by auto\n  then obtain k where \"k = N div m\"\n    by auto\n  then show \"\\<exists>k. N = m * k + r\"\n    using assms by (metis mult.commute mult_div_mod_eq)\nqed", "origin": "congruence_mod_6", "update_count": 0}, "expand_polynomialV11": {"skill_name": "expand_polynomialV11", "marker": "lemma expand_polynomial:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"(a + b)^2 = (a + b) * (a + b)\" by sos\n  then have \"... = a * a + a * b + b * a + b * b\" by (simp add: algebra_simps)\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"(a + b)^2 = (a + b) * (a + b)\" by sos\n  then have \"... = a * a + a * b + b * a + b * b\" by (simp add: algebra_simps)\n  then show ?thesis by sos\nqed", "origin": "square_of_difference", "update_count": 0}, "count_termsV4": {"skill_name": "count_termsV4", "marker": "lemma count_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\n  by (simp add: assms)", "description": "-", "full_code": "lemma count_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\n  by (simp add: assms)", "origin": "count_terms", "update_count": 0}, "count_termsV5": {"skill_name": "count_termsV5", "marker": "lemma count_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a..<b} = b - a\"\n    by (simp add: card_of_nat)\n  then show ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma count_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a..<b} = b - a\"\n    by (simp add: card_of_nat)\n  then show ?thesis using assms by simp\nqed", "origin": "count_terms", "update_count": 0}, "units_digit_of_sum": {"skill_name": "units_digit_of_sum", "marker": "lemma units_digit_of_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  have \"x = (x mod 10) + 10 * (x div 10)\" \n    by (simp add: nat_eq_iff)\n  have \"y = (y mod 10) + 10 * (y div 10)\" \n    by (simp add: nat_eq_iff)\n  then have \"x + y = (x mod 10) + (y mod 10) + 10 * ((x div 10) + (y div 10))\" \n    by simp\n  have \"(x + y) mod 10 = ((x mod 10) + (y mod 10) + 10 * ((x div 10) + (y div 10))) mod 10\" \n    by presburger\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\" \n    using mod_add_eq by presburger\n  also have \"... = (x mod 10 + y mod 10) mod 10\" \n    by simp\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma units_digit_of_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  have \"x = (x mod 10) + 10 * (x div 10)\" \n    by (simp add: nat_eq_iff)\n  have \"y = (y mod 10) + 10 * (y div 10)\" \n    by (simp add: nat_eq_iff)\n  then have \"x + y = (x mod 10) + (y mod 10) + 10 * ((x div 10) + (y div 10))\" \n    by simp\n  have \"(x + y) mod 10 = ((x mod 10) + (y mod 10) + 10 * ((x div 10) + (y div 10))) mod 10\" \n    by presburger\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\" \n    using mod_add_eq by presburger\n  also have \"... = (x mod 10 + y mod 10) mod 10\" \n    by simp\n  finally show ?thesis by presburger\nqed", "origin": "do_request", "update_count": 0}, "units_digit_of_sumV2": {"skill_name": "units_digit_of_sumV2", "marker": "lemma units_digit_of_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  have \"x = (x mod 10) + 10 * (x div 10)\" \n    by (simp add: nat_eq_iff)\n  have \"y = (y mod 10) + 10 * (y div 10)\" \n    by (simp add: nat_eq_iff)\n  then have \"x + y = ((x mod 10) + (y mod 10)) + 10 * ((x div 10) + (y div 10))\" \n    by simp\n  then have \"(x + y) mod 10 = (((x mod 10) + (y mod 10)) + 10 * ((x div 10) + (y div 10))) mod 10\" \n    by presburger\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\" \n    by presburger\n  thus ?thesis \n    by presburger\nqed", "description": "-", "full_code": "lemma units_digit_of_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  have \"x = (x mod 10) + 10 * (x div 10)\" \n    by (simp add: nat_eq_iff)\n  have \"y = (y mod 10) + 10 * (y div 10)\" \n    by (simp add: nat_eq_iff)\n  then have \"x + y = ((x mod 10) + (y mod 10)) + 10 * ((x div 10) + (y div 10))\" \n    by simp\n  then have \"(x + y) mod 10 = (((x mod 10) + (y mod 10)) + 10 * ((x div 10) + (y div 10))) mod 10\" \n    by presburger\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\" \n    by presburger\n  thus ?thesis \n    by presburger\nqed", "origin": "do_request", "update_count": 0}, "square_of_difference_n": {"skill_name": "square_of_difference_n", "marker": "lemma square_of_difference_n:\n  fixes a :: \"real list\"\n  assumes \"length a = 2\"\n  shows \"(a ! 0 - a ! 1)^2 = (a ! 0)^2 - 2 * (a ! 0) * (a ! 1) + (a ! 1)^2\"\nproof -\n  have \"a ! 0 - a ! 1 = a ! 0 + - (a ! 1)\" by simp\n  then show ?thesis by (metis diff_minus_eq_add square_of_difference_multi verit_minus_simplify(3))\nqed", "description": "-", "full_code": "lemma square_of_difference_multi:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"a - b = a + -b\" by simp\n  then show ?thesis by sos\nqed\n\nlemma square_of_difference_n:\n  fixes a :: \"real list\"\n  assumes \"length a = 2\"\n  shows \"(a ! 0 - a ! 1)^2 = (a ! 0)^2 - 2 * (a ! 0) * (a ! 1) + (a ! 1)^2\"\nproof -\n  have \"a ! 0 - a ! 1 = a ! 0 + - (a ! 1)\" by simp\n  then show ?thesis by (metis diff_minus_eq_add square_of_difference_multi verit_minus_simplify(3))\nqed", "origin": "square_of_difference", "update_count": 0}, "square_of_differenceV7": {"skill_name": "square_of_differenceV7", "marker": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(-b + a)^2 = a^2 + (-b)^2 + 2 * a * (-b)\" by (simp add: power2_eq_square algebra_simps)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma square_of_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(-b + a)^2 = a^2 + (-b)^2 + 2 * a * (-b)\" by (simp add: power2_eq_square algebra_simps)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "square_of_difference", "update_count": 0}, "square_root_propertyV4": {"skill_name": "square_root_propertyV4", "marker": "lemma square_root_property:\n  fixes a b :: real\n  assumes \"a = sqrt b\" and \"b >= 0\"\n  shows \"a^2 = b\"\nproof -\n  have \"a^2 = (sqrt b)^2\" using assms(1) by simp\n  then show ?thesis using assms(2) by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_root_property:\n  fixes a b :: real\n  assumes \"a = sqrt b\" and \"b >= 0\"\n  shows \"a^2 = b\"\nproof -\n  have \"a^2 = (sqrt b)^2\" using assms(1) by simp\n  then show ?thesis using assms(2) by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "congruence_mod_k": {"skill_name": "congruence_mod_k", "marker": "lemma congruence_mod_k:\n  fixes N k :: nat\n  assumes \"k > 0\" \"N mod k = r\" \"r < k\"\n  shows \"\\<exists>m. N = k * m + r\"\nproof -\n  have \"N = k * (N div k) + (N mod k)\" \n    by auto\n  then have \"N = k * (N div k) + r\" \n    using assms(2) by simp\n  then obtain m where \"m = N div k\" \n    by auto\n  thus \"\\<exists>m. N = k * m + r\" \n    by (metis \\<open>N = k * (N div k) + r\\<close>)\nqed", "description": "-", "full_code": "lemma congruence_mod_k:\n  fixes N k :: nat\n  assumes \"k > 0\" \"N mod k = r\" \"r < k\"\n  shows \"\\<exists>m. N = k * m + r\"\nproof -\n  have \"N = k * (N div k) + (N mod k)\" \n    by auto\n  then have \"N = k * (N div k) + r\" \n    using assms(2) by simp\n  then obtain m where \"m = N div k\" \n    by auto\n  thus \"\\<exists>m. N = k * m + r\" \n    by (metis \\<open>N = k * (N div k) + r\\<close>)\nqed", "origin": "congruence_mod_6", "update_count": 0}, "congruence_mod_kV2": {"skill_name": "congruence_mod_kV2", "marker": "lemma congruence_mod_k:\n  fixes N k :: nat\n  assumes \"k > 0\" \"N mod k = r\" \"r < k\"\n  shows \"\\<exists>m. N = k * m + r\"\nproof -\n  have \"N = k * (N div k) + (N mod k)\" \n    by auto\n  then obtain m where \"m = N div k\" \n    by auto\n  thus \"\\<exists>m. N = k * m + r\" \n    using assms(2) by (metis add.commute assms(3) le_refl le_trans mod_eq_nat2E mod_less mod_less_eq_dividend verit_comp_simplify1(3))\nqed", "description": "-", "full_code": "lemma congruence_mod_k:\n  fixes N k :: nat\n  assumes \"k > 0\" \"N mod k = r\" \"r < k\"\n  shows \"\\<exists>m. N = k * m + r\"\nproof -\n  have \"N = k * (N div k) + (N mod k)\" \n    by auto\n  then obtain m where \"m = N div k\" \n    by auto\n  thus \"\\<exists>m. N = k * m + r\" \n    using assms(2) by (metis add.commute assms(3) le_refl le_trans mod_eq_nat2E mod_less mod_less_eq_dividend verit_comp_simplify1(3))\nqed", "origin": "congruence_mod_6", "update_count": 0}, "average_value_with_nonneg_and_positive": {"skill_name": "average_value_with_nonneg_and_positive", "marker": "lemma average_value_with_nonneg_and_positive:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" \"total > 0\"\n  shows \"total / real count > 0\"\nproof -\n  have \"total / real count = (total / (real_of_nat count))\" using assms by simp\n  thus ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma average_value_with_nonneg:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" \"total >= 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  using assms by simp\n\nlemma average_value_with_nonneg_and_positive:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\" \"total > 0\"\n  shows \"total / real count > 0\"\nproof -\n  have \"total / real count = (total / (real_of_nat count))\" using assms by simp\n  thus ?thesis using assms by auto\nqed", "origin": "average_value", "update_count": 0}, "average_value_of_sums": {"skill_name": "average_value_of_sums", "marker": "lemma average_value_of_sums:\n  fixes total1 total2 :: real and count1 count2 :: nat\n  assumes \"count1 > 0\" \"count2 > 0\"\n  shows \"(total1 + total2) / real (count1 + count2) = (total1 / real count1) * (count1 / (count1 + count2)) + (total2 / real count2) * (count2 / (count1 + count2))\"\nproof -\n  have \"total1 + total2 = (total1 / real count1) * count1 + (total2 / real count2) * count2\" by (smt (verit) assms(1) assms(2) nat_less_le nonzero_eq_divide_eq of_nat_0_eq_iff)\n  hence \"(total1 + total2) / real (count1 + count2) = ((total1 / real count1) * count1 + (total2 / real count2) * count2) / real (count1 + count2)\" by simp\n  thus ?thesis by (smt (verit) add_divide_distrib times_divide_eq_right)\nqed", "description": "-", "full_code": "lemma average_value_of_sums:\n  fixes total1 total2 :: real and count1 count2 :: nat\n  assumes \"count1 > 0\" \"count2 > 0\"\n  shows \"(total1 + total2) / real (count1 + count2) = (total1 / real count1) * (count1 / (count1 + count2)) + (total2 / real count2) * (count2 / (count1 + count2))\"\nproof -\n  have \"total1 + total2 = (total1 / real count1) * count1 + (total2 / real count2) * count2\" by (smt (verit) assms(1) assms(2) nat_less_le nonzero_eq_divide_eq of_nat_0_eq_iff)\n  hence \"(total1 + total2) / real (count1 + count2) = ((total1 / real count1) * count1 + (total2 / real count2) * count2) / real (count1 + count2)\" by simp\n  thus ?thesis by (smt (verit) add_divide_distrib times_divide_eq_right)\nqed", "origin": "average_value", "update_count": 0}, "chinese_remainderV9": {"skill_name": "chinese_remainderV9", "marker": "theorem chinese_remainder:\n  fixes a m1 m2 r1 r2 :: nat\n  assumes \"a mod m1 = r1\" and \"a mod m2 = r2\"\n  shows \"\\<exists>k. a = r1 + k * m1\"\nproof -\n  let ?k = \"a div m1\"\n  have \"a = ?k * m1 + (a mod m1)\" by auto\n  then have \"a = ?k * m1 + r1\" using assms(1) by simp\n  thus \"\\<exists>k. a = r1 + k * m1\" \n    by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem chinese_remainder:\n  fixes a m1 m2 r1 r2 :: nat\n  assumes \"a mod m1 = r1\" and \"a mod m2 = r2\"\n  shows \"\\<exists>k. a = r1 + k * m1\"\nproof -\n  let ?k = \"a div m1\"\n  have \"a = ?k * m1 + (a mod m1)\" by auto\n  then have \"a = ?k * m1 + r1\" using assms(1) by simp\n  thus \"\\<exists>k. a = r1 + k * m1\" \n    by (auto simp: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "average_value_weightedV2": {"skill_name": "average_value_weightedV2", "marker": "lemma average_value_weighted:\n  fixes total :: real and count :: nat and weight :: real\n  assumes \"count > 0\" \"weight > 0\"\n  shows \"total / real count * weight = total * weight / (real_of_nat count)\"\n  using assms by (simp add: field_simps)", "description": "-", "full_code": "lemma average_value_weighted:\n  fixes total :: real and count :: nat and weight :: real\n  assumes \"count > 0\" \"weight > 0\"\n  shows \"total / real count * weight = total * weight / (real_of_nat count)\"\n  using assms by (simp add: field_simps)", "origin": "average_value", "update_count": 0}, "average_value_extendedV5": {"skill_name": "average_value_extendedV5", "marker": "lemma average_value_extended:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  and \"count = 0 \\<Longrightarrow> total = 0 \\<Longrightarrow> total / real count = 0\"\n  using assms by auto", "description": "-", "full_code": "lemma average_value_extended:\n  fixes total :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"total / real count = (total / (real_of_nat count))\"\n  and \"count = 0 \\<Longrightarrow> total = 0 \\<Longrightarrow> total / real count = 0\"\n  using assms by auto", "origin": "average_value", "update_count": 0}, "average_value_weightedV3": {"skill_name": "average_value_weightedV3", "marker": "lemma average_value_weighted:\n  fixes total :: real and count :: nat and weight :: real\n  assumes \"count > 0\" \"weight > 0\"\n  shows \"total / real count * weight = total * (weight / real_of_nat count)\"\nproof -\n  have \"total / real count * weight = (total * weight) / real count\" \n    by (simp add: field_simps)\n  also have \"... = total * (weight / real count)\" \n    by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma average_value_weighted:\n  fixes total :: real and count :: nat and weight :: real\n  assumes \"count > 0\" \"weight > 0\"\n  shows \"total / real count * weight = total * (weight / real_of_nat count)\"\nproof -\n  have \"total / real count * weight = (total * weight) / real count\" \n    by (simp add: field_simps)\n  also have \"... = total * (weight / real count)\" \n    by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "origin": "average_value", "update_count": 0}, "express_n_mod_conditions": {"skill_name": "express_n_mod_conditions", "marker": "lemma express_N_mod_conditions:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\n  using assms by simp", "description": "-", "full_code": "lemma express_N_mod_conditions:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\n  using assms by simp", "origin": "express_n_mod_6", "update_count": 0}, "express_n_mod_6_general": {"skill_name": "express_n_mod_6_general", "marker": "lemma express_N_mod_6_general:\n  fixes N :: nat and m :: nat\n  assumes \"N = r * m + s\" and \"r dvd s\"\n  shows \"N mod r = s mod r\"\nproof -\n  have \"N mod r = (r * m + s) mod r\" using assms by simp\n  also have \"... = (r * m mod r + s mod r)\" by auto\n  also have \"... = (0 + s mod r)\" by auto\n  finally show \"N mod r = s mod r\" by simp\nqed", "description": "-", "full_code": "lemma express_N_mod_6_general:\n  fixes N :: nat and m :: nat\n  assumes \"N = r * m + s\" and \"r dvd s\"\n  shows \"N mod r = s mod r\"\nproof -\n  have \"N mod r = (r * m + s) mod r\" using assms by simp\n  also have \"... = (r * m mod r + s mod r)\" by auto\n  also have \"... = (0 + s mod r)\" by auto\n  finally show \"N mod r = s mod r\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "average_value_difference": {"skill_name": "average_value_difference", "marker": "lemma average_value_difference:\n  fixes total1 total2 :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"(total1 - total2) / real count = (total1 / (real_of_nat count)) - (total2 / (real_of_nat count))\"\nproof -\n  have \"total1 - total2 = total1 - total2\" by simp\n  then show ?thesis \n    using assms by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma average_value_difference:\n  fixes total1 total2 :: real and count :: nat\n  assumes \"count > 0\"\n  shows \"(total1 - total2) / real count = (total1 / (real_of_nat count)) - (total2 / (real_of_nat count))\"\nproof -\n  have \"total1 - total2 = total1 - total2\" by simp\n  then show ?thesis \n    using assms by (simp add: field_simps)\nqed", "origin": "average_value", "update_count": 0}, "expand_expressionV10": {"skill_name": "expand_expressionV10", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have lhs: \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  have rhs: \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\"\n    by sos\n  have expanded_lhs: \n    \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by (simp add: lhs rhs)\n  show ?thesis\n  proof -\n    have \"((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2) = (x * y)^2 + x^2 + y^2 + 1\"\n      by (simp add: algebra_simps)\n    thus ?thesis using expanded_lhs by sos\n  qed\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  have lhs: \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  have rhs: \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\"\n    by sos\n  have expanded_lhs: \n    \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by (simp add: lhs rhs)\n  show ?thesis\n  proof -\n    have \"((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2) = (x * y)^2 + x^2 + y^2 + 1\"\n      by (simp add: algebra_simps)\n    thus ?thesis using expanded_lhs by sos\n  qed\nqed", "origin": "do_request", "update_count": 0}, "trivial_inequalityV7": {"skill_name": "trivial_inequalityV7", "marker": "lemma trivial_inequality:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"0 <= a\" using assms(1) by auto\n  have \"0 <= b\" using assms(2) by auto\n  thus ?thesis \n    by (metis add_nonneg_nonneg assms(1))\nqed", "description": "-", "full_code": "lemma trivial_inequality:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"0 <= a\" using assms(1) by auto\n  have \"0 <= b\" using assms(2) by auto\n  thus ?thesis \n    by (metis add_nonneg_nonneg assms(1))\nqed", "origin": "do_request", "update_count": 0}, "trivial_inequalityV8": {"skill_name": "trivial_inequalityV8", "marker": "lemma trivial_inequality:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  from assms have \"0 \\<le> a\" and \"0 \\<le> b\" \n    by auto\n  then have \"0 + 0 \\<le> a + b\" \n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma trivial_inequality:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  from assms have \"0 \\<le> a\" and \"0 \\<le> b\" \n    by auto\n  then have \"0 + 0 \\<le> a + b\" \n    by (simp add: add_nonneg_nonneg)\n  thus ?thesis \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "additional_condition_x_y": {"skill_name": "additional_condition_x_y", "marker": "lemma additional_condition_x_y:\n  fixes x y :: real\n  assumes \"x * y = 2\"\n  shows \"x + 2/x = y + 2/y\"\nproof -\n  have \"y + 2 / y = x + 2 / x\" using assms by (metis add.commute add_scale_eq_noteq divide_eq_0_iff mult.commute mult_cancel_left2 mult_cancel_right1 mult_delta_left nonzero_mult_div_cancel_left one_add_one right_inverse_eq times_divide_eq_left times_divide_eq_right zero_neq_numeral zero_neq_one)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma additional_condition_x_y:\n  fixes x y :: real\n  assumes \"x * y = 2\"\n  shows \"x + 2/x = y + 2/y\"\nproof -\n  have \"y + 2 / y = x + 2 / x\" using assms by (metis add.commute add_scale_eq_noteq divide_eq_0_iff mult.commute mult_cancel_left2 mult_cancel_right1 mult_delta_left nonzero_mult_div_cancel_left one_add_one right_inverse_eq times_divide_eq_left times_divide_eq_right zero_neq_numeral zero_neq_one)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "power_modV5": {"skill_name": "power_modV5", "marker": "lemma power_mod:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a ^ Suc n = a * (a ^ n)\" by simp\n    then have \"(a ^ Suc n) mod m = (a * (a ^ n)) mod m\" by simp\n    also have \"... = ((a mod m) * (a ^ n)) mod m\" \n      using `m > 0` by (metis mod_mult_left_eq)\n    also have \"... = ((a mod m) * ((a ^ n) mod m)) mod m\" \n      by (metis mod_mult_right_eq)\n    also have \"... = (a mod m) ^ Suc n mod m\" \n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "description": "-", "full_code": "lemma power_mod:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a ^ Suc n = a * (a ^ n)\" by simp\n    then have \"(a ^ Suc n) mod m = (a * (a ^ n)) mod m\" by simp\n    also have \"... = ((a mod m) * (a ^ n)) mod m\" \n      using `m > 0` by (metis mod_mult_left_eq)\n    also have \"... = ((a mod m) * ((a ^ n) mod m)) mod m\" \n      by (metis mod_mult_right_eq)\n    also have \"... = (a mod m) ^ Suc n mod m\" \n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sqrt_equationV6": {"skill_name": "sqrt_equationV6", "marker": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9\" using assms by simp\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  also have \"... = 81\" by simp\n  finally have \"x + 9 = 81\" by simp\n  then show ?thesis by (simp add: add_diff_cancel)\nqed", "description": "-", "full_code": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9\" using assms by simp\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  also have \"... = 81\" by simp\n  finally have \"x + 9 = 81\" by simp\n  then show ?thesis by (simp add: add_diff_cancel)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_square_generalV2": {"skill_name": "sqrt_square_generalV2", "marker": "lemma sqrt_square_general:\n  fixes a :: \"real \\<Rightarrow> real\"\n  assumes \"a x >= 0\" \"x \\<in> A\"  \n  shows \"sqrt (a x) * sqrt (a x) = a x\"\nproof -\n  have \"sqrt (a x) * sqrt (a x) = a x\" using assms by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_square_general:\n  fixes a :: \"real \\<Rightarrow> real\"\n  assumes \"a x >= 0\" \"x \\<in> A\"  \n  shows \"sqrt (a x) * sqrt (a x) = a x\"\nproof -\n  have \"sqrt (a x) * sqrt (a x) = a x\" using assms by auto\n  then show ?thesis by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "solve_linear_equation_with_parametersV2": {"skill_name": "solve_linear_equation_with_parametersV2", "marker": "theorem solve_linear_equation_with_parameters:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = d\"   \n  shows \"b = (c - 3 * d) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  then have \"2 * b = c - 3 * d\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "theorem solve_linear_equation_with_parameters:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = d\"   \n  shows \"b = (c - 3 * d) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have \"3 * d + 2 * b = c\" using h1 eq by simp\n  then have \"2 * b = c - 3 * d\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "express_n_multi_mod": {"skill_name": "express_n_multi_mod", "marker": "lemma express_N_multi_mod:\n  fixes N :: nat and k :: nat and d :: nat\n  assumes \"d > 0\" and \"N = d * k + (d - 1)\"\n  shows \"N mod d = (d - 1)\"\nproof -\n  have \"N mod d = (d * k + (d - 1)) mod d\" using assms by simp\n  also have \"... = (d * k mod d + (d - 1) mod d)\" by auto\n  also have \"... = (0 + (d - 1)) mod d\" by auto\n  also have \"... = (d - 1)\" by (metis add_cancel_left_left assms(1) diff_less less_numeral_extra(1) mod_less)\n  finally show \"N mod d = (d - 1)\" by simp\nqed", "description": "-", "full_code": "lemma express_N:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5) mod 8\" by auto\n  also have \"... = 5\" by simp\n  finally show \"N mod 8 = 5\" by simp\nqed\n\nlemma express_N_multi_mod:\n  fixes N :: nat and k :: nat and d :: nat\n  assumes \"d > 0\" and \"N = d * k + (d - 1)\"\n  shows \"N mod d = (d - 1)\"\nproof -\n  have \"N mod d = (d * k + (d - 1)) mod d\" using assms by simp\n  also have \"... = (d * k mod d + (d - 1) mod d)\" by auto\n  also have \"... = (0 + (d - 1)) mod d\" by auto\n  also have \"... = (d - 1)\" by (metis add_cancel_left_left assms(1) diff_less less_numeral_extra(1) mod_less)\n  finally show \"N mod d = (d - 1)\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "express_n_extended": {"skill_name": "express_n_extended", "marker": "lemma express_N_extended:\n  fixes N :: nat and k :: nat and d :: nat\n  assumes \"d > 0\" and \"N = d * k + (d - 1)\"\n  shows \"N mod d = d - 1\"\nproof -\n  have \"N mod d = (d * k + (d - 1)) mod d\" using assms by simp\n  also have \"... = (d * k mod d + (d - 1) mod d)\" by auto\n  also have \"... = (0 + (d - 1)) mod d\" by auto\n  also have \"... = d - 1\" by (metis add_cancel_left_left assms(1) diff_less less_numeral_extra(1) mod_less)\n  finally show \"N mod d = d - 1\" by simp\nqed", "description": "-", "full_code": "lemma express_N:\n  fixes N :: nat and k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5) mod 8\" by auto\n  also have \"... = 5\" by simp\n  finally show \"N mod 8 = 5\" by simp\nqed\n\nlemma express_N_extended:\n  fixes N :: nat and k :: nat and d :: nat\n  assumes \"d > 0\" and \"N = d * k + (d - 1)\"\n  shows \"N mod d = d - 1\"\nproof -\n  have \"N mod d = (d * k + (d - 1)) mod d\" using assms by simp\n  also have \"... = (d * k mod d + (d - 1) mod d)\" by auto\n  also have \"... = (0 + (d - 1)) mod d\" by auto\n  also have \"... = d - 1\" by (metis add_cancel_left_left assms(1) diff_less less_numeral_extra(1) mod_less)\n  finally show \"N mod d = d - 1\" by simp\nqed", "origin": "express_n_mod_6", "update_count": 0}, "congruence_modV3": {"skill_name": "congruence_modV3", "marker": "lemma congruence_mod:\n  fixes N :: nat\n  fixes m b :: nat\n  assumes \"N mod m = b\"\n  shows \"\\<exists>k. N = m * k + b\"\nproof -\n  have \"N = m * (N div m) + (N mod m)\"\n    by auto\n  then have \"N = m * (N div m) + b\"\n    using assms by simp\n  then obtain k where \"k = N div m\"\n    by auto\n  thus \"\\<exists>k. N = m * k + b\"\n    by (metis \\<open>N = m * (N div m) + b\\<close>)\nqed", "description": "-", "full_code": "lemma congruence_mod:\n  fixes N :: nat\n  fixes m b :: nat\n  assumes \"N mod m = b\"\n  shows \"\\<exists>k. N = m * k + b\"\nproof -\n  have \"N = m * (N div m) + (N mod m)\"\n    by auto\n  then have \"N = m * (N div m) + b\"\n    using assms by simp\n  then obtain k where \"k = N div m\"\n    by auto\n  thus \"\\<exists>k. N = m * k + b\"\n    by (metis \\<open>N = m * (N div m) + b\\<close>)\nqed", "origin": "congruence_mod_6", "update_count": 0}, "sqrt_sum_of_squares": {"skill_name": "sqrt_sum_of_squares", "marker": "lemma sqrt_sum_of_squares:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a^2 + b^2) * sqrt (1) = sqrt (a^2 + b^2)\"\n  using assms by simp", "description": "-", "full_code": "lemma sqrt_sum_of_squares:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a^2 + b^2) * sqrt (1) = sqrt (a^2 + b^2)\"\n  using assms by simp", "origin": "sqrt_squareV2", "update_count": 0}, "linear_congruence_solution": {"skill_name": "linear_congruence_solution", "marker": "lemma linear_congruence_solution:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"\\<exists>k. a + k * m = b \\<Longrightarrow> a mod m = b mod m\"\nproof -\n  assume \"\\<exists>k. a + k * m = b\"\n  then obtain k where eq: \"a + k * m = b\" by auto\n  have \"b = a + k * m\" by (metis eq)\n  hence \"b mod m = (a + k * m) mod m\" by simp\n  also have \"... = (a mod m + (k * m mod m)) mod m\" by auto\n  also have \"... = (a mod m + 0) mod m\" using assms by auto\n  finally show \"a mod m = b mod m\" by simp\nqed", "description": "-", "full_code": "lemma linear_congruence_solution:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"\\<exists>k. a + k * m = b \\<Longrightarrow> a mod m = b mod m\"\nproof -\n  assume \"\\<exists>k. a + k * m = b\"\n  then obtain k where eq: \"a + k * m = b\" by auto\n  have \"b = a + k * m\" by (metis eq)\n  hence \"b mod m = (a + k * m) mod m\" by simp\n  also have \"... = (a mod m + (k * m mod m)) mod m\" by auto\n  also have \"... = (a mod m + 0) mod m\" using assms by auto\n  finally show \"a mod m = b mod m\" by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_square_variable": {"skill_name": "sqrt_square_variable", "marker": "lemma sqrt_square_variable:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt (x * x) = abs x\"\nproof -\n  have \"sqrt (x * x) = sqrt (x^2)\" by (simp add: power2_eq_square)\n  then have \"sqrt (x^2) = abs x\" using real_sqrt_eq_iff[of \"x^2\"] by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_square_variable:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt (x * x) = abs x\"\nproof -\n  have \"sqrt (x * x) = sqrt (x^2)\" by (simp add: power2_eq_square)\n  then have \"sqrt (x^2) = abs x\" using real_sqrt_eq_iff[of \"x^2\"] by auto\n  then show ?thesis by simp\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_square_for_non_negative": {"skill_name": "sqrt_square_for_non_negative", "marker": "lemma sqrt_square_for_non_negative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a * sqrt a = a\"\nusing sqrt_square_general[of a] assms by simp", "description": "-", "full_code": "lemma sqrt_square_general:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  then show ?thesis by simp\nqed\n\nlemma sqrt_square_for_non_negative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a * sqrt a = a\"\nusing sqrt_square_general[of a] assms by simp", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_square_differenceV2": {"skill_name": "sqrt_square_differenceV2", "marker": "lemma sqrt_square_difference:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt a * sqrt a - sqrt b * sqrt b = a - b\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms(1) sqrt_square_general by simp\n  have \"sqrt b * sqrt b = b\" using assms(2) sqrt_square_general by simp\n  then show ?thesis by (metis \\<open>sqrt a * sqrt a = a\\<close>)\nqed", "description": "-", "full_code": "lemma sqrt_square_general:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  then show ?thesis by simp\nqed\n\nlemma sqrt_square_difference:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt a * sqrt a - sqrt b * sqrt b = a - b\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms(1) sqrt_square_general by simp\n  have \"sqrt b * sqrt b = b\" using assms(2) sqrt_square_general by simp\n  then show ?thesis by (metis \\<open>sqrt a * sqrt a = a\\<close>)\nqed", "origin": "sqrt_squareV2", "update_count": 0}, "sqrt_general_solution": {"skill_name": "sqrt_general_solution", "marker": "lemma sqrt_general_solution:\n  fixes x y :: real\n  assumes \"y >= 0\" \"y = sqrt (x + y)\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_general_solution:\n  fixes x y :: real\n  assumes \"y >= 0\" \"y = sqrt (x + y)\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"y^2 = x + y\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus ?thesis by simp\nqed", "origin": "sqrt_limit", "update_count": 0}, "congruence_mod_d": {"skill_name": "congruence_mod_d", "marker": "lemma congruence_mod_d:\n  fixes N d :: nat\n  assumes \"d > 0\" and \"N mod d = r\" and \"r < d\"\n  shows \"\\<exists>m. N = d * m + r\"\nproof -\n  have \"N = d * (N div d) + (N mod d)\" \n    by auto\n  then have \"N = d * (N div d) + r\" \n    using assms(2) by simp\n  then obtain m where \"m = N div d\" \n    by auto\n  thus \"\\<exists>m. N = d * m + r\" \n    by (metis \\<open>N = d * (N div d) + r\\<close>)\nqed", "description": "-", "full_code": "lemma congruence_mod_d:\n  fixes N d :: nat\n  assumes \"d > 0\" and \"N mod d = r\" and \"r < d\"\n  shows \"\\<exists>m. N = d * m + r\"\nproof -\n  have \"N = d * (N div d) + (N mod d)\" \n    by auto\n  then have \"N = d * (N div d) + r\" \n    using assms(2) by simp\n  then obtain m where \"m = N div d\" \n    by auto\n  thus \"\\<exists>m. N = d * m + r\" \n    by (metis \\<open>N = d * (N div d) + r\\<close>)\nqed", "origin": "congruence_mod_6", "update_count": 0}, "square_expansion_complexV2": {"skill_name": "square_expansion_complexV2", "marker": "lemma square_expansion_complex:\n  fixes z1 z2 :: complex\n  shows \"(z1 - z2)^2 = z1^2 - 2*z1*z2 + z2^2\"\nproof -\n  have \"(z1 - z2)^2 = (z1 + (-z2))^2\" by simp\n  also have \"... = z1^2 + 2*z1*(-z2) + (-z2)^2\" by (smt (verit) calculation diff_add_eq diff_minus_eq_add mult_minus_right power2_diff power2_eq_iff power2_eq_square verit_minus_simplify(4))\n  also have \"... = z1^2 - 2*z1*z2 + z2^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion_complex:\n  fixes z1 z2 :: complex\n  shows \"(z1 - z2)^2 = z1^2 - 2*z1*z2 + z2^2\"\nproof -\n  have \"(z1 - z2)^2 = (z1 + (-z2))^2\" by simp\n  also have \"... = z1^2 + 2*z1*(-z2) + (-z2)^2\" by (smt (verit) calculation diff_add_eq diff_minus_eq_add mult_minus_right power2_diff power2_eq_iff power2_eq_square verit_minus_simplify(4))\n  also have \"... = z1^2 - 2*z1*z2 + z2^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "sqrt_equation_with_nonneg": {"skill_name": "sqrt_equation_with_nonneg", "marker": "lemma sqrt_equation_with_nonneg:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_equation_with_nonneg:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus ?thesis by simp\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_difference_formula": {"skill_name": "sqrt_difference_formula", "marker": "lemma sqrt_difference_formula:\n  fixes a b c :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\" \"c = sqrt (a + b)\"\n  shows \"c^2 = a + b\"\nproof -\n  have \"c^2 = (sqrt (a + b))^2\" using assms by simp\n  thus ?thesis by (smt (verit) add_mono assms(1) assms(2) real_sqrt_pow2_iff)\nqed", "description": "-", "full_code": "lemma sqrt_difference_formula:\n  fixes a b c :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\" \"c = sqrt (a + b)\"\n  shows \"c^2 = a + b\"\nproof -\n  have \"c^2 = (sqrt (a + b))^2\" using assms by simp\n  thus ?thesis by (smt (verit) add_mono assms(1) assms(2) real_sqrt_pow2_iff)\nqed", "origin": "sqrt_limit", "update_count": 0}, "sqrt_nonneg_limit": {"skill_name": "sqrt_nonneg_limit", "marker": "lemma sqrt_nonneg_limit:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" by simp\n  hence \"x = 81 - 9\" by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_nonneg_limit:\n  fixes x :: real\n  assumes \"9 = sqrt(x + 9)\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" by simp\n  hence \"x = 81 - 9\" by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "sqrt_limit", "update_count": 0}, "inequality_solution": {"skill_name": "inequality_solution", "marker": "lemma inequality_solution:\n  fixes N m :: nat\n  assumes \"N < 50\" \"N = 24 * m + 21\"\n  shows \"m < 2\"\nproof -\n  from assms(1) have \"24 * m + 21 < 50\" by (metis assms(2))\n  hence \"24 * m < 50 - 21\" by (simp add: algebra_simps)\n  hence \"24 * m < 29\" by simp\n  then have \"m < 29 / 24\" by (simp add: less_divide_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_solution:\n  fixes N m :: nat\n  assumes \"N < 50\" \"N = 24 * m + 21\"\n  shows \"m < 2\"\nproof -\n  from assms(1) have \"24 * m + 21 < 50\" by (metis assms(2))\n  hence \"24 * m < 50 - 21\" by (simp add: algebra_simps)\n  hence \"24 * m < 29\" by simp\n  then have \"m < 29 / 24\" by (simp add: less_divide_eq)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "inequality_solutionV2": {"skill_name": "inequality_solutionV2", "marker": "lemma inequality_solution:\n  fixes N m :: nat\n  assumes \"N < 50\" \"N = 24 * m + 21\"\n  shows \"m < 2\"\nproof -\n  from assms(1) have \"N < 50\" by simp\n  from assms(2) have \"N = 24 * m + 21\" by simp\n  have \"24 * m + 21 < 50\" using assms(1) by (metis assms(2))\n  hence \"24 * m < 50 - 21\" by (simp add: algebra_simps)\n  hence \"24 * m < 29\" by simp\n  have \"m < 29 / 24\" by (metis \\<open>24 * m < 29\\<close> less_divide_eq_numeral1(1) mult.commute of_nat_mult of_nat_numeral real_of_nat_less_numeral_iff)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_solution:\n  fixes N m :: nat\n  assumes \"N < 50\" \"N = 24 * m + 21\"\n  shows \"m < 2\"\nproof -\n  from assms(1) have \"N < 50\" by simp\n  from assms(2) have \"N = 24 * m + 21\" by simp\n  have \"24 * m + 21 < 50\" using assms(1) by (metis assms(2))\n  hence \"24 * m < 50 - 21\" by (simp add: algebra_simps)\n  hence \"24 * m < 29\" by simp\n  have \"m < 29 / 24\" by (metis \\<open>24 * m < 29\\<close> less_divide_eq_numeral1(1) mult.commute of_nat_mult of_nat_numeral real_of_nat_less_numeral_iff)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_arithmeticV3": {"skill_name": "mod_arithmeticV3", "marker": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  have \"c * a = c * (b + m * (a div m))\"\n    by (metis \\<open>a = b + m * (a div m)\\<close> add.commute)\n  then have \"c * a = c * b + c * m * (a div m)\"\n    by (simp add: algebra_simps)\n  then have \"(c * a) mod m = (c * b + c * m * (a div m)) mod m\"\n    by simp\n  also have \"... = (c * b) mod m\" \n  proof (cases \"c = 0\")\n    case True\n    then have \"c * b = 0\" by simp\n    thus ?thesis by auto\n  next\n    case False\n    then have \"c * m * (a div m) mod m = 0\" \n      using mod_mult_div_eq[of \"c * m\" \"m\"] by simp\n    also have \"c * b mod m = (c * b + 0) mod m\" by simp\n    finally show ?thesis by presburger\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  have \"c * a = c * (b + m * (a div m))\"\n    by (metis \\<open>a = b + m * (a div m)\\<close> add.commute)\n  then have \"c * a = c * b + c * m * (a div m)\"\n    by (simp add: algebra_simps)\n  then have \"(c * a) mod m = (c * b + c * m * (a div m)) mod m\"\n    by simp\n  also have \"... = (c * b) mod m\" \n  proof (cases \"c = 0\")\n    case True\n    then have \"c * b = 0\" by simp\n    thus ?thesis by auto\n  next\n    case False\n    then have \"c * m * (a div m) mod m = 0\" \n      using mod_mult_div_eq[of \"c * m\" \"m\"] by simp\n    also have \"c * b mod m = (c * b + 0) mod m\" by simp\n    finally show ?thesis by presburger\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_arithmeticV4": {"skill_name": "mod_arithmeticV4", "marker": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  then have \"c * a = c * (b + m * (a div m))\" \n    by simp\n  also have \"... = c * b + c * m * (a div m)\" \n    by (simp add: algebra_simps)\n  finally have \"c * a = c * b + c * m * (a div m)\" by simp\n  then have \"(c * a) mod m = (c * b + c * m * (a div m)) mod m\" \n    by simp\n  also have \"... = (c * b) mod m\" \n  proof (cases \"c = 0\")\n    case True\n    then have \"c * b = 0\" by simp\n    then show ?thesis \n      by auto\n  next\n    case False\n    then have \"c * m * (a div m) mod m = 0\" \n      by auto\n    thus ?thesis \n      by (metis ab_semigroup_mult_class.mult_ac(1) add_0_iff mod_add_cong mod_mult_right_eq mod_mult_self1_is_0 mult.commute mult_delta_right)\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  then have \"c * a = c * (b + m * (a div m))\" \n    by simp\n  also have \"... = c * b + c * m * (a div m)\" \n    by (simp add: algebra_simps)\n  finally have \"c * a = c * b + c * m * (a div m)\" by simp\n  then have \"(c * a) mod m = (c * b + c * m * (a div m)) mod m\" \n    by simp\n  also have \"... = (c * b) mod m\" \n  proof (cases \"c = 0\")\n    case True\n    then have \"c * b = 0\" by simp\n    then show ?thesis \n      by auto\n  next\n    case False\n    then have \"c * m * (a div m) mod m = 0\" \n      by auto\n    thus ?thesis \n      by (metis ab_semigroup_mult_class.mult_ac(1) add_0_iff mod_add_cong mod_mult_right_eq mod_mult_self1_is_0 mult.commute mult_delta_right)\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_arithmeticV5": {"skill_name": "mod_arithmeticV5", "marker": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  have \"c * a = c * (b + m * (a div m))\" \n    by (metis \\<open>a = b + m * (a div m)\\<close> ac_simps)\n  then have \"(c * a) mod m = (c * b + c * m * (a div m)) mod m\" \n    by (auto simp: field_simps)\n  also have \"... = (c * b) mod m\" \n  proof (cases \"c = 0\")\n    case True\n    then have \"c * b = 0\" by simp\n    thus ?thesis by auto\n  next\n    case False\n    then have \"c * m mod m = 0\" by (simp add: mod_mult_div_eq)\n    thus ?thesis by (metis ab_semigroup_mult_class.mult_ac(1) add_cancel_left_right mod_add_cong mod_mult_right_eq mod_mult_self1_is_0 mult.commute mult_delta_right)\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  have \"c * a = c * (b + m * (a div m))\" \n    by (metis \\<open>a = b + m * (a div m)\\<close> ac_simps)\n  then have \"(c * a) mod m = (c * b + c * m * (a div m)) mod m\" \n    by (auto simp: field_simps)\n  also have \"... = (c * b) mod m\" \n  proof (cases \"c = 0\")\n    case True\n    then have \"c * b = 0\" by simp\n    thus ?thesis by auto\n  next\n    case False\n    then have \"c * m mod m = 0\" by (simp add: mod_mult_div_eq)\n    thus ?thesis by (metis ab_semigroup_mult_class.mult_ac(1) add_cancel_left_right mod_add_cong mod_mult_right_eq mod_mult_self1_is_0 mult.commute mult_delta_right)\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_arithmeticV6": {"skill_name": "mod_arithmeticV6", "marker": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  then have \"c * a = c * (b + m * (a div m))\" \n    by simp\n  then have \"c * a = c * b + c * m * (a div m)\" \n    by (simp add: algebra_simps)\n  then have \"(c * a) mod m = (c * b + c * m * (a div m)) mod m\" \n    by simp\n  also have \"... = (c * b) mod m\" \n  proof -\n    have \"c * m * (a div m) mod m = 0\" \n      by (simp add: mod_mult_div_eq)\n    thus ?thesis by (metis ab_semigroup_mult_class.mult_ac(1) add_cancel_left_right mod_add_cong mod_mult_right_eq mod_mult_self1_is_0 mult.commute mult_delta_right)\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  then have \"c * a = c * (b + m * (a div m))\" \n    by simp\n  then have \"c * a = c * b + c * m * (a div m)\" \n    by (simp add: algebra_simps)\n  then have \"(c * a) mod m = (c * b + c * m * (a div m)) mod m\" \n    by simp\n  also have \"... = (c * b) mod m\" \n  proof -\n    have \"c * m * (a div m) mod m = 0\" \n      by (simp add: mod_mult_div_eq)\n    thus ?thesis by (metis ab_semigroup_mult_class.mult_ac(1) add_cancel_left_right mod_add_cong mod_mult_right_eq mod_mult_self1_is_0 mult.commute mult_delta_right)\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_arithmeticV7": {"skill_name": "mod_arithmeticV7", "marker": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  then have \"c * a = c * (b + m * (a div m))\" \n    by (simp add: algebra_simps)\n  also have \"... = c * b + c * (m * (a div m))\" \n    by (simp add: algebra_simps)\n  also have \"... = c * b + (c * m) * (a div m)\" \n    by auto\n  finally have \"c * a = c * b + (c * m) * (a div m)\" \n    by simp\n  then have \"(c * a) mod m = (c * b + (c * m) * (a div m)) mod m\" \n    by simp\n  also have \"... = (c * b) mod m\" \n    by (metis ab_semigroup_mult_class.mult_ac(1) add_cancel_left_right mod_add_cong mod_mult_right_eq mod_mult_self1_is_0 mult.commute mult_delta_right)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  then have \"c * a = c * (b + m * (a div m))\" \n    by (simp add: algebra_simps)\n  also have \"... = c * b + c * (m * (a div m))\" \n    by (simp add: algebra_simps)\n  also have \"... = c * b + (c * m) * (a div m)\" \n    by auto\n  finally have \"c * a = c * b + (c * m) * (a div m)\" \n    by simp\n  then have \"(c * a) mod m = (c * b + (c * m) * (a div m)) mod m\" \n    by simp\n  also have \"... = (c * b) mod m\" \n    by (metis ab_semigroup_mult_class.mult_ac(1) add_cancel_left_right mod_add_cong mod_mult_right_eq mod_mult_self1_is_0 mult.commute mult_delta_right)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_arithmeticV8": {"skill_name": "mod_arithmeticV8", "marker": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  have \"c * a = c * (b + m * (a div m))\" \n    by (metis \\<open>a = b + m * (a div m)\\<close> algebra_simps)\n  then have \"c * a = c * b + c * m * (a div m)\" \n    by (simp add: algebra_simps)\n  then have \"(c * a) mod m = (c * b + c * m * (a div m)) mod m\" \n    by simp\n  also have \"... = (c * b) mod m\" \n    by (metis add_cancel_left_right mod_add_cong mod_mult_right_eq mod_mult_self1_is_0 mult.assoc mult.commute mult_delta_right)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof -\n  have \"a = b + m * (a div m)\" \n    using assms by auto\n  have \"c * a = c * (b + m * (a div m))\" \n    by (metis \\<open>a = b + m * (a div m)\\<close> algebra_simps)\n  then have \"c * a = c * b + c * m * (a div m)\" \n    by (simp add: algebra_simps)\n  then have \"(c * a) mod m = (c * b + c * m * (a div m)) mod m\" \n    by simp\n  also have \"... = (c * b) mod m\" \n    by (metis add_cancel_left_right mod_add_cong mod_mult_right_eq mod_mult_self1_is_0 mult.assoc mult.commute mult_delta_right)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_differenceV4": {"skill_name": "square_differenceV4", "marker": "lemma square_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b)^2\" by simp\n  then have \"(a - b)^2 = a^2 + 2*a*(-b) + (-b)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = a^2 - 2*a*b + b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = (a + -b)^2\" by simp\n  then have \"(a - b)^2 = a^2 + 2*a*(-b) + (-b)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = a^2 - 2*a*b + b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "congruence_mod_12": {"skill_name": "congruence_mod_12", "marker": "lemma congruence_mod_12:\n  fixes N :: nat\n  assumes \"N mod 12 = 5\"\n  shows \"\\<exists>k. N = 12 * k + 5\"\nproof -\n  have \"N = 12 * (N div 12) + (N mod 12)\"\n    by auto\n  then have \"N = 12 * (N div 12) + 5\"\n    using assms by simp\n  then obtain k where \"k = N div 12\"\n    by auto\n  thus \"\\<exists>k. N = 12 * k + 5\"\n    by (metis \\<open>N = 12 * (N div 12) + 5\\<close>)\nqed", "description": "-", "full_code": "lemma congruence_mod_12:\n  fixes N :: nat\n  assumes \"N mod 12 = 5\"\n  shows \"\\<exists>k. N = 12 * k + 5\"\nproof -\n  have \"N = 12 * (N div 12) + (N mod 12)\"\n    by auto\n  then have \"N = 12 * (N div 12) + 5\"\n    using assms by simp\n  then obtain k where \"k = N div 12\"\n    by auto\n  thus \"\\<exists>k. N = 12 * k + 5\"\n    by (metis \\<open>N = 12 * (N div 12) + 5\\<close>)\nqed", "origin": "congruence_mod_6", "update_count": 0}, "congruence_mod_6_extended": {"skill_name": "congruence_mod_6_extended", "marker": "lemma congruence_mod_6_extended:\n  fixes N :: nat\n  assumes \"N mod 6 = 3\"\n  shows \"\\<exists>m. N = 6 * m + 3\"\n  using congruence_mod_n[of N 6 3] assms by simp", "description": "-", "full_code": "lemma congruence_mod_n:\n  fixes N :: nat and n :: nat\n  assumes \"N mod n = r\" and \"0 \\<le> r\" and \"r < n\"\n  shows \"\\<exists>m. N = n * m + r\"\nproof -\n  have \"N = n * (N div n) + (N mod n)\" \n    by auto\n  then have \"N = n * (N div n) + r\" \n    using assms by simp\n  then obtain m where \"m = N div n\" \n    by auto\n  thus \"\\<exists>m. N = n * m + r\" \n    by (metis \\<open>N = n * (N div n) + r\\<close>)\nqed\n\nlemma congruence_mod_6_extended:\n  fixes N :: nat\n  assumes \"N mod 6 = 3\"\n  shows \"\\<exists>m. N = 6 * m + 3\"\n  using congruence_mod_n[of N 6 3] assms by simp", "origin": "congruence_mod_6", "update_count": 0}}
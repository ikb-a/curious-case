{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "log_power_property": {"skill_name": "log_power_property", "marker": "lemma log_power_property:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\" \n    by (simp add: log_nat_power[of a a n] assms(1))\n  also have \"log a a = 1\" \n    using assms(1) assms(2) by simp\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma log_power_property:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\" \n    by (simp add: log_nat_power[of a a n] assms(1))\n  also have \"log a a = 1\" \n    using assms(1) assms(2) by simp\n  ultimately show ?thesis by simp\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "mod_add_power_generalized": {"skill_name": "mod_add_power_generalized", "marker": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b) ^ c) mod n = ((a + b) ^ c) mod n\"\nproof -\n  have \"((x + b) ^ c) mod n = ((x mod n + b) ^ c) mod n\"\n    using mod_add_left_eq power_mod by (smt (verit) mod_add_cong mod_mod_trivial)\n  also have \"... = ((a + b) ^ c) mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b) ^ c) mod n = ((a + b) ^ c) mod n\"\nproof -\n  have \"((x + b) ^ c) mod n = ((x mod n + b) ^ c) mod n\"\n    using mod_add_left_eq power_mod by (smt (verit) mod_add_cong mod_mod_trivial)\n  also have \"... = ((a + b) ^ c) mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_sum_power": {"skill_name": "mod_sum_power", "marker": "lemma mod_sum_power:\n  fixes x y n a b c :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\" \"c > 0\"\n  shows \"(x + y) ^ c mod n = (a + b) ^ c mod n\"\nproof -\n  have \"(x + y) mod n = (a + b) mod n\"\n    by (metis assms(2) assms(3) mod_add_cong mod_add_eq)\n  then show ?thesis\n    by (metis mod_add_left_eq power_mod)\nqed", "description": "-", "full_code": "lemma mod_sum_power:\n  fixes x y n a b c :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\" \"c > 0\"\n  shows \"(x + y) ^ c mod n = (a + b) ^ c mod n\"\nproof -\n  have \"(x + y) mod n = (a + b) mod n\"\n    by (metis assms(2) assms(3) mod_add_cong mod_add_eq)\n  then show ?thesis\n    by (metis mod_add_left_eq power_mod)\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_extended": {"skill_name": "mod_add_power_extended", "marker": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\" \"d mod n = b\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + b) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + (d mod n)) mod n\"\n    by presburger\n  also have \"... = ((x + b)^c mod n + b) mod n\"\n    using assms(6) by simp\n  also have \"... = ((x mod n + b)^c mod n + b) mod n\"\n    using assms(5) by (smt (verit) mod_add_cong mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c mod n + b) mod n\"\n    using assms(5) by (simp add: power_mod)\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\" \"d mod n = b\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + b) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + (d mod n)) mod n\"\n    by presburger\n  also have \"... = ((x + b)^c mod n + b) mod n\"\n    using assms(6) by simp\n  also have \"... = ((x mod n + b)^c mod n + b) mod n\"\n    using assms(5) by (smt (verit) mod_add_cong mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c mod n + b) mod n\"\n    using assms(5) by (simp add: power_mod)\n  finally show ?thesis by presburger\nqed", "origin": "mod_add_power", "update_count": 0}, "multi_distrib_complex_ext": {"skill_name": "multi_distrib_complex_ext", "marker": "lemma multi_distrib_complex_ext:\n  fixes a b :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"((a + b) * (c + d)) = (a * c + b * c + a * d + b * d)\" by (simp add: distrib_left distrib_right)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_ext:\n  fixes a b :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"((a + b) * (c + d)) = (a * c + b * c + a * d + b * d)\" by (simp add: distrib_left distrib_right)\n  thus ?thesis by simp\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "sum_and_product_to_sum_of_squares_generalized": {"skill_name": "sum_and_product_to_sum_of_squares_generalized", "marker": "theorem sum_and_product_to_sum_of_squares_generalized:\n  fixes x y :: real\n  assumes h0 : \"x + y = a\"\n    and h1 : \"x * y = b\"\n    and h2 : \"a > 0\"\n    and h3 : \"b > 0\"\n  shows \"sqrt (x^2 + y^2) = sqrt (a^2 - 2 * b)\"\nproof -\n  have \"sqrt (x^2 + y^2) = sqrt ((x + y)^2 - 2 * x * y)\" \n    by (smt (verit) power2_sum real_sqrt_eq_iff)\n  also have \"... = sqrt (a^2 - 2 * b)\" using h0 h1\n    by (metis ab_semigroup_mult_class.mult_ac(1) mult.commute mult.left_commute mult_2_right power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "theorem sum_and_product_to_sum_of_squares_generalized:\n  fixes x y :: real\n  assumes h0 : \"x + y = a\"\n    and h1 : \"x * y = b\"\n    and h2 : \"a > 0\"\n    and h3 : \"b > 0\"\n  shows \"sqrt (x^2 + y^2) = sqrt (a^2 - 2 * b)\"\nproof -\n  have \"sqrt (x^2 + y^2) = sqrt ((x + y)^2 - 2 * x * y)\" \n    by (smt (verit) power2_sum real_sqrt_eq_iff)\n  also have \"... = sqrt (a^2 - 2 * b)\" using h0 h1\n    by (metis ab_semigroup_mult_class.mult_ac(1) mult.commute mult.left_commute mult_2_right power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "cancle_div", "update_count": 0}, "solve_linear_equation_generalized": {"skill_name": "solve_linear_equation_generalized", "marker": "lemma solve_linear_equation_generalized:\n  fixes n :: nat\n  assumes \"a > 0\"\n  assumes \"a * n + b = c\"\n  shows \"n = (c - b) div a\"\nproof -\n  have \"a * n + b = c\" using assms by simp\n  then have \"a * n = c - b\" by simp\n  then have \"n = (c - b) div a\" using `a > 0`\n    by (smt (verit) div_mult_self1_is_m)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma solve_linear_equation_generalized:\n  fixes n :: nat\n  assumes \"a > 0\"\n  assumes \"a * n + b = c\"\n  shows \"n = (c - b) div a\"\nproof -\n  have \"a * n + b = c\" using assms by simp\n  then have \"a * n = c - b\" by simp\n  then have \"n = (c - b) div a\" using `a > 0`\n    by (smt (verit) div_mult_self1_is_m)\n  then show ?thesis by simp\nqed", "origin": "cancle_div", "update_count": 0}, "multi_distrib_complex_ext_generalized": {"skill_name": "multi_distrib_complex_ext_generalized", "marker": "lemma multi_distrib_complex_ext_generalized:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d + e + f) = a * c + a * d + a * e + a * f + b * c + b * d + b * e + b * f\"\nproof -\n  have \"((a + b) * (c + d + e + f)) = (a * c + b * c + a * d + b * d + a * e + b * e + a * f + b * f)\" \n    using distrib_left by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_ext_generalized:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d + e + f) = a * c + a * d + a * e + a * f + b * c + b * d + b * e + b * f\"\nproof -\n  have \"((a + b) * (c + d + e + f)) = (a * c + b * c + a * d + b * d + a * e + b * e + a * f + b * f)\" \n    using distrib_left by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "origin": "multi_distrib_complex_ext", "update_count": 0}, "multi_distrib_complex_ext_general": {"skill_name": "multi_distrib_complex_ext_general", "marker": "lemma multi_distrib_complex_ext_general:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + b + e + f) * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a * c + b * c + a * d + b * d) + (e * c + f * c + e * d + f * d)\"\n    by (auto simp: field_simps)\n  also have \"... = (a + b + e + f) * (c + d)\"\n    by (auto simp: field_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_ext_general:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + b + e + f) * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a * c + b * c + a * d + b * d) + (e * c + f * c + e * d + f * d)\"\n    by (auto simp: field_simps)\n  also have \"... = (a + b + e + f) * (c + d)\"\n    by (auto simp: field_simps)\n  finally show ?thesis by simp\nqed", "origin": "multi_distrib_complex_ext", "update_count": 0}, "multi_distrib_complex_ext_generalV2": {"skill_name": "multi_distrib_complex_ext_generalV2", "marker": "lemma multi_distrib_complex_ext_general:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_ext_general:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "origin": "multi_distrib_complex_ext", "update_count": 0}, "log_natural_power_property": {"skill_name": "log_natural_power_property", "marker": "lemma log_natural_power_property:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"ln (a^n) = n * ln a\"\nproof -\n  have \"ln (a^n) = n * ln a\" \n    by (metis assms(1) ln_realpow)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma log_natural_power_property:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"ln (a^n) = n * ln a\"\nproof -\n  have \"ln (a^n) = n * ln a\" \n    by (metis assms(1) ln_realpow)\n  thus ?thesis by simp\nqed", "origin": "log_power_property", "update_count": 0}, "multi_distrib_general": {"skill_name": "multi_distrib_general", "marker": "lemma multi_distrib_general:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" \n    by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" \n    by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_general:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" \n    by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" \n    by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "origin": "multi_distrib_complex_ext_generalV2", "update_count": 0}, "multi_distrib_with_params": {"skill_name": "multi_distrib_with_params", "marker": "lemma multi_distrib_with_params:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\n  using multi_distrib_general by blast", "description": "-", "full_code": "lemma multi_distrib_general:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed\n\nlemma multi_distrib_with_params:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\n  using multi_distrib_general by blast", "origin": "multi_distrib_complex_ext_generalV2", "update_count": 0}, "multi_distrib_parametrized": {"skill_name": "multi_distrib_parametrized", "marker": "lemma multi_distrib_parametrized:\n  fixes x y z w u v :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) + (u + v) * (x + y) = (x * z + y * z + x * w + y * w) + (u * x + u * y + v * x + v * y)\"\nproof -\n  have \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\" by (simp add: distrib_left distrib_right)\n  moreover have \"(u + v) * (x + y) = u * x + u * y + v * x + v * y\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_parametrized:\n  fixes x y z w u v :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) + (u + v) * (x + y) = (x * z + y * z + x * w + y * w) + (u * x + u * y + v * x + v * y)\"\nproof -\n  have \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\" by (simp add: distrib_left distrib_right)\n  moreover have \"(u + v) * (x + y) = u * x + u * y + v * x + v * y\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "origin": "multi_distrib_complex_ext_generalV2", "update_count": 0}, "generalized_linear_equation_solution": {"skill_name": "generalized_linear_equation_solution", "marker": "lemma generalized_linear_equation_solution:\n  fixes a b c n :: real\n  assumes \"a > 0\"\n  assumes \"a * n + b = c\"\n  shows \"n = (c - b) / a\"\nproof -\n  have \"a * n + b = c\" using assms by simp\n  then have \"a * n = c - b\" by simp\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma generalized_linear_equation_solution:\n  fixes a b c n :: real\n  assumes \"a > 0\"\n  assumes \"a * n + b = c\"\n  shows \"n = (c - b) / a\"\nproof -\n  have \"a * n + b = c\" using assms by simp\n  then have \"a * n = c - b\" by simp\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "origin": "solve_linear_equation_generalized", "update_count": 0}, "linear_equation_solution": {"skill_name": "linear_equation_solution", "marker": "lemma linear_equation_solution:\n  fixes a b c n :: real\n  assumes \"a > 0\"\n  assumes \"a * n + b = c\"\n  shows \"n = (c - b) / a\"\nproof -\n  have \"a * n = c - b\" using assms by simp\n  then show ?thesis using `a > 0` by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma linear_equation_solution:\n  fixes a b c n :: real\n  assumes \"a > 0\"\n  assumes \"a * n + b = c\"\n  shows \"n = (c - b) / a\"\nproof -\n  have \"a * n = c - b\" using assms by simp\n  then show ?thesis using `a > 0` by (auto simp: field_simps)\nqed", "origin": "solve_linear_equation_generalized", "update_count": 0}, "manipulate_division": {"skill_name": "manipulate_division", "marker": "lemma manipulate_division:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (smt (verit) assms(1) cancel_div)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed\n\nlemma manipulate_division:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (smt (verit) assms(1) cancel_div)\n  then show ?thesis by simp\nqed", "origin": "cancle_div", "update_count": 0}, "multi_distrib_parametrized_advanced": {"skill_name": "multi_distrib_parametrized_advanced", "marker": "lemma multi_distrib_parametrized_advanced:\n  fixes x y z w u v :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) + (u + v) * (z + w) = (x + u) * (z + w) + (y + v) * (z + w)\"\nproof -\n  have \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\" by (simp add: distrib_left distrib_right)\n  moreover have \"(u + v) * (z + w) = u * z + v * z + u * w + v * w\" by (simp add: distrib_left distrib_right)\n  then have \"x * z + y * z + x * w + y * w + u * z + v * z + u * w + v * w = (x + u) * (z + w) + (y + v) * (z + w)\"\n    by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_parametrized_advanced:\n  fixes x y z w u v :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) + (u + v) * (z + w) = (x + u) * (z + w) + (y + v) * (z + w)\"\nproof -\n  have \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\" by (simp add: distrib_left distrib_right)\n  moreover have \"(u + v) * (z + w) = u * z + v * z + u * w + v * w\" by (simp add: distrib_left distrib_right)\n  then have \"x * z + y * z + x * w + y * w + u * z + v * z + u * w + v * w = (x + u) * (z + w) + (y + v) * (z + w)\"\n    by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_parametrized", "update_count": 0}, "distributive_property": {"skill_name": "distributive_property", "marker": "lemma distributive_property:\n  fixes x y z :: \"'a :: comm_ring\"\n  shows \"(x + y) * z = x * z + y * z\"\nproof -\n  have \"(x + y) * z = x * z + y * z\" by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma distributive_property:\n  fixes x y z :: \"'a :: comm_ring\"\n  shows \"(x + y) * z = x * z + y * z\"\nproof -\n  have \"(x + y) * z = x * z + y * z\" by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "origin": "multi_distrib_parametrized", "update_count": 0}, "solve_for_variable": {"skill_name": "solve_for_variable", "marker": "lemma solve_for_variable:\n  fixes a b c d n :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  assumes \"a * n + b = c\"\n  shows \"n = (c - b) / a\"\n  using generalized_linear_equation_solution[of a b c n] by (metis add_diff_cancel_right' add_divide_eq_if_simps(4) assms(1) assms(3) div_by_1 eq_divide_eq mult.commute mult_delta_left mult_delta_right)", "description": "-", "full_code": "lemma generalized_linear_equation_solution:\n  fixes a b c n :: real\n  assumes \"a \\<noteq> 0\"\n  assumes \"a * n + b = c\"\n  shows \"n = (c - b) / a\"\nproof -\n  have \"a * n + b = c\" using assms by simp\n  then have \"a * n = c - b\" by simp\n  then show ?thesis using assms by (simp add: field_simps)\nqed\n\nlemma solve_for_variable:\n  fixes a b c d n :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  assumes \"a * n + b = c\"\n  shows \"n = (c - b) / a\"\n  using generalized_linear_equation_solution[of a b c n] by (metis add_diff_cancel_right' add_divide_eq_if_simps(4) assms(1) assms(3) div_by_1 eq_divide_eq mult.commute mult_delta_left mult_delta_right)", "origin": "generalized_linear_equation_solution", "update_count": 0}, "cancle_div_multi_dim": {"skill_name": "cancle_div_multi_dim", "marker": "lemma cancle_div_multi_dim:\n  fixes x a b c :: \"real list\"\n  assumes \"x \\<noteq> []\" \"\\<forall>i. x ! i > 0\" \"\\<forall>i. a ! i + b ! i / (x ! i) = c ! i\"\n  shows \"\\<forall>i. x ! i * a ! i + b ! i = c ! i * (x ! i)\"\nproof -\n  have \"\\<forall>i. x ! i * (a ! i + b ! i / (x ! i)) = c ! i * (x ! i)\"\n    using assms(3) by auto\n  then have \"\\<forall>i. x ! i * a ! i + x ! i * (b ! i / (x ! i)) = c ! i * (x ! i)\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(2) by (smt (verit) assms(3) cancle_div_multi)\nqed", "description": "-", "full_code": "lemma cancle_div_multi:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"x * a + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed\n\nlemma cancle_div_multi_dim:\n  fixes x a b c :: \"real list\"\n  assumes \"x \\<noteq> []\" \"\\<forall>i. x ! i > 0\" \"\\<forall>i. a ! i + b ! i / (x ! i) = c ! i\"\n  shows \"\\<forall>i. x ! i * a ! i + b ! i = c ! i * (x ! i)\"\nproof -\n  have \"\\<forall>i. x ! i * (a ! i + b ! i / (x ! i)) = c ! i * (x ! i)\"\n    using assms(3) by auto\n  then have \"\\<forall>i. x ! i * a ! i + x ! i * (b ! i / (x ! i)) = c ! i * (x ! i)\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(2) by (smt (verit) assms(3) cancle_div_multi)\nqed", "origin": "cancle_div", "update_count": 0}, "distributive_property_generalized": {"skill_name": "distributive_property_generalized", "marker": "lemma distributive_property_generalized:\n  fixes x y z :: \"'a :: comm_ring\"\n  shows \"(x + y) * z = x * z + y * z\"\n  by (auto simp: field_simps)", "description": "-", "full_code": "lemma distributive_property_generalized:\n  fixes x y z :: \"'a :: comm_ring\"\n  shows \"(x + y) * z = x * z + y * z\"\n  by (auto simp: field_simps)", "origin": "distributive_property", "update_count": 0}, "distributive_property_multiple": {"skill_name": "distributive_property_multiple", "marker": "lemma distributive_property_multiple:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a + b) * c + (a + b) * d\" by (auto simp: field_simps)\n  also have \"... = a * c + b * c + a * d + b * d\" by (simp add: distributive_property_generalized)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distributive_property_generalized:\n  fixes x y z :: \"'a :: comm_ring\"\n  shows \"(x + y) * z = x * z + y * z\"\nproof -\n  have \"(x + y) * z = x * z + y * z\" by (auto simp: field_simps)\n  thus ?thesis by simp\nqed\n\nlemma distributive_property_multiple:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a + b) * c + (a + b) * d\" by (auto simp: field_simps)\n  also have \"... = a * c + b * c + a * d + b * d\" by (simp add: distributive_property_generalized)\n  finally show ?thesis by simp\nqed", "origin": "distributive_property", "update_count": 0}, "multi_distrib_parametrized_advanced_n_dimensions": {"skill_name": "multi_distrib_parametrized_advanced_n_dimensions", "marker": "lemma multi_distrib_parametrized_advanced_n_dimensions:\n  fixes x y z w u v :: \"'a :: comm_ring\"\n  assumes \"n > 0\"\n  shows \"(\\<Sum>i\\<in>{1..n}. (x + y) * (z + w) + (u + v) * (z + w)) = \n         (\\<Sum>i\\<in>{1..n}. (x + u) * (z + w) + (y + v) * (z + w))\"\nproof -\n  have \"\\<forall>i. (x + y) * (z + w) = x * z + y * z + x * w + y * w\" \n    by (simp add: distrib_left distrib_right)\n  moreover have \"\\<forall>i. (u + v) * (z + w) = u * z + v * z + u * w + v * w\" \n    by (simp add: distrib_left distrib_right)\n  then have \"(\\<Sum>i\\<in>{1..n}. (x * z + y * z + x * w + y * w + u * z + v * z + u * w + v * w)) =\n         (\\<Sum>i\\<in>{1..n}. (x + u) * (z + w) + (y + v) * (z + w))\"\n    by (auto simp: field_simps)\n  ultimately show ?thesis using assms by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_parametrized_advanced_n_dimensions:\n  fixes x y z w u v :: \"'a :: comm_ring\"\n  assumes \"n > 0\"\n  shows \"(\\<Sum>i\\<in>{1..n}. (x + y) * (z + w) + (u + v) * (z + w)) = \n         (\\<Sum>i\\<in>{1..n}. (x + u) * (z + w) + (y + v) * (z + w))\"\nproof -\n  have \"\\<forall>i. (x + y) * (z + w) = x * z + y * z + x * w + y * w\" \n    by (simp add: distrib_left distrib_right)\n  moreover have \"\\<forall>i. (u + v) * (z + w) = u * z + v * z + u * w + v * w\" \n    by (simp add: distrib_left distrib_right)\n  then have \"(\\<Sum>i\\<in>{1..n}. (x * z + y * z + x * w + y * w + u * z + v * z + u * w + v * w)) =\n         (\\<Sum>i\\<in>{1..n}. (x + u) * (z + w) + (y + v) * (z + w))\"\n    by (auto simp: field_simps)\n  ultimately show ?thesis using assms by (auto simp: field_simps)\nqed", "origin": "multi_distrib_parametrized_advanced", "update_count": 0}, "multi_distrib_parametrized_advanced_multi": {"skill_name": "multi_distrib_parametrized_advanced_multi", "marker": "lemma multi_distrib_parametrized_advanced_multi:\n  fixes x y z w u v :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) + (u + v) * (z + w) = (x + u) * (z + w) + (y + v) * (z + w) \\<or> \n         (x + y) * (z + w) + (u + v) * (z + w) = (x + u + v) * (z + w)\"\nproof -\n  have \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\" by (simp add: distrib_left distrib_right)\n  moreover have \"(u + v) * (z + w) = u * z + v * z + u * w + v * w\" by (simp add: distrib_left distrib_right)\n  then have \"x * z + y * z + x * w + y * w + u * z + v * z + u * w + v * w = (x + u) * (z + w) + (y + v) * (z + w)\"\n    by (simp add: distrib_left distrib_right)\n  moreover have \"(x + y) * (z + w) + (u + v) * (z + w) = (x + u + v) * (z + w) + (y) * (z + w)\"\n    by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_parametrized_advanced_multi:\n  fixes x y z w u v :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) + (u + v) * (z + w) = (x + u) * (z + w) + (y + v) * (z + w) \\<or> \n         (x + y) * (z + w) + (u + v) * (z + w) = (x + u + v) * (z + w)\"\nproof -\n  have \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\" by (simp add: distrib_left distrib_right)\n  moreover have \"(u + v) * (z + w) = u * z + v * z + u * w + v * w\" by (simp add: distrib_left distrib_right)\n  then have \"x * z + y * z + x * w + y * w + u * z + v * z + u * w + v * w = (x + u) * (z + w) + (y + v) * (z + w)\"\n    by (simp add: distrib_left distrib_right)\n  moreover have \"(x + y) * (z + w) + (u + v) * (z + w) = (x + u + v) * (z + w) + (y) * (z + w)\"\n    by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_parametrized_advanced", "update_count": 0}, "log_natural_power_property_multi": {"skill_name": "log_natural_power_property_multi", "marker": "lemma log_natural_power_property_multi:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"m > 0\"\n  shows \"ln (a^(n + m)) = ln (a^n) + ln (a^m)\"\nproof -\n  have \"ln (a^(n + m)) = (n + m) * ln a\" \n    by (metis assms(1) ln_realpow)\n  also have \"... = n * ln a + m * ln a\" by (auto simp: field_simps)\n  also have \"... = ln (a^n) + ln (a^m)\" by (metis assms(1) ln_realpow)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma log_natural_power_property_multi:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"m > 0\"\n  shows \"ln (a^(n + m)) = ln (a^n) + ln (a^m)\"\nproof -\n  have \"ln (a^(n + m)) = (n + m) * ln a\" \n    by (metis assms(1) ln_realpow)\n  also have \"... = n * ln a + m * ln a\" by (auto simp: field_simps)\n  also have \"... = ln (a^n) + ln (a^m)\" by (metis assms(1) ln_realpow)\n  finally show ?thesis .\nqed", "origin": "log_natural_power_property", "update_count": 0}, "log_natural_power_property_multiV2": {"skill_name": "log_natural_power_property_multiV2", "marker": "lemma log_natural_power_property_multi:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"m > 0\"\n  shows \"ln (a^(n + m)) = ln (a^n) + ln (a^m)\"\nproof -\n  have \"ln (a^(n + m)) = (n + m) * ln a\" \n    by (metis assms(1) ln_realpow)\n  also have \"... = (n * ln a) + (m * ln a)\" by (simp add: algebra_simps)\n  also have \"... = ln (a^n) + ln (a^m)\" \n    by (metis assms(1) ln_realpow)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma log_natural_power_property_multi:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"m > 0\"\n  shows \"ln (a^(n + m)) = ln (a^n) + ln (a^m)\"\nproof -\n  have \"ln (a^(n + m)) = (n + m) * ln a\" \n    by (metis assms(1) ln_realpow)\n  also have \"... = (n * ln a) + (m * ln a)\" by (simp add: algebra_simps)\n  also have \"... = ln (a^n) + ln (a^m)\" \n    by (metis assms(1) ln_realpow)\n  finally show ?thesis by simp\nqed", "origin": "log_natural_power_property", "update_count": 0}, "floor_sum_properties": {"skill_name": "floor_sum_properties", "marker": "lemma floor_sum_properties:\n  fixes a b x :: real\n  assumes \"a < b\" \"x > 0\"\n  shows \"floor (x + a) + floor (x + b) = floor (x + a) + floor (x + b)\"\nproof -\n  have \"floor (x + a) + floor (x + b) = floor (x + a) + floor (x + b)\"\n    by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_sum_properties:\n  fixes a b x :: real\n  assumes \"a < b\" \"x > 0\"\n  shows \"floor (x + a) + floor (x + b) = floor (x + a) + floor (x + b)\"\nproof -\n  have \"floor (x + a) + floor (x + b) = floor (x + a) + floor (x + b)\"\n    by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_propertiesV2": {"skill_name": "floor_sum_propertiesV2", "marker": "lemma floor_sum_properties:\n  fixes a b r :: real\n  assumes \"a < b\" \"r > 0\"\n  shows \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b)\"\nproof -\n  have \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b)\"\n    by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_sum_properties:\n  fixes a b r :: real\n  assumes \"a < b\" \"r > 0\"\n  shows \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b)\"\nproof -\n  have \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b)\"\n    by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "log_natural_power_propertyV2": {"skill_name": "log_natural_power_propertyV2", "marker": "lemma log_natural_power_property:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"m > 0\"\n  shows \"ln (a^n) + ln (a^m) = ln (a^(n + m))\"\nproof -\n  have \"ln (a^n) = n * ln a\" by (metis assms(1) ln_realpow)\n  have \"ln (a^m) = m * ln a\" by (metis assms(1) ln_realpow)\n  then have \"ln (a^n) + ln (a^m) = n * ln a + m * ln a\" by (metis \\<open>ln (a ^ n) = real n * ln a\\<close>)\n  also have \"... = (n + m) * ln a\" by (simp add: algebra_simps)\n  finally show \"ln (a^n) + ln (a^m) = ln (a^(n + m))\" \n    using assms(1) by (metis ln_realpow)\nqed", "description": "-", "full_code": "lemma log_natural_power_property:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"m > 0\"\n  shows \"ln (a^n) + ln (a^m) = ln (a^(n + m))\"\nproof -\n  have \"ln (a^n) = n * ln a\" by (metis assms(1) ln_realpow)\n  have \"ln (a^m) = m * ln a\" by (metis assms(1) ln_realpow)\n  then have \"ln (a^n) + ln (a^m) = n * ln a + m * ln a\" by (metis \\<open>ln (a ^ n) = real n * ln a\\<close>)\n  also have \"... = (n + m) * ln a\" by (simp add: algebra_simps)\n  finally show \"ln (a^n) + ln (a^m) = ln (a^(n + m))\" \n    using assms(1) by (metis ln_realpow)\nqed", "origin": "log_natural_power_property_multiV2", "update_count": 0}, "log_product_property": {"skill_name": "log_product_property", "marker": "lemma log_product_property:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"ln (a * b) = ln a + ln b\"\nproof -\n  have \"ln (a * b) = ln a + ln b\" \n    by (metis assms(1) assms(2) ln_mult)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma log_product_property:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"ln (a * b) = ln a + ln b\"\nproof -\n  have \"ln (a * b) = ln a + ln b\" \n    by (metis assms(1) assms(2) ln_mult)\n  then show ?thesis by simp\nqed", "origin": "log_natural_power_property_multiV2", "update_count": 0}, "mod_sum_property": {"skill_name": "mod_sum_property", "marker": "lemma mod_sum_property:\n  fixes x y n :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\"\n  shows \"(x + y) mod n = (a + b) mod n\"\nproof -\n  have \"(x + y) mod n = (x mod n + y mod n) mod n\"\n    using mod_add_left_eq by presburger\n  also have \"... = (a + b) mod n\" using assms by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_sum_property:\n  fixes x y n :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\"\n  shows \"(x + y) mod n = (a + b) mod n\"\nproof -\n  have \"(x + y) mod n = (x mod n + y mod n) mod n\"\n    using mod_add_left_eq by presburger\n  also have \"... = (a + b) mod n\" using assms by auto\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power_generalized", "update_count": 0}, "scale_and_translate": {"skill_name": "scale_and_translate", "marker": "lemma scale_and_translate:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"x * a + b = x * c\"\nproof -\n  have \"x * (a + b / x) = x * c\"\n    using assms(2) by auto\n  then have \"x * a + b = x * c\"\n    using assms(1) by (simp add: distrib_left)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma scale_and_translate:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"x * a + b = x * c\"\nproof -\n  have \"x * (a + b / x) = x * c\"\n    using assms(2) by auto\n  then have \"x * a + b = x * c\"\n    using assms(1) by (simp add: distrib_left)\n  thus ?thesis by simp\nqed", "origin": "cancle_div", "update_count": 0}, "mod_add_power_extended_general": {"skill_name": "mod_add_power_extended_general", "marker": "lemma mod_add_power_extended_general:\n  fixes x n a b c d e :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"e > 0\" \n          \"x mod n = a\" \"d mod n = b\" \"e mod n = c\"\n  shows \"((x + b)^e + d) mod n = ((a + b)^e + b) mod n\"\nproof -\n  have \"((x + b)^e + d) mod n = (((x + b)^e mod n) + (d mod n)) mod n\"\n    by presburger\n  also have \"... = ((x + b)^e mod n + b) mod n\"\n    using assms(7) by simp\n  also have \"... = ((x mod n + b)^e mod n + b) mod n\"\n    using assms(6) by (smt (verit) mod_add_cong mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^e mod n + b) mod n\"\n    using assms(6) by (simp add: power_mod)\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_add_power_extended_general:\n  fixes x n a b c d e :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"e > 0\" \n          \"x mod n = a\" \"d mod n = b\" \"e mod n = c\"\n  shows \"((x + b)^e + d) mod n = ((a + b)^e + b) mod n\"\nproof -\n  have \"((x + b)^e + d) mod n = (((x + b)^e mod n) + (d mod n)) mod n\"\n    by presburger\n  also have \"... = ((x + b)^e mod n + b) mod n\"\n    using assms(7) by simp\n  also have \"... = ((x mod n + b)^e mod n + b) mod n\"\n    using assms(6) by (smt (verit) mod_add_cong mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^e mod n + b) mod n\"\n    using assms(6) by (simp add: power_mod)\n  finally show ?thesis by presburger\nqed", "origin": "mod_add_power_extended", "update_count": 0}, "mod_add_power_extended_generalized": {"skill_name": "mod_add_power_extended_generalized", "marker": "lemma mod_add_power_extended_generalized:\n  fixes x n a b c d e :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"e > 0\" \"x mod n = a\" \"d mod n = b\"\n  shows \"((x + b)^c + d + e) mod n = ((a + b)^c + b + e) mod n\"\nproof -\n  have \"((x + b)^c + d + e) mod n = (((x + b)^c mod n) + (d + e) mod n) mod n\"\n    by (metis add.commute group_cancel.add1 group_cancel.add2 mod_add_eq)\n  also have \"... = ((x + b)^c mod n + (b + e)) mod n\"\n    using assms(6) by (smt (verit) assms(7) mod_add_left_eq mod_add_right_eq)\n  also have \"... = ((x mod n + b)^c mod n + (b + e)) mod n\"\n    using assms(5) by (smt (verit) mod_add_cong mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c mod n + (b + e)) mod n\"\n    using assms(5) by (metis add.commute assms(6) group_cancel.add2 mod_add_cong mod_add_left_eq mod_add_right_eq)\n  finally show ?thesis by (smt (verit) \\<open>((x + b) ^ c + d + e) mod n = ((x + b) ^ c mod n + (d + e) mod n) mod n\\<close> \\<open>((x + b) ^ c mod n + (b + e)) mod n = ((x mod n + b) ^ c mod n + (b + e)) mod n\\<close> \\<open>((x + b) ^ c mod n + (d + e) mod n) mod n = ((x + b) ^ c mod n + (b + e)) mod n\\<close> assms(6) group_cancel.add1 mod_add_left_eq)\nqed", "description": "-", "full_code": "lemma mod_add_power_extended_generalized:\n  fixes x n a b c d e :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"e > 0\" \"x mod n = a\" \"d mod n = b\"\n  shows \"((x + b)^c + d + e) mod n = ((a + b)^c + b + e) mod n\"\nproof -\n  have \"((x + b)^c + d + e) mod n = (((x + b)^c mod n) + (d + e) mod n) mod n\"\n    by (metis add.commute group_cancel.add1 group_cancel.add2 mod_add_eq)\n  also have \"... = ((x + b)^c mod n + (b + e)) mod n\"\n    using assms(6) by (smt (verit) assms(7) mod_add_left_eq mod_add_right_eq)\n  also have \"... = ((x mod n + b)^c mod n + (b + e)) mod n\"\n    using assms(5) by (smt (verit) mod_add_cong mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c mod n + (b + e)) mod n\"\n    using assms(5) by (metis add.commute assms(6) group_cancel.add2 mod_add_cong mod_add_left_eq mod_add_right_eq)\n  finally show ?thesis by (smt (verit) \\<open>((x + b) ^ c + d + e) mod n = ((x + b) ^ c mod n + (d + e) mod n) mod n\\<close> \\<open>((x + b) ^ c mod n + (b + e)) mod n = ((x mod n + b) ^ c mod n + (b + e)) mod n\\<close> \\<open>((x + b) ^ c mod n + (d + e) mod n) mod n = ((x + b) ^ c mod n + (b + e)) mod n\\<close> assms(6) group_cancel.add1 mod_add_left_eq)\nqed", "origin": "mod_add_power_extended", "update_count": 0}, "mod_add_power_general": {"skill_name": "mod_add_power_general", "marker": "lemma mod_add_power_general:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"b > 0\" \n          \"x mod n = a\"\n  shows \"((x + b)^e) mod n = ((a + b)^e) mod n\"\nproof -\n  have \"((x + b)^e) mod n = (((x + b)^e mod n))\"\n    by presburger\n  also have \"... = ((x mod n + b)^e mod n)\"\n    using assms(3) by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^e mod n)\"\n    using assms(3) by (simp add: power_mod)\n  finally show ?thesis by (metis \\<open>(x + b) ^ e mod n = (x mod n + b) ^ e mod n\\<close> add.commute assms(3))\nqed", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"b > 0\" \n          \"x mod n = a\"\n  shows \"((x + b)^e) mod n = ((a + b)^e) mod n\"\nproof -\n  have \"((x + b)^e) mod n = (((x + b)^e mod n))\"\n    by presburger\n  also have \"... = ((x mod n + b)^e mod n)\"\n    using assms(3) by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^e mod n)\"\n    using assms(3) by (simp add: power_mod)\n  finally show ?thesis by (metis \\<open>(x + b) ^ e mod n = (x mod n + b) ^ e mod n\\<close> add.commute assms(3))\nqed", "origin": "mod_add_power_extended_general", "update_count": 0}, "mod_add_power_generalV2": {"skill_name": "mod_add_power_generalV2", "marker": "lemma mod_add_power_general:\n  fixes x a b n e :: nat\n  assumes \"n > 0\" \"b > 0\" \"e > 0\" \n          \"x mod n = a\"\n  shows \"((x + b)^e) mod n = ((a + b)^e) mod n\"\nproof -\n  have \"((x + b)^e) mod n = ((x mod n + b)^e) mod n\" \n    using assms(4) by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^e) mod n\" \n    using assms(4) by (simp add: power_mod)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x a b n e :: nat\n  assumes \"n > 0\" \"b > 0\" \"e > 0\" \n          \"x mod n = a\"\n  shows \"((x + b)^e) mod n = ((a + b)^e) mod n\"\nproof -\n  have \"((x + b)^e) mod n = ((x mod n + b)^e) mod n\" \n    using assms(4) by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^e) mod n\" \n    using assms(4) by (simp add: power_mod)\n  finally show ?thesis by simp\nqed", "origin": "mod_add_power_extended_general", "update_count": 0}, "distributive_property_with_params": {"skill_name": "distributive_property_with_params", "marker": "lemma distributive_property_with_params:\n  fixes a b c d x y :: \"'a :: comm_ring\"\n  assumes \"x = a + b\" \"y = c + d\"\n  shows \"x * y = a * c + a * d + b * c + b * d\"\nproof -\n  have \"x * y = (a + b) * (c + d)\" using assms by simp\n  thus ?thesis using distributive_property_multiple by simp\nqed", "description": "-", "full_code": "lemma distributive_property_generalized:\n  fixes x y z :: \"'a :: comm_ring\"\n  shows \"(x + y) * z = x * z + y * z\"\nby (simp add: field_simps)\n\nlemma distributive_property_multiple:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a + b) * c + (a + b) * d\" by (simp add: field_simps)\n  also have \"... = a * c + b * c + a * d + b * d\" \n    by (simp add: distributive_property_generalized)\n  finally show ?thesis by simp\nqed\n\nlemma distributive_property_with_params:\n  fixes a b c d x y :: \"'a :: comm_ring\"\n  assumes \"x = a + b\" \"y = c + d\"\n  shows \"x * y = a * c + a * d + b * c + b * d\"\nproof -\n  have \"x * y = (a + b) * (c + d)\" using assms by simp\n  thus ?thesis using distributive_property_multiple by simp\nqed", "origin": "distributive_property_multiple", "update_count": 0}, "number_terms": {"skill_name": "number_terms", "marker": "lemma number_terms:\n  fixes n x :: nat\n  assumes \"x + (73 - x) = 73\"\n  shows \"x = x\"\nproof -\n  have \"x + (73 - x) = 73\" using assms by simp\n  then have \"73 = 73\" by simp\n  thus \"x = x\" by (simp add: eq_reflection)\nqed", "description": "-", "full_code": "lemma number_terms:\n  fixes n x :: nat\n  assumes \"x + (73 - x) = 73\"\n  shows \"x = x\"\nproof -\n  have \"x + (73 - x) = 73\" using assms by simp\n  then have \"73 = 73\" by simp\n  thus \"x = x\" by (simp add: eq_reflection)\nqed", "origin": "do_request", "update_count": 0}, "number_termsV2": {"skill_name": "number_termsV2", "marker": "lemma number_terms:\n  fixes n x :: nat\n  assumes \"x + (73 - x) = 73\"\n  shows \"x = x\"\nproof -\n  from assms have \"73 - x = 73 - x\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma number_terms:\n  fixes n x :: nat\n  assumes \"x + (73 - x) = 73\"\n  shows \"x = x\"\nproof -\n  from assms have \"73 - x = 73 - x\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "number_termsV3": {"skill_name": "number_termsV3", "marker": "lemma number_terms:\n  fixes n x :: nat\n  assumes \"x + (73 - x) = 73\"\n  shows \"x = x\"\nproof -\n  have \"x + (73 - x) = 73\" using assms by assumption\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma number_terms:\n  fixes n x :: nat\n  assumes \"x + (73 - x) = 73\"\n  shows \"x = x\"\nproof -\n  have \"x + (73 - x) = 73\" using assms by assumption\n  then show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "distribution_with_parameters": {"skill_name": "distribution_with_parameters", "marker": "lemma distribution_with_parameters:\n  fixes x y z w :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\"\nproof -\n  have \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\" by (simp add: distrib_left distrib_right)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_with_parameters:\n  fixes x y z w :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\"\nproof -\n  have \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\" by (simp add: distrib_left distrib_right)\n  then show ?thesis by simp\nqed", "origin": "multi_distrib_parametrized_advanced", "update_count": 0}, "distributive_propertyV2": {"skill_name": "distributive_propertyV2", "marker": "lemma distributive_property:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by (auto simp: field_simps)\n  then show ?thesis by (simp add: distrib_left)\nqed", "description": "-", "full_code": "lemma distributive_property:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by (auto simp: field_simps)\n  then show ?thesis by (simp add: distrib_left)\nqed", "origin": "multi_distrib_parametrized_advanced", "update_count": 0}, "multi_distrib_parametrizedV2": {"skill_name": "multi_distrib_parametrizedV2", "marker": "lemma multi_distrib_parametrized:\n  fixes x y z w :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\"\nproof -\n  have \"(x + y) * (z + w) = (x + y) * z + (x + y) * w\" by (simp add: distrib_left)\n  then show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_parametrized:\n  fixes x y z w :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\"\nproof -\n  have \"(x + y) * (z + w) = (x + y) * z + (x + y) * w\" by (simp add: distrib_left)\n  then show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_parametrized_advanced", "update_count": 0}, "multi_distrib_advanced": {"skill_name": "multi_distrib_advanced", "marker": "lemma multi_distrib_advanced:\n  fixes x y z w u v :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) + (u + v) * (z + w) = (x + u) * (z + w) + (y + v) * (z + w)\"\nproof -\n  have \"((x + y) * (z + w) + (u + v) * (z + w)) = (x + y + u + v) * (z + w)\" \n    by (auto simp: field_simps)\n  then show ?thesis\n    using multi_distrib_parametrized by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_parametrized:\n  fixes x y z w :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\"\nproof -\n  have \"(x + y) * (z + w) = (x + y) * z + (x + y) * w\" by (simp add: distrib_left)\n  then show ?thesis by (auto simp: field_simps)\nqed\n\nlemma multi_distrib_advanced:\n  fixes x y z w u v :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) + (u + v) * (z + w) = (x + u) * (z + w) + (y + v) * (z + w)\"\nproof -\n  have \"((x + y) * (z + w) + (u + v) * (z + w)) = (x + y + u + v) * (z + w)\" \n    by (auto simp: field_simps)\n  then show ?thesis\n    using multi_distrib_parametrized by (auto simp: field_simps)\nqed", "origin": "multi_distrib_parametrized_advanced", "update_count": 0}, "multi_distrib_complex_extended": {"skill_name": "multi_distrib_complex_extended", "marker": "lemma multi_distrib_complex_extended:\n  fixes a b :: complex\n  fixes xs ys :: \"complex list\"\n  shows \"(a + b) * complex_sum xs = a * complex_sum xs + b * complex_sum xs\"\nproof (induction xs)\n  case Nil\n  then show ?case \n    by (auto simp: field_simps)\nnext\n  case (Cons x xs)\n  then show ?case \n    by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_extended:\n  fixes a b :: complex\n  fixes xs ys :: \"complex list\"\n  shows \"(a + b) * complex_sum xs = a * complex_sum xs + b * complex_sum xs\"\nproof (induction xs)\n  case Nil\n  then show ?case \n    by (auto simp: field_simps)\nnext\n  case (Cons x xs)\n  then show ?case \n    by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "manipulate_division_complex": {"skill_name": "manipulate_division_complex", "marker": "lemma manipulate_division_complex:\n  fixes x a b c d :: complex\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (smt (verit) assms(1) cancel_div_general)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancel_div_general:\n  fixes x a b c :: \"'a::field\"\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed\n\nlemma manipulate_division_complex:\n  fixes x a b c d :: complex\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (smt (verit) assms(1) cancel_div_general)\n  then show ?thesis by simp\nqed", "origin": "manipulate_division", "update_count": 0}, "distribution_of_sums": {"skill_name": "distribution_of_sums", "marker": "lemma distribution_of_sums:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by (auto simp: field_simps)\n  also have \"... = a * c + a * d + b * c + b * d\" by (simp add: distrib_left)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_of_sums:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by (auto simp: field_simps)\n  also have \"... = a * c + a * d + b * c + b * d\" by (simp add: distrib_left)\n  finally show ?thesis by simp\nqed", "origin": "multi_distrib_parametrized", "update_count": 0}, "distribution_of_sum": {"skill_name": "distribution_of_sum", "marker": "lemma distribution_of_sum:\n  fixes x y z :: \"'a :: comm_ring\"\n  shows \"(x + y) * z = x * z + y * z\"\nproof -\n  have \"(x + y) * z = x * z + y * z\" \n    by (simp add: distrib_left distrib_right)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_of_sum:\n  fixes x y z :: \"'a :: comm_ring\"\n  shows \"(x + y) * z = x * z + y * z\"\nproof -\n  have \"(x + y) * z = x * z + y * z\" \n    by (simp add: distrib_left distrib_right)\n  thus ?thesis by simp\nqed", "origin": "multi_distrib_parametrized", "update_count": 0}, "distribution_of_sumV2": {"skill_name": "distribution_of_sumV2", "marker": "lemma distribution_of_sum:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (a + b) = (a * c + b * c + a * d + b * d) + (e * a + e * b + f * a + f * b)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (a + b) = e * a + e * b + f * a + f * b\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_of_sum:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (a + b) = (a * c + b * c + a * d + b * d) + (e * a + e * b + f * a + f * b)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (a + b) = e * a + e * b + f * a + f * b\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "origin": "multi_distrib_parametrized", "update_count": 0}, "multiplicative_inverse": {"skill_name": "multiplicative_inverse", "marker": "lemma multiplicative_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma multiplicative_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp)\n  thus ?thesis by simp\nqed", "origin": "a_times_vera", "update_count": 0}, "non_zero_division": {"skill_name": "non_zero_division", "marker": "lemma non_zero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"1 / a * a = 1\"\nproof -\n  have \"1 / a * a = (a / a)\" using assms by (simp add: field_simps)\n  also have \"... = 1\" using assms by (simp add: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma non_zero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"1 / a * a = 1\"\nproof -\n  have \"1 / a * a = (a / a)\" using assms by (simp add: field_simps)\n  also have \"... = 1\" using assms by (simp add: field_simps)\n  finally show ?thesis .\nqed", "origin": "a_times_vera", "update_count": 0}, "linear_equation_solution_multi": {"skill_name": "linear_equation_solution_multi", "marker": "lemma linear_equation_solution_multi:\n  fixes a b c n :: real\n  assumes \"a > 0\"\n  assumes \"(\\<forall>i. a * n + b = c)\"\n  shows \"n = (c - b) / a\"\nproof -\n  obtain n where \"(\\<forall>i. a * n + b = c)\" by (metis assms(2))\n  then show ?thesis using assms by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma linear_equation_solution_multi:\n  fixes a b c n :: real\n  assumes \"a > 0\"\n  assumes \"(\\<forall>i. a * n + b = c)\"\n  shows \"n = (c - b) / a\"\nproof -\n  obtain n where \"(\\<forall>i. a * n + b = c)\" by (metis assms(2))\n  then show ?thesis using assms by (auto simp: field_simps)\nqed", "origin": "linear_equation_solution", "update_count": 0}, "conditions_on_n": {"skill_name": "conditions_on_n", "marker": "lemma conditions_on_n:\n  fixes n :: nat\n  assumes \"73 * n \\<le> 546\"\n  shows \"546 - 73 * n \\<ge> 0\"\nproof -\n  have \"546 - 73 * n \\<ge> 546 - 546\" using assms by (simp add: le_diff_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma conditions_on_n:\n  fixes n :: nat\n  assumes \"73 * n \\<le> 546\"\n  shows \"546 - 73 * n \\<ge> 0\"\nproof -\n  have \"546 - 73 * n \\<ge> 546 - 546\" using assms by (simp add: le_diff_eq)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_multi_list": {"skill_name": "cancel_div_multi_list", "marker": "lemma cancel_div_multi_list:\n  fixes x a b c :: \"real list\"\n  assumes \"x \\<noteq> []\" \"\\<forall>i. x ! i > 0\" \"\\<forall>i. a ! i + b ! i / (x ! i) = c ! i\"\n  shows \"\\<forall>i. x ! i * a ! i + b ! i = c ! i * (x ! i)\"\nproof -\n  have \"\\<forall>i. x ! i * (a ! i + b ! i / (x ! i)) = c ! i * (x ! i)\"\n    using assms(3) by auto\n  then have \"\\<forall>i. x ! i * a ! i + b ! i = c ! i * (x ! i)\"\n    by (smt (verit) assms(2) assms(3) cancel_div_multi_real)\n  thus ?thesis using assms(2) by (metis)\nqed", "description": "-", "full_code": "lemma cancel_div_multi_real:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"x * a + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + b = c * x\"\n    using assms(1) by (simp add: distrib_left)\n  thus ?thesis by simp\nqed\n\nlemma cancel_div_multi_list:\n  fixes x a b c :: \"real list\"\n  assumes \"x \\<noteq> []\" \"\\<forall>i. x ! i > 0\" \"\\<forall>i. a ! i + b ! i / (x ! i) = c ! i\"\n  shows \"\\<forall>i. x ! i * a ! i + b ! i = c ! i * (x ! i)\"\nproof -\n  have \"\\<forall>i. x ! i * (a ! i + b ! i / (x ! i)) = c ! i * (x ! i)\"\n    using assms(3) by auto\n  then have \"\\<forall>i. x ! i * a ! i + b ! i = c ! i * (x ! i)\"\n    by (smt (verit) assms(2) assms(3) cancel_div_multi_real)\n  thus ?thesis using assms(2) by (metis)\nqed", "origin": "cancle_div_multi_dim", "update_count": 0}, "cancel_div_multi": {"skill_name": "cancel_div_multi", "marker": "lemma cancel_div_multi:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"x * a + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + b = c * x\"\n    using assms(1) by (simp add: distrib_left)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancel_div_multi:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"x * a + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + b = c * x\"\n    using assms(1) by (simp add: distrib_left)\n  then show ?thesis by simp\nqed", "origin": "cancle_div_multi_dim", "update_count": 0}, "non_zero_cancel": {"skill_name": "non_zero_cancel", "marker": "lemma non_zero_cancel:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"x * a + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then show ?thesis using assms(1) by (simp add: distrib_left)\nqed", "description": "-", "full_code": "lemma non_zero_cancel:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"x * a + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then show ?thesis using assms(1) by (simp add: distrib_left)\nqed", "origin": "cancle_div_multi_dim", "update_count": 0}, "cancel_div_specific": {"skill_name": "cancel_div_specific", "marker": "lemma cancel_div_specific:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"b = c * x - a * x\"\nproof -\n  have \"a + b / x = c\" using assms(2) by simp\n  then have \"b / x = c - a\" by simp\n  then have \"b = (c - a) * x\" using assms(1) by (auto simp: field_simps)\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma cancel_div_specific:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"b = c * x - a * x\"\nproof -\n  have \"a + b / x = c\" using assms(2) by simp\n  then have \"b / x = c - a\" by simp\n  then have \"b = (c - a) * x\" using assms(1) by (auto simp: field_simps)\n  then show ?thesis by sos\nqed", "origin": "cancle_div", "update_count": 0}, "conditions_on_nV2": {"skill_name": "conditions_on_nV2", "marker": "lemma conditions_on_n:\n  fixes n :: nat\n  assumes \"73 * n \\<le> 546\"\n  shows \"546 - 73 * n \\<ge> 0\"\nproof -\n  have \"546 - 73 * n = 546 - (73 * n)\" by simp\n  also have \"... = 546 - 546 + (546 - 73 * n)\" using assms by (simp add: le_diff_eq)\n  finally have \"546 - 73 * n \\<ge> 0\" by (simp add: le_zero_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma conditions_on_n:\n  fixes n :: nat\n  assumes \"73 * n \\<le> 546\"\n  shows \"546 - 73 * n \\<ge> 0\"\nproof -\n  have \"546 - 73 * n = 546 - (73 * n)\" by simp\n  also have \"... = 546 - 546 + (546 - 73 * n)\" using assms by (simp add: le_diff_eq)\n  finally have \"546 - 73 * n \\<ge> 0\" by (simp add: le_zero_eq)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_change": {"skill_name": "floor_change", "marker": "lemma floor_change:\n  fixes r :: real and k :: nat\n  assumes \"k \\<in> {19..91}\"\n  shows \"floor (r + (k + 1) / 100) - floor (r + k / 100) \\<in> {0, 1}\"\nproof -\n  let ?x = \"r + k / 100\"\n  let ?y = \"r + (k + 1) / 100\"\n  have \"floor ?y - floor ?x \\<in> {0, 1}\"\n  proof -\n    have \"floor ?y = floor (?x + 0.01)\"\n      by (auto simp: field_simps)\n    have \"floor ?y = floor ?x + (if ?x + 0.01 < floor ?x + 1 then 0 else 1)\"\n      using floor_add by (smt (verit) \\<open>\\<lfloor>r + real (k + 1) / 100\\<rfloor> = \\<lfloor>r + real k / 100 + 1 / 10\\<^sup>2\\<rfloor>\\<close> add.commute add_less_imp_less_left add_less_same_cancel1 divide_less_cancel divide_less_eq_1_pos floor_add_int floor_eq floor_less_cancel floor_less_iff floor_zero int_ops(1) int_ops(2) less_add_one linorder_neqE_linordered_idom nat_1_add_1 not_one_less_zero numeral_Bit0_div_2 numerals(1) odd_one odd_succ_div_two of_nat_less_imp_less one_div_two_eq_zero one_less_power pos2 zadd_int_left zero_less_power_eq)\n    thus ?thesis\n      by auto\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_change:\n  fixes r :: real and k :: nat\n  assumes \"k \\<in> {19..91}\"\n  shows \"floor (r + (k + 1) / 100) - floor (r + k / 100) \\<in> {0, 1}\"\nproof -\n  let ?x = \"r + k / 100\"\n  let ?y = \"r + (k + 1) / 100\"\n  have \"floor ?y - floor ?x \\<in> {0, 1}\"\n  proof -\n    have \"floor ?y = floor (?x + 0.01)\"\n      by (auto simp: field_simps)\n    have \"floor ?y = floor ?x + (if ?x + 0.01 < floor ?x + 1 then 0 else 1)\"\n      using floor_add by (smt (verit) \\<open>\\<lfloor>r + real (k + 1) / 100\\<rfloor> = \\<lfloor>r + real k / 100 + 1 / 10\\<^sup>2\\<rfloor>\\<close> add.commute add_less_imp_less_left add_less_same_cancel1 divide_less_cancel divide_less_eq_1_pos floor_add_int floor_eq floor_less_cancel floor_less_iff floor_zero int_ops(1) int_ops(2) less_add_one linorder_neqE_linordered_idom nat_1_add_1 not_one_less_zero numeral_Bit0_div_2 numerals(1) odd_one odd_succ_div_two of_nat_less_imp_less one_div_two_eq_zero one_less_power pos2 zadd_int_left zero_less_power_eq)\n    thus ?thesis\n      by auto\n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sum_distribution": {"skill_name": "sum_distribution", "marker": "lemma sum_distribution:\n  fixes a b c d :: \"'a :: comm_ring\"\n  assumes \"n > 0\"\n  shows \"(\\<Sum>i\\<in>{1..n}. (a + b) * (c + d)) = \n         (\\<Sum>i\\<in>{1..n}. (a * (c + d) + b * (c + d)))\"\nproof -\n  have \"\\<forall>i. (a + b) * (c + d) = a * (c + d) + b * (c + d)\"\n    by (auto simp: field_simps)\n  then show ?thesis by (simp add: sum_constant)\nqed", "description": "-", "full_code": "lemma sum_distribution:\n  fixes a b c d :: \"'a :: comm_ring\"\n  assumes \"n > 0\"\n  shows \"(\\<Sum>i\\<in>{1..n}. (a + b) * (c + d)) = \n         (\\<Sum>i\\<in>{1..n}. (a * (c + d) + b * (c + d)))\"\nproof -\n  have \"\\<forall>i. (a + b) * (c + d) = a * (c + d) + b * (c + d)\"\n    by (auto simp: field_simps)\n  then show ?thesis by (simp add: sum_constant)\nqed", "origin": "multi_distrib_parametrized_advanced_n_dimensions", "update_count": 0}, "multi_distrib_generalized": {"skill_name": "multi_distrib_generalized", "marker": "lemma multi_distrib_generalized:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"((a + b) * (c + d) + (e + f) * (c + d)) = ((a + b + e + f) * (c + d))\" \n    by (auto simp: field_simps)\n  then show ?thesis\n    using multi_distrib_parametrized by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_parametrized:\n  fixes x y z w :: \"'a :: comm_ring\"\n  shows \"(x + y) * (z + w) = x * z + y * z + x * w + y * w\"\nproof -\n  have \"(x + y) * (z + w) = (x + y) * z + (x + y) * w\" by (simp add: distrib_left)\n  then show ?thesis by (auto simp: field_simps)\nqed\n\nlemma multi_distrib_generalized:\n  fixes a b c d e f :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"((a + b) * (c + d) + (e + f) * (c + d)) = ((a + b + e + f) * (c + d))\" \n    by (auto simp: field_simps)\n  then show ?thesis\n    using multi_distrib_parametrized by (auto simp: field_simps)\nqed", "origin": "multi_distrib_advanced", "update_count": 0}, "multiplicative_inverse_property": {"skill_name": "multiplicative_inverse_property", "marker": "lemma multiplicative_inverse_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b = 1 / a\"\n  shows \"a * b = 1\"\nproof -\n  have \"a * b = a * (1 / a)\" using assms(2) by simp\n  thus ?thesis using assms(1) by auto\nqed", "description": "-", "full_code": "lemma multiplicative_inverse_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b = 1 / a\"\n  shows \"a * b = 1\"\nproof -\n  have \"a * b = a * (1 / a)\" using assms(2) by simp\n  thus ?thesis using assms(1) by auto\nqed", "origin": "multiplicative_inverse", "update_count": 0}, "solve_linear_inequality_generalized": {"skill_name": "solve_linear_inequality_generalized", "marker": "lemma solve_linear_inequality_generalized:\n  fixes a b c :: real\n  assumes \"a > 0\"\n  assumes \"a * x + b < c\"\n  shows \"x < (c - b) / a\"\nproof -\n  have \"a * x + b < c\" using assms by simp\n  then have \"a * x < c - b\" by simp\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma solve_linear_inequality_generalized:\n  fixes a b c :: real\n  assumes \"a > 0\"\n  assumes \"a * x + b < c\"\n  shows \"x < (c - b) / a\"\nproof -\n  have \"a * x + b < c\" using assms by simp\n  then have \"a * x < c - b\" by simp\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "origin": "generalized_linear_equation_solution", "update_count": 0}, "real_number_properties": {"skill_name": "real_number_properties", "marker": "lemma real_number_properties:\n  fixes x y z :: real\n  shows \"x < y \\<Longrightarrow> x + z < y + z\"\nproof -\n  assume \"x < y\"\n  then have \"x + z < y + z\" \n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma real_number_properties:\n  fixes x y z :: real\n  shows \"x < y \\<Longrightarrow> x + z < y + z\"\nproof -\n  assume \"x < y\"\n  then have \"x + z < y + z\" \n    by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_add": {"skill_name": "floor_add", "marker": "lemma floor_add:\n  fixes r :: real and k :: real\n  shows \"floor (r + k) = floor r + floor k + (if r + k < floor r + floor k + 1 then 0 else 1)\"\nproof -\n  have \"floor (r + k) = floor (floor r + floor k + (r - floor r) + (k - floor k))\"\n    by auto\n  then show ?thesis\n    by (smt (verit) ceiling_add_of_int ceiling_of_int ceiling_zero floor_add floor_add_int floor_eq_iff floor_one floor_zero int_add_floor le_floor_add le_floor_iff not_one_le_zero of_int_1 of_int_add)\nqed", "description": "-", "full_code": "lemma floor_add:\n  fixes r :: real and k :: real\n  shows \"floor (r + k) = floor r + floor k + (if r + k < floor r + floor k + 1 then 0 else 1)\"\nproof -\n  have \"floor (r + k) = floor (floor r + floor k + (r - floor r) + (k - floor k))\"\n    by auto\n  then show ?thesis\n    by (smt (verit) ceiling_add_of_int ceiling_of_int ceiling_zero floor_add floor_add_int floor_eq_iff floor_one floor_zero int_add_floor le_floor_add le_floor_iff not_one_le_zero of_int_1 of_int_add)\nqed", "origin": "do_request", "update_count": 0}, "floor_addV2": {"skill_name": "floor_addV2", "marker": "lemma floor_add:\n  fixes r :: real and k :: real\n  shows \"floor (r + k) = floor r + floor k + (if r + k < floor r + floor k + 1 then 0 else 1)\"\nproof -\n  have \"floor (r + k) = floor r + floor k + (if r + k < floor r + floor k + 1 then 0 else 1)\"\n  proof (cases \"r + k < floor r + floor k + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) add_cancel_right_right floor_add floor_eq_iff leD)\n  next\n    case False\n    then show ?thesis \n      by (smt (verit) add1_zle_eq floor_add floor_less_iff)\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_add:\n  fixes r :: real and k :: real\n  shows \"floor (r + k) = floor r + floor k + (if r + k < floor r + floor k + 1 then 0 else 1)\"\nproof -\n  have \"floor (r + k) = floor r + floor k + (if r + k < floor r + floor k + 1 then 0 else 1)\"\n  proof (cases \"r + k < floor r + floor k + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) add_cancel_right_right floor_add floor_eq_iff leD)\n  next\n    case False\n    then show ?thesis \n      by (smt (verit) add1_zle_eq floor_add floor_less_iff)\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_add_power_for_any_x": {"skill_name": "mod_add_power_for_any_x", "marker": "lemma mod_add_power_for_any_x:\n  fixes x b c n a :: nat\n  assumes \"x mod n = a\" \"b > 0\" \"c > 0\" \"n > 0\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_generalized[of x n a b c] by (smt (verit) assms(1) assms(2) assms(3) assms(4) mod_add_power_generalized)", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_for_any_x:\n  fixes x b c n a :: nat\n  assumes \"x mod n = a\" \"b > 0\" \"c > 0\" \"n > 0\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_generalized[of x n a b c] by (smt (verit) assms(1) assms(2) assms(3) assms(4) mod_add_power_generalized)", "origin": "mod_add_power", "update_count": 0}, "manipulate_division_with_addition": {"skill_name": "manipulate_division_with_addition", "marker": "lemma manipulate_division_with_addition:\n  fixes x a b c d :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d \\<ge> 0\"\n  shows \"c * x + d = a * x + b + d\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (metis add.commute add_cancel_left_right assms(1) cancel_div_general_extended mult_eq_0_iff)\n  then show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma cancel_div_general_extended:\n  fixes x a b c d :: \"'a::field\"\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d \\<noteq> 0\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" by (metis add.commute add_divide_eq_if_simps(2) add_right_imp_eq add_scale_eq_noteq assms(1) assms(2) divide_cancel_right mult.commute mult.left_commute mult_delta_left mult_right_cancel nonzero_eq_divide_eq times_divide_eq_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed\n\nlemma manipulate_division_with_addition:\n  fixes x a b c d :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d \\<ge> 0\"\n  shows \"c * x + d = a * x + b + d\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (metis add.commute add_cancel_left_right assms(1) cancel_div_general_extended mult_eq_0_iff)\n  then show ?thesis by (simp add: field_simps)\nqed", "origin": "manipulate_division_complex", "update_count": 0}, "cancel_div_general_extended": {"skill_name": "cancel_div_general_extended", "marker": "lemma cancel_div_general_extended:\n  fixes x a b c d :: \"'a::field\"\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d \\<noteq> 0\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" by (metis add.commute add_divide_eq_if_simps(2) add_right_imp_eq add_scale_eq_noteq assms(1) assms(2) divide_cancel_right mult.commute mult.left_commute mult_delta_left mult_right_cancel nonzero_eq_divide_eq times_divide_eq_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancel_div_general_extended:\n  fixes x a b c d :: \"'a::field\"\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d \\<noteq> 0\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" by (metis add.commute add_divide_eq_if_simps(2) add_right_imp_eq add_scale_eq_noteq assms(1) assms(2) divide_cancel_right mult.commute mult.left_commute mult_delta_left mult_right_cancel nonzero_eq_divide_eq times_divide_eq_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "origin": "manipulate_division_complex", "update_count": 0}, "manipulate_division_with_additionV2": {"skill_name": "manipulate_division_with_additionV2", "marker": "lemma manipulate_division_with_addition:\n  fixes x a b c d :: \"'a::field\"\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d \\<noteq> 0\"\n  shows \"d * (c * x - b) = d * (a * x)\"\nproof -\n  have \"c * x - b = a * x\" using cancel_div_advanced assms(1, 2) by auto\n  then have \"d * (c * x - b) = d * (a * x)\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancel_div_advanced:\n  fixes x a b c d :: \"'a::field\"\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (metis add.commute add_cancel_right_left add_cancel_right_right add_divide_eq_if_simps(2) add_right_imp_eq add_scale_eq_noteq assms(1) comm_monoid_add_class.add_0 crossproduct_eq divide_cancel_left divide_cancel_right divide_divide_eq_right divide_divide_times_eq divide_eq_0_iff eq_divide_eq frac_eq_eq group_cancel.add1 group_cancel.add2 mult.assoc mult.commute mult.left_commute mult_delta_left mult_delta_right mult_left_cancel mult_right_cancel times_divide_eq_left)\n  then show ?thesis by simp\nqed\n\nlemma manipulate_division_with_addition:\n  fixes x a b c d :: \"'a::field\"\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d \\<noteq> 0\"\n  shows \"d * (c * x - b) = d * (a * x)\"\nproof -\n  have \"c * x - b = a * x\" using cancel_div_advanced assms(1, 2) by auto\n  then have \"d * (c * x - b) = d * (a * x)\" by simp\n  thus ?thesis by simp\nqed", "origin": "manipulate_division_complex", "update_count": 0}, "cancel_div_advanced": {"skill_name": "cancel_div_advanced", "marker": "lemma cancel_div_advanced:\n  fixes x a b c d :: \"'a::field\"\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (metis add.commute add_cancel_right_left add_cancel_right_right add_divide_eq_if_simps(2) add_right_imp_eq add_scale_eq_noteq assms(1) comm_monoid_add_class.add_0 crossproduct_eq divide_cancel_left divide_cancel_right divide_divide_eq_right divide_divide_times_eq divide_eq_0_iff eq_divide_eq frac_eq_eq group_cancel.add1 group_cancel.add2 mult.assoc mult.commute mult.left_commute mult_delta_left mult_delta_right mult_left_cancel mult_right_cancel times_divide_eq_left)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancel_div_advanced:\n  fixes x a b c d :: \"'a::field\"\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (metis add.commute add_cancel_right_left add_cancel_right_right add_divide_eq_if_simps(2) add_right_imp_eq add_scale_eq_noteq assms(1) comm_monoid_add_class.add_0 crossproduct_eq divide_cancel_left divide_cancel_right divide_divide_eq_right divide_divide_times_eq divide_eq_0_iff eq_divide_eq frac_eq_eq group_cancel.add1 group_cancel.add2 mult.assoc mult.commute mult.left_commute mult_delta_left mult_delta_right mult_left_cancel mult_right_cancel times_divide_eq_left)\n  then show ?thesis by simp\nqed", "origin": "manipulate_division_complex", "update_count": 0}, "manipulate_division_for_complex": {"skill_name": "manipulate_division_for_complex", "marker": "lemma manipulate_division_for_complex:\n  fixes x a b c d :: complex\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (metis add.commute add_cancel_left_right add_divide_eq_if_simps(2) add_right_imp_eq assms(1) crossproduct_noteq divide_cancel_right divide_eq_eq mult.commute mult.left_commute mult_delta_left mult_delta_right mult_right_cancel nonzero_mult_div_cancel_left ring_class.ring_distribs(1) times_divide_eq_left)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma manipulate_division_for_complex:\n  fixes x a b c d :: complex\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (metis add.commute add_cancel_left_right add_divide_eq_if_simps(2) add_right_imp_eq assms(1) crossproduct_noteq divide_cancel_right divide_eq_eq mult.commute mult.left_commute mult_delta_left mult_delta_right mult_right_cancel nonzero_mult_div_cancel_left ring_class.ring_distribs(1) times_divide_eq_left)\n  thus ?thesis by simp\nqed", "origin": "manipulate_division_complex", "update_count": 0}, "cancel_div_for_complex": {"skill_name": "cancel_div_for_complex", "marker": "lemma cancel_div_for_complex:\n  fixes x a b c :: complex\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" by (metis ab_semigroup_mult_class.mult_ac(1) add.commute add_0_iff add_cancel_left_left add_divide_eq_if_simps(2) add_scale_eq_noteq assms(1) assms(2) crossproduct_eq divide_cancel_left divide_cancel_right divide_divide_eq_right divide_divide_times_eq divide_eq_0_iff divide_eq_eq frac_eq_eq mult.commute mult.left_commute mult_delta_left mult_delta_right mult_left_cancel mult_right_cancel nonzero_mult_divide_mult_cancel_right times_divide_eq_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancel_div_for_complex:\n  fixes x a b c :: complex\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" by (metis ab_semigroup_mult_class.mult_ac(1) add.commute add_0_iff add_cancel_left_left add_divide_eq_if_simps(2) add_scale_eq_noteq assms(1) assms(2) crossproduct_eq divide_cancel_left divide_cancel_right divide_divide_eq_right divide_divide_times_eq divide_eq_0_iff divide_eq_eq frac_eq_eq mult.commute mult.left_commute mult_delta_left mult_delta_right mult_left_cancel mult_right_cancel nonzero_mult_divide_mult_cancel_right times_divide_eq_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "origin": "manipulate_division_complex", "update_count": 0}, "multi_distrib_parametrized_extended": {"skill_name": "multi_distrib_parametrized_extended", "marker": "lemma multi_distrib_parametrized_extended:\n  fixes x y z w a b c d :: \"'a :: comm_ring\"\n  shows \"(x + y + a + b) * (z + w + c + d) = x * z + y * z + a * z + b * z + x * w + y * w + a * w + b * w + x * c + y * c + a * c + b * c + x * d + y * d + a * d + b * d\"\nproof -\n  have \"(x + y + a + b) * (z + w + c + d) = (x + y) * (z + w + c + d) + a * (z + w + c + d) + b * (z + w + c + d)\"\n    by (auto simp: field_simps)\n  also have \"... = (x + y) * (z + w) + (x + y) * c + (x + y) * d + a * (z + w) + a * c + a * d + b * (z + w) + b * c + b * d\"\n    by (simp add: distrib_left)\n  also have \"... = (x * z + y * z + x * w + y * w) + (x + y) * c + (x + y) * d + (a * z + b * z + a * w + b * w) + (a * c + a * d) + (b * c + b * d)\"\n    by (auto simp: field_simps)\n  also have \"... = x * z + y * z + a * z + b * z + x * w + y * w + a * w + b * w + (x + y) * c + (x + y) * d + a * c + b * c + a * d + b * d\"\n    by (simp add: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_parametrized_extended:\n  fixes x y z w a b c d :: \"'a :: comm_ring\"\n  shows \"(x + y + a + b) * (z + w + c + d) = x * z + y * z + a * z + b * z + x * w + y * w + a * w + b * w + x * c + y * c + a * c + b * c + x * d + y * d + a * d + b * d\"\nproof -\n  have \"(x + y + a + b) * (z + w + c + d) = (x + y) * (z + w + c + d) + a * (z + w + c + d) + b * (z + w + c + d)\"\n    by (auto simp: field_simps)\n  also have \"... = (x + y) * (z + w) + (x + y) * c + (x + y) * d + a * (z + w) + a * c + a * d + b * (z + w) + b * c + b * d\"\n    by (simp add: distrib_left)\n  also have \"... = (x * z + y * z + x * w + y * w) + (x + y) * c + (x + y) * d + (a * z + b * z + a * w + b * w) + (a * c + a * d) + (b * c + b * d)\"\n    by (auto simp: field_simps)\n  also have \"... = x * z + y * z + a * z + b * z + x * w + y * w + a * w + b * w + (x + y) * c + (x + y) * d + a * c + b * c + a * d + b * d\"\n    by (simp add: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_parametrizedV2", "update_count": 0}, "multi_distrib_generalV2": {"skill_name": "multi_distrib_generalV2", "marker": "lemma multi_distrib_general:\n  fixes x1 x2 y1 y2 :: \"'a :: comm_ring\"\n  shows \"(x1 + x2) * (y1 + y2) = x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2\"\nproof -\n  have \"(x1 + x2) * (y1 + y2) = (x1 + x2) * y1 + (x1 + x2) * y2\" by (simp add: distrib_left)\n  then show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_general:\n  fixes x1 x2 y1 y2 :: \"'a :: comm_ring\"\n  shows \"(x1 + x2) * (y1 + y2) = x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2\"\nproof -\n  have \"(x1 + x2) * (y1 + y2) = (x1 + x2) * y1 + (x1 + x2) * y2\" by (simp add: distrib_left)\n  then show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_parametrizedV2", "update_count": 0}, "generalized_linear_function_properties": {"skill_name": "generalized_linear_function_properties", "marker": "lemma generalized_linear_function_properties:\n  fixes m n b x1 x2 y1 y2 :: real\n  assumes \"\\<forall>x y. f x y = m * x + n * y + b\"\n  shows \"f x1 y1 - f x2 y2 = m * (x1 - x2) + n * (y1 - y2)\"\nproof -\n  have \"f x1 y1 - f x2 y2 = (m * x1 + n * y1 + b) - (m * x2 + n * y2 + b)\"\n    using assms by simp\n  also have \"... = m * (x1 - x2) + n * (y1 - y2)\" by (simp add: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma generalized_linear_function_properties:\n  fixes m n b x1 x2 y1 y2 :: real\n  assumes \"\\<forall>x y. f x y = m * x + n * y + b\"\n  shows \"f x1 y1 - f x2 y2 = m * (x1 - x2) + n * (y1 - y2)\"\nproof -\n  have \"f x1 y1 - f x2 y2 = (m * x1 + n * y1 + b) - (m * x2 + n * y2 + b)\"\n    using assms by simp\n  also have \"... = m * (x1 - x2) + n * (y1 - y2)\" by (simp add: field_simps)\n  finally show ?thesis .\nqed", "origin": "manipulate_division_complex", "update_count": 0}, "complex_division_manipulation": {"skill_name": "complex_division_manipulation", "marker": "lemma complex_division_manipulation:\n  fixes x a b c d :: complex\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (metis add.commute add_cancel_left_right add_divide_eq_if_simps(2) add_scale_eq_noteq assms(1) crossproduct_noteq distrib_left divide_cancel_right divide_eq_eq mult.commute mult.left_commute mult_delta_left mult_delta_right mult_left_cancel nonzero_mult_div_cancel_left times_divide_eq_left)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma complex_division_manipulation:\n  fixes x a b c d :: complex\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using assms(2) by (metis add.commute add_cancel_left_right add_divide_eq_if_simps(2) add_scale_eq_noteq assms(1) crossproduct_noteq distrib_left divide_cancel_right divide_eq_eq mult.commute mult.left_commute mult_delta_left mult_delta_right mult_left_cancel nonzero_mult_div_cancel_left times_divide_eq_left)\n  thus ?thesis by simp\nqed", "origin": "manipulate_division_complex", "update_count": 0}, "manipulate_multiple_variables": {"skill_name": "manipulate_multiple_variables", "marker": "lemma manipulate_multiple_variables:\n  fixes x1 x2 a1 a2 b1 b2 c1 c2 :: \"'a::field\"\n  assumes \"x1 \\<noteq> 0\" \"x2 \\<noteq> 0\" \"a1 + b1 / x1 = c1\" \"a2 + b2 / x2 = c2\"\n  shows \"c1 * x1 - b1 = a1 * x1\" and \"c2 * x2 - b2 = a2 * x2\"\nproof -\n  have \"c1 * x1 = a1 * x1 + b1\" using assms(3) by (metis add.commute add_cancel_left_left add_cancel_right_left add_cancel_right_right add_divide_eq_if_simps(2) add_eq_0_iff add_num_frac add_scale_eq_noteq assms(1) crossproduct_eq divide_cancel_right divide_divide_eq_right divide_eq_0_iff divide_eq_1_iff divide_eq_eq group_cancel.add2 mult.commute mult.left_commute mult_cancel_right1 mult_delta_left mult_delta_right neg_eq_iff_add_eq_0 one_eq_divide_iff times_divide_eq_left times_divide_eq_right)\n  then show \"c1 * x1 - b1 = a1 * x1\" by simp\n  have \"c2 * x2 = a2 * x2 + b2\" using assms(4) by (metis ab_group_add_class.ab_diff_conv_add_uminus add.commute add_cancel_right_left add_cancel_right_right add_divide_eq_if_simps(2) add_frac_eq add_scale_eq_noteq assms(2) crossproduct_eq diff_0 diff_divide_distrib diff_eq_diff_eq diff_minus_eq_add diff_zero div_by_1 divide_cancel_left divide_cancel_right divide_eq_0_iff divide_eq_1_iff divide_eq_minus_1_iff eq_divide_eq eq_iff_diff_eq_0 frac_eq_eq group_cancel.sub1 left_diff_distrib' minus_diff_eq minus_divide_right mult.commute mult.left_commute mult_cancel_left2 mult_cancel_right1 mult_cancel_right2 mult_delta_left mult_delta_right mult_minus1_right mult_minus_right right_inverse_eq square_eq_1_iff times_divide_times_eq uminus_add_conv_diff zero_neq_one)\n  thus \"c2 * x2 - b2 = a2 * x2\" by simp\nqed", "description": "-", "full_code": "lemma manipulate_multiple_variables:\n  fixes x1 x2 a1 a2 b1 b2 c1 c2 :: \"'a::field\"\n  assumes \"x1 \\<noteq> 0\" \"x2 \\<noteq> 0\" \"a1 + b1 / x1 = c1\" \"a2 + b2 / x2 = c2\"\n  shows \"c1 * x1 - b1 = a1 * x1\" and \"c2 * x2 - b2 = a2 * x2\"\nproof -\n  have \"c1 * x1 = a1 * x1 + b1\" using assms(3) by (metis add.commute add_cancel_left_left add_cancel_right_left add_cancel_right_right add_divide_eq_if_simps(2) add_eq_0_iff add_num_frac add_scale_eq_noteq assms(1) crossproduct_eq divide_cancel_right divide_divide_eq_right divide_eq_0_iff divide_eq_1_iff divide_eq_eq group_cancel.add2 mult.commute mult.left_commute mult_cancel_right1 mult_delta_left mult_delta_right neg_eq_iff_add_eq_0 one_eq_divide_iff times_divide_eq_left times_divide_eq_right)\n  then show \"c1 * x1 - b1 = a1 * x1\" by simp\n  have \"c2 * x2 = a2 * x2 + b2\" using assms(4) by (metis ab_group_add_class.ab_diff_conv_add_uminus add.commute add_cancel_right_left add_cancel_right_right add_divide_eq_if_simps(2) add_frac_eq add_scale_eq_noteq assms(2) crossproduct_eq diff_0 diff_divide_distrib diff_eq_diff_eq diff_minus_eq_add diff_zero div_by_1 divide_cancel_left divide_cancel_right divide_eq_0_iff divide_eq_1_iff divide_eq_minus_1_iff eq_divide_eq eq_iff_diff_eq_0 frac_eq_eq group_cancel.sub1 left_diff_distrib' minus_diff_eq minus_divide_right mult.commute mult.left_commute mult_cancel_left2 mult_cancel_right1 mult_cancel_right2 mult_delta_left mult_delta_right mult_minus1_right mult_minus_right right_inverse_eq square_eq_1_iff times_divide_times_eq uminus_add_conv_diff zero_neq_one)\n  thus \"c2 * x2 - b2 = a2 * x2\" by simp\nqed", "origin": "manipulate_division_complex", "update_count": 0}, "multi_distrib_general_parametrized": {"skill_name": "multi_distrib_general_parametrized", "marker": "lemma multi_distrib_general_parametrized:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  assumes \"x = a + b\" \"y = c + d\" \"u = e + f\" \"v = g + h\"\n  shows \"x * y + u * v = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"x * y = (a + b) * (c + d)\" using assms by simp\n  then have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"u * v = (e + f) * (g + h)\" using assms by simp\n  then have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by (metis \\<open>u * v = (e + f) * (g + h)\\<close> \\<open>x * y = (a + b) * (c + d)\\<close>)\nqed", "description": "-", "full_code": "lemma multi_distrib_general_parametrized:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  assumes \"x = a + b\" \"y = c + d\" \"u = e + f\" \"v = g + h\"\n  shows \"x * y + u * v = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"x * y = (a + b) * (c + d)\" using assms by simp\n  then have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"u * v = (e + f) * (g + h)\" using assms by simp\n  then have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by (metis \\<open>u * v = (e + f) * (g + h)\\<close> \\<open>x * y = (a + b) * (c + d)\\<close>)\nqed", "origin": "multi_distrib_with_params", "update_count": 0}, "distributive_property_general": {"skill_name": "distributive_property_general", "marker": "lemma distributive_property_general:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  assumes \"x + y = a\" \"u + v = e\"\n  shows \"(x + y) * (c + d) + (u + v) * (g + h) = (x * c + y * c + x * d + y * d) + (u * g + v * g + u * h + v * h)\"\nproof -\n  have \"(x + y) * (c + d) = x * c + y * c + x * d + y * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(u + v) * (g + h) = u * g + v * g + u * h + v * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distributive_property_general:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  assumes \"x + y = a\" \"u + v = e\"\n  shows \"(x + y) * (c + d) + (u + v) * (g + h) = (x * c + y * c + x * d + y * d) + (u * g + v * g + u * h + v * h)\"\nproof -\n  have \"(x + y) * (c + d) = x * c + y * c + x * d + y * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(u + v) * (g + h) = u * g + v * g + u * h + v * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "origin": "multi_distrib_with_params", "update_count": 0}, "multi_distrib_with_paramsV2": {"skill_name": "multi_distrib_with_paramsV2", "marker": "lemma multi_distrib_with_params:\n  fixes a b c d e f g h x y u v :: \"'a :: comm_ring\"\n  shows \"(x + y) * (c + d) + (u + v) * (g + h) = (x * c + y * c + x * d + y * d) + (u * g + v * g + u * h + v * h)\"\n  using distributive_property_general by blast", "description": "-", "full_code": "lemma distributive_property_general:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  assumes \"x + y = a\" \"u + v = e\"\n  shows \"(x + y) * (c + d) + (u + v) * (g + h) = (x * c + y * c + x * d + y * d) + (u * g + v * g + u * h + v * h)\"\nproof -\n  have \"(x + y) * (c + d) = x * c + y * c + x * d + y * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(u + v) * (g + h) = u * g + v * g + u * h + v * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed\n\nlemma multi_distrib_with_params:\n  fixes a b c d e f g h x y u v :: \"'a :: comm_ring\"\n  shows \"(x + y) * (c + d) + (u + v) * (g + h) = (x * c + y * c + x * d + y * d) + (u * g + v * g + u * h + v * h)\"\n  using distributive_property_general by blast", "origin": "multi_distrib_with_params", "update_count": 0}, "conditions_on_a_and_n": {"skill_name": "conditions_on_a_and_n", "marker": "lemma conditions_on_a_and_n:\n  fixes a :: nat\n  fixes n :: nat\n  assumes \"b > 0\"\n  assumes \"b * n \\<le> c\" \n  shows \"c - b * n \\<ge> 0\"\nproof -\n  have \"c - b * n = c - (b * n)\" by simp\n  also have \"... = c - c + (c - b * n)\" using assms by (simp add: le_diff_eq)\n  finally have \"c - b * n \\<ge> 0\" by (simp add: le_zero_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma conditions_on_a_and_n:\n  fixes a :: nat\n  fixes n :: nat\n  assumes \"b > 0\"\n  assumes \"b * n \\<le> c\" \n  shows \"c - b * n \\<ge> 0\"\nproof -\n  have \"c - b * n = c - (b * n)\" by simp\n  also have \"... = c - c + (c - b * n)\" using assms by (simp add: le_diff_eq)\n  finally have \"c - b * n \\<ge> 0\" by (simp add: le_zero_eq)\n  thus ?thesis by simp\nqed", "origin": "conditions_on_nV2", "update_count": 0}, "multi_distrib_nat": {"skill_name": "multi_distrib_nat", "marker": "lemma multi_distrib_nat:\n  fixes a b c d :: nat\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  using distributive_property by (auto simp: field_simps)", "description": "-", "full_code": "lemma distributive_property:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"((a + b) * (c + d)) = (a * c + b * c + a * d + b * d)\" by (simp add: distrib_left distrib_right)\n  thus ?thesis by simp\nqed\n\nlemma multi_distrib_nat:\n  fixes a b c d :: nat\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  using distributive_property by (auto simp: field_simps)", "origin": "multi_distrib_complex_ext", "update_count": 0}, "distribution_property": {"skill_name": "distribution_property", "marker": "lemma distribution_property:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\"\nproof -\n  have \"((a + b) * (c + d)) = (a * c + b * c + a * d + b * d)\" by (simp add: distrib_left distrib_right)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_property:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\"\nproof -\n  have \"((a + b) * (c + d)) = (a * c + b * c + a * d + b * d)\" by (simp add: distrib_left distrib_right)\n  thus ?thesis by simp\nqed", "origin": "multi_distrib_complex_ext", "update_count": 0}, "add_inequality": {"skill_name": "add_inequality", "marker": "lemma add_inequality:\n  fixes a b c :: real\n  assumes \"a < b\"\n  shows \"a + c < b + c\"\nproof -\n  have \"a + c < b + c\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma add_inequality:\n  fixes a b c :: real\n  assumes \"a < b\"\n  shows \"a + c < b + c\"\nproof -\n  have \"a + c < b + c\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "multi_distrib_complex_ext", "update_count": 0}, "multi_distrib_complex_general": {"skill_name": "multi_distrib_complex_general", "marker": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a + b + e + f) * (c + d)\" by (auto simp: field_simps)\n  also have \"... = (a + e) * (c + d) + (b + f) * (c + d)\" by (auto simp: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a + b + e + f) * (c + d)\" by (auto simp: field_simps)\n  also have \"... = (a + e) * (c + d) + (b + f) * (c + d)\" by (auto simp: field_simps)\n  finally show ?thesis .\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib_generalV3": {"skill_name": "multi_distrib_generalV3", "marker": "lemma multi_distrib_general:\n  fixes a b c d e f :: \"'a::ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a * (c + d) + b * (c + d) + e * (c + d) + f * (c + d))\"\n    by (auto simp: field_simps)\n  also have \"... = ((a + e) + (b + f)) * (c + d)\" by (auto simp: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_general:\n  fixes a b c d e f :: \"'a::ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a * (c + d) + b * (c + d) + e * (c + d) + f * (c + d))\"\n    by (auto simp: field_simps)\n  also have \"... = ((a + e) + (b + f)) * (c + d)\" by (auto simp: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "floor_100r": {"skill_name": "floor_100r", "marker": "lemma floor_100r:\n  fixes r :: real\n  assumes \"7.43 \\<le> r \\<and> r < 8.09\"\n  shows \"743 \\<le> floor (100 * r) \\<and> floor (100 * r) < 809\"\nproof -\n  have \"100 * 7.43 \\<le> 100 * r\" using assms by simp\n  hence \"743 \\<le> 100 * r\" by (simp add: mult_left_mono)\n  have \"100 * r < 100 * 8.09\" using assms by simp\n  hence \"100 * r < 809\" by (simp add: mult_left_mono)\n  show ?thesis\n  proof -\n    have \"743 \\<le> floor (100 * r)\" \n      using `743 \\<le> 100 * r` by auto\n    moreover\n    have \"floor (100 * r) < 809\"\n      using `100 * r < 809` by auto\n    ultimately show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma floor_100r:\n  fixes r :: real\n  assumes \"7.43 \\<le> r \\<and> r < 8.09\"\n  shows \"743 \\<le> floor (100 * r) \\<and> floor (100 * r) < 809\"\nproof -\n  have \"100 * 7.43 \\<le> 100 * r\" using assms by simp\n  hence \"743 \\<le> 100 * r\" by (simp add: mult_left_mono)\n  have \"100 * r < 100 * 8.09\" using assms by simp\n  hence \"100 * r < 809\" by (simp add: mult_left_mono)\n  show ?thesis\n  proof -\n    have \"743 \\<le> floor (100 * r)\" \n      using `743 \\<le> 100 * r` by auto\n    moreover\n    have \"floor (100 * r) < 809\"\n      using `100 * r < 809` by auto\n    ultimately show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "manipulate_linear_equation": {"skill_name": "manipulate_linear_equation", "marker": "lemma manipulate_linear_equation:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x = a * x + b\"\nproof -\n  have \"c * x = a * x + b\" using assms by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma manipulate_linear_equation:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x = a * x + b\"\nproof -\n  have \"c * x = a * x + b\" using assms by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "origin": "manipulate_division_with_addition", "update_count": 0}, "multi_distrib_generalizedV2": {"skill_name": "multi_distrib_generalizedV2", "marker": "lemma multi_distrib_generalized:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a + b) * c + (a + b) * d\" by (simp add: distrib_left)\n  then show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_generalized:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a + b) * c + (a + b) * d\" by (simp add: distrib_left)\n  then show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_generalV2", "update_count": 0}, "multi_distrib_generalizedV3": {"skill_name": "multi_distrib_generalizedV3", "marker": "lemma multi_distrib_generalized:\n  fixes x1 x2 y1 y2 :: \"'a :: comm_ring\"\n  shows \"(x1 + x2) * (y1 + y2) = x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2\"\nby (auto simp: field_simps)", "description": "-", "full_code": "lemma multi_distrib_generalized:\n  fixes x1 x2 y1 y2 :: \"'a :: comm_ring\"\n  shows \"(x1 + x2) * (y1 + y2) = x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2\"\nby (auto simp: field_simps)", "origin": "multi_distrib_generalV2", "update_count": 0}, "multi_distrib_extended": {"skill_name": "multi_distrib_extended", "marker": "lemma multi_distrib_extended:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" \n    by (simp add: multi_distrib)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" \n    by (simp add: multi_distrib)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  show \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n    by (simp add: distrib_left distrib_right)\nqed\n\nlemma multi_distrib_extended:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" \n    by (simp add: multi_distrib)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" \n    by (simp add: multi_distrib)\n  ultimately show ?thesis by simp\nqed", "origin": "multi_distrib_general", "update_count": 0}, "multi_distrib": {"skill_name": "multi_distrib", "marker": "lemma multi_distrib:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  show \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n    by (simp add: distrib_left distrib_right)\nqed", "description": "-", "full_code": "lemma multi_distrib:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  show \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n    by (simp add: distrib_left distrib_right)\nqed", "origin": "multi_distrib_general", "update_count": 0}, "multi_distrib_with_vars": {"skill_name": "multi_distrib_with_vars", "marker": "lemma multi_distrib_with_vars:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  show ?thesis by (simp add: distrib_left distrib_right)\nqed", "description": "-", "full_code": "lemma multi_distrib_with_vars:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  show ?thesis by (simp add: distrib_left distrib_right)\nqed", "origin": "multi_distrib_general", "update_count": 0}, "multi_distrib_sum": {"skill_name": "multi_distrib_sum", "marker": "lemma multi_distrib_sum:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = \n         (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\" \n    by (simp add: multi_distrib_with_vars)\n  moreover have \"(e + f) * (g + h) = e * g + e * h + f * g + f * h\" \n    by (simp add: multi_distrib_with_vars)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_with_vars:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  show ?thesis by (simp add: distrib_left distrib_right)\nqed\n\nlemma multi_distrib_sum:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = \n         (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\" \n    by (simp add: multi_distrib_with_vars)\n  moreover have \"(e + f) * (g + h) = e * g + e * h + f * g + f * h\" \n    by (simp add: multi_distrib_with_vars)\n  ultimately show ?thesis by simp\nqed", "origin": "multi_distrib_general", "update_count": 0}, "log_natural_power_sum_property": {"skill_name": "log_natural_power_sum_property", "marker": "lemma log_natural_power_sum_property:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"m > 0\" \"k > 0\"\n  shows \"ln (a^n) + ln (a^m) + ln (a^k) = ln (a^(n + m + k))\"\nproof -\n  have \"ln (a^n) = n * ln a\" by (metis assms(1) ln_realpow)\n  have \"ln (a^m) = m * ln a\" by (metis assms(1) ln_realpow)\n  have \"ln (a^k) = k * ln a\" by (metis assms(1) ln_realpow)\n  then have \"ln (a^n) + ln (a^m) + ln (a^k) = n * ln a + m * ln a + k * ln a\" by (metis \\<open>ln (a ^ m) = real m * ln a\\<close> \\<open>ln (a ^ n) = real n * ln a\\<close>)\n  also have \"... = (n + m + k) * ln a\" by (simp add: algebra_simps)\n  finally show \"ln (a^n) + ln (a^m) + ln (a^k) = ln (a^(n + m + k))\" \n    using assms(1) by (metis ln_realpow)\nqed", "description": "-", "full_code": "lemma log_natural_power_sum_property:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"m > 0\" \"k > 0\"\n  shows \"ln (a^n) + ln (a^m) + ln (a^k) = ln (a^(n + m + k))\"\nproof -\n  have \"ln (a^n) = n * ln a\" by (metis assms(1) ln_realpow)\n  have \"ln (a^m) = m * ln a\" by (metis assms(1) ln_realpow)\n  have \"ln (a^k) = k * ln a\" by (metis assms(1) ln_realpow)\n  then have \"ln (a^n) + ln (a^m) + ln (a^k) = n * ln a + m * ln a + k * ln a\" by (metis \\<open>ln (a ^ m) = real m * ln a\\<close> \\<open>ln (a ^ n) = real n * ln a\\<close>)\n  also have \"... = (n + m + k) * ln a\" by (simp add: algebra_simps)\n  finally show \"ln (a^n) + ln (a^m) + ln (a^k) = ln (a^(n + m + k))\" \n    using assms(1) by (metis ln_realpow)\nqed", "origin": "log_natural_power_propertyV2", "update_count": 0}, "multi_distrib_complex_generalV2": {"skill_name": "multi_distrib_complex_generalV2", "marker": "lemma multi_distrib_complex_general:\n  fixes z1 z2 z3 z4 :: complex\n  assumes \"z1 = a + b\" and \"z2 = c + d\"\n  shows \"z1 * z2 = a * c + a * d + b * c + b * d\"\nproof -\n  obtain a b c d where \"z1 = a + b\" and \"z2 = c + d\" using assms by auto\n  have \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n    by (simp add: distrib_left distrib_right)\n  thus ?thesis by (metis add.commute add.left_commute assms(1) assms(2) combine_common_factor distrib_right group_cancel.add1 mult.commute)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_general:\n  fixes z1 z2 z3 z4 :: complex\n  assumes \"z1 = a + b\" and \"z2 = c + d\"\n  shows \"z1 * z2 = a * c + a * d + b * c + b * d\"\nproof -\n  obtain a b c d where \"z1 = a + b\" and \"z2 = c + d\" using assms by auto\n  have \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n    by (simp add: distrib_left distrib_right)\n  thus ?thesis by (metis add.commute add.left_commute assms(1) assms(2) combine_common_factor distrib_right group_cancel.add1 mult.commute)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib_complex_set": {"skill_name": "multi_distrib_complex_set", "marker": "lemma multi_distrib_complex_set:\n  fixes zs1 zs2 :: \"complex set\"\n  assumes \"finite zs1\" and \"finite zs2\"\n  shows \"sum (\\<lambda>z1. sum (\\<lambda>z2. z1 * z2) zs2) zs1 = sum (\\<lambda>z1. (sum (\\<lambda>z2. z1 * z2) zs2)) zs1\"\nproof -\n  have \"sum (\\<lambda>z1. sum (\\<lambda>z2. z1 * z2) zs2) zs1 = sum (\\<lambda>z1. sum (\\<lambda>z2. z1 * z2) zs2) zs1\"\n    using assms by (induction rule: finite_induct, auto)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_set:\n  fixes zs1 zs2 :: \"complex set\"\n  assumes \"finite zs1\" and \"finite zs2\"\n  shows \"sum (\\<lambda>z1. sum (\\<lambda>z2. z1 * z2) zs2) zs1 = sum (\\<lambda>z1. (sum (\\<lambda>z2. z1 * z2) zs2)) zs1\"\nproof -\n  have \"sum (\\<lambda>z1. sum (\\<lambda>z2. z1 * z2) zs2) zs1 = sum (\\<lambda>z1. sum (\\<lambda>z2. z1 * z2) zs2) zs1\"\n    using assms by (induction rule: finite_induct, auto)\n  thus ?thesis by auto\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "mod_add_property": {"skill_name": "mod_add_property", "marker": "lemma mod_add_property:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b mod n = b\"\n  shows \"(x + b) mod n = (a + b) mod n\"\nproof -\n  have \"x mod n + b mod n = a + b\" using assms(2) assms(3) by simp\n  then show ?thesis using assms(1) by (metis add.commute assms(2) assms(3) mod_add_cong mod_add_right_eq mod_mod_trivial)\nqed", "description": "-", "full_code": "lemma mod_add_property:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b mod n = b\"\n  shows \"(x + b) mod n = (a + b) mod n\"\nproof -\n  have \"x mod n + b mod n = a + b\" using assms(2) assms(3) by simp\n  then show ?thesis using assms(1) by (metis add.commute assms(2) assms(3) mod_add_cong mod_add_right_eq mod_mod_trivial)\nqed", "origin": "mod_add_power_extended", "update_count": 0}, "floor_sum_inequality": {"skill_name": "floor_sum_inequality", "marker": "lemma floor_sum_inequality:\n  fixes a b r :: real\n  assumes \"a + b = n\" \"7 * a + 8 * b = S\"\n  shows \"b = (S - 7 * n) / 1\"\nproof -\n  from assms(1) have \"b = n - a\" by auto\n  then have \"7 * a + 8 * (n - a) = S\" using assms(2) by (simp add: algebra_simps)\n  then have \"7 * a + 8 * n - 8 * a = S\" by simp\n  then have \"(7 - 8) * a + 8 * n = S\" by simp\n  then have \"-a + 8 * n = S\" by simp\n  then have \"a = 8 * n - S\" by (simp add: algebra_simps)\n  then have \"b = n - (8 * n - S)\" using `b = n - a` by simp\n  then have \"b = n - 8 * n + S\" by (simp add: algebra_simps)\n  then have \"b = (S - 7 * n)\" by simp\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma floor_sum_inequality:\n  fixes a b r :: real\n  assumes \"a + b = n\" \"7 * a + 8 * b = S\"\n  shows \"b = (S - 7 * n) / 1\"\nproof -\n  from assms(1) have \"b = n - a\" by auto\n  then have \"7 * a + 8 * (n - a) = S\" using assms(2) by (simp add: algebra_simps)\n  then have \"7 * a + 8 * n - 8 * a = S\" by simp\n  then have \"(7 - 8) * a + 8 * n = S\" by simp\n  then have \"-a + 8 * n = S\" by simp\n  then have \"a = 8 * n - S\" by (simp add: algebra_simps)\n  then have \"b = n - (8 * n - S)\" using `b = n - a` by simp\n  then have \"b = n - 8 * n + S\" by (simp add: algebra_simps)\n  then have \"b = (S - 7 * n)\" by simp\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "conditions_on_n_and_r": {"skill_name": "conditions_on_n_and_r", "marker": "lemma conditions_on_n_and_r:\n  fixes n r :: nat\n  assumes \"73 * n + r = 546\"\n  shows \"0 \\<le> r \\<and> 73 * n \\<le> 546\"\nproof -\n  have \"r = 546 - 73 * n\" using assms by simp\n  moreover have \"0 \\<le> r\" using assms by auto\n  ultimately show ?thesis by (metis assms le_add1)\nqed", "description": "-", "full_code": "lemma conditions_on_n_and_r:\n  fixes n r :: nat\n  assumes \"73 * n + r = 546\"\n  shows \"0 \\<le> r \\<and> 73 * n \\<le> 546\"\nproof -\n  have \"r = 546 - 73 * n\" using assms by simp\n  moreover have \"0 \\<le> r\" using assms by auto\n  ultimately show ?thesis by (metis assms le_add1)\nqed", "origin": "conditions_on_n", "update_count": 0}, "division_identity": {"skill_name": "division_identity", "marker": "lemma division_identity:\n  fixes x a b c d :: \"'a::field\"\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d \\<noteq> 0\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then show ?thesis by (simp add: assms(1) algebra_simps)\nqed", "description": "-", "full_code": "lemma division_identity:\n  fixes x a b c d :: \"'a::field\"\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d \\<noteq> 0\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then show ?thesis by (simp add: assms(1) algebra_simps)\nqed", "origin": "cancel_div_general_extended", "update_count": 0}, "linear_equation_rearrangement": {"skill_name": "linear_equation_rearrangement", "marker": "lemma linear_equation_rearrangement:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a = c - b / x\"\nproof -\n  have \"c - b / x = a\" using assms by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma linear_equation_rearrangement:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a = c - b / x\"\nproof -\n  have \"c - b / x = a\" using assms by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "origin": "manipulate_linear_equation", "update_count": 0}, "ordered_field_add": {"skill_name": "ordered_field_add", "marker": "lemma ordered_field_add:\n  fixes x y z :: real\n  assumes \"x < y\"\n  shows \"x + z < y + z\"\nproof -\n  from assms have \"x + z < y + z\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma ordered_field_add:\n  fixes x y z :: real\n  assumes \"x < y\"\n  shows \"x + z < y + z\"\nproof -\n  from assms have \"x + z < y + z\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "real_number_properties", "update_count": 0}, "solve_linear_inequality_with_bounds": {"skill_name": "solve_linear_inequality_with_bounds", "marker": "lemma solve_linear_inequality_with_bounds:\n  fixes a b c d :: real\n  assumes \"a > 0\" \"b < c\"\n  shows \"d < (c - b) / a \\<Longrightarrow> a * d + b < c\"\nproof -\n  assume \"d < (c - b) / a\"\n  then have \"a * d < c - b\" using assms by (simp add: field_simps)\n  thus \"a * d + b < c\" using assms by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma solve_linear_inequality_with_bounds:\n  fixes a b c d :: real\n  assumes \"a > 0\" \"b < c\"\n  shows \"d < (c - b) / a \\<Longrightarrow> a * d + b < c\"\nproof -\n  assume \"d < (c - b) / a\"\n  then have \"a * d < c - b\" using assms by (simp add: field_simps)\n  thus \"a * d + b < c\" using assms by (simp add: field_simps)\nqed", "origin": "solve_linear_inequality_generalized", "update_count": 0}, "multiplicative_inverse_property_extended": {"skill_name": "multiplicative_inverse_property_extended", "marker": "lemma multiplicative_inverse_property_extended:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b = 1 / a\"\n  shows \"a * b = 1\"\n  and \"b = 1 / a \\<Longrightarrow> a * b = 1\"\n  and \"b = 1 / a \\<Longrightarrow> a * (b * c) = c\"\n  and \"b = 1 / a \\<Longrightarrow> (a * b) * c = c\"\nproof -\n  have \"a * b = a * (1 / a)\" using assms(2) by simp\n  thus \"a * b = 1\" using assms(1) by auto\nnext\n  show \"b = 1 / a \\<Longrightarrow> a * b = 1\" using assms(2) by (metis assms(1) divide_self frac_eq_eq nonzero_divide_eq_eq zero_eq_1_divide_iff)\nnext\n  show \"b = 1 / a \\<Longrightarrow> a * (b * c) = c\" \n    using assms(2) by (metis assms(1) div_by_1 divide_divide_eq_left frac_eq_eq mult.commute mult.right_neutral mult_cancel_right1 mult_eq_0_iff nonzero_divide_eq_eq nonzero_divide_mult_cancel_right zero_neq_one)\nnext\n  show \"b = 1 / a \\<Longrightarrow> (a * b) * c = c\" \n    using assms(2) by (metis assms(1) comm_monoid_mult_class.mult_1 div_by_1 frac_eq_eq mult.commute mult.right_neutral mult_cancel_right2 nonzero_divide_eq_eq nonzero_mult_div_cancel_right zero_eq_1_divide_iff zero_neq_one)\nqed", "description": "-", "full_code": "lemma multiplicative_inverse_property_extended:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b = 1 / a\"\n  shows \"a * b = 1\"\n  and \"b = 1 / a \\<Longrightarrow> a * b = 1\"\n  and \"b = 1 / a \\<Longrightarrow> a * (b * c) = c\"\n  and \"b = 1 / a \\<Longrightarrow> (a * b) * c = c\"\nproof -\n  have \"a * b = a * (1 / a)\" using assms(2) by simp\n  thus \"a * b = 1\" using assms(1) by auto\nnext\n  show \"b = 1 / a \\<Longrightarrow> a * b = 1\" using assms(2) by (metis assms(1) divide_self frac_eq_eq nonzero_divide_eq_eq zero_eq_1_divide_iff)\nnext\n  show \"b = 1 / a \\<Longrightarrow> a * (b * c) = c\" \n    using assms(2) by (metis assms(1) div_by_1 divide_divide_eq_left frac_eq_eq mult.commute mult.right_neutral mult_cancel_right1 mult_eq_0_iff nonzero_divide_eq_eq nonzero_divide_mult_cancel_right zero_neq_one)\nnext\n  show \"b = 1 / a \\<Longrightarrow> (a * b) * c = c\" \n    using assms(2) by (metis assms(1) comm_monoid_mult_class.mult_1 div_by_1 frac_eq_eq mult.commute mult.right_neutral mult_cancel_right2 nonzero_divide_eq_eq nonzero_mult_div_cancel_right zero_eq_1_divide_iff zero_neq_one)\nqed", "origin": "multiplicative_inverse_property", "update_count": 0}, "floor_properties": {"skill_name": "floor_properties", "marker": "lemma floor_properties:\n  fixes x :: real\n  shows \"floor x + 1 > x\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  then have \"floor x + 1 > x\" \n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_properties:\n  fixes x :: real\n  shows \"floor x + 1 > x\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  then have \"floor x + 1 > x\" \n    by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "logarithm_inequality": {"skill_name": "logarithm_inequality", "marker": "lemma logarithm_inequality:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\" \"a < b\"\n  shows \"ln a < ln b\"\nproof -\n  have \"ln b - ln a = ln (b / a)\" by (metis assms(1) assms(2) ln_div)\n  also have \"... > 0\" using assms by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_inequality:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\" \"a < b\"\n  shows \"ln a < ln b\"\nproof -\n  have \"ln b - ln a = ln (b / a)\" by (metis assms(1) assms(2) ln_div)\n  also have \"... > 0\" using assms by auto\n  finally show ?thesis by simp\nqed", "origin": "log_natural_power_property_multiV2", "update_count": 0}, "inequality_manipulation": {"skill_name": "inequality_manipulation", "marker": "lemma inequality_manipulation:\n  fixes a b :: real\n  assumes \"a < b\"\n  shows \"a + c < b + c\"\nproof -\n  have \"a < b\" using assms by simp\n  then have \"a + c < b + c\" \n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b :: real\n  assumes \"a < b\"\n  shows \"a + c < b + c\"\nproof -\n  have \"a < b\" using assms by simp\n  then have \"a + c < b + c\" \n    by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "inequality_manipulationV2": {"skill_name": "inequality_manipulationV2", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\"\n  shows \"a + c < b + c\"\nproof -\n  have \"b - a > 0\" using assms by (simp add: field_simps)\n  hence \"b + c - (a + c) > 0\" by (simp)\n  thus \"a + c < b + c\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\"\n  shows \"a + c < b + c\"\nproof -\n  have \"b - a > 0\" using assms by (simp add: field_simps)\n  hence \"b + c - (a + c) > 0\" by (simp)\n  thus \"a + c < b + c\" by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "valid_n_values": {"skill_name": "valid_n_values", "marker": "lemma valid_n_values:\n  fixes n :: nat\n  assumes \"73 * n + x = 546\"\n  shows \"x \\<ge> 0 \\<Longrightarrow> n \\<le> 7\"\nproof -\n  assume \"x \\<ge> 0\"\n  from assms have \"x = 546 - 73 * n\" by simp\n  then have \"546 - 73 * n \\<ge> 0\" using `x \\<ge> 0` by simp\n  thus \"n \\<le> 7\" \n  proof -\n    have \"546 - x = 73 * n\" using assms by simp\n    have \"73 * n \\<le> 546\" by (metis assms le_add1)\n    from `73 * n \\<le> 546` show \"n \\<le> 7\" by auto\n  qed\nqed", "description": "-", "full_code": "lemma valid_n_values:\n  fixes n :: nat\n  assumes \"73 * n + x = 546\"\n  shows \"x \\<ge> 0 \\<Longrightarrow> n \\<le> 7\"\nproof -\n  assume \"x \\<ge> 0\"\n  from assms have \"x = 546 - 73 * n\" by simp\n  then have \"546 - 73 * n \\<ge> 0\" using `x \\<ge> 0` by simp\n  thus \"n \\<le> 7\" \n  proof -\n    have \"546 - x = 73 * n\" using assms by simp\n    have \"73 * n \\<le> 546\" by (metis assms le_add1)\n    from `73 * n \\<le> 546` show \"n \\<le> 7\" by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "count_terms_in_sequence": {"skill_name": "count_terms_in_sequence", "marker": "lemma count_terms_in_sequence:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"b - a + 1 = (b - a + 1)\"\nproof -\n  have \"b - a + 1 = b - a + 1\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms_in_sequence:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"b - a + 1 = (b - a + 1)\"\nproof -\n  have \"b - a + 1 = b - a + 1\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_leq_next_integer": {"skill_name": "floor_leq_next_integer", "marker": "lemma floor_leq_next_integer:\n  fixes x :: real\n  shows \"floor x + 1 > x\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_leq_next_integer:\n  fixes x :: real\n  shows \"floor x + 1 > x\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  then show ?thesis by auto\nqed", "origin": "floor_properties", "update_count": 0}, "floor_upper_bound": {"skill_name": "floor_upper_bound", "marker": "lemma floor_upper_bound:\n  fixes x :: real\n  shows \"floor x < x + 1\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  then show ?thesis using add_le_mono by arith\nqed", "description": "-", "full_code": "lemma floor_upper_bound:\n  fixes x :: real\n  shows \"floor x < x + 1\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  then show ?thesis using add_le_mono by arith\nqed", "origin": "floor_properties", "update_count": 0}, "multi_distrib_nested": {"skill_name": "multi_distrib_nested", "marker": "lemma multi_distrib_nested:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"((a + b) * (c + d)) * ((e + f) * (g + h)) = (a * c + b * c + a * d + b * d) * (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"((a + b) * (c + d)) * ((e + f) * (g + h)) = (a * c + b * c + a * d + b * d) * (e * g + f * g + e * h + f * h)\"\n    using multi_distrib_general by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_general:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed\n\nlemma multi_distrib_nested:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"((a + b) * (c + d)) * ((e + f) * (g + h)) = (a * c + b * c + a * d + b * d) * (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"((a + b) * (c + d)) * ((e + f) * (g + h)) = (a * c + b * c + a * d + b * d) * (e * g + f * g + e * h + f * h)\"\n    using multi_distrib_general by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "origin": "multi_distrib_with_params", "update_count": 0}, "multi_distrib_with_scalars": {"skill_name": "multi_distrib_with_scalars", "marker": "lemma multi_distrib_with_scalars:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"k * ((a + b) * (c + d) + (e + f) * (g + h)) = k * (a * c + b * c + a * d + b * d) + k * (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately have \"((a + b) * (c + d) + (e + f) * (g + h)) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\" by simp\n  thus ?thesis by (simp add: distrib_left)\nqed", "description": "-", "full_code": "lemma multi_distrib_with_scalars:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"k * ((a + b) * (c + d) + (e + f) * (g + h)) = k * (a * c + b * c + a * d + b * d) + k * (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately have \"((a + b) * (c + d) + (e + f) * (g + h)) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\" by simp\n  thus ?thesis by (simp add: distrib_left)\nqed", "origin": "multi_distrib_with_params", "update_count": 0}, "multiplicative_inverse_extended": {"skill_name": "multiplicative_inverse_extended", "marker": "lemma multiplicative_inverse_extended:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a * (1 / a)) * (b * (1 / b)) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp)\n  have \"b * (1 / b) = 1\" using assms(2) by (simp)\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close> comm_monoid_mult_class.mult_1)\nqed", "description": "-", "full_code": "lemma multiplicative_inverse_extended:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a * (1 / a)) * (b * (1 / b)) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp)\n  have \"b * (1 / b) = 1\" using assms(2) by (simp)\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close> comm_monoid_mult_class.mult_1)\nqed", "origin": "multiplicative_inverse", "update_count": 0}, "multiplicative_inverse_product": {"skill_name": "multiplicative_inverse_product", "marker": "lemma multiplicative_inverse_product:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1 / (a * b) = (1 / a) * (1 / b)\"\nproof -\n  have \"1 / (a * b) = (1 / a) * (1 / b)\" using assms by auto\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma multiplicative_inverse_product:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1 / (a * b) = (1 / a) * (1 / b)\"\nproof -\n  have \"1 / (a * b) = (1 / a) * (1 / b)\" using assms by auto\n  thus ?thesis .\nqed", "origin": "multiplicative_inverse", "update_count": 0}, "multiplicative_inverse_sum": {"skill_name": "multiplicative_inverse_sum", "marker": "lemma multiplicative_inverse_sum:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1 / (a + b) = (1 / a) * (1 / (1 + b / a))\"\nproof -\n  have \"1 / (a + b) = 1 / (a * (1 + b / a))\" using assms by sos\n  also have \"... = (1 / a) * (1 / (1 + b / a))\" by (simp add: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma multiplicative_inverse_sum:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1 / (a + b) = (1 / a) * (1 / (1 + b / a))\"\nproof -\n  have \"1 / (a + b) = 1 / (a * (1 + b / a))\" using assms by sos\n  also have \"... = (1 / a) * (1 / (1 + b / a))\" by (simp add: field_simps)\n  finally show ?thesis .\nqed", "origin": "multiplicative_inverse", "update_count": 0}, "multiplicative_inverse_sumV2": {"skill_name": "multiplicative_inverse_sumV2", "marker": "lemma multiplicative_inverse_sum:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) + b * (1 / b) = 1 + 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp)\n  moreover have \"b * (1 / b) = 1\" using assms(2) by (simp)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multiplicative_inverse_sum:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) + b * (1 / b) = 1 + 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp)\n  moreover have \"b * (1 / b) = 1\" using assms(2) by (simp)\n  ultimately show ?thesis by simp\nqed", "origin": "multiplicative_inverse", "update_count": 0}, "distribution_with_parameters_n_dimensional": {"skill_name": "distribution_with_parameters_n_dimensional", "marker": "lemma distribution_with_parameters_n_dimensional:\n  fixes x y z :: \"'a :: comm_ring\" and A B :: \"'a set\"\n  assumes \"finite A\" and \"finite B\"\n  shows \"(\\<Sum>i\\<in>A. x + i) * (\\<Sum>j\\<in>B. z + j) = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. (x + i) * (z + j))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. x + i) * (\\<Sum>j\\<in>B. z + j) = (\\<Sum>i\\<in>A. (x + i) * (\\<Sum>j\\<in>B. z + j))\"\n    by (simp add: sum_distrib_right)\n  also have \"... = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. (x + i) * (z + j))\" by (metis sum_distrib_left)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_with_parameters_n_dimensional:\n  fixes x y z :: \"'a :: comm_ring\" and A B :: \"'a set\"\n  assumes \"finite A\" and \"finite B\"\n  shows \"(\\<Sum>i\\<in>A. x + i) * (\\<Sum>j\\<in>B. z + j) = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. (x + i) * (z + j))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. x + i) * (\\<Sum>j\\<in>B. z + j) = (\\<Sum>i\\<in>A. (x + i) * (\\<Sum>j\\<in>B. z + j))\"\n    by (simp add: sum_distrib_right)\n  also have \"... = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. (x + i) * (z + j))\" by (metis sum_distrib_left)\n  finally show ?thesis by simp\nqed", "origin": "distribution_with_parameters", "update_count": 0}, "distribution_with_parameters_n_dimensions": {"skill_name": "distribution_with_parameters_n_dimensions", "marker": "lemma distribution_with_parameters_n_dimensions:\n  fixes x y :: \"'a :: comm_ring\" and z :: \"'a :: comm_ring list\"\n  shows \"(x + y) * (sum_list z) = x * (sum_list z) + y * (sum_list z)\"\nproof -\n  have \"sum_list z = fold (+) z 0\" by (metis add.commute add.left_commute add_right_imp_eq fold_plus_sum_list_rev sum_list_rev verit_sum_simplify)\n  then show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma distribution_with_parameters_n_dimensions:\n  fixes x y :: \"'a :: comm_ring\" and z :: \"'a :: comm_ring list\"\n  shows \"(x + y) * (sum_list z) = x * (sum_list z) + y * (sum_list z)\"\nproof -\n  have \"sum_list z = fold (+) z 0\" by (metis add.commute add.left_commute add_right_imp_eq fold_plus_sum_list_rev sum_list_rev verit_sum_simplify)\n  then show ?thesis by (auto simp: field_simps)\nqed", "origin": "distribution_with_parameters", "update_count": 0}, "mod_add_propertyV2": {"skill_name": "mod_add_propertyV2", "marker": "lemma mod_add_property:\n  fixes x a b n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"(x + b) mod n = (a + b) mod n\"\nproof -\n  have \"(x + b) mod n = (x mod n + b) mod n\" \n    using assms(3) by (smt (verit) mod_add_left_eq)\n  also have \"... = (a + b) mod n\" \n    using assms(3) by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add_property:\n  fixes x a b n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"(x + b) mod n = (a + b) mod n\"\nproof -\n  have \"(x + b) mod n = (x mod n + b) mod n\" \n    using assms(3) by (smt (verit) mod_add_left_eq)\n  also have \"... = (a + b) mod n\" \n    using assms(3) by auto\n  finally show ?thesis by simp\nqed", "origin": "mod_add_power_generalV2", "update_count": 0}, "average_sum": {"skill_name": "average_sum", "marker": "lemma average_sum:\n  fixes s :: real\n  assumes \"n > 0\"\n  shows \"s / n = avg \\<Longrightarrow> s = n * avg\"\nproof -\n  assume \"s / n = avg\"\n  have \"s = n * avg\" \n  proof -\n    have \"n * avg = (n * avg) / 1\" by simp\n    hence \"s = n * avg\" using `s / n = avg` by (metis assms div_by_1 frac_eq_eq less_numeral_extra(3) mult.commute mult.right_neutral zero_neq_one)\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma average_sum:\n  fixes s :: real\n  assumes \"n > 0\"\n  shows \"s / n = avg \\<Longrightarrow> s = n * avg\"\nproof -\n  assume \"s / n = avg\"\n  have \"s = n * avg\" \n  proof -\n    have \"n * avg = (n * avg) / 1\" by simp\n    hence \"s = n * avg\" using `s / n = avg` by (metis assms div_by_1 frac_eq_eq less_numeral_extra(3) mult.commute mult.right_neutral zero_neq_one)\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_propertiesV3": {"skill_name": "floor_sum_propertiesV3", "marker": "lemma floor_sum_properties:\n  fixes r :: real and a b :: real\n  assumes \"a < b\"\n  shows \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1)\"\nproof -\n  have \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b)\"\n    by simp\n  have \"floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1) = \n        floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1)\"\n    by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_sum_properties:\n  fixes r :: real and a b :: real\n  assumes \"a < b\"\n  shows \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1)\"\nproof -\n  have \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b)\"\n    by simp\n  have \"floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1) = \n        floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1)\"\n    by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_propertiesV4": {"skill_name": "floor_sum_propertiesV4", "marker": "lemma floor_sum_properties:\n  fixes r :: real and a b :: real\n  assumes \"a < b\"\n  shows \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1)\"\nproof -\n  have \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1)\"\n  proof (cases \"r + a < floor (r + a) + 1\")\n    case True\n    then show ?thesis \n      by (simp add: True)  \n  next\n    case False\n    then show ?thesis \n      by (simp add: False) \n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_sum_properties:\n  fixes r :: real and a b :: real\n  assumes \"a < b\"\n  shows \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1)\"\nproof -\n  have \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1)\"\n  proof (cases \"r + a < floor (r + a) + 1\")\n    case True\n    then show ?thesis \n      by (simp add: True)  \n  next\n    case False\n    then show ?thesis \n      by (simp add: False) \n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_propertiesV5": {"skill_name": "floor_sum_propertiesV5", "marker": "lemma floor_sum_properties:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1)\"\nproof -\n  have \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b)\" \n    by simp\n  let ?f1 = \"floor (r + a)\"\n  let ?f2 = \"floor (r + b)\"\n  have \"\\<forall> x. x = floor (x) + (if x < floor (x) + 1 then 0 else 1)\" \n    for x::real\n    by auto\n  then show ?thesis \n    using `a < b` by auto\nqed", "description": "-", "full_code": "lemma floor_sum_properties:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b) + (if r + a < floor (r + a) + 1 then 0 else 1)\"\nproof -\n  have \"floor (r + a) + floor (r + b) = floor (r + a) + floor (r + b)\" \n    by simp\n  let ?f1 = \"floor (r + a)\"\n  let ?f2 = \"floor (r + b)\"\n  have \"\\<forall> x. x = floor (x) + (if x < floor (x) + 1 then 0 else 1)\" \n    for x::real\n    by auto\n  then show ?thesis \n    using `a < b` by auto\nqed", "origin": "do_request", "update_count": 0}, "multi_distrib_with_vars_extended": {"skill_name": "multi_distrib_with_vars_extended", "marker": "lemma multi_distrib_with_vars_extended:\n  fixes a b c d e f g h i j :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) + (i + j) * (k + l) = \n         (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h) + (i * k + j * k + i * l + j * l)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\" \n    by (simp add: multi_distrib_with_vars)\n  moreover have \"(e + f) * (g + h) = e * g + e * h + f * g + f * h\" \n    by (simp add: multi_distrib_with_vars)\n  moreover have \"(i + j) * (k + l) = i * k + i * l + j * k + j * l\"\n    by (simp add: multi_distrib_with_vars)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_with_vars:\n  fixes a b c d :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  show ?thesis by (simp add: distrib_left distrib_right)\nqed\n\nlemma multi_distrib_with_vars_extended:\n  fixes a b c d e f g h i j :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) + (i + j) * (k + l) = \n         (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h) + (i * k + j * k + i * l + j * l)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\" \n    by (simp add: multi_distrib_with_vars)\n  moreover have \"(e + f) * (g + h) = e * g + e * h + f * g + f * h\" \n    by (simp add: multi_distrib_with_vars)\n  moreover have \"(i + j) * (k + l) = i * k + i * l + j * k + j * l\"\n    by (simp add: multi_distrib_with_vars)\n  ultimately show ?thesis by simp\nqed", "origin": "multi_distrib_sum", "update_count": 0}, "multi_distrib_sum_with_three_terms": {"skill_name": "multi_distrib_sum_with_three_terms", "marker": "lemma multi_distrib_sum_with_three_terms:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b + c) * (d + e) + (f + g) * (h + e) = \n         (a * (d + e) + b * (d + e) + c * (d + e)) + (f * (h + e) + g * (h + e))\"\nproof -\n  have \"(a + b + c) * (d + e) = a * (d + e) + b * (d + e) + c * (d + e)\" \n    by (simp add: multi_distrib_with_three_terms)\n  moreover have \"(f + g) * (h + e) = f * (h + e) + g * (h + e)\" \n    by (auto simp: field_simps)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_with_vars:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  show ?thesis by (simp add: distrib_left distrib_right)\nqed\n\nlemma multi_distrib_sum:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = \n         (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\" \n    by (simp add: multi_distrib_with_vars)\n  moreover have \"(e + f) * (g + h) = e * g + e * h + f * g + f * h\" \n    by (simp add: multi_distrib_with_vars)\n  ultimately show ?thesis by simp\nqed\n\nlemma multi_distrib_with_three_terms:\n  fixes a b c d e f g :: \"'a :: comm_ring\"\n  shows \"(a + b + c) * (d + e) = a * (d + e) + b * (d + e) + c * (d + e)\"\nproof -\n  have \"(a + b + c) * (d + e) = (a + b) * (d + e) + c * (d + e)\" \n    by (auto simp: field_simps)\n  thus ?thesis by (auto simp: field_simps)\nqed\n\nlemma multi_distrib_sum_with_three_terms:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b + c) * (d + e) + (f + g) * (h + e) = \n         (a * (d + e) + b * (d + e) + c * (d + e)) + (f * (h + e) + g * (h + e))\"\nproof -\n  have \"(a + b + c) * (d + e) = a * (d + e) + b * (d + e) + c * (d + e)\" \n    by (simp add: multi_distrib_with_three_terms)\n  moreover have \"(f + g) * (h + e) = f * (h + e) + g * (h + e)\" \n    by (auto simp: field_simps)\n  ultimately show ?thesis by simp\nqed", "origin": "multi_distrib_sum", "update_count": 0}, "multi_distrib_with_three_terms": {"skill_name": "multi_distrib_with_three_terms", "marker": "lemma multi_distrib_with_three_terms:\n  fixes a b c d e f g :: \"'a :: comm_ring\"\n  shows \"(a + b + c) * (d + e) = a * (d + e) + b * (d + e) + c * (d + e)\"\nproof -\n  have \"(a + b + c) * (d + e) = (a + b) * (d + e) + c * (d + e)\" \n    by (auto simp: field_simps)\n  thus ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_with_three_terms:\n  fixes a b c d e f g :: \"'a :: comm_ring\"\n  shows \"(a + b + c) * (d + e) = a * (d + e) + b * (d + e) + c * (d + e)\"\nproof -\n  have \"(a + b + c) * (d + e) = (a + b) * (d + e) + c * (d + e)\" \n    by (auto simp: field_simps)\n  thus ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_sum", "update_count": 0}, "linear_equation_with_nonzero_x": {"skill_name": "linear_equation_with_nonzero_x", "marker": "lemma linear_equation_with_nonzero_x:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"c * x = a * x + b\"\n  shows \"a + b / x = c\"\nproof -\n  have \"c * x - b = a * x\" using assms(2) by simp\n  then have \"a = (c * x - b) / x\" using assms(1) by (simp add: field_simps)\n  thus ?thesis by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(2) nonzero_mult_div_cancel_right)\nqed", "description": "-", "full_code": "lemma linear_equation_with_nonzero_x:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"c * x = a * x + b\"\n  shows \"a + b / x = c\"\nproof -\n  have \"c * x - b = a * x\" using assms(2) by simp\n  then have \"a = (c * x - b) / x\" using assms(1) by (simp add: field_simps)\n  thus ?thesis by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(2) nonzero_mult_div_cancel_right)\nqed", "origin": "manipulate_linear_equation", "update_count": 0}, "add_inequality_n_dimensions": {"skill_name": "add_inequality_n_dimensions", "marker": "lemma add_inequality_n_dimensions:\n  fixes a b c :: \"real list\" and n :: nat\n  assumes \"length a = n\" \"length b = n\" \"length c = n\" \"(\\<forall>i < n. a ! i < b ! i)\"\n  shows \"(\\<forall>i < n. a ! i + c ! i < b ! i + c ! i)\"\nproof -\n  have \"\\<forall>i < n. a ! i + c ! i < b ! i + c ! i\"\n  proof (rule allI, rule impI)\n    fix i :: nat\n    assume \"i < n\"\n    then have \"a ! i < b ! i\" using assms(4) by simp\n    then show \"a ! i + c ! i < b ! i + c ! i\" by simp\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma add_inequality_n_dimensions:\n  fixes a b c :: \"real list\" and n :: nat\n  assumes \"length a = n\" \"length b = n\" \"length c = n\" \"(\\<forall>i < n. a ! i < b ! i)\"\n  shows \"(\\<forall>i < n. a ! i + c ! i < b ! i + c ! i)\"\nproof -\n  have \"\\<forall>i < n. a ! i + c ! i < b ! i + c ! i\"\n  proof (rule allI, rule impI)\n    fix i :: nat\n    assume \"i < n\"\n    then have \"a ! i < b ! i\" using assms(4) by simp\n    then show \"a ! i + c ! i < b ! i + c ! i\" by simp\n  qed\n  thus ?thesis by simp\nqed", "origin": "add_inequality", "update_count": 0}, "conditions_on_n_extended": {"skill_name": "conditions_on_n_extended", "marker": "lemma conditions_on_n_extended:\n  fixes n :: nat\n  assumes \"k > 0\" \"k * n \\<le> m\"\n  shows \"m - k * n \\<ge> 0\"\nproof -\n  have \"m - k * n \\<ge> m - m\" using assms by (simp add: le_diff_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma conditions_on_n_extended:\n  fixes n :: nat\n  assumes \"k > 0\" \"k * n \\<le> m\"\n  shows \"m - k * n \\<ge> 0\"\nproof -\n  have \"m - k * n \\<ge> m - m\" using assms by (simp add: le_diff_eq)\n  thus ?thesis by simp\nqed", "origin": "conditions_on_n", "update_count": 0}, "floor_integer_relation": {"skill_name": "floor_integer_relation", "marker": "lemma floor_integer_relation:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n <= r \\<and> r < n + 1\"\nproof -\n  have \"floor r \\<le> r\" using assms by simp\n  moreover have \"r < floor r + 1\" using assms by auto\n  ultimately show ?thesis by (metis add.commute add_strict_increasing assms floor_add_int floor_less_cancel floor_one le_floor_iff less_add_same_cancel2 less_numeral_extra(1) nle_le order_refl zero_less_one)\nqed", "description": "-", "full_code": "lemma floor_integer_relation:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n <= r \\<and> r < n + 1\"\nproof -\n  have \"floor r \\<le> r\" using assms by simp\n  moreover have \"r < floor r + 1\" using assms by auto\n  ultimately show ?thesis by (metis add.commute add_strict_increasing assms floor_add_int floor_less_cancel floor_one le_floor_iff less_add_same_cancel2 less_numeral_extra(1) nle_le order_refl zero_less_one)\nqed", "origin": "do_request", "update_count": 0}, "distribution_of_sum_generalized": {"skill_name": "distribution_of_sum_generalized", "marker": "lemma distribution_of_sum_generalized:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" using distrib_left distrib_right by (auto simp: field_simps)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" using distrib_left distrib_right by (auto simp: field_simps)\n  ultimately show ?thesis by (metis add.assoc add.commute)\nqed", "description": "-", "full_code": "lemma distribution_of_sum_generalized:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" using distrib_left distrib_right by (auto simp: field_simps)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" using distrib_left distrib_right by (auto simp: field_simps)\n  ultimately show ?thesis by (metis add.assoc add.commute)\nqed", "origin": "distribution_of_sumV2", "update_count": 0}, "distribution_of_sum_extended": {"skill_name": "distribution_of_sum_extended", "marker": "lemma distribution_of_sum_extended:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) * (a + b) = (a * c + b * c + a * d + b * d) + (e * g * a + e * g * b + e * h * a + e * h * b + f * g * a + f * g * b + f * h * a + f * h * b)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) * (a + b) = (e * g + e * h + f * g + f * h) * (a + b)\" \n    by (auto simp: field_simps)\n  moreover have \"... = (e * g * a + e * g * b + e * h * a + e * h * b + f * g * a + f * g * b + f * h * a + f * h * b)\" \n    by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_of_sum_extended:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) * (a + b) = (a * c + b * c + a * d + b * d) + (e * g * a + e * g * b + e * h * a + e * h * b + f * g * a + f * g * b + f * h * a + f * h * b)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) * (a + b) = (e * g + e * h + f * g + f * h) * (a + b)\" \n    by (auto simp: field_simps)\n  moreover have \"... = (e * g * a + e * g * b + e * h * a + e * h * b + f * g * a + f * g * b + f * h * a + f * h * b)\" \n    by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "origin": "distribution_of_sumV2", "update_count": 0}, "distribution_of_sum_expanded": {"skill_name": "distribution_of_sum_expanded", "marker": "lemma distribution_of_sum_expanded:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + e * h + f * g + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) = e * g + e * h + f * g + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_of_sum_expanded:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + e * h + f * g + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) = e * g + e * h + f * g + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "origin": "distribution_of_sumV2", "update_count": 0}, "distribution_of_sum_nested": {"skill_name": "distribution_of_sum_nested", "marker": "lemma distribution_of_sum_nested:\n  fixes a b c d e f g h i j :: \"'a :: comm_ring\"\n  shows \"(a + b) * ((c + d) * (e + f)) + (g + h) * (i + j) = (a * (c * e + c * f + d * e + d * f) + b * (c * e + c * f + d * e + d * f)) + (g * (i + j) + h * (i + j))\"\nproof -\n  have \"((c + d) * (e + f)) = (c * e + c * f + d * e + d * f)\" by (simp add: distrib_left distrib_right)\n  moreover have \"(g + h) * (i + j) = g * i + g * j + h * i + h * j\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma distribution_of_sum_nested:\n  fixes a b c d e f g h i j :: \"'a :: comm_ring\"\n  shows \"(a + b) * ((c + d) * (e + f)) + (g + h) * (i + j) = (a * (c * e + c * f + d * e + d * f) + b * (c * e + c * f + d * e + d * f)) + (g * (i + j) + h * (i + j))\"\nproof -\n  have \"((c + d) * (e + f)) = (c * e + c * f + d * e + d * f)\" by (simp add: distrib_left distrib_right)\n  moreover have \"(g + h) * (i + j) = g * i + g * j + h * i + h * j\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by (auto simp: field_simps)\nqed", "origin": "distribution_of_sumV2", "update_count": 0}, "conditions_on_nV3": {"skill_name": "conditions_on_nV3", "marker": "lemma conditions_on_n:\n  fixes n :: nat\n  assumes \"73 * n \\<le> 546\"\n  shows \"546 - 73 * n \\<ge> 0\"\nproof -\n  have \"546 - 73 * n = 546 - (73 * n)\" by simp\n  then have \"546 - 73 * n \\<ge> 546 - 546\" using assms by (simp add: le_diff_eq)\n  hence \"546 - 73 * n \\<ge> 0\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma conditions_on_n:\n  fixes n :: nat\n  assumes \"73 * n \\<le> 546\"\n  shows \"546 - 73 * n \\<ge> 0\"\nproof -\n  have \"546 - 73 * n = 546 - (73 * n)\" by simp\n  then have \"546 - 73 * n \\<ge> 546 - 546\" using assms by (simp add: le_diff_eq)\n  hence \"546 - 73 * n \\<ge> 0\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "distribution_of_sum_with_coefficients": {"skill_name": "distribution_of_sum_with_coefficients", "marker": "lemma distribution_of_sum_with_coefficients:\n  fixes a b c d e f g h k l :: \"'a :: comm_ring\"\n  shows \"(k * a + l * b) * (c + d) + (e + f) * (g + h) = \n         (k * a * c + l * b * c + k * a * d + l * b * d) + \n         (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(k * a + l * b) * (c + d) = k * a * c + l * b * c + k * a * d + l * b * d\" \n    using distrib_left distrib_right by (auto simp: field_simps)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" \n    using distrib_left distrib_right by (auto simp: field_simps)\n  ultimately show ?thesis \n    by (metis add.assoc add.commute)\nqed", "description": "-", "full_code": "lemma distribution_of_sum_with_coefficients:\n  fixes a b c d e f g h k l :: \"'a :: comm_ring\"\n  shows \"(k * a + l * b) * (c + d) + (e + f) * (g + h) = \n         (k * a * c + l * b * c + k * a * d + l * b * d) + \n         (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(k * a + l * b) * (c + d) = k * a * c + l * b * c + k * a * d + l * b * d\" \n    using distrib_left distrib_right by (auto simp: field_simps)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" \n    using distrib_left distrib_right by (auto simp: field_simps)\n  ultimately show ?thesis \n    by (metis add.assoc add.commute)\nqed", "origin": "distribution_of_sum_generalized", "update_count": 0}, "distribution_of_sum_parameterized": {"skill_name": "distribution_of_sum_parameterized", "marker": "lemma distribution_of_sum_parameterized:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  assumes \"m + n = a\" and \"p + q = b\"\n  shows \"(a * c + b * d) = (m * c + n * c + p * d + q * d)\"\nproof -\n  have \"a * c + b * d = (m + n) * c + (p + q) * d\" using assms by simp\n  also have \"... = m * c + n * c + p * d + q * d\" by (auto simp: field_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_of_sum_parameterized:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  assumes \"m + n = a\" and \"p + q = b\"\n  shows \"(a * c + b * d) = (m * c + n * c + p * d + q * d)\"\nproof -\n  have \"a * c + b * d = (m + n) * c + (p + q) * d\" using assms by simp\n  also have \"... = m * c + n * c + p * d + q * d\" by (auto simp: field_simps)\n  finally show ?thesis by simp\nqed", "origin": "distribution_of_sum_generalized", "update_count": 0}, "distribution_of_sum_expanded_generalized": {"skill_name": "distribution_of_sum_expanded_generalized", "marker": "lemma distribution_of_sum_expanded_generalized:\n  fixes x1 x2 y1 y2 z1 z2 :: \"'a :: comm_ring\"\n  shows \"(x1 + x2) * (y1 + y2) + (z1 + z2) * (y1 + y2) = (x1 * y1 + x2 * y1 + x1 * y2 + x2 * y2) + (z1 * y1 + z1 * y2 + z2 * y1 + z2 * y2)\"\nproof -\n  have \"(x1 + x2) * (y1 + y2) = x1 * y1 + x2 * y1 + x1 * y2 + x2 * y2\" by (simp add: distrib_left distrib_right)\n  moreover have \"(z1 + z2) * (y1 + y2) = z1 * y1 + z2 * y1 + z1 * y2 + z2 * y2\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_of_sum_expanded_generalized:\n  fixes x1 x2 y1 y2 z1 z2 :: \"'a :: comm_ring\"\n  shows \"(x1 + x2) * (y1 + y2) + (z1 + z2) * (y1 + y2) = (x1 * y1 + x2 * y1 + x1 * y2 + x2 * y2) + (z1 * y1 + z1 * y2 + z2 * y1 + z2 * y2)\"\nproof -\n  have \"(x1 + x2) * (y1 + y2) = x1 * y1 + x2 * y1 + x1 * y2 + x2 * y2\" by (simp add: distrib_left distrib_right)\n  moreover have \"(z1 + z2) * (y1 + y2) = z1 * y1 + z2 * y1 + z1 * y2 + z2 * y2\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "origin": "distribution_of_sum_expanded", "update_count": 0}, "distribution_of_sum_general": {"skill_name": "distribution_of_sum_general", "marker": "lemma distribution_of_sum_general:\n  fixes x y z :: \"'a :: comm_ring\"\n  assumes \"x + y = a\" and \"z = b\"\n  shows \"(x + y) * z = x * z + y * z\"\nproof -\n  have \"(x + y) * z = a * b\" using assms by simp\n  also have \"... = x * z + y * z\" by (metis assms(1) assms(2) mult.commute ring_class.ring_distribs(1))\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_of_sum_general:\n  fixes x y z :: \"'a :: comm_ring\"\n  assumes \"x + y = a\" and \"z = b\"\n  shows \"(x + y) * z = x * z + y * z\"\nproof -\n  have \"(x + y) * z = a * b\" using assms by simp\n  also have \"... = x * z + y * z\" by (metis assms(1) assms(2) mult.commute ring_class.ring_distribs(1))\n  finally show ?thesis by simp\nqed", "origin": "distribution_of_sum", "update_count": 0}, "distribution_of_sum_generalV2": {"skill_name": "distribution_of_sum_generalV2", "marker": "lemma distribution_of_sum_general:\n  fixes x y z :: \"'a :: comm_ring\"\n  assumes \"x + y = a\"\n  shows \"(a * z) = (x * z + y * z)\"\nproof -\n  have \"(x + y) * z = x * z + y * z\" \n    by (simp add: distrib_left distrib_right)\n  then show ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma distribution_of_sum_general:\n  fixes x y z :: \"'a :: comm_ring\"\n  assumes \"x + y = a\"\n  shows \"(a * z) = (x * z + y * z)\"\nproof -\n  have \"(x + y) * z = x * z + y * z\" \n    by (simp add: distrib_left distrib_right)\n  then show ?thesis using assms by simp\nqed", "origin": "distribution_of_sum", "update_count": 0}, "multi_distrib_with_variables": {"skill_name": "multi_distrib_with_variables", "marker": "lemma multi_distrib_with_variables:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  assumes \"a = x + y\" \"b = z + w\" \"c = u + v\" \"d = s + t\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (x + y + z + w) * (u + v + s + t) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = (x + y + z + w) * (u + v + s + t)\" using assms by (auto simp: field_simps)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_with_variables:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  assumes \"a = x + y\" \"b = z + w\" \"c = u + v\" \"d = s + t\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (x + y + z + w) * (u + v + s + t) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = (x + y + z + w) * (u + v + s + t)\" using assms by (auto simp: field_simps)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed", "origin": "multi_distrib_complex_ext_generalV2", "update_count": 0}, "multi_distrib_with_parameters": {"skill_name": "multi_distrib_with_parameters", "marker": "lemma multi_distrib_with_parameters:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  assumes \"x = a + b\" \"y = c + d\" \"u = e + f\" \"v = g + h\"\n  shows \"x * y + u * v = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"x * y = (a + b) * (c + d)\" using assms by simp\n  moreover have \"u * v = (e + f) * (g + h)\" using assms by simp\n  ultimately show ?thesis using multi_distrib_general by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_general:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  shows \"(a + b) * (c + d) + (e + f) * (g + h) = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\" by (simp add: distrib_left distrib_right)\n  moreover have \"(e + f) * (g + h) = e * g + f * g + e * h + f * h\" by (simp add: distrib_left distrib_right)\n  ultimately show ?thesis by simp\nqed\n\nlemma multi_distrib_with_parameters:\n  fixes a b c d e f g h :: \"'a :: comm_ring\"\n  assumes \"x = a + b\" \"y = c + d\" \"u = e + f\" \"v = g + h\"\n  shows \"x * y + u * v = (a * c + b * c + a * d + b * d) + (e * g + f * g + e * h + f * h)\"\nproof -\n  have \"x * y = (a + b) * (c + d)\" using assms by simp\n  moreover have \"u * v = (e + f) * (g + h)\" using assms by simp\n  ultimately show ?thesis using multi_distrib_general by simp\nqed", "origin": "multi_distrib_complex_ext_generalV2", "update_count": 0}, "number_of_terms": {"skill_name": "number_of_terms", "marker": "lemma number_of_terms:\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\nproof -\n  have \"card {k. k \\<in> {19::nat..<92}} = 92 - 19\" \n    by (metis Collect_mem_eq card_atLeastLessThan)\n  also have \"... = 73\" \n    by simp\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma number_of_terms:\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\nproof -\n  have \"card {k. k \\<in> {19::nat..<92}} = 92 - 19\" \n    by (metis Collect_mem_eq card_atLeastLessThan)\n  also have \"... = 73\" \n    by simp\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}}
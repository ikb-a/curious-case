{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "cal_log_value_multi": {"skill_name": "cal_log_value_multi", "marker": "lemma cal_log_value_multi:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\n  and \"\\<forall>k::nat. b^k = a^(c*k)\" \nproof -\n  from assms(1) have \"b > 0\" by (metis assms(3))\n  then have \"b^k > 0\" for k::nat by simp\n  moreover have \"log a (b^k) = k * log a b\" by (metis assms(3) log_nat_power)\n  ultimately show \"b = a ^ c\" by (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)\n  show \"\\<forall>k::nat. b^k = a^(c*k)\" \n    by (smt (verit) \\<open>b = a ^ c\\<close> power_mult)\nqed", "description": "-", "full_code": "lemma cal_log_value_multi:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\n  and \"\\<forall>k::nat. b^k = a^(c*k)\" \nproof -\n  from assms(1) have \"b > 0\" by (metis assms(3))\n  then have \"b^k > 0\" for k::nat by simp\n  moreover have \"log a (b^k) = k * log a b\" by (metis assms(3) log_nat_power)\n  ultimately show \"b = a ^ c\" by (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)\n  show \"\\<forall>k::nat. b^k = a^(c*k)\" \n    by (smt (verit) \\<open>b = a ^ c\\<close> power_mult)\nqed", "origin": "cal_log_value", "update_count": 0}, "log_base_change": {"skill_name": "log_base_change", "marker": "fun log_base_change :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where\n\"log_base_change a b c = log b c / log b a\"", "description": "-", "full_code": "fun log_base_change :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where\n\"log_base_change a b c = log b c / log b a\"", "origin": "cal_log_value", "update_count": 0}, "mod_add": {"skill_name": "mod_add", "marker": "lemma mod_add:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\"\n    by auto\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" and \"b = 10 * (b div 10) + ?m_b\"\n    by auto\n  then have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  thus ?thesis\n  proof -\n    have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n      by simp\n    also have \"... mod 10 = (?m_a + ?m_b) mod 10\"\n      by (metis mod_mult_self4)\n    finally show ?thesis\n      by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\"\n    by auto\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" and \"b = 10 * (b div 10) + ?m_b\"\n    by auto\n  then have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  thus ?thesis\n  proof -\n    have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n      by simp\n    also have \"... mod 10 = (?m_a + ?m_b) mod 10\"\n      by (metis mod_mult_self4)\n    finally show ?thesis\n      by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "multi_distrib_complex_general": {"skill_name": "multi_distrib_complex_general", "marker": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a * (c + d) + b * (c + d)) + (e * (c + d) + f * (c + d))\"\n    by (auto simp: field_simps)\n  also have \"... = (a + b + e + f) * (c + d)\" by (simp add: distrib_right)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a * (c + d) + b * (c + d)) + (e * (c + d) + f * (c + d))\"\n    by (auto simp: field_simps)\n  also have \"... = (a + b + e + f) * (c + d)\" by (simp add: distrib_right)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib_complex_ext": {"skill_name": "multi_distrib_complex_ext", "marker": "lemma multi_distrib_complex_ext:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) * (e + f) = a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f\"\nproof -\n  have \"((a + b) * (c + d)) * (e + f) = (a * c + a * d + b * c + b * d) * (e + f)\"\n    by (auto simp: field_simps)\n  also have \"... = (a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f)\"\n    by (auto simp: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_ext:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) * (e + f) = a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f\"\nproof -\n  have \"((a + b) * (c + d)) * (e + f) = (a * c + a * d + b * c + b * d) * (e + f)\"\n    by (auto simp: field_simps)\n  also have \"... = (a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f)\"\n    by (auto simp: field_simps)\n  finally show ?thesis .\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "nonzero_product_inverse": {"skill_name": "nonzero_product_inverse", "marker": "lemma nonzero_product_inverse:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"(a * b) * (1 / (a * b)) = 1\"\nproof -\n  have \"1 / (a * b) = (1 / a) * (1 / b)\"\n    by (simp add: field_simps)\n  then show ?thesis by (simp add: assms)\nqed", "description": "-", "full_code": "lemma nonzero_product_inverse:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"(a * b) * (1 / (a * b)) = 1\"\nproof -\n  have \"1 / (a * b) = (1 / a) * (1 / b)\"\n    by (simp add: field_simps)\n  then show ?thesis by (simp add: assms)\nqed", "origin": "a_times_vera", "update_count": 0}, "a_times_vera_n_dimensions": {"skill_name": "a_times_vera_n_dimensions", "marker": "lemma a_times_vera_n_dimensions:\n  fixes a :: \"real list\"\n  assumes \"\\<forall>i. a ! i \\<noteq> 0\"\n  shows \"\\<forall>i. a ! i * (1 / (a ! i)) = 1\"\nproof -\n  show \"\\<forall>i. a ! i * (1 / (a ! i)) = 1\"\n  proof (rule allI)\n    fix i\n    from assms have \"a ! i \\<noteq> 0\" by auto\n    then show \"a ! i * (1 / (a ! i)) = 1\" by (simp add: field_simps)\n  qed\nqed", "description": "-", "full_code": "lemma a_times_vera_n_dimensions:\n  fixes a :: \"real list\"\n  assumes \"\\<forall>i. a ! i \\<noteq> 0\"\n  shows \"\\<forall>i. a ! i * (1 / (a ! i)) = 1\"\nproof -\n  show \"\\<forall>i. a ! i * (1 / (a ! i)) = 1\"\n  proof (rule allI)\n    fix i\n    from assms have \"a ! i \\<noteq> 0\" by auto\n    then show \"a ! i * (1 / (a ! i)) = 1\" by (simp add: field_simps)\n  qed\nqed", "origin": "a_times_vera", "update_count": 0}, "a_times_vera_extended": {"skill_name": "a_times_vera_extended", "marker": "lemma a_times_vera_extended:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"1 / a \\<noteq> 0\" using assms by auto\n  then show ?thesis by (simp add: assms)\nqed", "description": "-", "full_code": "lemma a_times_vera_extended:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"1 / a \\<noteq> 0\" using assms by auto\n  then show ?thesis by (simp add: assms)\nqed", "origin": "a_times_vera", "update_count": 0}, "a_times_vera_extendedV2": {"skill_name": "a_times_vera_extendedV2", "marker": "lemma a_times_vera_extended:\n  fixes a :: real and b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1 \\<and> b * (1 / b) = 1\"\n  by (simp add: assms)", "description": "-", "full_code": "lemma a_times_vera_extended:\n  fixes a :: real and b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1 \\<and> b * (1 / b) = 1\"\n  by (simp add: assms)", "origin": "a_times_vera", "update_count": 0}, "product_inverse": {"skill_name": "product_inverse", "marker": "lemma product_inverse:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"(a * b) * (1 / (a * b)) = 1\"\nproof -\n  have \"a * b \\<noteq> 0\" using assms by simp\n  then show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma product_inverse:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"(a * b) * (1 / (a * b)) = 1\"\nproof -\n  have \"a * b \\<noteq> 0\" using assms by simp\n  then show ?thesis by (simp add: field_simps)\nqed", "origin": "a_times_vera", "update_count": 0}, "mod_addV2": {"skill_name": "mod_addV2", "marker": "lemma mod_add:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" and \"b = 10 * (b div 10) + ?m_b\"\n    by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  thus ?thesis\n  proof -\n    have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n      by simp\n    also have \"... mod 10 = (?m_a + ?m_b) mod 10\"\n      by (metis mod_mult_self4)\n    finally show ?thesis\n      by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" and \"b = 10 * (b div 10) + ?m_b\"\n    by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  thus ?thesis\n  proof -\n    have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n      by simp\n    also have \"... mod 10 = (?m_a + ?m_b) mod 10\"\n      by (metis mod_mult_self4)\n    finally show ?thesis\n      by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "combine_mod": {"skill_name": "combine_mod", "marker": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  have \"a = 10 * (a div 10) + x\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + y\" using assms(2) by auto\n  then have \"a + b = (10 * (a div 10) + x) + (10 * (b div 10) + y)\"\n    by (metis \\<open>a = 10 * (a div 10) + x\\<close>)\n  thus ?thesis\n  proof -\n    have \"a + b = 10 * ((a div 10) + (b div 10)) + (x + y)\"\n      by (smt (verit) \\<open>a = 10 * (a div 10) + x\\<close> \\<open>b = 10 * (b div 10) + y\\<close> ab_semigroup_add_class.add_ac(1) add.commute add_mult_distrib2)\n    also have \"... mod 10 = (x + y) mod 10\"\n      by (metis mod_mult_self4)\n    finally show ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  have \"a = 10 * (a div 10) + x\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + y\" using assms(2) by auto\n  then have \"a + b = (10 * (a div 10) + x) + (10 * (b div 10) + y)\"\n    by (metis \\<open>a = 10 * (a div 10) + x\\<close>)\n  thus ?thesis\n  proof -\n    have \"a + b = 10 * ((a div 10) + (b div 10)) + (x + y)\"\n      by (smt (verit) \\<open>a = 10 * (a div 10) + x\\<close> \\<open>b = 10 * (b div 10) + y\\<close> ab_semigroup_add_class.add_ac(1) add.commute add_mult_distrib2)\n    also have \"... mod 10 = (x + y) mod 10\"\n      by (metis mod_mult_self4)\n    finally show ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_mod_10": {"skill_name": "square_mod_10", "marker": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?m = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?m\" by auto\n  then have \"n^2 = (10 * (n div 10) + ?m)^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?m + ?m^2\" \n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?m + ?m^2\" \n    by (simp add: power_mult_distrib)\n  finally have \"n^2 mod 10 = (?m^2) mod 10\" \n    by (metis power_mod)\n  have \"?m^2 mod 10 = (?m^2) mod 10\" by simp\n  thus ?thesis by (simp add: `n^2 mod 10 = (?m^2) mod 10`)\nqed", "description": "-", "full_code": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?m = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?m\" by auto\n  then have \"n^2 = (10 * (n div 10) + ?m)^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?m + ?m^2\" \n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?m + ?m^2\" \n    by (simp add: power_mult_distrib)\n  finally have \"n^2 mod 10 = (?m^2) mod 10\" \n    by (metis power_mod)\n  have \"?m^2 mod 10 = (?m^2) mod 10\" by simp\n  thus ?thesis by (simp add: `n^2 mod 10 = (?m^2) mod 10`)\nqed", "origin": "do_request", "update_count": 0}, "square_mod_10V2": {"skill_name": "square_mod_10V2", "marker": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?m_n = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?m_n\" by (auto)\n  then have \"n^2 = (10 * (n div 10) + ?m_n)^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?m_n + ?m_n^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?m_n + ?m_n^2\"\n    by simp\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?m_n + ?m_n^2) mod 10\"\n    by simp\n  then have \"n^2 mod 10 = ?m_n^2 mod 10\"\n    by (metis power_mod)\n  thus ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?m_n = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?m_n\" by (auto)\n  then have \"n^2 = (10 * (n div 10) + ?m_n)^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?m_n + ?m_n^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?m_n + ?m_n^2\"\n    by simp\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?m_n + ?m_n^2) mod 10\"\n    by simp\n  then have \"n^2 mod 10 = ?m_n^2 mod 10\"\n    by (metis power_mod)\n  thus ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "square_mod_10V3": {"skill_name": "square_mod_10V3", "marker": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?m = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?m\" \n    by (auto)\n  have \"(n^2) mod 10 = ((10 * (n div 10) + ?m) ^ 2) mod 10\"\n    by simp\n  have \"(10 * (n div 10) + ?m) ^ 2 = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?m + ?m^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  thus ?thesis\n  proof -\n    have \"((10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?m + ?m^2) mod 10 = (?m^2) mod 10\"\n      by (smt (verit) \\<open>(10 * (n div 10) + n mod 10)\\<^sup>2 = (10 * (n div 10))\\<^sup>2 + 2 * (10 * (n div 10)) * (n mod 10) + (n mod 10)\\<^sup>2\\<close> \\<open>n = 10 * (n div 10) + n mod 10\\<close> power_mod)\n    also have \"... = (?m^2) mod 10\"\n      by (simp)\n    finally show ?thesis\n      by (metis power_mod)\n  qed\nqed", "description": "-", "full_code": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?m = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?m\" \n    by (auto)\n  have \"(n^2) mod 10 = ((10 * (n div 10) + ?m) ^ 2) mod 10\"\n    by simp\n  have \"(10 * (n div 10) + ?m) ^ 2 = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?m + ?m^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  thus ?thesis\n  proof -\n    have \"((10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?m + ?m^2) mod 10 = (?m^2) mod 10\"\n      by (smt (verit) \\<open>(10 * (n div 10) + n mod 10)\\<^sup>2 = (10 * (n div 10))\\<^sup>2 + 2 * (10 * (n div 10)) * (n mod 10) + (n mod 10)\\<^sup>2\\<close> \\<open>n = 10 * (n div 10) + n mod 10\\<close> power_mod)\n    also have \"... = (?m^2) mod 10\"\n      by (simp)\n    finally show ?thesis\n      by (metis power_mod)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_mod": {"skill_name": "square_mod", "marker": "lemma square_mod:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by simp\n  finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  also have \"... = 0\" by auto\n  thus ?thesis by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_mod:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by simp\n  finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  also have \"... = 0\" by auto\n  thus ?thesis by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "square_modV2": {"skill_name": "square_modV2", "marker": "lemma square_mod:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  hence \"k^2 = 100 * (k div 10)^2\" by simp\n  thus \"k^2 mod 10 = 0\" by auto\nqed", "description": "-", "full_code": "lemma square_mod:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  hence \"k^2 = 100 * (k div 10)^2\" by simp\n  thus \"k^2 mod 10 = 0\" by auto\nqed", "origin": "do_request", "update_count": 0}, "square_modV3": {"skill_name": "square_modV3", "marker": "lemma square_mod:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms(1) by auto\n  then show ?thesis\n  proof -\n    have \"k^2 = (10 * (k div 10))^2\" by (metis \\<open>k = 10 * (k div 10)\\<close>)\n    also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n    finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n    also have \"... = 0\" by auto\n    finally show ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma square_mod:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms(1) by auto\n  then show ?thesis\n  proof -\n    have \"k^2 = (10 * (k div 10))^2\" by (metis \\<open>k = 10 * (k div 10)\\<close>)\n    also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n    finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n    also have \"... = 0\" by auto\n    finally show ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_modV4": {"skill_name": "square_modV4", "marker": "lemma square_mod:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms(1) by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  also have \"... = 0\" using mod_mult_self2 by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_mod:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms(1) by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  also have \"... = 0\" using mod_mult_self2 by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_modV5": {"skill_name": "square_modV5", "marker": "lemma square_mod:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power_mult_distrib)\n  finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  then show ?thesis by (simp add: mod_mult_self4)\nqed", "description": "-", "full_code": "lemma square_mod:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power_mult_distrib)\n  finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  then show ?thesis by (simp add: mod_mult_self4)\nqed", "origin": "do_request", "update_count": 0}, "combine_modV2": {"skill_name": "combine_modV2", "marker": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m1 = \"a mod 10\"\n  let ?m2 = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m1\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m2\" using assms(2) by auto\n  then have \"a + b = (10 * (a div 10) + ?m1) + (10 * (b div 10) + ?m2)\"\n    by (metis \\<open>a = 10 * (a div 10) + ?m1\\<close>)\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m1 + ?m2)\"\n    by auto\n  also have \"... mod 10 = (?m1 + ?m2) mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis by (metis assms(1) assms(2) mod_add_cong mod_add_eq)\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m1 = \"a mod 10\"\n  let ?m2 = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m1\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m2\" using assms(2) by auto\n  then have \"a + b = (10 * (a div 10) + ?m1) + (10 * (b div 10) + ?m2)\"\n    by (metis \\<open>a = 10 * (a div 10) + ?m1\\<close>)\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m1 + ?m2)\"\n    by auto\n  also have \"... mod 10 = (?m1 + ?m2) mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis by (metis assms(1) assms(2) mod_add_cong mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "combine_modV3": {"skill_name": "combine_modV3", "marker": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m1 = \"a mod 10\"\n  let ?m2 = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m1\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m2\" using assms(2) by auto\n  then have \"a + b = (10 * (a div 10) + ?m1) + (10 * (b div 10) + ?m2)\"\n    by simp\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m1 + ?m2)\"\n    by (simp add: algebra_simps)\n  also have \"... mod 10 = (?m1 + ?m2) mod 10\"\n    by (metis mod_mult_self4)\n  moreover have \"?m1 = x\" \" ?m2 = y\" \n    using assms by simp_all\n  ultimately show ?thesis\n    by (metis mod_add_eq mod_add_cong)\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m1 = \"a mod 10\"\n  let ?m2 = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m1\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m2\" using assms(2) by auto\n  then have \"a + b = (10 * (a div 10) + ?m1) + (10 * (b div 10) + ?m2)\"\n    by simp\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m1 + ?m2)\"\n    by (simp add: algebra_simps)\n  also have \"... mod 10 = (?m1 + ?m2) mod 10\"\n    by (metis mod_mult_self4)\n  moreover have \"?m1 = x\" \" ?m2 = y\" \n    using assms by simp_all\n  ultimately show ?thesis\n    by (metis mod_add_eq mod_add_cong)\nqed", "origin": "do_request", "update_count": 0}, "combine_modV4": {"skill_name": "combine_modV4", "marker": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by simp\n  also have \"... mod 10 = (?m_a + ?m_b) mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis \n    by (simp add: assms(1) assms(2) mod_add_eq)\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by simp\n  also have \"... mod 10 = (?m_a + ?m_b) mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis \n    by (simp add: assms(1) assms(2) mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "combine_modV5": {"skill_name": "combine_modV5", "marker": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\" by simp\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\" by simp\n  also have \"... mod 10 = (?m_a + ?m_b) mod 10\" by (metis mod_mult_self4)\n  have \"?m_a = x\" and \"?m_b = y\" using assms by auto\n  thus ?thesis using `?m_a = x` `?m_b = y` by (metis mod_add_cong mod_add_eq)\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\" by simp\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\" by simp\n  also have \"... mod 10 = (?m_a + ?m_b) mod 10\" by (metis mod_mult_self4)\n  have \"?m_a = x\" and \"?m_b = y\" using assms by auto\n  thus ?thesis using `?m_a = x` `?m_b = y` by (metis mod_add_cong mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "combine_modV6": {"skill_name": "combine_modV6", "marker": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by (metis \\<open>a = 10 * (a div 10) + ?m_a\\<close> \\<open>b = 10 * (b div 10) + ?m_b\\<close>)\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by auto\n  have \"((a + b) mod 10) = ((10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)) mod 10)\"\n    by (auto simp: field_simps)\n  also have \"... = (?m_a + ?m_b) mod 10\"\n    by (metis mod_mult_self4)\n  also have \"... = (x + y) mod 10\"\n    using assms(1) assms(2) by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by (metis \\<open>a = 10 * (a div 10) + ?m_a\\<close> \\<open>b = 10 * (b div 10) + ?m_b\\<close>)\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by auto\n  have \"((a + b) mod 10) = ((10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)) mod 10)\"\n    by (auto simp: field_simps)\n  also have \"... = (?m_a + ?m_b) mod 10\"\n    by (metis mod_mult_self4)\n  also have \"... = (x + y) mod 10\"\n    using assms(1) assms(2) by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_modV7": {"skill_name": "combine_modV7", "marker": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m1 = \"a mod 10\"\n  let ?m2 = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m1\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m2\" using assms(2) by auto\n  have \"a + b = (10 * (a div 10) + ?m1) + (10 * (b div 10) + ?m2)\"\n    by simp\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m1 + ?m2)\"\n    by simp\n  have \"(a + b) mod 10 = (10 * ((a div 10) + (b div 10)) + (?m1 + ?m2)) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = (?m1 + ?m2) mod 10\"\n    by (metis mod_mult_self4)\n  also have \"... = (x + y) mod 10\"\n    using assms by auto\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\nproof -\n  let ?m1 = \"a mod 10\"\n  let ?m2 = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m1\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + ?m2\" using assms(2) by auto\n  have \"a + b = (10 * (a div 10) + ?m1) + (10 * (b div 10) + ?m2)\"\n    by simp\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m1 + ?m2)\"\n    by simp\n  have \"(a + b) mod 10 = (10 * ((a div 10) + (b div 10)) + (?m1 + ?m2)) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = (?m1 + ?m2) mod 10\"\n    by (metis mod_mult_self4)\n  also have \"... = (x + y) mod 10\"\n    using assms by auto\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "product_nonzero": {"skill_name": "product_nonzero", "marker": "lemma product_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a * b \\<noteq> 0\"\nproof -\n  have \"a * b = 0 \\<Longrightarrow> a = 0 \\<or> b = 0\" using assms by auto\n  then show ?thesis by (metis assms(1) assms(2))\nqed", "description": "-", "full_code": "lemma product_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a * b \\<noteq> 0\"\nproof -\n  have \"a * b = 0 \\<Longrightarrow> a = 0 \\<or> b = 0\" using assms by auto\n  then show ?thesis by (metis assms(1) assms(2))\nqed", "origin": "product_inverse", "update_count": 0}, "mod_add_general": {"skill_name": "mod_add_general", "marker": "lemma mod_add_general:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  let ?m_a = \"a mod m\"\n  let ?m_b = \"b mod m\"\n  have \"a = m * (a div m) + ?m_a\" and \"b = m * (b div m) + ?m_b\"\n    by auto\n  have \"a + b = (m * (a div m) + ?m_a) + (m * (b div m) + ?m_b)\"\n    by simp\n  thus ?thesis\n  proof -\n    have \"a + b = m * ((a div m) + (b div m)) + (?m_a + ?m_b)\"\n      by (auto simp: field_simps)\n    also have \"... mod m = (?m_a + ?m_b) mod m\"\n      by (metis mod_mult_self4)\n    finally show ?thesis\n      by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_add_general:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  let ?m_a = \"a mod m\"\n  let ?m_b = \"b mod m\"\n  have \"a = m * (a div m) + ?m_a\" and \"b = m * (b div m) + ?m_b\"\n    by auto\n  have \"a + b = (m * (a div m) + ?m_a) + (m * (b div m) + ?m_b)\"\n    by simp\n  thus ?thesis\n  proof -\n    have \"a + b = m * ((a div m) + (b div m)) + (?m_a + ?m_b)\"\n      by (auto simp: field_simps)\n    also have \"... mod m = (?m_a + ?m_b) mod m\"\n      by (metis mod_mult_self4)\n    finally show ?thesis\n      by simp\n  qed\nqed", "origin": "mod_addV2", "update_count": 0}, "mod_add_generalV2": {"skill_name": "mod_add_generalV2", "marker": "lemma mod_add_general:\n  fixes a b :: nat\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?m_a = \"a mod n\"\n  let ?m_b = \"b mod n\"\n  have \"a = n * (a div n) + ?m_a\" and \"b = n * (b div n) + ?m_b\"\n    by auto\n  have \"a + b = (n * (a div n) + ?m_a) + (n * (b div n) + ?m_b)\"\n    by simp\n  thus ?thesis\n  proof -\n    have \"a + b = n * ((a div n) + (b div n)) + (?m_a + ?m_b)\"\n      by (auto simp: field_simps)\n    also have \"... mod n = (?m_a + ?m_b) mod n\"\n      by (metis mod_mult_self4)\n    finally show ?thesis\n      by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_add_general:\n  fixes a b :: nat\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?m_a = \"a mod n\"\n  let ?m_b = \"b mod n\"\n  have \"a = n * (a div n) + ?m_a\" and \"b = n * (b div n) + ?m_b\"\n    by auto\n  have \"a + b = (n * (a div n) + ?m_a) + (n * (b div n) + ?m_b)\"\n    by simp\n  thus ?thesis\n  proof -\n    have \"a + b = n * ((a div n) + (b div n)) + (?m_a + ?m_b)\"\n      by (auto simp: field_simps)\n    also have \"... mod n = (?m_a + ?m_b) mod n\"\n      by (metis mod_mult_self4)\n    finally show ?thesis\n      by simp\n  qed\nqed", "origin": "mod_addV2", "update_count": 0}, "mod_add_example": {"skill_name": "mod_add_example", "marker": "lemma mod_add_example:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\n  using mod_add_general_extended[of a b 10] by presburger", "description": "-", "full_code": "lemma mod_add_general_extended:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?m_a = \"a mod n\"\n  let ?m_b = \"b mod n\"\n  have \"a = n * (a div n) + ?m_a\" and \"b = n * (b div n) + ?m_b\"\n    by auto\n  have \"a + b = (n * (a div n) + ?m_a) + (n * (b div n) + ?m_b)\"\n    by simp\n  thus ?thesis\n  proof -\n    have \"a + b = n * ((a div n) + (b div n)) + (?m_a + ?m_b)\"\n      by (auto simp: field_simps)\n    also have \"... mod n = (?m_a + ?m_b) mod n\"\n      by (metis mod_mult_self4)\n    finally show ?thesis\n      by simp\n  qed\nqed\n\nlemma mod_add_example:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\n  using mod_add_general_extended[of a b 10] by presburger", "origin": "mod_add_generalV2", "update_count": 0}, "mod_10_add": {"skill_name": "mod_10_add", "marker": "lemma mod_10_add:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\n  by presburger", "description": "", "full_code": "lemma mod_10_add:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\n  by presburger", "origin": "data/full_data/debug/valid_rand/amc12a_2008_p15.json_v8", "update_count": -1}, "mod_add_generalV3": {"skill_name": "mod_add_generalV3", "marker": "lemma mod_add_general:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = (a mod m + b mod m) mod m\"\nproof -\n  have \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\n    using assms by presburger\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_general:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = (a mod m + b mod m) mod m\"\nproof -\n  have \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\n    using assms by presburger\n  thus ?thesis by auto\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_10_add_extended": {"skill_name": "mod_10_add_extended", "marker": "lemma mod_10_add_extended:\n  fixes a b c :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\" \"c mod 10 = z\"\n  shows \"(a + b + c) mod 10 = (x + y + z) mod 10\"\nproof -\n  have \"((a + b) + c) mod 10 = ((a mod 10 + b mod 10) mod 10 + c) mod 10\"\n    using assms by (metis add.commute group_cancel.add1 group_cancel.add2 mod_add_eq mod_add_right_eq)\n  also have \"... = ((x + y) mod 10 + z) mod 10\"\n    by (smt (verit) assms(1) assms(2) assms(3) mod_add_right_eq)\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_10_add_extended:\n  fixes a b c :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\" \"c mod 10 = z\"\n  shows \"(a + b + c) mod 10 = (x + y + z) mod 10\"\nproof -\n  have \"((a + b) + c) mod 10 = ((a mod 10 + b mod 10) mod 10 + c) mod 10\"\n    using assms by (metis add.commute group_cancel.add1 group_cancel.add2 mod_add_eq mod_add_right_eq)\n  also have \"... = ((x + y) mod 10 + z) mod 10\"\n    by (smt (verit) assms(1) assms(2) assms(3) mod_add_right_eq)\n  finally show ?thesis by presburger\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_10_mult": {"skill_name": "mod_10_mult", "marker": "lemma mod_10_mult:\n  fixes a b :: nat\n  shows \"(a * b) mod 10 = ((a mod 10) * (b mod 10)) mod 10\"\n  by (metis mod_mult_eq)", "description": "-", "full_code": "lemma mod_10_mult:\n  fixes a b :: nat\n  shows \"(a * b) mod 10 = ((a mod 10) * (b mod 10)) mod 10\"\n  by (metis mod_mult_eq)", "origin": "mod_10_add", "update_count": 0}, "mod_n_add": {"skill_name": "mod_n_add", "marker": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\nproof -\n  have \"a + b = (a mod n + b mod n) + (n * ((a div n) + (b div n)))\"\n    by (auto simp: field_simps)\n  then show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\nproof -\n  have \"a + b = (a mod n + b mod n) + (n * ((a div n) + (b div n)))\"\n    by (auto simp: field_simps)\n  then show ?thesis\n    by auto\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_n_addV2": {"skill_name": "mod_n_addV2", "marker": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\n  by presburger", "description": "-", "full_code": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\n  by presburger", "origin": "mod_10_add", "update_count": 0}, "mod_add_extended": {"skill_name": "mod_add_extended", "marker": "lemma mod_add_extended:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a + b = (a mod d) + (b mod d) + d * ((a div d) + (b div d))\" \n    by (auto simp: field_simps)\n  then show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma mod_add_extended:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a + b = (a mod d) + (b mod d) + d * ((a div d) + (b div d))\" \n    by (auto simp: field_simps)\n  then show ?thesis \n    by auto\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_addV3": {"skill_name": "mod_addV3", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = (a mod m + b mod m) mod m\"\nproof -\n  have \"(a + b) mod m = ((a mod m) + (b mod m) + (m * (a div m + b div m))) mod m\"\n    by presburger\n  also have \"... = (a mod m + b mod m) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = (a mod m + b mod m) mod m\"\nproof -\n  have \"(a + b) mod m = ((a mod m) + (b mod m) + (m * (a div m + b div m))) mod m\"\n    by presburger\n  also have \"... = (a mod m + b mod m) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_n_addV3": {"skill_name": "mod_n_addV3", "marker": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\nproof -\n  have \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\n    by presburger\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\nproof -\n  have \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\n    by presburger\n  then show ?thesis by simp\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_d_add": {"skill_name": "mod_d_add", "marker": "lemma mod_d_add:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d < d\" by (rule mod_less_divisor[OF assms])\n  have \"b mod d < d\" by (rule mod_less_divisor[OF assms])\n  show ?thesis \n  proof (cases \"a + b < d\")\n    case True\n    then have \"(a + b) mod d = a + b\" by simp\n    then show ?thesis by presburger\n  next\n    case False\n    then have \"(a + b) mod d = (a mod d + b mod d) mod d\"\n      by presburger\n    thus ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_d_add:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d < d\" by (rule mod_less_divisor[OF assms])\n  have \"b mod d < d\" by (rule mod_less_divisor[OF assms])\n  show ?thesis \n  proof (cases \"a + b < d\")\n    case True\n    then have \"(a + b) mod d = a + b\" by simp\n    then show ?thesis by presburger\n  next\n    case False\n    then have \"(a + b) mod d = (a mod d + b mod d) mod d\"\n      by presburger\n    thus ?thesis by simp\n  qed\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_d_addV2": {"skill_name": "mod_d_addV2", "marker": "lemma mod_d_add:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"b mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"a + b = (a mod d) + (b mod d) + d * (a div d + b div d)\" by (auto simp: field_simps)\n  then show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma mod_d_add:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"b mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"a + b = (a mod d) + (b mod d) + d * (a div d + b div d)\" by (auto simp: field_simps)\n  then show ?thesis \n    by auto\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_10_calculation": {"skill_name": "mod_10_calculation", "marker": "lemma mod_10_calculation:\n  fixes a b :: nat\n  assumes \"a mod 10 = 4\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 0\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by presburger\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by presburger\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by simp\n  also have \"... mod 10 = (?m_a + ?m_b) mod 10\"\n    by (metis mod_mult_self4)\n  have \"?m_a + ?m_b = 4 + 6\" using assms by simp\n  then have \"?m_a + ?m_b = 10\" by simp\n  thus ?thesis\n    by presburger\nqed", "description": "-", "full_code": "lemma mod_10_calculation:\n  fixes a b :: nat\n  assumes \"a mod 10 = 4\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 0\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by presburger\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by presburger\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by simp\n  also have \"... mod 10 = (?m_a + ?m_b) mod 10\"\n    by (metis mod_mult_self4)\n  have \"?m_a + ?m_b = 4 + 6\" using assms by simp\n  then have \"?m_a + ?m_b = 10\" by simp\n  thus ?thesis\n    by presburger\nqed", "origin": "do_request", "update_count": 0}, "mod_10_calculationV2": {"skill_name": "mod_10_calculationV2", "marker": "lemma mod_10_calculation:\n  fixes a b :: nat\n  assumes \"a mod 10 = 4\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 0\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by presburger\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by presburger\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by simp\n  have \"?m_a + ?m_b = 4 + 6\" using assms by simp\n  thus ?thesis\n  proof -\n    have \"?m_a + ?m_b = 10\" by (metis assms(1) assms(2) numeral_eq_Suc numeral_plus_numeral semiring_norm(2) semiring_norm(3) semiring_norm(6) semiring_norm(7))\n    also have \"... mod 10 = 0\" by simp\n    finally show ?thesis by (metis \\<open>10 mod 10 = 0\\<close> \\<open>a mod 10 + b mod 10 = 10\\<close> assms(1) assms(2) bits_mod_div_trivial mod_add_cong mod_eq_self_iff_div_eq_0)\n  qed\nqed", "description": "-", "full_code": "lemma mod_10_calculation:\n  fixes a b :: nat\n  assumes \"a mod 10 = 4\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 0\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by presburger\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by presburger\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by simp\n  have \"?m_a + ?m_b = 4 + 6\" using assms by simp\n  thus ?thesis\n  proof -\n    have \"?m_a + ?m_b = 10\" by (metis assms(1) assms(2) numeral_eq_Suc numeral_plus_numeral semiring_norm(2) semiring_norm(3) semiring_norm(6) semiring_norm(7))\n    also have \"... mod 10 = 0\" by simp\n    finally show ?thesis by (metis \\<open>10 mod 10 = 0\\<close> \\<open>a mod 10 + b mod 10 = 10\\<close> assms(1) assms(2) bits_mod_div_trivial mod_add_cong mod_eq_self_iff_div_eq_0)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mod_n_addV4": {"skill_name": "mod_n_addV4", "marker": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\nproof -\n  have \"(a + b) mod n = (if a + b < n then a + b else (a mod n + b mod n) mod n)\"\n    by (metis mod_add_eq mod_less)\n  thus ?thesis\n    using assms by auto\nqed", "description": "-", "full_code": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\nproof -\n  have \"(a + b) mod n = (if a + b < n then a + b else (a mod n + b mod n) mod n)\"\n    by (metis mod_add_eq mod_less)\n  thus ?thesis\n    using assms by auto\nqed", "origin": "mod_10_add", "update_count": 0}, "combine_mod_results": {"skill_name": "combine_mod_results", "marker": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  let ?m_x = \"x mod 10\"\n  let ?m_y = \"y mod 10\"\n  have \"?m_x = 0\" using assms(1) by simp\n  have \"?m_y = 6\" using assms(2) by simp\n  have \"x = 10 * (x div 10) + ?m_x\" using assms(1) by auto\n  have \"y = 10 * (y div 10) + ?m_y\" using assms(2) by presburger\n  then have \"x + y = (10 * (x div 10) + ?m_x) + (10 * (y div 10) + ?m_y)\"\n    by (metis \\<open>x = 10 * (x div 10) + ?m_x\\<close> \\<open>y = 10 * (y div 10) + ?m_y\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + (?m_x + ?m_y)\"\n    by auto\n  have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + (?m_x + ?m_y)) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = (?m_x + ?m_y) mod 10\"\n    by (metis mod_mult_self4)\n  also have \"... = (0 + 6) mod 10\"\n    using `?m_x = 0` `?m_y = 6` by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  let ?m_x = \"x mod 10\"\n  let ?m_y = \"y mod 10\"\n  have \"?m_x = 0\" using assms(1) by simp\n  have \"?m_y = 6\" using assms(2) by simp\n  have \"x = 10 * (x div 10) + ?m_x\" using assms(1) by auto\n  have \"y = 10 * (y div 10) + ?m_y\" using assms(2) by presburger\n  then have \"x + y = (10 * (x div 10) + ?m_x) + (10 * (y div 10) + ?m_y)\"\n    by (metis \\<open>x = 10 * (x div 10) + ?m_x\\<close> \\<open>y = 10 * (y div 10) + ?m_y\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + (?m_x + ?m_y)\"\n    by auto\n  have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + (?m_x + ?m_y)) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = (?m_x + ?m_y) mod 10\"\n    by (metis mod_mult_self4)\n  also have \"... = (0 + 6) mod 10\"\n    using `?m_x = 0` `?m_y = 6` by simp\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_mod_resultsV2": {"skill_name": "combine_mod_resultsV2", "marker": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  have \"x = 10 * (x div 10) + 0\" using assms(1) by auto\n  have \"y = 10 * (y div 10) + 6\" using assms(2) by presburger\n  have \"x + y = (10 * (x div 10) + 0) + (10 * (y div 10) + 6)\"\n    by (metis \\<open>x = 10 * (x div 10) + 0\\<close> \\<open>y = 10 * (y div 10) + 6\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + 6\"\n    by auto\n  then have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + 6) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = 6 mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  have \"x = 10 * (x div 10) + 0\" using assms(1) by auto\n  have \"y = 10 * (y div 10) + 6\" using assms(2) by presburger\n  have \"x + y = (10 * (x div 10) + 0) + (10 * (y div 10) + 6)\"\n    by (metis \\<open>x = 10 * (x div 10) + 0\\<close> \\<open>y = 10 * (y div 10) + 6\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + 6\"\n    by auto\n  then have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + 6) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = 6 mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_mod_resultsV3": {"skill_name": "combine_mod_resultsV3", "marker": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  let ?m_x = \"x mod 10\"\n  let ?m_y = \"y mod 10\"\n  have \"?m_x = 0\" using assms(1) by simp\n  have \"?m_y = 6\" using assms(2) by simp\n  have \"x + y = (10 * (x div 10) + ?m_x) + (10 * (y div 10) + ?m_y)\"\n    by auto\n  then have \"x + y = 10 * (x div 10 + y div 10) + (?m_x + ?m_y)\"\n    by (simp add: algebra_simps)\n  have \"(x + y) mod 10 = (10 * (x div 10 + y div 10) + (?m_x + ?m_y)) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = (?m_x + ?m_y) mod 10\"\n    by (metis mod_mult_self4)\n  also have \"... = (0 + 6) mod 10\"\n    by (simp add: \\<open>?m_x = 0\\<close> \\<open>?m_y = 6\\<close>)\n  finally show ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  let ?m_x = \"x mod 10\"\n  let ?m_y = \"y mod 10\"\n  have \"?m_x = 0\" using assms(1) by simp\n  have \"?m_y = 6\" using assms(2) by simp\n  have \"x + y = (10 * (x div 10) + ?m_x) + (10 * (y div 10) + ?m_y)\"\n    by auto\n  then have \"x + y = 10 * (x div 10 + y div 10) + (?m_x + ?m_y)\"\n    by (simp add: algebra_simps)\n  have \"(x + y) mod 10 = (10 * (x div 10 + y div 10) + (?m_x + ?m_y)) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = (?m_x + ?m_y) mod 10\"\n    by (metis mod_mult_self4)\n  also have \"... = (0 + 6) mod 10\"\n    by (simp add: \\<open>?m_x = 0\\<close> \\<open>?m_y = 6\\<close>)\n  finally show ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_mod_resultsV4": {"skill_name": "combine_mod_resultsV4", "marker": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  have \"x mod 10 = 0\" using assms(1) by simp\n  have \"y mod 10 = 6\" using assms(2) by simp\n  have \"x = 10 * (x div 10) + 0\" using `x mod 10 = 0` by auto\n  have \"y = 10 * (y div 10) + 6\" using `y mod 10 = 6` by presburger\n  have \"x + y = (10 * (x div 10) + 0) + (10 * (y div 10) + 6)\"\n    by (metis \\<open>x = 10 * (x div 10) + 0\\<close> \\<open>y = 10 * (y div 10) + 6\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + 6\"\n    by auto\n  have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + 6) mod 10\"\n    by (metis \\<open>x + y = 10 * (x div 10 + y div 10) + 6\\<close> semiring_norm(3))\n  also have \"... = 6 mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  have \"x mod 10 = 0\" using assms(1) by simp\n  have \"y mod 10 = 6\" using assms(2) by simp\n  have \"x = 10 * (x div 10) + 0\" using `x mod 10 = 0` by auto\n  have \"y = 10 * (y div 10) + 6\" using `y mod 10 = 6` by presburger\n  have \"x + y = (10 * (x div 10) + 0) + (10 * (y div 10) + 6)\"\n    by (metis \\<open>x = 10 * (x div 10) + 0\\<close> \\<open>y = 10 * (y div 10) + 6\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + 6\"\n    by auto\n  have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + 6) mod 10\"\n    by (metis \\<open>x + y = 10 * (x div 10 + y div 10) + 6\\<close> semiring_norm(3))\n  also have \"... = 6 mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_mod_resultsV5": {"skill_name": "combine_mod_resultsV5", "marker": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  have \"x = 10 * (x div 10) + 0\" using assms(1) by auto\n  have \"y = 10 * (y div 10) + 6\" using assms(2) by presburger\n  then have \"x + y = (10 * (x div 10) + 0) + (10 * (y div 10) + 6)\"\n    by (metis \\<open>x = 10 * (x div 10) + 0\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + 6\"\n    by (simp add: algebra_simps)\n  have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + 6) mod 10\"\n    by (metis \\<open>x + y = 10 * (x div 10 + y div 10) + 6\\<close> semiring_norm(3))\n  also have \"... = 6 mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  have \"x = 10 * (x div 10) + 0\" using assms(1) by auto\n  have \"y = 10 * (y div 10) + 6\" using assms(2) by presburger\n  then have \"x + y = (10 * (x div 10) + 0) + (10 * (y div 10) + 6)\"\n    by (metis \\<open>x = 10 * (x div 10) + 0\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + 6\"\n    by (simp add: algebra_simps)\n  have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + 6) mod 10\"\n    by (metis \\<open>x + y = 10 * (x div 10 + y div 10) + 6\\<close> semiring_norm(3))\n  also have \"... = 6 mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_10_add_with_multiple": {"skill_name": "mod_10_add_with_multiple", "marker": "lemma mod_10_add_with_multiple:\n  fixes a b c :: nat\n  shows \"(a + b + c) mod 10 = ((a mod 10 + b mod 10 + c mod 10) mod 10)\"\nproof -\n  have \"((a + b) + c) mod 10 = ((a + b) mod 10 + c mod 10) mod 10\"\n    by (metis mod_add_eq)\n  thus ?thesis\n    by (metis group_cancel.add1 mod_add_cong mod_add_eq mod_mod_trivial)\nqed", "description": "-", "full_code": "lemma mod_10_add_with_multiple:\n  fixes a b c :: nat\n  shows \"(a + b + c) mod 10 = ((a mod 10 + b mod 10 + c mod 10) mod 10)\"\nproof -\n  have \"((a + b) + c) mod 10 = ((a + b) mod 10 + c mod 10) mod 10\"\n    by (metis mod_add_eq)\n  thus ?thesis\n    by (metis group_cancel.add1 mod_add_cong mod_add_eq mod_mod_trivial)\nqed", "origin": "mod_10_add", "update_count": 0}, "power_mod": {"skill_name": "power_mod", "marker": "lemma power_mod:\n  fixes a :: nat\n  fixes n m :: nat\n  assumes \"m > 0\" \"n > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a ^ Suc n = a * (a ^ n)\" by simp\n  then have \"(a ^ Suc n) mod m = (a * (a ^ n)) mod m\" by simp\n  also have \"... = ((a mod m) * ((a ^ n) mod m)) mod m\"\n    using `m > 0` by (metis mod_mult_eq)\n  also have \"... = ((a mod m) * ((a mod m) ^ n mod m)) mod m\"\n    using Suc.IH by simp\n  also have \"... = ((a mod m) ^ Suc n) mod m\"\n    by (metis calculation power_mod)\n  finally show ?case by simp\nqed", "description": "-", "full_code": "lemma power_mod:\n  fixes a :: nat\n  fixes n m :: nat\n  assumes \"m > 0\" \"n > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a ^ Suc n = a * (a ^ n)\" by simp\n  then have \"(a ^ Suc n) mod m = (a * (a ^ n)) mod m\" by simp\n  also have \"... = ((a mod m) * ((a ^ n) mod m)) mod m\"\n    using `m > 0` by (metis mod_mult_eq)\n  also have \"... = ((a mod m) * ((a mod m) ^ n mod m)) mod m\"\n    using Suc.IH by simp\n  also have \"... = ((a mod m) ^ Suc n) mod m\"\n    by (metis calculation power_mod)\n  finally show ?case by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_addV4": {"skill_name": "mod_addV4", "marker": "lemma mod_add:\n  fixes a b c d m :: nat\n  assumes \"a mod m = c\" \"b mod m = d\" \"m > 0\"\n  shows \"(a + b) mod m = (c + d) mod m\"\nproof -\n  have \"c < m\" using assms(1) by (metis assms(3) mod_less_divisor)\n  have \"d < m\" using assms(2) by (metis assms(3) mod_less_divisor)\n  have \"a = c + m * (a div m)\" using assms(1) by auto\n  have \"b = d + m * (b div m)\" using assms(2) by auto\n  then have \"a + b = (c + d) + m * ((a div m) + (b div m))\" by (smt (z3) \\<open>a = c + m * (a div m)\\<close> ab_semigroup_add_class.add_ac(1) add.assoc add_mono_thms_linordered_semiring(4) add_mult_distrib2 distrib_left group_cancel.add2)\n  have \"(a + b) mod m = ((c + d) + m * ((a div m) + (b div m))) mod m\" by (metis \\<open>a + b = c + d + m * (a div m + b div m)\\<close>)\n  also have \"... = (c + d) mod m\" using assms(3) by auto\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c d m :: nat\n  assumes \"a mod m = c\" \"b mod m = d\" \"m > 0\"\n  shows \"(a + b) mod m = (c + d) mod m\"\nproof -\n  have \"c < m\" using assms(1) by (metis assms(3) mod_less_divisor)\n  have \"d < m\" using assms(2) by (metis assms(3) mod_less_divisor)\n  have \"a = c + m * (a div m)\" using assms(1) by auto\n  have \"b = d + m * (b div m)\" using assms(2) by auto\n  then have \"a + b = (c + d) + m * ((a div m) + (b div m))\" by (smt (z3) \\<open>a = c + m * (a div m)\\<close> ab_semigroup_add_class.add_ac(1) add.assoc add_mono_thms_linordered_semiring(4) add_mult_distrib2 distrib_left group_cancel.add2)\n  have \"(a + b) mod m = ((c + d) + m * ((a div m) + (b div m))) mod m\" by (metis \\<open>a + b = c + d + m * (a div m + b div m)\\<close>)\n  also have \"... = (c + d) mod m\" using assms(3) by auto\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "mod_addV5": {"skill_name": "mod_addV5", "marker": "lemma mod_add:\n  fixes a b c d m :: nat\n  assumes \"a mod m = c\" \"b mod m = d\" \"m > 0\"\n  shows \"(a + b) mod m = (c + d) mod m\"\nproof -\n  have \"c < m\" and \"d < m\"\n    using assms by auto\n  have \"a = c + m * (a div m)\" and \"b = d + m * (b div m)\"\n    using assms by auto\n  have \"a + b = (c + d) + m * (a div m + b div m)\"\n    by (smt (z3) \\<open>a = c + m * (a div m)\\<close> \\<open>b = d + m * (b div m)\\<close> ab_semigroup_add_class.add_ac(1) add.assoc add_mono_thms_linordered_semiring(4) add_mult_distrib2 distrib_left group_cancel.add2)\n  then have \"(a + b) mod m = ((c + d) + m * (a div m + b div m)) mod m\"\n    by simp\n  also have \"... = (c + d) mod m\"\n    using `c < m` `d < m` by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c d m :: nat\n  assumes \"a mod m = c\" \"b mod m = d\" \"m > 0\"\n  shows \"(a + b) mod m = (c + d) mod m\"\nproof -\n  have \"c < m\" and \"d < m\"\n    using assms by auto\n  have \"a = c + m * (a div m)\" and \"b = d + m * (b div m)\"\n    using assms by auto\n  have \"a + b = (c + d) + m * (a div m + b div m)\"\n    by (smt (z3) \\<open>a = c + m * (a div m)\\<close> \\<open>b = d + m * (b div m)\\<close> ab_semigroup_add_class.add_ac(1) add.assoc add_mono_thms_linordered_semiring(4) add_mult_distrib2 distrib_left group_cancel.add2)\n  then have \"(a + b) mod m = ((c + d) + m * (a div m + b div m)) mod m\"\n    by simp\n  also have \"... = (c + d) mod m\"\n    using `c < m` `d < m` by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_add_generalV4": {"skill_name": "mod_add_generalV4", "marker": "lemma mod_add_general:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"b mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  then have \"a mod d + b mod d < 2 * d\" by (metis \\<open>a mod d < d\\<close> add_mono_thms_linordered_field(5) mult.commute mult_2_right)\n  then show ?thesis\n    using assms(1) by (metis mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_add_general:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"b mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  then have \"a mod d + b mod d < 2 * d\" by (metis \\<open>a mod d < d\\<close> add_mono_thms_linordered_field(5) mult.commute mult_2_right)\n  then show ?thesis\n    using assms(1) by (metis mod_add_eq)\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_d_addV3": {"skill_name": "mod_d_addV3", "marker": "lemma mod_d_add:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a + b mod d = (a mod d + b mod d) + (a div d) * d + (b div d) * d mod d\" \n    by (simp add: mod_add_eq)\n  then show ?thesis\n    by (simp add: mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_d_add:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a + b mod d = (a mod d + b mod d) + (a div d) * d + (b div d) * d mod d\" \n    by (simp add: mod_add_eq)\n  then show ?thesis\n    by (simp add: mod_add_eq)\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_add_generalV5": {"skill_name": "mod_add_generalV5", "marker": "lemma mod_add_general:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"b mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"(a + b) mod d = ((a mod d) + (b mod d)) mod d\"\n    by presburger\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add_general:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"b mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"(a + b) mod d = ((a mod d) + (b mod d)) mod d\"\n    by presburger\n  then show ?thesis by simp\nqed", "origin": "mod_10_add", "update_count": 0}, "k_definition": {"skill_name": "k_definition", "marker": "lemma k_definition:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows True\n  by simp", "description": "", "full_code": "lemma k_definition:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows True\n  by simp", "origin": "data/full_data/debug/valid_rand/amc12a_2008_p15.json_v17", "update_count": -1}, "mod_addition_properties": {"skill_name": "mod_addition_properties", "marker": "lemma mod_addition_properties:\n  fixes a b :: nat\n  assumes \"a < 100\" \"b < 100\"\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a + b < 200\" using assms by simp\n  hence \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\" \n    by presburger\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_addition_properties:\n  fixes a b :: nat\n  assumes \"a < 100\" \"b < 100\"\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a + b < 200\" using assms by simp\n  hence \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\" \n    by presburger\n  thus ?thesis by simp\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_addition_general": {"skill_name": "mod_addition_general", "marker": "lemma mod_addition_general:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = (a mod m + b mod m) mod m\"\nproof -\n  have \"a mod m + b mod m < 2 * m\" using assms by (metis add_mono_thms_linordered_field(5) mod_less_divisor mult.commute mult_2_right)\n  hence \"(a + b) mod m = (a mod m + b mod m) mod m\" \n    by presburger\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_addition_general:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = (a mod m + b mod m) mod m\"\nproof -\n  have \"a mod m + b mod m < 2 * m\" using assms by (metis add_mono_thms_linordered_field(5) mod_less_divisor mult.commute mult_2_right)\n  hence \"(a + b) mod m = (a mod m + b mod m) mod m\" \n    by presburger\n  thus ?thesis by simp\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_add_with_bounds": {"skill_name": "mod_add_with_bounds", "marker": "lemma mod_add_with_bounds:\n  fixes a b :: nat\n  assumes \"a < 100\" \"b < 100\"\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a + b < 200\" using assms by simp\n  thus ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_add_with_bounds:\n  fixes a b :: nat\n  assumes \"a < 100\" \"b < 100\"\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a + b < 200\" using assms by simp\n  thus ?thesis by presburger\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_add_extendedV2": {"skill_name": "mod_add_extendedV2", "marker": "lemma mod_add_extended:\n  fixes a b c :: nat\n  assumes \"a < 100\" \"b < 100\" \"c < 10\"\n  shows \"(a + b + c) mod 10 = (a mod 10 + b mod 10 + c) mod 10\"\nproof -\n  have \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\" using mod_add_with_bounds assms(1) assms(2) by blast\n  then show ?thesis by (smt (verit) mod_add_cong)\nqed", "description": "-", "full_code": "lemma mod_add_with_bounds:\n  fixes a b :: nat\n  assumes \"a < 100\" \"b < 100\"\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a + b < 200\" using assms by simp\n  thus ?thesis by presburger\nqed\n\nlemma mod_add_extended:\n  fixes a b c :: nat\n  assumes \"a < 100\" \"b < 100\" \"c < 10\"\n  shows \"(a + b + c) mod 10 = (a mod 10 + b mod 10 + c) mod 10\"\nproof -\n  have \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\" using mod_add_with_bounds assms(1) assms(2) by blast\n  then show ?thesis by (smt (verit) mod_add_cong)\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_square": {"skill_name": "mod_square", "marker": "lemma mod_square:\n  fixes a b m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a^2) mod m = (b^2) mod m\"\nproof -\n  have \"a = m * (a div m) + (a mod m)\" by auto\n  then have \"a = m * (a div m) + b\" using assms by simp\n  then have \"a^2 = (m * (a div m) + b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * b + b^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = (m^2 * (a div m)^2) + (2 * m * (a div m) * b) + b^2\" by (auto simp: field_simps)\n  then show \"(a^2) mod m = (b^2) mod m\" by (metis \\<open>a\\<^sup>2 = (m * (a div m) + b)\\<^sup>2\\<close> mod_mult_cong mod_mult_self4 power2_eq_square)\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a b m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a^2) mod m = (b^2) mod m\"\nproof -\n  have \"a = m * (a div m) + (a mod m)\" by auto\n  then have \"a = m * (a div m) + b\" using assms by simp\n  then have \"a^2 = (m * (a div m) + b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * b + b^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = (m^2 * (a div m)^2) + (2 * m * (a div m) * b) + b^2\" by (auto simp: field_simps)\n  then show \"(a^2) mod m = (b^2) mod m\" by (metis \\<open>a\\<^sup>2 = (m * (a div m) + b)\\<^sup>2\\<close> mod_mult_cong mod_mult_self4 power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "mod_squareV2": {"skill_name": "mod_squareV2", "marker": "lemma mod_square:\n  fixes a m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a^2) mod m = (b^2) mod m\"\nproof -\n  have \"a = m * (a div m) + b\" using assms by auto\n  then have \"a^2 = (m * (a div m) + b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * b + b^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2\" by (auto simp: field_simps)\n  thus ?thesis by (metis \\<open>a\\<^sup>2 = (m * (a div m) + b)\\<^sup>2\\<close> mod_mult_cong mod_mult_self4 power2_eq_square)\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a^2) mod m = (b^2) mod m\"\nproof -\n  have \"a = m * (a div m) + b\" using assms by auto\n  then have \"a^2 = (m * (a div m) + b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * b + b^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2\" by (auto simp: field_simps)\n  thus ?thesis by (metis \\<open>a\\<^sup>2 = (m * (a div m) + b)\\<^sup>2\\<close> mod_mult_cong mod_mult_self4 power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "mod_squareV3": {"skill_name": "mod_squareV3", "marker": "lemma mod_square:\n  fixes a m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a^2) mod m = (b^2) mod m\"\nproof -\n  have \"a = m * (a div m) + (a mod m)\" by auto\n  then have \"a = m * (a div m) + b\" using assms by simp\n  then have \"a^2 = (m * (a div m) + b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * b + b^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2\"\n    by (auto simp: field_simps)\n  then have \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2) mod m\"\n    by (metis calculation modulo_nat_def mult.commute power2_eq_square)\n  have \"m^2 * (a div m)^2 mod m = 0\" \n    by auto\n  have \"2 * m * (a div m) * b mod m = 0\" \n    by auto\n  thus ?thesis \n    by (metis assms mod_mult_eq nat_mod_eq_iff power2_eq_square)\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a^2) mod m = (b^2) mod m\"\nproof -\n  have \"a = m * (a div m) + (a mod m)\" by auto\n  then have \"a = m * (a div m) + b\" using assms by simp\n  then have \"a^2 = (m * (a div m) + b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * b + b^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2\"\n    by (auto simp: field_simps)\n  then have \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2) mod m\"\n    by (metis calculation modulo_nat_def mult.commute power2_eq_square)\n  have \"m^2 * (a div m)^2 mod m = 0\" \n    by auto\n  have \"2 * m * (a div m) * b mod m = 0\" \n    by auto\n  thus ?thesis \n    by (metis assms mod_mult_eq nat_mod_eq_iff power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "mod_10_calculationV3": {"skill_name": "mod_10_calculationV3", "marker": "lemma mod_10_calculation:\n  fixes a b :: nat\n  assumes \"a mod 10 = 4\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 0\"\nproof -\n  have \"a = 10 * (a div 10) + 4\" using assms(1) by presburger\n  have \"b = 10 * (b div 10) + 6\" using assms(2) by presburger\n  then have \"a + b = (10 * (a div 10) + 4) + (10 * (b div 10) + 6)\"\n    by (metis \\<open>a = 10 * (a div 10) + 4\\<close>)\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (4 + 6)\"\n    by simp\n  have \"4 + 6 = 10\" by simp\n  thus ?thesis\n    by (metis \\<open>a + b = 10 * (a div 10 + b div 10) + (4 + 6)\\<close> mod_add_self2 mod_mult_self1_is_0 numeral_plus_numeral semiring_norm(2) semiring_norm(3) semiring_norm(6) semiring_norm(7))\nqed", "description": "-", "full_code": "lemma mod_10_calculation:\n  fixes a b :: nat\n  assumes \"a mod 10 = 4\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 0\"\nproof -\n  have \"a = 10 * (a div 10) + 4\" using assms(1) by presburger\n  have \"b = 10 * (b div 10) + 6\" using assms(2) by presburger\n  then have \"a + b = (10 * (a div 10) + 4) + (10 * (b div 10) + 6)\"\n    by (metis \\<open>a = 10 * (a div 10) + 4\\<close>)\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (4 + 6)\"\n    by simp\n  have \"4 + 6 = 10\" by simp\n  thus ?thesis\n    by (metis \\<open>a + b = 10 * (a div 10 + b div 10) + (4 + 6)\\<close> mod_add_self2 mod_mult_self1_is_0 numeral_plus_numeral semiring_norm(2) semiring_norm(3) semiring_norm(6) semiring_norm(7))\nqed", "origin": "do_request", "update_count": 0}, "mod_n_multiply": {"skill_name": "mod_n_multiply", "marker": "lemma mod_n_multiply:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a * b) mod n = (a mod n * b mod n) mod n\"\n  using assms by (metis mod_mod_trivial mod_mult_left_eq)", "description": "-", "full_code": "lemma mod_n_multiply:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a * b) mod n = (a mod n * b mod n) mod n\"\n  using assms by (metis mod_mod_trivial mod_mult_left_eq)", "origin": "mod_10_add", "update_count": 0}, "mod_add_special_case": {"skill_name": "mod_add_special_case", "marker": "lemma mod_add_special_case:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\n  using mod_add_general by simp", "description": "-", "full_code": "lemma mod_add_general:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = (a mod m + b mod m) mod m\"\n  by presburger\n\nlemma mod_add_special_case:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\n  using mod_add_general by simp", "origin": "mod_10_add", "update_count": 0}, "k_definition_mod": {"skill_name": "k_definition_mod", "marker": "lemma k_definition_mod:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 100 = (2008^2 mod 100 + 2^2008 mod 100) mod 100\"\nproof -\n  have \"k mod 100 = (2008^2 + 2^2008) mod 100\" using assms by blast\n  also have \"... = (2008^2 mod 100 + 2^2008 mod 100) mod 100\" by eval\n  finally show ?thesis by blast\nqed", "description": "-", "full_code": "lemma k_definition_mod:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 100 = (2008^2 mod 100 + 2^2008 mod 100) mod 100\"\nproof -\n  have \"k mod 100 = (2008^2 + 2^2008) mod 100\" using assms by blast\n  also have \"... = (2008^2 mod 100 + 2^2008 mod 100) mod 100\" by eval\n  finally show ?thesis by blast\nqed", "origin": "k_definition", "update_count": 0}, "k_expression_mod": {"skill_name": "k_expression_mod", "marker": "lemma k_expression_mod:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 100 = (2008^2 mod 100 + 2^2008 mod 100) mod 100\"\nproof -\n  have \"k mod 100 = (2008^2 + 2^2008) mod 100\" by (metis add.commute assms mod_add_cong numeral_1_eq_Suc_0 one_eq_numeral_iff push_bit_of_Suc_0)\n  also have \"... = (2008^2 mod 100 + 2^2008 mod 100) mod 100\" by eval\n  finally show ?thesis by blast\nqed", "description": "-", "full_code": "lemma k_expression_mod:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 100 = (2008^2 mod 100 + 2^2008 mod 100) mod 100\"\nproof -\n  have \"k mod 100 = (2008^2 + 2^2008) mod 100\" by (metis add.commute assms mod_add_cong numeral_1_eq_Suc_0 one_eq_numeral_iff push_bit_of_Suc_0)\n  also have \"... = (2008^2 mod 100 + 2^2008 mod 100) mod 100\" by eval\n  finally show ?thesis by blast\nqed", "origin": "k_definition", "update_count": 0}, "k_definition_extended": {"skill_name": "k_definition_extended", "marker": "lemma k_definition_extended:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k > 0\"\n  by (simp add: assms)", "description": "-", "full_code": "lemma k_definition_extended:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k > 0\"\n  by (simp add: assms)", "origin": "k_definition", "update_count": 0}, "mod_10_multV2": {"skill_name": "mod_10_multV2", "marker": "lemma mod_10_mult:\n  fixes a b :: nat\n  shows \"(a * b) mod 10 = ( (a mod 10) * (b mod 10) ) mod 10\"\nproof -\n  have \"(a * b) mod 10 = ((a mod 10) + 10 * (a div 10)) * ((b mod 10) + 10 * (b div 10)) mod 10\"\n    by auto\n  also have \"... = ((a mod 10) * (b mod 10)) mod 10\"\n    by (metis calculation mod_mult_eq)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_10_mult:\n  fixes a b :: nat\n  shows \"(a * b) mod 10 = ( (a mod 10) * (b mod 10) ) mod 10\"\nproof -\n  have \"(a * b) mod 10 = ((a mod 10) + 10 * (a div 10)) * ((b mod 10) + 10 * (b div 10)) mod 10\"\n    by auto\n  also have \"... = ((a mod 10) * (b mod 10)) mod 10\"\n    by (metis calculation mod_mult_eq)\n  finally show ?thesis by simp\nqed", "origin": "mod_10_add", "update_count": 0}, "k_mod_10": {"skill_name": "k_mod_10", "marker": "lemma k_mod_10:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = (2008^2 + 2^2008) mod 10\" \n    by (metis assms mod_add_cong) \n  also have \"... = (2008^2 mod 10 + 2^2008 mod 10) mod 10\" \n    by eval\n  finally show ?thesis \n    by blast\nqed", "description": "-", "full_code": "lemma k_mod_10:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = (2008^2 + 2^2008) mod 10\" \n    by (metis assms mod_add_cong) \n  also have \"... = (2008^2 mod 10 + 2^2008 mod 10) mod 10\" \n    by eval\n  finally show ?thesis \n    by blast\nqed", "origin": "do_request", "update_count": 0}, "k_definition_generalized": {"skill_name": "k_definition_generalized", "marker": "lemma k_definition_generalized:\n  fixes k n :: nat\n  assumes \"k = n^2 + 2^n\"\n  shows \"k mod 10 = (n^2 + 2^n) mod 10\"\nproof -\n  have \"k mod 10 = (n^2 mod 10 + 2^n mod 10) mod 10\"\n    by (metis assms mod_add_cong mod_mod_trivial power2_eq_square)\n  then show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma k_definition_generalized:\n  fixes k n :: nat\n  assumes \"k = n^2 + 2^n\"\n  shows \"k mod 10 = (n^2 + 2^n) mod 10\"\nproof -\n  have \"k mod 10 = (n^2 mod 10 + 2^n mod 10) mod 10\"\n    by (metis assms mod_add_cong mod_mod_trivial power2_eq_square)\n  then show ?thesis by presburger\nqed", "origin": "k_definition", "update_count": 0}, "mod_d_addV4": {"skill_name": "mod_d_addV4", "marker": "lemma mod_d_add:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"b mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"(a mod d + b mod d) mod d < 2 * d\" \n    by (metis add_strict_increasing2 assms less_eq_nat.simps(1) mod_add_left_eq mod_add_right_eq mod_less_divisor mult.commute mult_2_right)\n  hence \"(a + b) mod d = ((a mod d + b mod d) + (a - a mod d) + (b - b mod d)) mod d\"\n    by (simp add: mod_add_eq)\n  thus ?thesis \n    by (simp add: mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_d_add:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"b mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  have \"(a mod d + b mod d) mod d < 2 * d\" \n    by (metis add_strict_increasing2 assms less_eq_nat.simps(1) mod_add_left_eq mod_add_right_eq mod_less_divisor mult.commute mult_2_right)\n  hence \"(a + b) mod d = ((a mod d + b mod d) + (a - a mod d) + (b - b mod d)) mod d\"\n    by (simp add: mod_add_eq)\n  thus ?thesis \n    by (simp add: mod_add_eq)\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_n_addV5": {"skill_name": "mod_n_addV5", "marker": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\nproof -\n  have \"a + b = (a mod n) + (b mod n) + n * (a div n + b div n)\"\n    by (auto simp: field_simps)\n  then show ?thesis\n    by (simp add: mod_add_right_eq)\nqed", "description": "-", "full_code": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\nproof -\n  have \"a + b = (a mod n) + (b mod n) + n * (a div n + b div n)\"\n    by (auto simp: field_simps)\n  then show ?thesis\n    by (simp add: mod_add_right_eq)\nqed", "origin": "mod_10_add", "update_count": 0}, "units_digit_of_sum": {"skill_name": "units_digit_of_sum", "marker": "lemma units_digit_of_sum:\n  fixes x y :: nat\n  shows \"(x + y) mod 10 = ((x mod 10) + (y mod 10)) mod 10\"\nproof -\n  let ?m_x = \"x mod 10\"\n  let ?m_y = \"y mod 10\"\n  have \"x = 10 * (x div 10) + ?m_x\" by auto\n  have \"y = 10 * (y div 10) + ?m_y\" by auto\n  have \"x + y = (10 * (x div 10) + ?m_x) + (10 * (y div 10) + ?m_y)\" \n    by (metis \\<open>x = 10 * (x div 10) + ?m_x\\<close> \\<open>y = 10 * (y div 10) + ?m_y\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + (?m_x + ?m_y)\" \n    by (simp add: algebra_simps)\n  have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + (?m_x + ?m_y)) mod 10\" \n    by (metis \\<open>x + y = 10 * ((x div 10) + (y div 10)) + (?m_x + ?m_y)\\<close> semiring_norm(3))\n  also have \"... = (?m_x + ?m_y) mod 10\" \n    by (metis mod_mult_self4)\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\" \n    by auto\n  finally show ?thesis \n    by presburger\nqed", "description": "-", "full_code": "lemma units_digit_of_sum:\n  fixes x y :: nat\n  shows \"(x + y) mod 10 = ((x mod 10) + (y mod 10)) mod 10\"\nproof -\n  let ?m_x = \"x mod 10\"\n  let ?m_y = \"y mod 10\"\n  have \"x = 10 * (x div 10) + ?m_x\" by auto\n  have \"y = 10 * (y div 10) + ?m_y\" by auto\n  have \"x + y = (10 * (x div 10) + ?m_x) + (10 * (y div 10) + ?m_y)\" \n    by (metis \\<open>x = 10 * (x div 10) + ?m_x\\<close> \\<open>y = 10 * (y div 10) + ?m_y\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + (?m_x + ?m_y)\" \n    by (simp add: algebra_simps)\n  have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + (?m_x + ?m_y)) mod 10\" \n    by (metis \\<open>x + y = 10 * ((x div 10) + (y div 10)) + (?m_x + ?m_y)\\<close> semiring_norm(3))\n  also have \"... = (?m_x + ?m_y) mod 10\" \n    by (metis mod_mult_self4)\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\" \n    by auto\n  finally show ?thesis \n    by presburger\nqed", "origin": "do_request", "update_count": 0}, "mod_10_calculationV4": {"skill_name": "mod_10_calculationV4", "marker": "lemma mod_10_calculation:\n  fixes a b :: nat\n  assumes \"a mod 10 = 4\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 0\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by presburger\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by presburger\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by simp\n  have \"?m_a + ?m_b = 4 + 6\" using assms by simp\n  have \"?m_a + ?m_b = 10\" by (metis assms(1) assms(2) numeral_eq_Suc numeral_plus_numeral semiring_norm(2) semiring_norm(3) semiring_norm(6) semiring_norm(7))\n  thus ?thesis\n    by presburger\nqed", "description": "-", "full_code": "lemma mod_10_calculation:\n  fixes a b :: nat\n  assumes \"a mod 10 = 4\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 0\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" using assms(1) by presburger\n  have \"b = 10 * (b div 10) + ?m_b\" using assms(2) by presburger\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by simp\n  have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by simp\n  have \"?m_a + ?m_b = 4 + 6\" using assms by simp\n  have \"?m_a + ?m_b = 10\" by (metis assms(1) assms(2) numeral_eq_Suc numeral_plus_numeral semiring_norm(2) semiring_norm(3) semiring_norm(6) semiring_norm(7))\n  thus ?thesis\n    by presburger\nqed", "origin": "do_request", "update_count": 0}, "combine_modV8": {"skill_name": "combine_modV8", "marker": "lemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\n  using assms mod_10_add by auto", "description": "-", "full_code": "lemma mod_10_add:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\n  by presburger\n\nlemma combine_mod:\n  fixes a b :: nat\n  assumes \"a mod 10 = x\" \"b mod 10 = y\"\n  shows \"(a + b) mod 10 = (x + y) mod 10\"\n  using assms mod_10_add by auto", "origin": "mod_10_add", "update_count": 0}, "mod_10_addV2": {"skill_name": "mod_10_addV2", "marker": "lemma mod_10_add:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a = 10 * (a div 10) + (a mod 10)\" and \"b = 10 * (b div 10) + (b mod 10)\"\n    by auto\n  then have \"a + b = 10 * (a div 10 + b div 10) + (a mod 10 + b mod 10)\" by simp\n  then show ?thesis by (metis mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_10_add:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a = 10 * (a div 10) + (a mod 10)\" and \"b = 10 * (b div 10) + (b mod 10)\"\n    by auto\n  then have \"a + b = 10 * (a div 10 + b div 10) + (a mod 10 + b mod 10)\" by simp\n  then show ?thesis by (metis mod_add_eq)\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_10_add_combined": {"skill_name": "mod_10_add_combined", "marker": "lemma mod_10_add_combined:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a = 10 * (a div 10) + (a mod 10)\" by auto\n  have \"b = 10 * (b div 10) + (b mod 10)\" by auto\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + ((a mod 10) + (b mod 10))\" by simp\n  thus ?thesis by (metis mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_10_add_combined:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a = 10 * (a div 10) + (a mod 10)\" by auto\n  have \"b = 10 * (b div 10) + (b mod 10)\" by auto\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + ((a mod 10) + (b mod 10))\" by simp\n  thus ?thesis by (metis mod_add_eq)\nqed", "origin": "mod_10_add", "update_count": 0}, "combine_mod_resultsV6": {"skill_name": "combine_mod_resultsV6", "marker": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  have \"x = 10 * (x div 10) + 0\" using assms(1) by auto\n  have \"y = 10 * (y div 10) + 6\" using assms(2) by presburger\n  have \"x + y = (10 * (x div 10) + 0) + (10 * (y div 10) + 6)\"\n    by (metis \\<open>x = 10 * (x div 10) + 0\\<close> \\<open>y = 10 * (y div 10) + 6\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + 6\"\n    by (simp add: algebra_simps)\n  have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + 6) mod 10\"\n    by (metis \\<open>x + y = 10 * (x div 10 + y div 10) + 6\\<close> semiring_norm(3))\n  also have \"... = 6 mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod_results:\n  fixes x y :: nat\n  assumes \"x mod 10 = 0\" and \"y mod 10 = 6\"\n  shows \"(x + y) mod 10 = 6\"\nproof -\n  have \"x = 10 * (x div 10) + 0\" using assms(1) by auto\n  have \"y = 10 * (y div 10) + 6\" using assms(2) by presburger\n  have \"x + y = (10 * (x div 10) + 0) + (10 * (y div 10) + 6)\"\n    by (metis \\<open>x = 10 * (x div 10) + 0\\<close> \\<open>y = 10 * (y div 10) + 6\\<close>)\n  then have \"x + y = 10 * ((x div 10) + (y div 10)) + 6\"\n    by (simp add: algebra_simps)\n  have \"(x + y) mod 10 = (10 * ((x div 10) + (y div 10)) + 6) mod 10\"\n    by (metis \\<open>x + y = 10 * (x div 10 + y div 10) + 6\\<close> semiring_norm(3))\n  also have \"... = 6 mod 10\"\n    by (metis mod_mult_self4)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_10_multV3": {"skill_name": "mod_10_multV3", "marker": "lemma mod_10_mult:\n  fixes a b :: nat\n  shows \"(a * b) mod 10 = (a mod 10 * b mod 10) mod 10\"\nproof -\n  have \"a * b = (10 * (a div 10) + (a mod 10)) * (10 * (b div 10) + (b mod 10))\"\n    by (simp add: nat_mult_distrib)\n  then have \"(a * b) mod 10 = ((a mod 10) * (b mod 10)) mod 10\"\n    by (metis mod_mult_eq)\n  thus ?thesis by (metis mod_mod_trivial mod_mult_left_eq)\nqed", "description": "-", "full_code": "lemma mod_10_mult:\n  fixes a b :: nat\n  shows \"(a * b) mod 10 = (a mod 10 * b mod 10) mod 10\"\nproof -\n  have \"a * b = (10 * (a div 10) + (a mod 10)) * (10 * (b div 10) + (b mod 10))\"\n    by (simp add: nat_mult_distrib)\n  then have \"(a * b) mod 10 = ((a mod 10) * (b mod 10)) mod 10\"\n    by (metis mod_mult_eq)\n  thus ?thesis by (metis mod_mod_trivial mod_mult_left_eq)\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_10_multiplication": {"skill_name": "mod_10_multiplication", "marker": "lemma mod_10_multiplication:\n  fixes a b :: nat\n  shows \"(a * b) mod 10 = ((a mod 10) * (b mod 10)) mod 10\"\nproof -\n  have \"a * b = (10 * (a div 10) + (a mod 10)) * (10 * (b div 10) + (b mod 10))\" by auto\n  then have \"(a * b) mod 10 = ((a mod 10) * (b mod 10)) mod 10\" by (metis mod_mult_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_10_multiplication:\n  fixes a b :: nat\n  shows \"(a * b) mod 10 = ((a mod 10) * (b mod 10)) mod 10\"\nproof -\n  have \"a * b = (10 * (a div 10) + (a mod 10)) * (10 * (b div 10) + (b mod 10))\" by auto\n  then have \"(a * b) mod 10 = ((a mod 10) * (b mod 10)) mod 10\" by (metis mod_mult_eq)\n  thus ?thesis by simp\nqed", "origin": "mod_10_add", "update_count": 0}, "k_modular_properties": {"skill_name": "k_modular_properties", "marker": "lemma k_modular_properties:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = (2008^2 + 2^2008) mod 10\"\n    using assms by blast\n  also have \"... = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\n    by eval\n  finally show \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\" by blast\nqed", "description": "-", "full_code": "lemma k_modular_properties:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = (2008^2 + 2^2008) mod 10\"\n    using assms by blast\n  also have \"... = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\n    by eval\n  finally show \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\" by blast\nqed", "origin": "k_definition", "update_count": 0}, "mod_squareV4": {"skill_name": "mod_squareV4", "marker": "lemma mod_square:\n  fixes a m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a^2) mod m = (b^2) mod m\"\nproof -\n  have \"a = m * (a div m) + (a mod m)\" by simp\n  then have \"a = m * (a div m) + b\" using assms by simp\n  then have \"a^2 = (m * (a div m) + b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * b + b^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2\"\n    by (auto simp: field_simps)\n  have \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2) mod m\"\n    by (metis \\<open>(m * (a div m))\\<^sup>2 + 2 * (m * (a div m)) * b + b\\<^sup>2 = m\\<^sup>2 * (a div m)\\<^sup>2 + 2 * m * (a div m) * b + b\\<^sup>2\\<close> calculation modulo_nat_def mult.commute power2_eq_square)\n  have \"m^2 * (a div m)^2 mod m = 0\"\n    by (simp add: nat_mod_eq_iff)\n  have \"2 * m * (a div m) * b mod m = 0\"\n    by (simp add: nat_mod_eq_iff)\n  thus ?thesis\n    by (metis assms mod_mult_eq nat_mod_eq_iff power2_eq_square)\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a^2) mod m = (b^2) mod m\"\nproof -\n  have \"a = m * (a div m) + (a mod m)\" by simp\n  then have \"a = m * (a div m) + b\" using assms by simp\n  then have \"a^2 = (m * (a div m) + b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * b + b^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2\"\n    by (auto simp: field_simps)\n  have \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2) mod m\"\n    by (metis \\<open>(m * (a div m))\\<^sup>2 + 2 * (m * (a div m)) * b + b\\<^sup>2 = m\\<^sup>2 * (a div m)\\<^sup>2 + 2 * m * (a div m) * b + b\\<^sup>2\\<close> calculation modulo_nat_def mult.commute power2_eq_square)\n  have \"m^2 * (a div m)^2 mod m = 0\"\n    by (simp add: nat_mod_eq_iff)\n  have \"2 * m * (a div m) * b mod m = 0\"\n    by (simp add: nat_mod_eq_iff)\n  thus ?thesis\n    by (metis assms mod_mult_eq nat_mod_eq_iff power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "mod_squareV5": {"skill_name": "mod_squareV5", "marker": "lemma mod_square:\n  fixes a b m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a^2) mod m = (b^2) mod m\"\nproof -\n  have \"a = m * (a div m) + (a mod m)\" by (simp add: nat_mod_eq_iff)\n  then have \"a = m * (a div m) + b\" using assms by simp\n  then have \"a^2 = (m * (a div m) + b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * b + b^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2\"\n    by (simp add: field_simps)\n  have \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2) mod m\" \n    by (metis \\<open>(m * (a div m))\\<^sup>2 + 2 * (m * (a div m)) * b + b\\<^sup>2 = m\\<^sup>2 * (a div m)\\<^sup>2 + 2 * m * (a div m) * b + b\\<^sup>2\\<close> calculation modulo_nat_def mult.commute power2_eq_square)\n  have \"m^2 * (a div m)^2 mod m = 0\" by auto\n  have \"2 * m * (a div m) * b mod m = 0\" by auto\n  thus ?thesis \n    by (metis assms mod_mult_eq nat_mod_eq_iff power2_eq_square)\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a b m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a^2) mod m = (b^2) mod m\"\nproof -\n  have \"a = m * (a div m) + (a mod m)\" by (simp add: nat_mod_eq_iff)\n  then have \"a = m * (a div m) + b\" using assms by simp\n  then have \"a^2 = (m * (a div m) + b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * b + b^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2\"\n    by (simp add: field_simps)\n  have \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * b + b^2) mod m\" \n    by (metis \\<open>(m * (a div m))\\<^sup>2 + 2 * (m * (a div m)) * b + b\\<^sup>2 = m\\<^sup>2 * (a div m)\\<^sup>2 + 2 * m * (a div m) * b + b\\<^sup>2\\<close> calculation modulo_nat_def mult.commute power2_eq_square)\n  have \"m^2 * (a div m)^2 mod m = 0\" by auto\n  have \"2 * m * (a div m) * b mod m = 0\" by auto\n  thus ?thesis \n    by (metis assms mod_mult_eq nat_mod_eq_iff power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "mod_squareV6": {"skill_name": "mod_squareV6", "marker": "lemma mod_square:\n  fixes a m :: nat\n  shows \"(a^2) mod m = ((a mod m) ^ 2) mod m\"\nproof -\n  let ?b = \"a mod m\"\n  have \"a = m * (a div m) + ?b\" by (simp add: nat_mod_eq_iff)\n  then have \"a^2 = (m * (a div m) + ?b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * ?b + ?b^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * ?b + ?b^2\"\n    by (simp add: field_simps)\n  then have \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * ?b + ?b^2) mod m\"\n    by (metis calculation modulo_nat_def mult.commute power2_eq_square)\n  have \"m^2 * (a div m)^2 mod m = 0\" \n    by (simp add: nat_mod_eq_iff)\n  have \"2 * m * (a div m) * ?b mod m = 0\" \n    by (simp add: nat_mod_eq_iff)\n  have \"?b^2 mod m = (?b^2) mod m\" by simp\n  thus ?thesis \n    by (metis power_mod)\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a m :: nat\n  shows \"(a^2) mod m = ((a mod m) ^ 2) mod m\"\nproof -\n  let ?b = \"a mod m\"\n  have \"a = m * (a div m) + ?b\" by (simp add: nat_mod_eq_iff)\n  then have \"a^2 = (m * (a div m) + ?b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * ?b + ?b^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * ?b + ?b^2\"\n    by (simp add: field_simps)\n  then have \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * ?b + ?b^2) mod m\"\n    by (metis calculation modulo_nat_def mult.commute power2_eq_square)\n  have \"m^2 * (a div m)^2 mod m = 0\" \n    by (simp add: nat_mod_eq_iff)\n  have \"2 * m * (a div m) * ?b mod m = 0\" \n    by (simp add: nat_mod_eq_iff)\n  have \"?b^2 mod m = (?b^2) mod m\" by simp\n  thus ?thesis \n    by (metis power_mod)\nqed", "origin": "do_request", "update_count": 0}, "mod_squareV7": {"skill_name": "mod_squareV7", "marker": "lemma mod_square:\n  fixes a m :: nat\n  shows \"(a^2) mod m = ((a mod m) ^ 2) mod m\"\nproof -\n  let ?b = \"a mod m\"\n  have \"a = m * (a div m) + ?b\" by (simp add: nat_mod_eq_iff)\n  then have \"a^2 = (m * (a div m) + ?b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * ?b + ?b^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * ?b + ?b^2\" \n    by (simp add: field_simps)\n  then have \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * ?b + ?b^2) mod m\" \n    by (metis ab_semigroup_mult_class.mult_ac(1) add.commute add_cancel_left_right group_cancel.add1 group_cancel.add2 mod_add_cong mod_mult_eq mod_mult_self1_is_0 mod_mult_self2 mult.left_commute mult_is_0 power2_eq_square power_mod power_mult_distrib)\n  have \"m^2 * (a div m)^2 mod m = 0\" \n    by (simp add: nat_mod_eq_iff)\n  have \"2 * m * (a div m) * ?b mod m = 0\" \n    by (simp add: nat_mod_eq_iff)\n  thus ?thesis \n    by (metis mod_mult_eq nat_mod_eq_iff power2_eq_square)\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a m :: nat\n  shows \"(a^2) mod m = ((a mod m) ^ 2) mod m\"\nproof -\n  let ?b = \"a mod m\"\n  have \"a = m * (a div m) + ?b\" by (simp add: nat_mod_eq_iff)\n  then have \"a^2 = (m * (a div m) + ?b)^2\" by simp\n  also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * ?b + ?b^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * ?b + ?b^2\" \n    by (simp add: field_simps)\n  then have \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * ?b + ?b^2) mod m\" \n    by (metis ab_semigroup_mult_class.mult_ac(1) add.commute add_cancel_left_right group_cancel.add1 group_cancel.add2 mod_add_cong mod_mult_eq mod_mult_self1_is_0 mod_mult_self2 mult.left_commute mult_is_0 power2_eq_square power_mod power_mult_distrib)\n  have \"m^2 * (a div m)^2 mod m = 0\" \n    by (simp add: nat_mod_eq_iff)\n  have \"2 * m * (a div m) * ?b mod m = 0\" \n    by (simp add: nat_mod_eq_iff)\n  thus ?thesis \n    by (metis mod_mult_eq nat_mod_eq_iff power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "k_mod_10V2": {"skill_name": "k_mod_10V2", "marker": "lemma k_mod_10:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = (2008^2 + 2^2008) mod 10\"\n    using assms by blast\n  also have \"... = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\n    by (metis (no_types, lifting) add.commute mod_add_eq mod_eq_0_iff_dvd)\n  finally show ?thesis by blast\nqed", "description": "-", "full_code": "lemma k_mod_10:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = (2008^2 + 2^2008) mod 10\"\n    using assms by blast\n  also have \"... = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\n    by (metis (no_types, lifting) add.commute mod_add_eq mod_eq_0_iff_dvd)\n  finally show ?thesis by blast\nqed", "origin": "do_request", "update_count": 0}, "mod_n_addV6": {"skill_name": "mod_n_addV6", "marker": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\nproof -\n  have \"a + b = (a mod n) + (b mod n) + n * (a div n + b div n)\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod n = ((a mod n) + (b mod n) + n * (a div n + b div n)) mod n\"\n    by (simp add: assms)\n  then show ?thesis using mod_add_eq by auto\nqed", "description": "-", "full_code": "lemma mod_n_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = (a mod n + b mod n) mod n\"\nproof -\n  have \"a + b = (a mod n) + (b mod n) + n * (a div n + b div n)\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod n = ((a mod n) + (b mod n) + n * (a div n + b div n)) mod n\"\n    by (simp add: assms)\n  then show ?thesis using mod_add_eq by auto\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_n_power": {"skill_name": "mod_n_power", "marker": "lemma mod_n_power:\n  fixes a n k :: nat\n  assumes \"n > 0\" \"k > 0\"\n  shows \"(a ^ k) mod n = (a mod n) ^ k mod n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  then have \"a ^ Suc k = a * (a ^ k)\" by simp\n  also have \"(a * (a ^ k)) mod n = (a mod n * (a ^ k mod n)) mod n\" using assms by (metis mod_mult_eq)\n  also have \"... = (a mod n * (a mod n) ^ k) mod n\" by (metis Suc \\<open>a * a ^ k mod n = a mod n * (a ^ k mod n) mod n\\<close> \\<open>a ^ Suc k = a * a ^ k\\<close> mod_mult_cong mod_mult_left_eq power_Suc)\n  also have \"... = ((a mod n) ^ Suc k) mod n\" by (simp add: mod_n_mult)\n  finally show ?case by simp\nqed", "description": "-", "full_code": "lemma mod_n_mult:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a * b) mod n = (a mod n * b mod n) mod n\"\n  using assms by (metis mod_mod_trivial mod_mult_left_eq)\n\nlemma mod_n_power:\n  fixes a n k :: nat\n  assumes \"n > 0\" \"k > 0\"\n  shows \"(a ^ k) mod n = (a mod n) ^ k mod n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  then have \"a ^ Suc k = a * (a ^ k)\" by simp\n  also have \"(a * (a ^ k)) mod n = (a mod n * (a ^ k mod n)) mod n\" using assms by (metis mod_mult_eq)\n  also have \"... = (a mod n * (a mod n) ^ k) mod n\" by (metis Suc \\<open>a * a ^ k mod n = a mod n * (a ^ k mod n) mod n\\<close> \\<open>a ^ Suc k = a * a ^ k\\<close> mod_mult_cong mod_mult_left_eq power_Suc)\n  also have \"... = ((a mod n) ^ Suc k) mod n\" by (simp add: mod_n_mult)\n  finally show ?case by simp\nqed", "origin": "mod_10_add", "update_count": 0}, "units_digit_sum": {"skill_name": "units_digit_sum", "marker": "lemma units_digit_sum:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\"\n    by auto\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" by auto\n  have \"b = 10 * (b div 10) + ?m_b\" by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by (metis \\<open>a = 10 * (a div 10) + ?m_a\\<close> \\<open>b = 10 * (b div 10) + ?m_b\\<close>)\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by (simp add: algebra_simps)\n  have \"(a + b) mod 10 = (10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)) mod 10\"\n    by (metis \\<open>a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\\<close> semiring_norm(3))\n  also have \"... = (?m_a + ?m_b) mod 10\"\n    by (metis mod_mult_self4)\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n    by auto\n  finally show ?thesis \n    by presburger\nqed", "description": "-", "full_code": "lemma units_digit_sum:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"a mod 10 < 10\" and \"b mod 10 < 10\"\n    by auto\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" by auto\n  have \"b = 10 * (b div 10) + ?m_b\" by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\"\n    by (metis \\<open>a = 10 * (a div 10) + ?m_a\\<close> \\<open>b = 10 * (b div 10) + ?m_b\\<close>)\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\"\n    by (simp add: algebra_simps)\n  have \"(a + b) mod 10 = (10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)) mod 10\"\n    by (metis \\<open>a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\\<close> semiring_norm(3))\n  also have \"... = (?m_a + ?m_b) mod 10\"\n    by (metis mod_mult_self4)\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n    by auto\n  finally show ?thesis \n    by presburger\nqed", "origin": "do_request", "update_count": 0}, "units_digit_sumV2": {"skill_name": "units_digit_sumV2", "marker": "lemma units_digit_sum:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\n    by presburger\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma units_digit_sum:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10) mod 10\"\nproof -\n  have \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\n    by presburger\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_addV6": {"skill_name": "mod_addV6", "marker": "lemma mod_add:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" by auto\n  have \"b = 10 * (b div 10) + ?m_b\" by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\" \n    by (metis \\<open>a = 10 * (a div 10) + ?m_a\\<close> \\<open>b = 10 * (b div 10) + ?m_b\\<close>)\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\" \n    by (simp add: algebra_simps)\n  have \"(a + b) mod 10 = (10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)) mod 10\" \n    by (metis \\<open>a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\\<close> semiring_norm(3))\n  also have \"... = (?m_a + ?m_b) mod 10\" \n    by (metis mod_mult_self4)\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\" \n    by auto\n  finally show ?thesis \n    by presburger\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  let ?m_a = \"a mod 10\"\n  let ?m_b = \"b mod 10\"\n  have \"a = 10 * (a div 10) + ?m_a\" by auto\n  have \"b = 10 * (b div 10) + ?m_b\" by auto\n  have \"a + b = (10 * (a div 10) + ?m_a) + (10 * (b div 10) + ?m_b)\" \n    by (metis \\<open>a = 10 * (a div 10) + ?m_a\\<close> \\<open>b = 10 * (b div 10) + ?m_b\\<close>)\n  then have \"a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\" \n    by (simp add: algebra_simps)\n  have \"(a + b) mod 10 = (10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)) mod 10\" \n    by (metis \\<open>a + b = 10 * ((a div 10) + (b div 10)) + (?m_a + ?m_b)\\<close> semiring_norm(3))\n  also have \"... = (?m_a + ?m_b) mod 10\" \n    by (metis mod_mult_self4)\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\" \n    by auto\n  finally show ?thesis \n    by presburger\nqed", "origin": "do_request", "update_count": 0}, "k_definition_generalizedV2": {"skill_name": "k_definition_generalizedV2", "marker": "lemma k_definition_generalized:\n  fixes k :: nat\n  fixes a b :: nat\n  assumes \"k = a^2 + b^a\"\n  shows True\n  by simp", "description": "-", "full_code": "lemma k_definition_generalized:\n  fixes k :: nat\n  fixes a b :: nat\n  assumes \"k = a^2 + b^a\"\n  shows True\n  by simp", "origin": "k_definition", "update_count": 0}, "k_definition_extendedV2": {"skill_name": "k_definition_extendedV2", "marker": "lemma k_definition_extended:\n  fixes k :: nat and d :: nat\n  assumes \"d > 0\" and \"k = 2008^2 + 2^2008\"\n  shows \"k mod d \\<in> {0..d-1}\"\nproof -\n  have \"k = 2008^2 + 2^2008\" by (rule assms(2))\n  hence \"k \\<ge> 0\" by simp\n  have \"k mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma k_definition_extended:\n  fixes k :: nat and d :: nat\n  assumes \"d > 0\" and \"k = 2008^2 + 2^2008\"\n  shows \"k mod d \\<in> {0..d-1}\"\nproof -\n  have \"k = 2008^2 + 2^2008\" by (rule assms(2))\n  hence \"k \\<ge> 0\" by simp\n  have \"k mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  then show ?thesis by auto\nqed", "origin": "k_definition", "update_count": 0}, "k_definition_extendedV3": {"skill_name": "k_definition_extendedV3", "marker": "lemma k_definition_extended:\n  fixes k :: nat\n  assumes \"k = n^2 + m^n\"  \n  shows \"k > 0\"  \nproof -\n  have \"n^2 >= 0\" by simp  \n  moreover have \"m^n >= 0\" by simp  \n  ultimately show ?thesis by (metis add_is_0 assms less_numeral_extra(3) nat_1_add_1 nat_zero_less_power_iff power_eq_0_iff zero_less_iff_neq_zero)\nqed", "description": "-", "full_code": "lemma k_definition_extended:\n  fixes k :: nat\n  assumes \"k = n^2 + m^n\"  \n  shows \"k > 0\"  \nproof -\n  have \"n^2 >= 0\" by simp  \n  moreover have \"m^n >= 0\" by simp  \n  ultimately show ?thesis by (metis add_is_0 assms less_numeral_extra(3) nat_1_add_1 nat_zero_less_power_iff power_eq_0_iff zero_less_iff_neq_zero)\nqed", "origin": "k_definition", "update_count": 0}, "mod_m_add": {"skill_name": "mod_m_add", "marker": "lemma mod_m_add:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = (a mod m + b mod m) mod m\"\nproof -\n  have \"a + b = (a mod m) + (b mod m) + m * ((a div m) + (b div m))\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod m = ((a mod m) + (b mod m) + m * ((a div m) + (b div m))) mod m\"\n    by simp\n  also have \"... = ((a mod m) + (b mod m)) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_m_add:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = (a mod m + b mod m) mod m\"\nproof -\n  have \"a + b = (a mod m) + (b mod m) + m * ((a div m) + (b div m))\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod m = ((a mod m) + (b mod m) + m * ((a div m) + (b div m))) mod m\"\n    by simp\n  also have \"... = ((a mod m) + (b mod m)) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_10_power": {"skill_name": "mod_10_power", "marker": "lemma mod_10_power:\n  fixes a :: nat\n  assumes \"a > 0\"\n  shows \"(a ^ n) mod 10 = (a mod 10) ^ n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a ^ Suc n = a * (a ^ n)\" by simp\n  then show ?case \n    using Suc.IH by (metis power_mod)\nqed", "description": "-", "full_code": "lemma mod_10_power:\n  fixes a :: nat\n  assumes \"a > 0\"\n  shows \"(a ^ n) mod 10 = (a mod 10) ^ n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a ^ Suc n = a * (a ^ n)\" by simp\n  then show ?case \n    using Suc.IH by (metis power_mod)\nqed", "origin": "mod_10_add", "update_count": 0}, "square_modV6": {"skill_name": "square_modV6", "marker": "lemma square_mod:\n  fixes x :: nat\n  shows \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\nproof -\n  let ?m = \"x mod 10\"\n  have \"x = 10 * (x div 10) + ?m\" \n    by (auto)\n  have \"(x^2) mod 10 = ((10 * (x div 10) + ?m)^2) mod 10\"\n    by simp\n  have \"((10 * (x div 10) + ?m)^2) = (10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?m + ?m^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  thus ?thesis\n  proof -\n    have \"((10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?m + ?m^2) mod 10 = (?m^2) mod 10\"\n      by (smt (verit) \\<open>(10 * (x div 10) + x mod 10)\\<^sup>2 = (10 * (x div 10))\\<^sup>2 + 2 * (10 * (x div 10)) * (x mod 10) + (x mod 10)\\<^sup>2\\<close> \\<open>x = 10 * (x div 10) + x mod 10\\<close> power_mod)\n    also have \"... = ?m^2 mod 10\"\n      by (simp)\n    finally show ?thesis\n      by (metis power_mod)\n  qed\nqed", "description": "-", "full_code": "lemma square_mod:\n  fixes x :: nat\n  shows \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\nproof -\n  let ?m = \"x mod 10\"\n  have \"x = 10 * (x div 10) + ?m\" \n    by (auto)\n  have \"(x^2) mod 10 = ((10 * (x div 10) + ?m)^2) mod 10\"\n    by simp\n  have \"((10 * (x div 10) + ?m)^2) = (10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?m + ?m^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  thus ?thesis\n  proof -\n    have \"((10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?m + ?m^2) mod 10 = (?m^2) mod 10\"\n      by (smt (verit) \\<open>(10 * (x div 10) + x mod 10)\\<^sup>2 = (10 * (x div 10))\\<^sup>2 + 2 * (10 * (x div 10)) * (x mod 10) + (x mod 10)\\<^sup>2\\<close> \\<open>x = 10 * (x div 10) + x mod 10\\<close> power_mod)\n    also have \"... = ?m^2 mod 10\"\n      by (simp)\n    finally show ?thesis\n      by (metis power_mod)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_modV7": {"skill_name": "square_modV7", "marker": "lemma square_mod:\n  fixes x :: nat\n  shows \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\nproof -\n  let ?m = \"x mod 10\"\n  have \"x = 10 * (x div 10) + ?m\" \n    by (auto)\n  have \"(x^2) mod 10 = ((10 * (x div 10) + ?m)^2) mod 10\"\n    by simp\n  have \"((10 * (x div 10) + ?m)^2) = (10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?m + ?m^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  have \"(10 * (x div 10))^2 mod 10 = 0\"\n    by (simp add: mod_mult_self4)\n  have \"2 * (10 * (x div 10)) * ?m mod 10 = 0\"\n    by (simp add: mod_mult_self4)\n  thus ?thesis\n  proof -\n    have \"((10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?m + ?m^2) mod 10 = (?m^2) mod 10\"\n      by (metis \\<open>(10 * (x div 10) + x mod 10)\\<^sup>2 = (10 * (x div 10))\\<^sup>2 + 2 * (10 * (x div 10)) * (x mod 10) + (x mod 10)\\<^sup>2\\<close> \\<open>x = 10 * (x div 10) + x mod 10\\<close> power2_eq_square power_mod semiring_norm(3))\n    also have \"... = ?m^2 mod 10\"\n      by (simp)\n    finally show ?thesis\n      by (metis power_mod)\n  qed\nqed", "description": "-", "full_code": "lemma square_mod:\n  fixes x :: nat\n  shows \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\nproof -\n  let ?m = \"x mod 10\"\n  have \"x = 10 * (x div 10) + ?m\" \n    by (auto)\n  have \"(x^2) mod 10 = ((10 * (x div 10) + ?m)^2) mod 10\"\n    by simp\n  have \"((10 * (x div 10) + ?m)^2) = (10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?m + ?m^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  have \"(10 * (x div 10))^2 mod 10 = 0\"\n    by (simp add: mod_mult_self4)\n  have \"2 * (10 * (x div 10)) * ?m mod 10 = 0\"\n    by (simp add: mod_mult_self4)\n  thus ?thesis\n  proof -\n    have \"((10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?m + ?m^2) mod 10 = (?m^2) mod 10\"\n      by (metis \\<open>(10 * (x div 10) + x mod 10)\\<^sup>2 = (10 * (x div 10))\\<^sup>2 + 2 * (10 * (x div 10)) * (x mod 10) + (x mod 10)\\<^sup>2\\<close> \\<open>x = 10 * (x div 10) + x mod 10\\<close> power2_eq_square power_mod semiring_norm(3))\n    also have \"... = ?m^2 mod 10\"\n      by (simp)\n    finally show ?thesis\n      by (metis power_mod)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "k_definition_in_different_dimensions": {"skill_name": "k_definition_in_different_dimensions", "marker": "lemma k_definition_in_different_dimensions:\n  fixes k :: nat and d :: nat\n  assumes \"k = 2008^d + 2^(2008 * d)\"\n  shows \"k + 1 = (2008^d + 1) + 2^(2008 * d)\"\n  by (metis ab_semigroup_add_class.add_ac(1) add.commute add_diff_cancel_left' add_left_imp_eq assms eq_diff_iff group_cancel.add1 le_add1 le_add2 le_iff_add mult.commute one_add_one semiring_norm(3) semiring_norm(5))", "description": "-", "full_code": "lemma k_definition_in_different_dimensions:\n  fixes k :: nat and d :: nat\n  assumes \"k = 2008^d + 2^(2008 * d)\"\n  shows \"k + 1 = (2008^d + 1) + 2^(2008 * d)\"\n  by (metis ab_semigroup_add_class.add_ac(1) add.commute add_diff_cancel_left' add_left_imp_eq assms eq_diff_iff group_cancel.add1 le_add1 le_add2 le_iff_add mult.commute one_add_one semiring_norm(3) semiring_norm(5))", "origin": "k_definition", "update_count": 0}, "k_definition_extendedV4": {"skill_name": "k_definition_extendedV4", "marker": "lemma k_definition_extended:\n  fixes k :: nat and d :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k + d = (2008^2 + d) + 2^2008\"\n  by (smt (verit) Nat.add_0_right add.commute add.left_commute add_left_imp_eq assms zero_power2)", "description": "-", "full_code": "lemma k_definition_extended:\n  fixes k :: nat and d :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k + d = (2008^2 + d) + 2^2008\"\n  by (smt (verit) Nat.add_0_right add.commute add.left_commute add_left_imp_eq assms zero_power2)", "origin": "k_definition", "update_count": 0}, "k_definition_extendedV5": {"skill_name": "k_definition_extendedV5", "marker": "lemma k_definition_extended:\n  fixes k :: nat and d :: nat\n  assumes \"k = 2008^2 + 2^2008\" \n  shows \"k mod d = (2008^2 mod d + 2^2008 mod d) mod d\"\nproof -\n  have \"k mod d = (2008^2 + 2^2008) mod d\" by (simp add: assms)\n  also have \"... = ((2008^2 mod d) + (2^2008 mod d)) mod d\"\n    by presburger\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma k_definition_extended:\n  fixes k :: nat and d :: nat\n  assumes \"k = 2008^2 + 2^2008\" \n  shows \"k mod d = (2008^2 mod d + 2^2008 mod d) mod d\"\nproof -\n  have \"k mod d = (2008^2 + 2^2008) mod d\" by (simp add: assms)\n  also have \"... = ((2008^2 mod d) + (2^2008 mod d)) mod d\"\n    by presburger\n  finally show ?thesis .\nqed", "origin": "k_definition", "update_count": 0}, "square_modV8": {"skill_name": "square_modV8", "marker": "lemma square_mod:\n  fixes x :: nat\n  shows \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\nproof -\n  let ?m = \"x mod 10\"\n  have \"x = 10 * (x div 10) + ?m\" by auto\n  then have \"x^2 = (10 * (x div 10) + ?m)^2\" by simp\n  also have \"... = (10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?m + ?m^2\" \n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (x div 10)^2 + 20 * (x div 10) * ?m + ?m^2\" \n    by (simp add: power_mult_distrib)\n  finally have \"x^2 mod 10 = (?m^2) mod 10\" \n    by (metis power_mod)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_mod:\n  fixes x :: nat\n  shows \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\nproof -\n  let ?m = \"x mod 10\"\n  have \"x = 10 * (x div 10) + ?m\" by auto\n  then have \"x^2 = (10 * (x div 10) + ?m)^2\" by simp\n  also have \"... = (10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?m + ?m^2\" \n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (x div 10)^2 + 20 * (x div 10) * ?m + ?m^2\" \n    by (simp add: power_mult_distrib)\n  finally have \"x^2 mod 10 = (?m^2) mod 10\" \n    by (metis power_mod)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "k_definition_extendedV6": {"skill_name": "k_definition_extendedV6", "marker": "lemma k_definition_extended:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\n    by (smt (verit) assms mod_add_eq)\n  thus ?thesis by blast\nqed", "description": "-", "full_code": "lemma k_definition_extended:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\n    by (smt (verit) assms mod_add_eq)\n  thus ?thesis by blast\nqed", "origin": "k_definition", "update_count": 0}, "k_definition_generalizedV3": {"skill_name": "k_definition_generalizedV3", "marker": "lemma k_definition_generalized:\n  fixes k d :: nat\n  assumes \"k = d^2 + 2^d\"\n  shows \"k mod d = (2^d) mod d\"\nproof -\n  have \"k = d^2 + 2^d\" by (simp add: assms)\n  hence \"k mod d = (d^2 mod d + 2^d mod d) mod d\" \n    by (metis mod_add_eq) \n  also have \"d^2 mod d = 0\" by auto\n  hence \"k mod d = (0 + 2^d mod d) mod d\"\n    by (metis Suc_1 calculation)\n  finally show ?thesis by (smt (verit) \\<open>d\\<^sup>2 mod d = 0\\<close> \\<open>k mod d = (d\\<^sup>2 mod d + 2 ^ d mod d) mod d\\<close> add_cancel_left_left mod_mod_trivial)\nqed", "description": "-", "full_code": "lemma k_definition_generalized:\n  fixes k d :: nat\n  assumes \"k = d^2 + 2^d\"\n  shows \"k mod d = (2^d) mod d\"\nproof -\n  have \"k = d^2 + 2^d\" by (simp add: assms)\n  hence \"k mod d = (d^2 mod d + 2^d mod d) mod d\" \n    by (metis mod_add_eq) \n  also have \"d^2 mod d = 0\" by auto\n  hence \"k mod d = (0 + 2^d mod d) mod d\"\n    by (metis Suc_1 calculation)\n  finally show ?thesis by (smt (verit) \\<open>d\\<^sup>2 mod d = 0\\<close> \\<open>k mod d = (d\\<^sup>2 mod d + 2 ^ d mod d) mod d\\<close> add_cancel_left_left mod_mod_trivial)\nqed", "origin": "k_definition", "update_count": 0}, "square_mod_10V4": {"skill_name": "square_mod_10V4", "marker": "lemma square_mod_10:\n  fixes x :: nat\n  shows \"(x mod 10)^2 mod 10 = (x^2 mod 10)\"\n  by (metis power_mod)", "description": "", "full_code": "lemma square_mod_10:\n  fixes x :: nat\n  shows \"(x mod 10)^2 mod 10 = (x^2 mod 10)\"\n  by (metis power_mod)", "origin": "data/full_data/debug/valid_rand/amc12a_2008_p15.json_v40", "update_count": -1}, "modulo_property": {"skill_name": "modulo_property", "marker": "lemma modulo_property:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  have \"(a + b) mod 10 = (a mod 10 + b mod 10 + (a div 10 + b div 10) * 10) mod 10\"\n    by presburger\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\"\n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma modulo_property:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  have \"(a + b) mod 10 = (a mod 10 + b mod 10 + (a div 10 + b div 10) * 10) mod 10\"\n    by presburger\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\"\n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "square_mod_10V4", "update_count": 0}, "k_definition_extendedV7": {"skill_name": "k_definition_extendedV7", "marker": "lemma k_definition_extended:\n  fixes k :: nat\n  assumes \"k = a^2 + b^c\" and \"a > 0\" and \"b > 0\" and \"c > 0\"\n  shows True\n  by simp", "description": "-", "full_code": "lemma k_definition_extended:\n  fixes k :: nat\n  assumes \"k = a^2 + b^c\" and \"a > 0\" and \"b > 0\" and \"c > 0\"\n  shows True\n  by simp", "origin": "k_definition", "update_count": 0}, "square_mod_k": {"skill_name": "square_mod_k", "marker": "lemma square_mod_k:\n  fixes x k :: nat\n  assumes \"k > 0\"\n  shows \"(x mod k)^2 mod k = (x^2 mod k)\"\n  using assms\n  by (metis power_mod)", "description": "-", "full_code": "lemma square_mod_k:\n  fixes x k :: nat\n  assumes \"k > 0\"\n  shows \"(x mod k)^2 mod k = (x^2 mod k)\"\n  using assms\n  by (metis power_mod)", "origin": "square_mod_10V4", "update_count": 0}, "mod_add_generalV6": {"skill_name": "mod_add_generalV6", "marker": "lemma mod_add_general:\n  fixes a b c m :: nat\n  assumes \"a mod m = c\" \"b mod m = d\"\n  shows \"(a + b) mod m = (c + d) mod m\"\nproof -\n  have \"a + b = (a mod m) + (b mod m) + m * (a div m + b div m)\" \n    using assms by (auto simp: field_simps)\n  then show ?thesis\n    by (metis assms(1) assms(2) mod_add_cong mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_add_general:\n  fixes a b c m :: nat\n  assumes \"a mod m = c\" \"b mod m = d\"\n  shows \"(a + b) mod m = (c + d) mod m\"\nproof -\n  have \"a + b = (a mod m) + (b mod m) + m * (a div m + b div m)\" \n    using assms by (auto simp: field_simps)\n  then show ?thesis\n    by (metis assms(1) assms(2) mod_add_cong mod_add_eq)\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_add_with_difference": {"skill_name": "mod_add_with_difference", "marker": "lemma mod_add_with_difference:\n  fixes a b c m :: nat\n  assumes \"a mod m = c\" \"b mod m = d\"\n  shows \"(a + b) mod m = (c + d) mod m\"\n  using assms by (metis mod_add_cong mod_add_eq)", "description": "-", "full_code": "lemma mod_add_with_difference:\n  fixes a b c m :: nat\n  assumes \"a mod m = c\" \"b mod m = d\"\n  shows \"(a + b) mod m = (c + d) mod m\"\n  using assms by (metis mod_add_cong mod_add_eq)", "origin": "mod_10_add", "update_count": 0}, "mod_add_with_properties": {"skill_name": "mod_add_with_properties", "marker": "lemma mod_add_with_properties:\n  fixes a b c m :: nat\n  assumes \"a mod m = c\" \"b mod m = d\" \"c + d < m\"\n  shows \"(a + b) mod m = c + d\"\nproof -\n  obtain k1 k2 where \"a = c + k1 * m\" \"b = d + k2 * m\" by (metis assms(1) assms(2) mod_mult_div_eq mult.commute)\n  have \"(a + b) mod m = (c + k1 * m + d + k2 * m) mod m\" by (smt (verit) One_nat_def Suc_diff_eq_diff_pred \\<open>a = c + k1 * m\\<close> assms(2) diff_Suc_1 le_add1 le_add_same_cancel1 le_numeral_extra(3) mod_add_eq mod_add_left_eq mod_add_right_eq mod_mult_self2_is_0 ordered_cancel_comm_monoid_diff_class.diff_add_assoc ordered_cancel_comm_monoid_diff_class.diff_diff_right verit_sum_simplify zero_less_one)\n  also have \"... = (c + d + (k1 + k2) * m) mod m\" by (auto simp: field_simps)\n  finally show ?thesis using assms(3) by simp\nqed", "description": "-", "full_code": "lemma mod_add_with_properties:\n  fixes a b c m :: nat\n  assumes \"a mod m = c\" \"b mod m = d\" \"c + d < m\"\n  shows \"(a + b) mod m = c + d\"\nproof -\n  obtain k1 k2 where \"a = c + k1 * m\" \"b = d + k2 * m\" by (metis assms(1) assms(2) mod_mult_div_eq mult.commute)\n  have \"(a + b) mod m = (c + k1 * m + d + k2 * m) mod m\" by (smt (verit) One_nat_def Suc_diff_eq_diff_pred \\<open>a = c + k1 * m\\<close> assms(2) diff_Suc_1 le_add1 le_add_same_cancel1 le_numeral_extra(3) mod_add_eq mod_add_left_eq mod_add_right_eq mod_mult_self2_is_0 ordered_cancel_comm_monoid_diff_class.diff_add_assoc ordered_cancel_comm_monoid_diff_class.diff_diff_right verit_sum_simplify zero_less_one)\n  also have \"... = (c + d + (k1 + k2) * m) mod m\" by (auto simp: field_simps)\n  finally show ?thesis using assms(3) by simp\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_add_generalV7": {"skill_name": "mod_add_generalV7", "marker": "lemma mod_add_general:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = (a mod m + b mod m) mod m\"\nproof -\n  have \"a = (a mod m) + (m * (a div m))\" and \"b = (b mod m) + (m * (b div m))\"\n    by auto\n  then have \"a + b = (a mod m + b mod m) + m * ((a div m) + (b div m))\" by (auto simp: field_simps)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_general:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = (a mod m + b mod m) mod m\"\nproof -\n  have \"a = (a mod m) + (m * (a div m))\" and \"b = (b mod m) + (m * (b div m))\"\n    by auto\n  then have \"a + b = (a mod m + b mod m) + m * ((a div m) + (b div m))\" by (auto simp: field_simps)\n  thus ?thesis by auto\nqed", "origin": "mod_10_add", "update_count": 0}, "mod_n_addV7": {"skill_name": "mod_n_addV7", "marker": "lemma mod_n_add:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d + b mod d < d + d\" by (metis add_strict_mono assms mod_less_divisor)\n  then show ?thesis \n    by presburger\nqed", "description": "-", "full_code": "lemma mod_n_add:\n  fixes a b d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = (a mod d + b mod d) mod d\"\nproof -\n  have \"a mod d + b mod d < d + d\" by (metis add_strict_mono assms mod_less_divisor)\n  then show ?thesis \n    by presburger\nqed", "origin": "mod_10_add", "update_count": 0}, "k_definition_extendedV8": {"skill_name": "k_definition_extendedV8", "marker": "lemma k_definition_extended:\n  fixes k :: nat and d :: nat\n  assumes \"d > 0\" and \"k = 2008^2 + d^2008\"\n  shows True\n  by simp", "description": "-", "full_code": "lemma k_definition:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows True\n  by simp\n\nlemma k_definition_extended:\n  fixes k :: nat and d :: nat\n  assumes \"d > 0\" and \"k = 2008^2 + d^2008\"\n  shows True\n  by simp", "origin": "k_definition", "update_count": 0}, "k_definition_extendedV9": {"skill_name": "k_definition_extendedV9", "marker": "lemma k_definition_extended:\n  fixes k :: nat\n  assumes \"k = n^2 + 2^n\" and \"n > 0\"\n  shows \"k = n^2 + 2^n\"\n  by (metis assms(1))", "description": "-", "full_code": "lemma k_definition_extended:\n  fixes k :: nat\n  assumes \"k = n^2 + 2^n\" and \"n > 0\"\n  shows \"k = n^2 + 2^n\"\n  by (metis assms(1))", "origin": "k_definition", "update_count": 0}, "square_mod_10_properties": {"skill_name": "square_mod_10_properties", "marker": "lemma square_mod_10_properties:\n  fixes x y :: nat\n  shows \"((x + y) mod n)^2 mod n = ((x mod n + y mod n) mod n)^2 mod n\"\n  by (metis mod_add_eq)", "description": "-", "full_code": "lemma square_mod_10_properties:\n  fixes x y :: nat\n  shows \"((x + y) mod n)^2 mod n = ((x mod n + y mod n) mod n)^2 mod n\"\n  by (metis mod_add_eq)", "origin": "square_mod_10V4", "update_count": 0}, "k_mod_10_evolved": {"skill_name": "k_mod_10_evolved", "marker": "lemma k_mod_10_evolved:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = ((2008^2 mod 10) + (2^2008 mod 10)) mod 10\"\n    using assms square_mod_10_general by presburger\n  thus ?thesis by blast\nqed", "description": "-", "full_code": "lemma square_mod_10_general:\n  fixes x :: nat\n  shows \"(x mod 10)^2 mod 10 = (x^2 mod 10)\"\n  by (metis power_mod)\n\nlemma k_mod_10_evolved:\n  fixes k :: nat\n  assumes \"k = 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = ((2008^2 mod 10) + (2^2008 mod 10)) mod 10\"\n    using assms square_mod_10_general by presburger\n  thus ?thesis by blast\nqed", "origin": "square_mod_10V4", "update_count": 0}}
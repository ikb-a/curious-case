{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "multi_distrib_complex_general": {"skill_name": "multi_distrib_complex_general", "marker": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a * c + a * d + b * c + b * d) + (e * c + e * d + f * c + f * d)\"\n    by (auto simp: field_simps)\n  also have \"... = ((a + e) * c + (a + e) * d) + ((b + f) * c + (b + f) * d)\"\n    by (auto simp: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a * c + a * d + b * c + b * d) + (e * c + e * d + f * c + f * d)\"\n    by (auto simp: field_simps)\n  also have \"... = ((a + e) * c + (a + e) * d) + ((b + f) * c + (b + f) * d)\"\n    by (auto simp: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib_complex_generalV2": {"skill_name": "multi_distrib_complex_generalV2", "marker": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  assumes \"a + b = e\" \"c + d = f\"\n  shows \"(a + b) * (c + d) = e * f\"\nproof -\n  have \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\" \n    by (simp add: distrib_left distrib_right)\n  also have \"... = (a + b) * (c + d)\" by (auto simp: field_simps)\n  finally show ?thesis by (metis assms(1) assms(2))\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  assumes \"a + b = e\" \"c + d = f\"\n  shows \"(a + b) * (c + d) = e * f\"\nproof -\n  have \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\" \n    by (simp add: distrib_left distrib_right)\n  also have \"... = (a + b) * (c + d)\" by (auto simp: field_simps)\n  finally show ?thesis by (metis assms(1) assms(2))\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "mod_add_power_general": {"skill_name": "mod_add_power_general", "marker": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b) mod n = (x mod n + b) mod n\"\n    by (simp add: mod_add_left_eq)\n  then have \"((x + b)^c) mod n = ((x mod n + b)^c) mod n\" by (smt (verit) power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b) mod n = (x mod n + b) mod n\"\n    by (simp add: mod_add_left_eq)\n  then have \"((x + b)^c) mod n = ((x mod n + b)^c) mod n\" by (smt (verit) power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_generalV2": {"skill_name": "mod_add_power_generalV2", "marker": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b) mod n)^c = ((a + b) mod n)^c\"\nproof -\n  have \"(x + b) mod n = (x mod n + b) mod n\"\n    by (simp add: mod_add_left_eq)\n  then have \"((x + b) mod n)^c = ((a + b) mod n)^c\"\n    using assms(4) by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b) mod n)^c = ((a + b) mod n)^c\"\nproof -\n  have \"(x + b) mod n = (x mod n + b) mod n\"\n    by (simp add: mod_add_left_eq)\n  then have \"((x + b) mod n)^c = ((a + b) mod n)^c\"\n    using assms(4) by auto\n  thus ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_generalV3": {"skill_name": "mod_add_power_generalV3", "marker": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"x mod n = a\" by (simp add: assms(4))\n  then have \"(x + b) mod n = (a + b) mod n\"\n    by (smt (verit) mod_add_left_eq)\n  then show ?thesis\n    by (metis add.commute power_mod)\nqed", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"x mod n = a\" by (simp add: assms(4))\n  then have \"(x + b) mod n = (a + b) mod n\"\n    by (smt (verit) mod_add_left_eq)\n  then show ?thesis\n    by (metis add.commute power_mod)\nqed", "origin": "mod_add_power", "update_count": 0}, "log_base_change": {"skill_name": "log_base_change", "marker": "lemma log_base_change:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"b \\<noteq> 1\"\n  shows \"log b (a) = log a (a) / log a (b)\"\nproof -\n  have \"log b (a) = log a (a) / log a (b)\"\n    by (metis assms(1) assms(2) log_base_change)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma log_base_change:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"b \\<noteq> 1\"\n  shows \"log b (a) = log a (a) / log a (b)\"\nproof -\n  have \"log b (a) = log a (a) / log a (b)\"\n    by (metis assms(1) assms(2) log_base_change)\n  thus ?thesis by simp\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "log_base_power_generalized": {"skill_name": "log_base_power_generalized", "marker": "lemma log_base_power_generalized:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then show ?thesis \n    by (metis assms(1) assms(2) log_pow_cancel)\nqed", "description": "-", "full_code": "lemma log_base_power_generalized:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then show ?thesis \n    by (metis assms(1) assms(2) log_pow_cancel)\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "multi_distrib_complex_advanced": {"skill_name": "multi_distrib_complex_advanced", "marker": "lemma multi_distrib_complex_advanced:\n  fixes a b c d e f :: complex\n  assumes \"c + d \\<noteq> 0\" \n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"((a + b) + (e + f)) * (c + d) = (a + e + b + f) * (c + d)\"\n    by (simp add: algebra_simps)\n  also have \"... = (a + e) * (c + d) + (b + f) * (c + d)\"\n    using assms by (simp add: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_advanced:\n  fixes a b c d e f :: complex\n  assumes \"c + d \\<noteq> 0\" \n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"((a + b) + (e + f)) * (c + d) = (a + e + b + f) * (c + d)\"\n    by (simp add: algebra_simps)\n  also have \"... = (a + e) * (c + d) + (b + f) * (c + d)\"\n    using assms by (simp add: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex_general", "update_count": 0}, "multi_distrib_complex_refined": {"skill_name": "multi_distrib_complex_refined", "marker": "lemma multi_distrib_complex_refined:\n  fixes a b c d e f g h :: complex\n  assumes \"g = a + e\" \"h = b + f\"\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = g * (c + d) + h * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a * c + a * d + b * c + b * d) + (e * c + e * d + f * c + f * d)\"\n    by (auto simp: field_simps)\n  also have \"... = (g * c + g * d) + (h * c + h * d)\"\n    using assms by (auto simp: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_refined:\n  fixes a b c d e f g h :: complex\n  assumes \"g = a + e\" \"h = b + f\"\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = g * (c + d) + h * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) + (e + f) * (c + d) = (a * c + a * d + b * c + b * d) + (e * c + e * d + f * c + f * d)\"\n    by (auto simp: field_simps)\n  also have \"... = (g * c + g * d) + (h * c + h * d)\"\n    using assms by (auto simp: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex_general", "update_count": 0}, "multi_distrib_complex_special": {"skill_name": "multi_distrib_complex_special", "marker": "lemma multi_distrib_complex_special:\n  fixes a b c d e f g :: complex\n  assumes \"g = c + d\"\n  shows \"(a + b) * g + (e + f) * g = (a + e) * g + (b + f) * g\"\nproof -\n  have \"(a + b) * g + (e + f) * g = (a * g + b * g) + (e * g + f * g)\"\n    by (auto simp: field_simps)\n  also have \"... = ((a + e) * g) + ((b + f) * g)\"\n    using assms by (simp add: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_special:\n  fixes a b c d e f g :: complex\n  assumes \"g = c + d\"\n  shows \"(a + b) * g + (e + f) * g = (a + e) * g + (b + f) * g\"\nproof -\n  have \"(a + b) * g + (e + f) * g = (a * g + b * g) + (e * g + f * g)\"\n    by (auto simp: field_simps)\n  also have \"... = ((a + e) * g) + ((b + f) * g)\"\n    using assms by (simp add: field_simps)\n  finally show ?thesis .\nqed", "origin": "multi_distrib_complex_general", "update_count": 0}, "multi_distrib_complex_generalV3": {"skill_name": "multi_distrib_complex_generalV3", "marker": "lemma multi_distrib_complex_general:\n  fixes a b :: complex\n  assumes \"finite A\" \"finite B\"\n  shows \"(\\<Sum>i\\<in>A. a * i) * (\\<Sum>j\\<in>B. b * j) = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. (a * i) * (b * j))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. a * i) * (\\<Sum>j\\<in>B. b * j) = (\\<Sum>i\\<in>A. (\\<Sum>j\\<in>B. (a * i) * (b * j)))\"\n    by (metis sum_product)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_general:\n  fixes a b :: complex\n  assumes \"finite A\" \"finite B\"\n  shows \"(\\<Sum>i\\<in>A. a * i) * (\\<Sum>j\\<in>B. b * j) = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. (a * i) * (b * j))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. a * i) * (\\<Sum>j\\<in>B. b * j) = (\\<Sum>i\\<in>A. (\\<Sum>j\\<in>B. (a * i) * (b * j)))\"\n    by (metis sum_product)\n  then show ?thesis by simp\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib_complex_extended": {"skill_name": "multi_distrib_complex_extended", "marker": "lemma multi_distrib_complex_extended:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"((a + b) + (e + f)) * (c + d) = (a + e + b + f) * (c + d)\"\n    by simp\n  then show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_extended:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"((a + b) + (e + f)) * (c + d) = (a + e + b + f) * (c + d)\"\n    by simp\n  then show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "mod_add_power_of_variables": {"skill_name": "mod_add_power_of_variables", "marker": "lemma mod_add_power_of_variables:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_generalized[of x n a b c]\n  by (smt (verit) assms(1) assms(2) assms(3) assms(4) mod_add_power_generalized)", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"x mod n = a\" by (simp add: assms(4))\n  then have \"(x + b) mod n = (a + b) mod n\"\n    by (smt (verit) mod_add_left_eq)\n  then show ?thesis\n    by (metis add.commute power_mod)\nqed\n\nlemma mod_add_power_of_variables:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_generalized[of x n a b c]\n  by (smt (verit) assms(1) assms(2) assms(3) assms(4) mod_add_power_generalized)", "origin": "mod_add_power_generalV3", "update_count": 0}, "mod_add_power_specialized": {"skill_name": "mod_add_power_specialized", "marker": "theorem mod_add_power_specialized:\n  fixes x n b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = 0\"\n  shows \"((x + b)^c) mod n = (b^c) mod n\"\nproof -\n  let ?a = \"0\"\n  have \"((x + b)^c) mod n = ((?a + b)^c) mod n\" \n    using assms by (simp add: mod_add_power_generalized)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"x mod n = a\" by (simp add: assms(4))\n  then have \"(x + b) mod n = (a + b) mod n\"\n    by (smt (verit) mod_add_left_eq)\n  then show ?thesis\n    by (metis add.commute power_mod)\nqed\n\ntheorem mod_add_power_specialized:\n  fixes x n b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = 0\"\n  shows \"((x + b)^c) mod n = (b^c) mod n\"\nproof -\n  let ?a = \"0\"\n  have \"((x + b)^c) mod n = ((?a + b)^c) mod n\" \n    using assms by (simp add: mod_add_power_generalized)\n  thus ?thesis by simp\nqed", "origin": "mod_add_power_generalV3", "update_count": 0}, "basic_arithmetic_mod": {"skill_name": "basic_arithmetic_mod", "marker": "lemma basic_arithmetic_mod:\n  fixes a b m :: int\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"a mod m = a - m * (a div m)\" by (auto simp: field_simps)\n  have \"b mod m = b - m * (b div m)\" by (auto simp: field_simps)\n  then have \"((a mod m) + (b mod m)) mod m = ((a - m * (a div m)) + (b - m * (b div m))) mod m\"\n    by (metis minus_mult_div_eq_mod)\n  also have \"... = (a + b - m * ((a div m) + (b div m))) mod m\"\n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by presburger\nqed", "description": "-", "full_code": "lemma basic_arithmetic_mod:\n  fixes a b m :: int\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"a mod m = a - m * (a div m)\" by (auto simp: field_simps)\n  have \"b mod m = b - m * (b div m)\" by (auto simp: field_simps)\n  then have \"((a mod m) + (b mod m)) mod m = ((a - m * (a div m)) + (b - m * (b div m))) mod m\"\n    by (metis minus_mult_div_eq_mod)\n  also have \"... = (a + b - m * ((a div m) + (b div m))) mod m\"\n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by presburger\nqed", "origin": "do_request", "update_count": 0}, "basic_arithmetic_modV2": {"skill_name": "basic_arithmetic_modV2", "marker": "lemma basic_arithmetic_mod:\n  fixes a b :: int\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"a mod m = a - (a div m) * m\" by (auto simp: field_simps)\n  have \"b mod m = b - (b div m) * m\" by (auto simp: field_simps)\n  have \"((a mod m) + (b mod m)) mod m = (a - (a div m) * m + b - (b div m) * m) mod m\"\n    by (metis diff_add_eq diff_diff_eq diff_diff_eq2 group_cancel.sub1 int_distrib(1) int_distrib(2) minus_div_mult_eq_mod minus_mult_div_eq_mod mult.commute)\n  also have \"... = (a + b - ((a div m) + (b div m)) * m) mod m\"\n    by (simp add: algebra_simps)\n  finally have \"((a mod m) + (b mod m)) mod m = (a + b - ((a div m) + (b div m)) * m) mod m\" .\n  have \"(a + b) mod m = (a + b - (a div m + b div m) * m) mod m\"\n    by (smt (verit) \\<open>(a mod m + b mod m) mod m = (a + b - (a div m + b div m) * m) mod m\\<close> mod_add_eq)\n  thus ?thesis\n    using `((a mod m) + (b mod m)) mod m = (a + b - ((a div m) + (b div m)) * m) mod m`\n    by auto\nqed", "description": "-", "full_code": "lemma basic_arithmetic_mod:\n  fixes a b :: int\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"a mod m = a - (a div m) * m\" by (auto simp: field_simps)\n  have \"b mod m = b - (b div m) * m\" by (auto simp: field_simps)\n  have \"((a mod m) + (b mod m)) mod m = (a - (a div m) * m + b - (b div m) * m) mod m\"\n    by (metis diff_add_eq diff_diff_eq diff_diff_eq2 group_cancel.sub1 int_distrib(1) int_distrib(2) minus_div_mult_eq_mod minus_mult_div_eq_mod mult.commute)\n  also have \"... = (a + b - ((a div m) + (b div m)) * m) mod m\"\n    by (simp add: algebra_simps)\n  finally have \"((a mod m) + (b mod m)) mod m = (a + b - ((a div m) + (b div m)) * m) mod m\" .\n  have \"(a + b) mod m = (a + b - (a div m + b div m) * m) mod m\"\n    by (smt (verit) \\<open>(a mod m + b mod m) mod m = (a + b - (a div m + b div m) * m) mod m\\<close> mod_add_eq)\n  thus ?thesis\n    using `((a mod m) + (b mod m)) mod m = (a + b - ((a div m) + (b div m)) * m) mod m`\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "case_analysis_modulo_4": {"skill_name": "case_analysis_modulo_4", "marker": "lemma case_analysis_modulo_4:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" by (simp add: mod_less)\n  then have \"a mod 4 \\<in> {0, 1, 2, 3}\" \n    by auto\n  thus ?thesis \n    by (cases \"a mod 4\") auto\nqed", "description": "-", "full_code": "lemma case_analysis_modulo_4:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" by (simp add: mod_less)\n  then have \"a mod 4 \\<in> {0, 1, 2, 3}\" \n    by auto\n  thus ?thesis \n    by (cases \"a mod 4\") auto\nqed", "origin": "do_request", "update_count": 0}, "cancel_div": {"skill_name": "cancel_div", "marker": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by (simp add: field_simps)\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  have \"x * (b / x) = b\"\n    using assms(1) by (simp add: divide_simps)\n  then have \"x * a + b = c * x\"\n    by (smt (verit) \\<open>x * a + x * (b / x) = c * x\\<close>)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by (simp add: field_simps)\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  have \"x * (b / x) = b\"\n    using assms(1) by (simp add: divide_simps)\n  then have \"x * a + b = c * x\"\n    by (smt (verit) \\<open>x * a + x * (b / x) = c * x\\<close>)\n  thus ?thesis by sos\nqed", "origin": "do_request", "update_count": 0}, "cancel_divV2": {"skill_name": "cancel_divV2", "marker": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" \n    using assms(2) by (auto)\n  then have \"x * a + x * (b / x) = c * x\" \n    by (simp add: distrib_left)\n  then have \"x * a + b = c * x\" \n    using assms(1) by (simp add: mult.commute)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" \n    using assms(2) by (auto)\n  then have \"x * a + x * (b / x) = c * x\" \n    by (simp add: distrib_left)\n  then have \"x * a + b = c * x\" \n    using assms(1) by (simp add: mult.commute)\n  thus ?thesis by sos\nqed", "origin": "do_request", "update_count": 0}, "cancel_divV3": {"skill_name": "cancel_divV3", "marker": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by (simp)\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then have \"x * a + b = c * x\"\n    by (metis add.commute assms(1) divide_divide_eq_left' divide_divide_eq_right divide_less_eq_1_pos divide_self_if less_numeral_extra(1) mult.commute mult.right_neutral real_divide_square_eq times_divide_eq_left times_divide_eq_right verit_comp_simplify1(1))\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by (simp)\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then have \"x * a + b = c * x\"\n    by (metis add.commute assms(1) divide_divide_eq_left' divide_divide_eq_right divide_less_eq_1_pos divide_self_if less_numeral_extra(1) mult.commute mult.right_neutral real_divide_square_eq times_divide_eq_left times_divide_eq_right verit_comp_simplify1(1))\n  thus ?thesis by sos\nqed", "origin": "do_request", "update_count": 0}, "multi_distrib_complexV2": {"skill_name": "multi_distrib_complexV2", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\n    by (simp add: distrib_right)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\n    by (simp add: distrib_right)\n  then show ?thesis by simp\nqed", "origin": "multi_distrib_complex_extended", "update_count": 0}, "multi_distrib_complexV3": {"skill_name": "multi_distrib_complexV3", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\nproof -\n  have \"a * (c + d) + b * (c + d) = (a + b) * (c + d)\"\n    by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\nproof -\n  have \"a * (c + d) + b * (c + d) = (a + b) * (c + d)\"\n    by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "origin": "multi_distrib_complex_extended", "update_count": 0}, "case_analysis_modulo_4V2": {"skill_name": "case_analysis_modulo_4V2", "marker": "lemma case_analysis_modulo_4:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" \n    by auto\n  moreover have \"a mod 4 \\<ge> 0\" \n    by auto\n  ultimately have \"a mod 4 \\<in> {0, 1, 2, 3}\" \n    by auto\n  thus ?thesis \n    by (auto)\nqed", "description": "-", "full_code": "lemma case_analysis_modulo_4:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" \n    by auto\n  moreover have \"a mod 4 \\<ge> 0\" \n    by auto\n  ultimately have \"a mod 4 \\<in> {0, 1, 2, 3}\" \n    by auto\n  thus ?thesis \n    by (auto)\nqed", "origin": "do_request", "update_count": 0}, "case_analysis_modulo_4V3": {"skill_name": "case_analysis_modulo_4V3", "marker": "lemma case_analysis_modulo_4:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"\\<exists>r. a = 4 * (a div 4) + r \\<and> r < 4\"\n    by presburger\n  then obtain r where r_def: \"a = 4 * (a div 4) + r\" and r_lt: \"r < 4\" by auto\n  then have \"r = 0 \\<or> r = 1 \\<or> r = 2 \\<or> r = 3\"\n  proof -\n    have \"r < 4\" by (metis r_lt)\n    moreover have \"r \\<ge> 0\" \n      using r_def by auto\n    ultimately show ?thesis\n      by auto\n  qed\n  thus ?thesis\n    using r_def by auto\nqed", "description": "-", "full_code": "lemma case_analysis_modulo_4:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"\\<exists>r. a = 4 * (a div 4) + r \\<and> r < 4\"\n    by presburger\n  then obtain r where r_def: \"a = 4 * (a div 4) + r\" and r_lt: \"r < 4\" by auto\n  then have \"r = 0 \\<or> r = 1 \\<or> r = 2 \\<or> r = 3\"\n  proof -\n    have \"r < 4\" by (metis r_lt)\n    moreover have \"r \\<ge> 0\" \n      using r_def by auto\n    ultimately show ?thesis\n      by auto\n  qed\n  thus ?thesis\n    using r_def by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_square": {"skill_name": "mod_square", "marker": "lemma mod_square:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\nproof -\n  assume \"a mod 4 = 0\"\n  then obtain k where \"a = 4 * k\" by auto\n  then have \"a^2 = (4 * k)^2\" \n    by auto\n  hence \"a^2 = 16 * k^2\" \n    by (simp add: power2_eq_square)\n  then have \"a^2 mod 4 = (16 * k^2) mod 4\" \n    by auto\n  also have \"(16 * k^2) mod 4 = 0\" \n    by (simp add: mod_mult_self2) \n  finally show \"a^2 mod 4 = 0\" .\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\nproof -\n  assume \"a mod 4 = 0\"\n  then obtain k where \"a = 4 * k\" by auto\n  then have \"a^2 = (4 * k)^2\" \n    by auto\n  hence \"a^2 = 16 * k^2\" \n    by (simp add: power2_eq_square)\n  then have \"a^2 mod 4 = (16 * k^2) mod 4\" \n    by auto\n  also have \"(16 * k^2) mod 4 = 0\" \n    by (simp add: mod_mult_self2) \n  finally show \"a^2 mod 4 = 0\" .\nqed", "origin": "do_request", "update_count": 0}, "mod_squareV2": {"skill_name": "mod_squareV2", "marker": "lemma mod_square:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\nproof -\n  assume \"a mod 4 = 0\"\n  then obtain r where r_def: \"a = 4 * r\" by auto\n  have \"a^2 = (4 * r)^2\" by (simp add: r_def)\n  also have \"... = 16 * r^2\" by (simp add: power2_eq_square)\n  finally have \"a^2 mod 4 = (16 * r^2) mod 4\" by simp\n  have \"16 * r^2 mod 4 = 0\" by (simp add: mod_mult_eq)\n  thus \"a^2 mod 4 = 0\" by (metis \\<open>a mod 4 = 0\\<close> mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\nproof -\n  assume \"a mod 4 = 0\"\n  then obtain r where r_def: \"a = 4 * r\" by auto\n  have \"a^2 = (4 * r)^2\" by (simp add: r_def)\n  also have \"... = 16 * r^2\" by (simp add: power2_eq_square)\n  finally have \"a^2 mod 4 = (16 * r^2) mod 4\" by simp\n  have \"16 * r^2 mod 4 = 0\" by (simp add: mod_mult_eq)\n  thus \"a^2 mod 4 = 0\" by (metis \\<open>a mod 4 = 0\\<close> mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "multi_distrib_complex_refinedV2": {"skill_name": "multi_distrib_complex_refinedV2", "marker": "lemma multi_distrib_complex_refined:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have lhs: \"(a + b) * (c + d) + (e + f) * (c + d) = (a * c + a * d + b * c + b * d) + (e * c + e * d + f * c + f * d)\"\n    by (auto simp: field_simps)\n  have rhs: \"((a + e) * c + (a + e) * d) + ((b + f) * c + (b + f) * d) = (a + e) * (c + d) + (b + f) * (c + d)\"\n    by (simp add: distrib_left)\n  show ?thesis using lhs rhs by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_refined:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have lhs: \"(a + b) * (c + d) + (e + f) * (c + d) = (a * c + a * d + b * c + b * d) + (e * c + e * d + f * c + f * d)\"\n    by (auto simp: field_simps)\n  have rhs: \"((a + e) * c + (a + e) * d) + ((b + f) * c + (b + f) * d) = (a + e) * (c + d) + (b + f) * (c + d)\"\n    by (simp add: distrib_left)\n  show ?thesis using lhs rhs by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex_general", "update_count": 0}, "multi_distrib_complex_complete": {"skill_name": "multi_distrib_complex_complete", "marker": "theorem multi_distrib_complex_complete:\n  fixes a b c d e f g h :: complex\n  assumes \"g = a + b\" \"h = c + d\"\n  shows \"g * h = (a * c + a * d + b * c + b * d)\"\nproof -\n  have \"g * h = (a + b) * (c + d)\" using assms by auto\n  thus ?thesis using multi_distrib_complex by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a * c + a * d) + (b * c + b * d)\"\n    by (auto simp: field_simps)\n  thus ?thesis by auto\nqed\n\ntheorem multi_distrib_complex_complete:\n  fixes a b c d e f g h :: complex\n  assumes \"g = a + b\" \"h = c + d\"\n  shows \"g * h = (a * c + a * d + b * c + b * d)\"\nproof -\n  have \"g * h = (a + b) * (c + d)\" using assms by auto\n  thus ?thesis using multi_distrib_complex by simp\nqed", "origin": "multi_distrib_complex_general", "update_count": 0}, "multi_distrib_complexV4": {"skill_name": "multi_distrib_complexV4", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a * c + a * d) + (b * c + b * d)\"\n    by (auto simp: field_simps)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a * c + a * d) + (b * c + b * d)\"\n    by (auto simp: field_simps)\n  thus ?thesis by auto\nqed", "origin": "multi_distrib_complex_general", "update_count": 0}, "multi_distrib_complex_refinedV3": {"skill_name": "multi_distrib_complex_refinedV3", "marker": "lemma multi_distrib_complex_refined:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e + b + f) * (c + d)\"\nproof -\n  have \"((a + b) * (c + d) + (e + f) * (c + d)) = (a * c + a * d + b * c + b * d) + (e * c + e * d + f * c + f * d)\"\n    by (auto simp: field_simps)\n  also have \"... = (a + b + e + f) * (c + d)\"\n    by (auto simp: field_simps)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_refined:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + e + b + f) * (c + d)\"\nproof -\n  have \"((a + b) * (c + d) + (e + f) * (c + d)) = (a * c + a * d + b * c + b * d) + (e * c + e * d + f * c + f * d)\"\n    by (auto simp: field_simps)\n  also have \"... = (a + b + e + f) * (c + d)\"\n    by (auto simp: field_simps)\n  finally show ?thesis by auto\nqed", "origin": "multi_distrib_complex_general", "update_count": 0}, "mod_4_cases": {"skill_name": "mod_4_cases", "marker": "lemma mod_4_cases:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n  by auto", "description": "", "full_code": "lemma mod_4_cases:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n  by auto", "origin": "data/full_data/debug/valid_rand/numbertheory_sqmod4in01d.json_v5", "update_count": -1}, "numbertheory_sqmod4in01d": {"skill_name": "numbertheory_sqmod4in01d", "marker": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  moreover {\n    assume \"a mod 4 = 0\"\n    have \"a^2 mod 4 = (0^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 0\\<close> power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 1\\<close> power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 2\\<close> power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 3\\<close> power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  then show ?thesis \n    by (metis calculation(1) calculation(2) calculation(3) calculation(4))\nqed", "description": "", "full_code": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  moreover {\n    assume \"a mod 4 = 0\"\n    have \"a^2 mod 4 = (0^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 0\\<close> power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 1\\<close> power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 2\\<close> power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 3\\<close> power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  then show ?thesis \n    by (metis calculation(1) calculation(2) calculation(3) calculation(4))\nqed", "origin": "data/full_data/debug/valid_rand/numbertheory_sqmod4in01d.json_v6", "update_count": -1}, "mod_mult": {"skill_name": "mod_mult", "marker": "lemma mod_mult:\n  fixes a b m :: nat\n  shows \"(a * b) mod m = ((a mod m) * (b mod m)) mod m\"\n  by (metis mod_mult_eq)", "description": "-", "full_code": "lemma mod_mult:\n  fixes a b m :: nat\n  shows \"(a * b) mod m = ((a mod m) * (b mod m)) mod m\"\n  by (metis mod_mult_eq)", "origin": "mod_4_cases", "update_count": 0}, "mod_4_subtraction": {"skill_name": "mod_4_subtraction", "marker": "lemma mod_4_subtraction:\n  fixes a b :: int\n  shows \"(a - b) mod 4 = ((a mod 4) - (b mod 4)) mod 4\"\n  by presburger", "description": "-", "full_code": "lemma mod_4_subtraction:\n  fixes a b :: int\n  shows \"(a - b) mod 4 = ((a mod 4) - (b mod 4)) mod 4\"\n  by presburger", "origin": "mod_4_cases", "update_count": 0}, "square_modulo_properties": {"skill_name": "square_modulo_properties", "marker": "lemma square_modulo_properties:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 1) \\<Longrightarrow> (a^2 mod 4 = 1)\"\n    and \"(a mod 4 = 2) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 1)\"\nproof -\n  {\n    assume \"a mod 4 = 0\"\n    have \"a^2 mod 4 = (0^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 0\\<close> power_mod)\n    then show \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\" by simp\n  }\n  {\n    assume \"a mod 4 = 1\"\n    have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 1\\<close> power_mod)\n    then show \"(a mod 4 = 1) \\<Longrightarrow> (a^2 mod 4 = 1)\" by simp\n  }\n  {\n    assume \"a mod 4 = 2\"\n    have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 2\\<close> power_mod)\n    then show \"(a mod 4 = 2) \\<Longrightarrow> (a^2 mod 4 = 0)\" by simp\n  }\n  {\n    assume \"a mod 4 = 3\"\n    have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 3\\<close> power_mod)\n    then show \"(a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 1)\" by simp\n  }\nqed", "description": "-", "full_code": "lemma square_modulo_properties:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 1) \\<Longrightarrow> (a^2 mod 4 = 1)\"\n    and \"(a mod 4 = 2) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 1)\"\nproof -\n  {\n    assume \"a mod 4 = 0\"\n    have \"a^2 mod 4 = (0^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 0\\<close> power_mod)\n    then show \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\" by simp\n  }\n  {\n    assume \"a mod 4 = 1\"\n    have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 1\\<close> power_mod)\n    then show \"(a mod 4 = 1) \\<Longrightarrow> (a^2 mod 4 = 1)\" by simp\n  }\n  {\n    assume \"a mod 4 = 2\"\n    have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 2\\<close> power_mod)\n    then show \"(a mod 4 = 2) \\<Longrightarrow> (a^2 mod 4 = 0)\" by simp\n  }\n  {\n    assume \"a mod 4 = 3\"\n    have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 3\\<close> power_mod)\n    then show \"(a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 1)\" by simp\n  }\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "numbertheory_sqmod4in01dV2": {"skill_name": "numbertheory_sqmod4in01dV2", "marker": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  then show ?thesis \n    by (metis square_modulo_properties(1) square_modulo_properties(2) \n                square_modulo_properties(3) square_modulo_properties(4))\nqed", "description": "-", "full_code": "lemma square_modulo_properties:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 1) \\<Longrightarrow> (a^2 mod 4 = 1)\"\n    and \"(a mod 4 = 2) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 1)\"\nproof -\n  {\n    assume \"a mod 4 = 0\"\n    have \"a^2 mod 4 = (0^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 0\\<close> power_mod)\n    then show \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\" by simp\n  }\n  {\n    assume \"a mod 4 = 1\"\n    have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 1\\<close> power_mod)\n    then show \"(a mod 4 = 1) \\<Longrightarrow> (a^2 mod 4 = 1)\" by simp\n  }\n  {\n    assume \"a mod 4 = 2\"\n    have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 2\\<close> power_mod)\n    then show \"(a mod 4 = 2) \\<Longrightarrow> (a^2 mod 4 = 0)\" by simp\n  }\n  {\n    assume \"a mod 4 = 3\"\n    have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 3\\<close> power_mod)\n    then show \"(a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 1)\" by simp\n  }\nqed\n\ntheorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  then show ?thesis \n    by (metis square_modulo_properties(1) square_modulo_properties(2) \n                square_modulo_properties(3) square_modulo_properties(4))\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "square_mod_4": {"skill_name": "square_mod_4", "marker": "lemma square_mod_4:\n  fixes a :: int\n  shows \"(a mod 4 = 0 \\<longrightarrow> a^2 mod 4 = 0) \\<and>\n         (a mod 4 = 1 \\<longrightarrow> a^2 mod 4 = 1) \\<and>\n         (a mod 4 = 2 \\<longrightarrow> a^2 mod 4 = 0) \\<and>\n         (a mod 4 = 3 \\<longrightarrow> a^2 mod 4 = 1)\"\nproof -\n  {\n    assume \"a mod 4 = 0\"\n    hence \"a^2 mod 4 = (0^2) mod 4\" by auto\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    hence \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) power_mod)\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    hence \"a^2 mod 4 = (2^2) mod 4\" by (metis dbl_simps(3) dbl_simps(5) mod_exp_def power_mod push_bit_of_1)\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    hence \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) power_mod)\n  }\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_mod_4:\n  fixes a :: int\n  shows \"(a mod 4 = 0 \\<longrightarrow> a^2 mod 4 = 0) \\<and>\n         (a mod 4 = 1 \\<longrightarrow> a^2 mod 4 = 1) \\<and>\n         (a mod 4 = 2 \\<longrightarrow> a^2 mod 4 = 0) \\<and>\n         (a mod 4 = 3 \\<longrightarrow> a^2 mod 4 = 1)\"\nproof -\n  {\n    assume \"a mod 4 = 0\"\n    hence \"a^2 mod 4 = (0^2) mod 4\" by auto\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    hence \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) power_mod)\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    hence \"a^2 mod 4 = (2^2) mod 4\" by (metis dbl_simps(3) dbl_simps(5) mod_exp_def power_mod push_bit_of_1)\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    hence \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) power_mod)\n  }\n  ultimately show ?thesis by auto\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "mod_n_cases": {"skill_name": "mod_n_cases", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n \\<in> {0..n-1}\"\nproof -\n  have \"a mod n < n\" by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)\n  moreover have \"a mod n \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n \\<in> {0..n-1}\"\nproof -\n  have \"a mod n < n\" by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)\n  moreover have \"a mod n \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff)\n  ultimately show ?thesis by auto\nqed", "origin": "mod_4_cases", "update_count": 0}, "mod_n_casesV2": {"skill_name": "mod_n_casesV2", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"0 \\<le> a mod n \\<and> a mod n < n\"\nproof -\n  have \"a mod n = a - n * (a div n)\" by (auto simp: field_simps)\n  then have \"a mod n \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff)\n  moreover have \"a mod n < n\" using assms by auto\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"0 \\<le> a mod n \\<and> a mod n < n\"\nproof -\n  have \"a mod n = a - n * (a div n)\" by (auto simp: field_simps)\n  then have \"a mod n \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff)\n  moreover have \"a mod n < n\" using assms by auto\n  ultimately show ?thesis by auto\nqed", "origin": "mod_4_cases", "update_count": 0}, "mod_4_cases_with_proof": {"skill_name": "mod_4_cases_with_proof", "marker": "lemma mod_4_cases_with_proof:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_4_cases_with_proof:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" by auto\n  then show ?thesis by auto\nqed", "origin": "mod_4_cases", "update_count": 0}, "mod_4_cases_extended": {"skill_name": "mod_4_cases_extended", "marker": "lemma mod_4_cases_extended:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3 \\<or> a mod 4 = 4\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_4_cases_extended:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3 \\<or> a mod 4 = 4\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" by auto\n  thus ?thesis by auto\nqed", "origin": "mod_4_cases", "update_count": 0}, "mod_7_cases": {"skill_name": "mod_7_cases", "marker": "lemma mod_7_cases:\n  fixes n :: int\n  shows \"n mod 7 = 0 \\<or> n mod 7 = 1 \\<or> n mod 7 = 2 \\<or> n mod 7 = 3 \\<or> n mod 7 = 4 \\<or> n mod 7 = 5 \\<or> n mod 7 = 6\"\n  by auto", "description": "-", "full_code": "lemma mod_7_cases:\n  fixes n :: int\n  shows \"n mod 7 = 0 \\<or> n mod 7 = 1 \\<or> n mod 7 = 2 \\<or> n mod 7 = 3 \\<or> n mod 7 = 4 \\<or> n mod 7 = 5 \\<or> n mod 7 = 6\"\n  by auto", "origin": "mod_4_cases", "update_count": 0}, "mod_n_casesV3": {"skill_name": "mod_n_casesV3", "marker": "lemma mod_n_cases:\n  fixes a :: int\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. 0 \\<le> r \\<and> r < n \\<and> (a mod n = r)\"\nproof -\n  have \"a mod n < n\" using assms by (simp add: mod_less)\n  then obtain r where \"r = a mod n\" by auto\n  then show ?thesis using \\<open>n > 0\\<close> by (metis Euclidean_Division.pos_mod_sign \\<open>a mod int n < int n\\<close> int_nat_eq le0 nat_less_iff of_nat_0_less_iff)\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. 0 \\<le> r \\<and> r < n \\<and> (a mod n = r)\"\nproof -\n  have \"a mod n < n\" using assms by (simp add: mod_less)\n  then obtain r where \"r = a mod n\" by auto\n  then show ?thesis using \\<open>n > 0\\<close> by (metis Euclidean_Division.pos_mod_sign \\<open>a mod int n < int n\\<close> int_nat_eq le0 nat_less_iff of_nat_0_less_iff)\nqed", "origin": "mod_4_cases", "update_count": 0}, "number_theory_sqmod4in01d": {"skill_name": "number_theory_sqmod4in01d", "marker": "theorem number_theory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  then show ?thesis \n    by (metis number_theory_mod_4)\nqed", "description": "-", "full_code": "lemma number_theory_mod_4:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 1) \\<Longrightarrow> (a^2 mod 4 = 1)\"\n    and \"(a mod 4 = 2) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 1)\"\nproof -\n  {\n    assume \"a mod 4 = 0\"\n    then have \"a^2 mod 4 = (0^2) mod 4\" by auto\n    thus \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    then have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) power_mod)\n    thus \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    then have \"a^2 mod 4 = (2^2) mod 4\" by (metis dbl_simps(3) dbl_simps(5) mod_exp_def power_mod push_bit_of_1)\n    thus \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    then have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) power_mod)\n    thus \"a^2 mod 4 = 1\" by simp\n  }\nqed\n\ntheorem number_theory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  then show ?thesis \n    by (metis number_theory_mod_4)\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "number_theory_mod_4": {"skill_name": "number_theory_mod_4", "marker": "lemma number_theory_mod_4:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 1) \\<Longrightarrow> (a^2 mod 4 = 1)\"\n    and \"(a mod 4 = 2) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 1)\"\nproof -\n  {\n    assume \"a mod 4 = 0\"\n    then have \"a^2 mod 4 = (0^2) mod 4\" by auto\n    thus \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    then have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) power_mod)\n    thus \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    then have \"a^2 mod 4 = (2^2) mod 4\" by (metis dbl_simps(3) dbl_simps(5) mod_exp_def power_mod push_bit_of_1)\n    thus \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    then have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) power_mod)\n    thus \"a^2 mod 4 = 1\" by simp\n  }\nqed", "description": "-", "full_code": "lemma number_theory_mod_4:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 1) \\<Longrightarrow> (a^2 mod 4 = 1)\"\n    and \"(a mod 4 = 2) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n    and \"(a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 1)\"\nproof -\n  {\n    assume \"a mod 4 = 0\"\n    then have \"a^2 mod 4 = (0^2) mod 4\" by auto\n    thus \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    then have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) power_mod)\n    thus \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    then have \"a^2 mod 4 = (2^2) mod 4\" by (metis dbl_simps(3) dbl_simps(5) mod_exp_def power_mod push_bit_of_1)\n    thus \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    then have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) power_mod)\n    thus \"a^2 mod 4 = 1\" by simp\n  }\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "mod_n_casesV4": {"skill_name": "mod_n_casesV4", "marker": "lemma mod_n_cases:\n  fixes a :: int\n  assumes \"n > 0\"\n  shows \"a mod n \\<in> {0..(n-1)}\"\nproof -\n  have \"a mod n = (if a mod n < 0 then a mod n + n else a mod n)\"\n    by (metis Euclidean_Division.pos_mod_sign assms order.strict_iff_not)\n  then show ?thesis by (metis Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign assms atLeastAtMost_iff zle_diff1_eq)\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int\n  assumes \"n > 0\"\n  shows \"a mod n \\<in> {0..(n-1)}\"\nproof -\n  have \"a mod n = (if a mod n < 0 then a mod n + n else a mod n)\"\n    by (metis Euclidean_Division.pos_mod_sign assms order.strict_iff_not)\n  then show ?thesis by (metis Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign assms atLeastAtMost_iff zle_diff1_eq)\nqed", "origin": "mod_4_cases", "update_count": 0}, "mod_m_cases": {"skill_name": "mod_m_cases", "marker": "lemma mod_m_cases:\n  fixes a :: int\n  fixes m :: nat\n  assumes \"m > 0\"\n  shows \"\\<exists>r. r < m \\<and> (a mod m = r)\"\nproof -\n  let ?r = \"a mod m\"\n  have \"0 \\<le> ?r\" by (metis Euclidean_Division.pos_mod_sign assms less_eq_int_code(1) nat_less_iff nat_zero_as_int)\n  moreover have \"?r < m\" using assms by auto\n  ultimately show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_m_cases:\n  fixes a :: int\n  fixes m :: nat\n  assumes \"m > 0\"\n  shows \"\\<exists>r. r < m \\<and> (a mod m = r)\"\nproof -\n  let ?r = \"a mod m\"\n  have \"0 \\<le> ?r\" by (metis Euclidean_Division.pos_mod_sign assms less_eq_int_code(1) nat_less_iff nat_zero_as_int)\n  moreover have \"?r < m\" using assms by auto\n  ultimately show ?thesis by presburger\nqed", "origin": "mod_4_cases", "update_count": 0}, "square_mod_4V2": {"skill_name": "square_mod_4V2", "marker": "lemma square_mod_4:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<or> (a mod 4 = 1) \\<or> (a mod 4 = 2) \\<or> (a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  assume \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n  moreover {\n    assume \"a mod 4 = 0\"\n    have \"a^2 mod 4 = (0^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 0\\<close> power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 1\\<close> power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 2\\<close> power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 3\\<close> power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  ultimately show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma square_mod_4:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<or> (a mod 4 = 1) \\<or> (a mod 4 = 2) \\<or> (a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  assume \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n  moreover {\n    assume \"a mod 4 = 0\"\n    have \"a^2 mod 4 = (0^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 0\\<close> power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 1\\<close> power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 2\\<close> power_mod)\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 3\\<close> power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  ultimately show ?thesis \n    by auto\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "mod_n_casesV5": {"skill_name": "mod_n_casesV5", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n \\<in> {0..<n}\"\nproof -\n  have \"a mod n < n\" by (simp add: assms)\n  moreover have \"a mod n \\<ge> 0\" by (simp add: assms)\n  ultimately show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n \\<in> {0..<n}\"\nproof -\n  have \"a mod n < n\" by (simp add: assms)\n  moreover have \"a mod n \\<ge> 0\" by (simp add: assms)\n  ultimately show ?thesis \n    by auto\nqed", "origin": "mod_4_cases", "update_count": 0}, "mod_4_cases_with_remainder": {"skill_name": "mod_4_cases_with_remainder", "marker": "lemma mod_4_cases_with_remainder:\n  fixes n :: nat\n  shows \"n mod 4 = (0::nat) \\<or> n mod 4 = 1 \\<or> n mod 4 = 2 \\<or> n mod 4 = 3\"\nproof -\n  have \"n mod 4 < 4\" by auto\n  moreover have \"0 \\<le> n mod 4\" by auto\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_4_cases_with_remainder:\n  fixes n :: nat\n  shows \"n mod 4 = (0::nat) \\<or> n mod 4 = 1 \\<or> n mod 4 = 2 \\<or> n mod 4 = 3\"\nproof -\n  have \"n mod 4 < 4\" by auto\n  moreover have \"0 \\<le> n mod 4\" by auto\n  ultimately show ?thesis by auto\nqed", "origin": "mod_4_cases", "update_count": 0}, "remainder_modulo_extended": {"skill_name": "remainder_modulo_extended", "marker": "lemma remainder_modulo_extended:\n  fixes a d :: int\n  assumes \"d > 0\"\n  shows \"a mod d \\<in> {0..d-1}\"\nproof -\n  have \"a mod d < d\" by (metis Euclidean_Division.pos_mod_bound assms)\n  moreover have \"a mod d \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma remainder_modulo_extended:\n  fixes a d :: int\n  assumes \"d > 0\"\n  shows \"a mod d \\<in> {0..d-1}\"\nproof -\n  have \"a mod d < d\" by (metis Euclidean_Division.pos_mod_bound assms)\n  moreover have \"a mod d \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms)\n  ultimately show ?thesis by auto\nqed", "origin": "mod_4_cases", "update_count": 0}, "remainder_modulo_general": {"skill_name": "remainder_modulo_general", "marker": "lemma remainder_modulo_general:\n  fixes a :: int\n  shows \"a mod d \\<in> {0..d-1} \\<Longrightarrow> d > 0\"\nproof -\n  assume \"a mod d \\<in> {0..d-1}\"\n  then show \"d > 0\" by auto\nqed", "description": "-", "full_code": "lemma remainder_modulo_general:\n  fixes a :: int\n  shows \"a mod d \\<in> {0..d-1} \\<Longrightarrow> d > 0\"\nproof -\n  assume \"a mod d \\<in> {0..d-1}\"\n  then show \"d > 0\" by auto\nqed", "origin": "mod_4_cases", "update_count": 0}, "numbertheory_sqmod4in01dV3": {"skill_name": "numbertheory_sqmod4in01dV3", "marker": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  then have \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\" \n    using square_mod_4 by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_mod_4:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n  and \"(a mod 4 = 1) \\<Longrightarrow> (a^2 mod 4 = 1)\"\n  and \"(a mod 4 = 2) \\<Longrightarrow> (a^2 mod 4 = 0)\"\n  and \"(a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 1)\"\nproof -\n  {\n    assume \"a mod 4 = 0\"\n    have \"a^2 mod 4 = (0^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 0\\<close> power_mod)\n    thus \"(a mod 4 = 0) \\<Longrightarrow> (a^2 mod 4 = 0)\" by simp\n  }\n  {\n    assume \"a mod 4 = 1\"\n    have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 1\\<close> power_mod)\n    thus \"(a mod 4 = 1) \\<Longrightarrow> (a^2 mod 4 = 1)\" by simp\n  }\n  {\n    assume \"a mod 4 = 2\"\n    have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 2\\<close> power_mod)\n    thus \"(a mod 4 = 2) \\<Longrightarrow> (a^2 mod 4 = 0)\" by simp\n  }\n  {\n    assume \"a mod 4 = 3\"\n    have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) \\<open>a mod 4 = 3\\<close> power_mod)\n    thus \"(a mod 4 = 3) \\<Longrightarrow> (a^2 mod 4 = 1)\" by simp\n  }\nqed\n\ntheorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  then have \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\" \n    using square_mod_4 by auto\n  thus ?thesis by simp\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "mod_n_casesV6": {"skill_name": "mod_n_casesV6", "marker": "lemma mod_n_cases:\n  fixes a :: int\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. r < n \\<and> (a mod n = r)\"\nproof -\n  have \"a mod n < n\" using assms by (simp add: mod_less)\n  then show ?thesis by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff of_nat_less_iff zero_le_imp_eq_int)\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. r < n \\<and> (a mod n = r)\"\nproof -\n  have \"a mod n < n\" using assms by (simp add: mod_less)\n  then show ?thesis by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff of_nat_less_iff zero_le_imp_eq_int)\nqed", "origin": "mod_4_cases", "update_count": 0}, "mod_n_casesV7": {"skill_name": "mod_n_casesV7", "marker": "lemma mod_n_cases:\n  fixes a :: int\n  assumes \"n > 0\"\n  shows \"\\<exists>k. a mod n = k \\<and> (0 \\<le> k \\<and> k < n)\"\nproof -\n  obtain k where \"a mod n = k\" by (metis mod_eq_0_iff_dvd)\n  then have \"0 \\<le> k\" by (metis Euclidean_Division.pos_mod_sign assms)\n  then have \"k < n\" using assms by (metis Euclidean_Division.pos_mod_bound \\<open>a mod n = k\\<close>)\n  then show ?thesis by (metis \\<open>0 \\<le> k\\<close> \\<open>a mod n = k\\<close>)\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int\n  assumes \"n > 0\"\n  shows \"\\<exists>k. a mod n = k \\<and> (0 \\<le> k \\<and> k < n)\"\nproof -\n  obtain k where \"a mod n = k\" by (metis mod_eq_0_iff_dvd)\n  then have \"0 \\<le> k\" by (metis Euclidean_Division.pos_mod_sign assms)\n  then have \"k < n\" using assms by (metis Euclidean_Division.pos_mod_bound \\<open>a mod n = k\\<close>)\n  then show ?thesis by (metis \\<open>0 \\<le> k\\<close> \\<open>a mod n = k\\<close>)\nqed", "origin": "mod_4_cases", "update_count": 0}, "mod_addition": {"skill_name": "mod_addition", "marker": "lemma mod_addition:\n  fixes a b c :: nat\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a + b = (a mod c) + (b mod c) + (a div c + b div c) * c\" \n    by (auto simp: field_simps)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b c :: nat\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a + b = (a mod c) + (b mod c) + (a div c + b div c) * c\" \n    by (auto simp: field_simps)\n  then show ?thesis by auto\nqed", "origin": "mod_4_cases", "update_count": 0}}
{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "logarithm_identity": {"skill_name": "logarithm_identity", "marker": "lemma logarithm_identity:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\"\n  shows \"log a (a ^ c) = c\"\nproof -\n  have \"log a (a ^ c) = c * log a a\" by (metis assms(1) log_nat_power)\n  also have \"... = c * 1\" by (metis assms(1) assms(2) log_eq_one mult.comm_neutral mult.right_neutral)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_identity:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\"\n  shows \"log a (a ^ c) = c\"\nproof -\n  have \"log a (a ^ c) = c * log a a\" by (metis assms(1) log_nat_power)\n  also have \"... = c * 1\" by (metis assms(1) assms(2) log_eq_one mult.comm_neutral mult.right_neutral)\n  finally show ?thesis by simp\nqed", "origin": "cal_log_value", "update_count": 0}, "cal_log_exp_value_general": {"skill_name": "cal_log_exp_value_general", "marker": "lemma cal_log_exp_value_general:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"b \\<noteq> 1\" \"n > 0\"\n  shows \"log a (b^n) = n * log a b\"\nproof -\n  have \"log a (b^n) = n * log a b\"\n    using log_nat_power[of b a n] by (simp add: assms(1) assms(2) assms(3) assms(4))\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma cal_log_exp_value_general:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"b \\<noteq> 1\" \"n > 0\"\n  shows \"log a (b^n) = n * log a b\"\nproof -\n  have \"log a (b^n) = n * log a b\"\n    using log_nat_power[of b a n] by (simp add: assms(1) assms(2) assms(3) assms(4))\n  thus ?thesis by simp\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "cal_log_exp_value_generalV2": {"skill_name": "cal_log_exp_value_generalV2", "marker": "lemma cal_log_exp_value_general:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  also have \"... = n * 1\" \n    by (metis assms(1) assms(2) log_eq_one mult.comm_neutral nat_mult_1_right)\n  finally show ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma cal_log_exp_value_general:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  also have \"... = n * 1\" \n    by (metis assms(1) assms(2) log_eq_one mult.comm_neutral nat_mult_1_right)\n  finally show ?thesis \n    by simp\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "cal_log_exp_value_generalV3": {"skill_name": "cal_log_exp_value_generalV3", "marker": "lemma cal_log_exp_value_general:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"k > 0\"\n  shows \"log (a^k) (a^n) = n / k\"\nproof -\n  have c0: \"log (a^k) (a^n) = log a (a^n) / log a (a^k)\"\n    by (metis assms(1) assms(2) log_base_change)\n  have c1: \"log a (a^n) = n\" \n    using log_nat_power[of a a n] assms(1) assms(2) by simp\n  have c2: \"log a (a^k) = k\"\n    using log_nat_power[of a a k] assms(1) assms(2) by simp\n  thus \"log (a^k) (a^n) = n / k\"\n    using c0 c1 c2 by simp\nqed", "description": "-", "full_code": "lemma cal_log_exp_value_general:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"k > 0\"\n  shows \"log (a^k) (a^n) = n / k\"\nproof -\n  have c0: \"log (a^k) (a^n) = log a (a^n) / log a (a^k)\"\n    by (metis assms(1) assms(2) log_base_change)\n  have c1: \"log a (a^n) = n\" \n    using log_nat_power[of a a n] assms(1) assms(2) by simp\n  have c2: \"log a (a^k) = k\"\n    using log_nat_power[of a a k] assms(1) assms(2) by simp\n  thus \"log (a^k) (a^n) = n / k\"\n    using c0 c1 c2 by simp\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "cal_log_exp_value_multiple": {"skill_name": "cal_log_exp_value_multiple", "marker": "lemma cal_log_exp_value_multiple:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\" \"a \\<noteq> 1\" \"b \\<noteq> 1\" \"n > 0\"\n  shows \"log a (b^n) = n * (log a b)\"\nproof -\n  have \"log a (b^n) = n * (log a b)\"\n    using log_nat_power[of b a n] by (metis assms(2))\n  then show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma cal_log_exp_value_multiple:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\" \"a \\<noteq> 1\" \"b \\<noteq> 1\" \"n > 0\"\n  shows \"log a (b^n) = n * (log a b)\"\nproof -\n  have \"log a (b^n) = n * (log a b)\"\n    using log_nat_power[of b a n] by (metis assms(2))\n  then show ?thesis \n    by auto\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "cal_log_exp_value_generalV4": {"skill_name": "cal_log_exp_value_generalV4", "marker": "lemma cal_log_exp_value_general:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"b > 1\"\n  shows \"log b (a^n) = n * (log b a)\"\nproof -\n  have \"log b (a^n) = n * (log b a)\"\n    using log_nat_power[of a b n] by (simp add: assms(1) assms(2) assms(4))\n  then show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma cal_log_exp_value_general:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"b > 1\"\n  shows \"log b (a^n) = n * (log b a)\"\nproof -\n  have \"log b (a^n) = n * (log b a)\"\n    using log_nat_power[of a b n] by (simp add: assms(1) assms(2) assms(4))\n  then show ?thesis \n    by auto\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "cancle_div_multi": {"skill_name": "cancle_div_multi", "marker": "lemma cancle_div_multi:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" and \"a + b / x = c\"\n  shows \"(\\<Sum>i\\<in>A. a * x + b) = (\\<Sum>i\\<in>A. c * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. x * (a + b / x)) = (\\<Sum>i\\<in>A. c * x)\"\n    using assms(2) by (metis assms(3) mult.commute)\n  then have \"(\\<Sum>i\\<in>A. x * a + x * (b / x)) = (\\<Sum>i\\<in>A. c * x)\"\n    by (simp add: distrib_left)\n  then show ?thesis using assms(1) \n    by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancle_div_multi:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" and \"a + b / x = c\"\n  shows \"(\\<Sum>i\\<in>A. a * x + b) = (\\<Sum>i\\<in>A. c * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. x * (a + b / x)) = (\\<Sum>i\\<in>A. c * x)\"\n    using assms(2) by (metis assms(3) mult.commute)\n  then have \"(\\<Sum>i\\<in>A. x * a + x * (b / x)) = (\\<Sum>i\\<in>A. c * x)\"\n    by (simp add: distrib_left)\n  then show ?thesis using assms(1) \n    by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "cancel_div_multiple_vars": {"skill_name": "cancel_div_multiple_vars", "marker": "lemma cancel_div_multiple_vars:\n  fixes x :: real\n  assumes \"x > 0\" \"A + B / x = C + D / x\"\n  shows \"A * x + B = C * x + D\"\nproof -\n  have \"x * (A + B / x) = x * (C + D / x)\"\n    using assms(2) by auto\n  then have \"x * A + B = C * x + D\"\n    by (metis add.commute assms(1) assms(2) cancel_div_high_dim mult.commute)\n  then show ?thesis using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancel_div_high_dim:\n  fixes x :: real\n  assumes \"x > 0\" \"A + B / x = C\"\n  shows \"A * x + B = C * x\"\nproof -\n  have \"x * (A + B / x) = C * x\"\n    using assms(2) by auto\n  then have \"x * A + x * (B / x) = C * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed\n\nlemma cancel_div_multiple_vars:\n  fixes x :: real\n  assumes \"x > 0\" \"A + B / x = C + D / x\"\n  shows \"A * x + B = C * x + D\"\nproof -\n  have \"x * (A + B / x) = x * (C + D / x)\"\n    using assms(2) by auto\n  then have \"x * A + B = C * x + D\"\n    by (metis add.commute assms(1) assms(2) cancel_div_high_dim mult.commute)\n  then show ?thesis using assms(1) by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "cal_log_value_multi_ext": {"skill_name": "cal_log_value_multi_ext", "marker": "lemma cal_log_value_multi_ext:\n  fixes a :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\"\n  shows \"\\<forall>c. log a (a^c) = c\"\nby (metis assms(1) assms(2) log_pow_cancel)", "description": "-", "full_code": "lemma cal_log_value_multi:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)\n\nlemma cal_log_value_multi_ext:\n  fixes a :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\"\n  shows \"\\<forall>c. log a (a^c) = c\"\nby (metis assms(1) assms(2) log_pow_cancel)", "origin": "cal_log_value", "update_count": 0}, "logarithm_exponentiation": {"skill_name": "logarithm_exponentiation", "marker": "lemma logarithm_exponentiation:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\n  using assms\n  by (metis powr_log_cancel powr_realpow)", "description": "-", "full_code": "lemma logarithm_exponentiation:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\n  using assms\n  by (metis powr_log_cancel powr_realpow)", "origin": "cal_log_value", "update_count": 0}, "sum_of_values": {"skill_name": "sum_of_values", "marker": "lemma sum_of_values:\n  shows \"21 + 45 = 66\"\nproof -\n  have \"21 + 45 = 66\" by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_of_values:\n  shows \"21 + 45 = 66\"\nproof -\n  have \"21 + 45 = 66\" by simp\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sum_of_products": {"skill_name": "sum_of_products", "marker": "lemma sum_of_products:\n  fixes A :: \"'a set\" and x a b c :: real\n  assumes \"x > 0\" \"finite A\" and \"a + b / x = c\"\n  shows \"(\\<Sum>i\\<in>A. a * x + b) = (\\<Sum>i\\<in>A. c * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. x * (a + b / x)) = (\\<Sum>i\\<in>A. c * x)\"\n    using assms(2) by (metis assms(3) mult.commute)\n  then have \"(\\<Sum>i\\<in>A. x * a + x * (b / x)) = (\\<Sum>i\\<in>A. c * x)\"\n    by (simp add: distrib_left)\n  then show ?thesis using assms(1) \n    by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma sum_of_products:\n  fixes A :: \"'a set\" and x a b c :: real\n  assumes \"x > 0\" \"finite A\" and \"a + b / x = c\"\n  shows \"(\\<Sum>i\\<in>A. a * x + b) = (\\<Sum>i\\<in>A. c * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. x * (a + b / x)) = (\\<Sum>i\\<in>A. c * x)\"\n    using assms(2) by (metis assms(3) mult.commute)\n  then have \"(\\<Sum>i\\<in>A. x * a + x * (b / x)) = (\\<Sum>i\\<in>A. c * x)\"\n    by (simp add: distrib_left)\n  then show ?thesis using assms(1) \n    by (simp add: mult.commute)\nqed", "origin": "cancle_div_multi", "update_count": 0}, "sum_of_sums": {"skill_name": "sum_of_sums", "marker": "lemma sum_of_sums:\n  fixes A :: \"'a set\" and x a b :: real\n  assumes \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. a + b) = card A * a + card A * b\"\nproof -\n  have \"(\\<Sum>i\\<in>A. a + b) = (\\<Sum>i\\<in>A. a) + (\\<Sum>i\\<in>A. b)\" by (simp add: distrib_left)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_of_sums:\n  fixes A :: \"'a set\" and x a b :: real\n  assumes \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. a + b) = card A * a + card A * b\"\nproof -\n  have \"(\\<Sum>i\\<in>A. a + b) = (\\<Sum>i\\<in>A. a) + (\\<Sum>i\\<in>A. b)\" by (simp add: distrib_left)\n  then show ?thesis by auto\nqed", "origin": "cancle_div_multi", "update_count": 0}, "sum_of_productsV2": {"skill_name": "sum_of_productsV2", "marker": "lemma sum_of_products:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\" using assms(3) by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_products:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\" using assms(3) by simp\n  then show ?thesis by simp\nqed", "origin": "cancle_div_multi", "update_count": 0}, "non_zero_property": {"skill_name": "non_zero_property", "marker": "lemma non_zero_property:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"1 / a * a = 1\"\n  by (simp add: assms)", "description": "-", "full_code": "lemma non_zero_property:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"1 / a * a = 1\"\n  by (simp add: assms)", "origin": "a_times_vera", "update_count": 0}, "nonzero_division": {"skill_name": "nonzero_division", "marker": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"1 / a \\<noteq> 0\" using assms by auto\n  then show ?thesis by (simp add: assms)\nqed", "description": "-", "full_code": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"1 / a \\<noteq> 0\" using assms by auto\n  then show ?thesis by (simp add: assms)\nqed", "origin": "a_times_vera", "update_count": 0}, "sum_of_scaled_products": {"skill_name": "sum_of_scaled_products", "marker": "lemma sum_of_scaled_products:\n  fixes A :: \"'a set\" and x a b c d :: real\n  assumes \"x > 0\" \"finite A\" and \"a + b / x = c\" and \"d = x * a + b\"\n  shows \"(\\<Sum>i\\<in>A. d) = (\\<Sum>i\\<in>A. c * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. d) = (\\<Sum>i\\<in>A. (x * a + b))\" using assms(4) by simp\n  also have \"... = (\\<Sum>i\\<in>A. (x * (a + b / x)))\" using assms(1) by (auto simp: field_simps)\n  also have \"... = (\\<Sum>i\\<in>A. (c * x))\" using assms(3) by (metis assms(1) mult.commute)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma sum_of_scaled_products:\n  fixes A :: \"'a set\" and x a b c d :: real\n  assumes \"x > 0\" \"finite A\" and \"a + b / x = c\" and \"d = x * a + b\"\n  shows \"(\\<Sum>i\\<in>A. d) = (\\<Sum>i\\<in>A. c * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. d) = (\\<Sum>i\\<in>A. (x * a + b))\" using assms(4) by simp\n  also have \"... = (\\<Sum>i\\<in>A. (x * (a + b / x)))\" using assms(1) by (auto simp: field_simps)\n  also have \"... = (\\<Sum>i\\<in>A. (c * x))\" using assms(3) by (metis assms(1) mult.commute)\n  finally show ?thesis .\nqed", "origin": "sum_of_products", "update_count": 0}, "multiplicative_inverse_property": {"skill_name": "multiplicative_inverse_property", "marker": "lemma multiplicative_inverse_property:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(1 / a) * a = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using nonzero_multiplicative_inverse assms by simp\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma nonzero_multiplicative_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"1 / a \\<noteq> 0\" using assms by auto\n  then show ?thesis by (simp add: assms)\nqed\n\nlemma multiplicative_inverse_property:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(1 / a) * a = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using nonzero_multiplicative_inverse assms by simp\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "origin": "nonzero_division", "update_count": 0}, "reciprocal_multiplication": {"skill_name": "reciprocal_multiplication", "marker": "lemma reciprocal_multiplication:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  using nonzero_division_property[of a] assms by simp", "description": "-", "full_code": "lemma nonzero_division_property:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"1 / a * a = 1\"\nproof -\n  have \"1 / a \\<noteq> 0\" using assms by auto\n  then show ?thesis by (simp add: assms)\nqed\n\nlemma reciprocal_multiplication:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  using nonzero_division_property[of a] assms by simp", "origin": "nonzero_division", "update_count": 0}, "logarithm_identity_general": {"skill_name": "logarithm_identity_general", "marker": "lemma logarithm_identity_general:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"c > 0\"\n  shows \"log a (b ^ c) = c * log a b\"\nproof -\n  have \"log a (b ^ c) = c * log a b\" using assms by (simp add: log_nat_power)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_identity_general:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"c > 0\"\n  shows \"log a (b ^ c) = c * log a b\"\nproof -\n  have \"log a (b ^ c) = c * log a b\" using assms by (simp add: log_nat_power)\n  thus ?thesis by simp\nqed", "origin": "logarithm_identity", "update_count": 0}, "sum_of_products_with_weight": {"skill_name": "sum_of_products_with_weight", "marker": "lemma sum_of_products_with_weight:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_products_with_weight:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  finally show ?thesis by simp\nqed", "origin": "sum_of_productsV2", "update_count": 0}, "weighted_sum_of_products": {"skill_name": "weighted_sum_of_products", "marker": "lemma weighted_sum_of_products:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c) \\<and> (\\<Sum>i\\<in>A. b * c) = x * (\\<Sum>i\\<in>A. a * c)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = x * (\\<Sum>i\\<in>A. a * c)\" by (simp add: sum_distrib_right)\n  finally show \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c) \\<and> (\\<Sum>i\\<in>A. b * c) = x * (\\<Sum>i\\<in>A. a * c)\" by auto\nqed", "description": "-", "full_code": "lemma weighted_sum_of_products:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c) \\<and> (\\<Sum>i\\<in>A. b * c) = x * (\\<Sum>i\\<in>A. a * c)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = x * (\\<Sum>i\\<in>A. a * c)\" by (simp add: sum_distrib_right)\n  finally show \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c) \\<and> (\\<Sum>i\\<in>A. b * c) = x * (\\<Sum>i\\<in>A. a * c)\" by auto\nqed", "origin": "sum_of_products_with_weight", "update_count": 0}, "sum_of_scaled_products_with_params": {"skill_name": "sum_of_scaled_products_with_params", "marker": "lemma sum_of_scaled_products_with_params:\n  fixes A :: \"'a set\" and x y z :: real\n  assumes \"x > 0\" \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. (y * x + z)) = (\\<Sum>i\\<in>A. y * x) + (\\<Sum>i\\<in>A. z)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. (y * x + z)) = (\\<Sum>i\\<in>A. y * x) + (\\<Sum>i\\<in>A. z)\" \n    by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_scaled_products_with_params:\n  fixes A :: \"'a set\" and x y z :: real\n  assumes \"x > 0\" \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. (y * x + z)) = (\\<Sum>i\\<in>A. y * x) + (\\<Sum>i\\<in>A. z)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. (y * x + z)) = (\\<Sum>i\\<in>A. y * x) + (\\<Sum>i\\<in>A. z)\" \n    by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "origin": "sum_of_scaled_products", "update_count": 0}, "mod_add_multiple": {"skill_name": "mod_add_multiple", "marker": "lemma mod_add_multiple:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b \\<ge> 0\"\n  shows \"((x + b) mod n) = ((a + b) mod n)\"\nproof -\n  have \"((x + b) mod n) = ((x mod n + b) mod n)\"\n    by (metis mod_add_left_eq)\n  also have \"... = ((a + b) mod n)\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add_multiple:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b \\<ge> 0\"\n  shows \"((x + b) mod n) = ((a + b) mod n)\"\nproof -\n  have \"((x + b) mod n) = ((x mod n + b) mod n)\"\n    by (metis mod_add_left_eq)\n  also have \"... = ((a + b) mod n)\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "origin": "mod_add_power", "update_count": 0}, "non_zero_property_in_multiple_dimensions": {"skill_name": "non_zero_property_in_multiple_dimensions", "marker": "lemma non_zero_property_in_multiple_dimensions:\n  fixes A :: \"real list\"\n  assumes \"\\<forall>i. A ! i \\<noteq> 0\"\n  shows \"\\<forall> i. (1 / (A ! i)) * (A ! i) = 1\"\nproof -\n  show ?thesis\n  proof (rule allI)\n    fix i\n    have \"(1 / (A ! i)) * (A ! i) = 1\" using assms by (simp add: field_simps)\n    thus \"1 / (A ! i) * (A ! i) = 1\" by simp\n  qed\nqed", "description": "-", "full_code": "lemma non_zero_property_in_multiple_dimensions:\n  fixes A :: \"real list\"\n  assumes \"\\<forall>i. A ! i \\<noteq> 0\"\n  shows \"\\<forall> i. (1 / (A ! i)) * (A ! i) = 1\"\nproof -\n  show ?thesis\n  proof (rule allI)\n    fix i\n    have \"(1 / (A ! i)) * (A ! i) = 1\" using assms by (simp add: field_simps)\n    thus \"1 / (A ! i) * (A ! i) = 1\" by simp\n  qed\nqed", "origin": "non_zero_property", "update_count": 0}, "non_zero_property_extended": {"skill_name": "non_zero_property_extended", "marker": "lemma non_zero_property_extended:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall> b. b \\<noteq> 0 \\<longrightarrow> (1 / a) * a = 1\"\nproof -\n  have \"1 / a * a = 1\" using assms by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_zero_property_extended:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall> b. b \\<noteq> 0 \\<longrightarrow> (1 / a) * a = 1\"\nproof -\n  have \"1 / a * a = 1\" using assms by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "non_zero_property", "update_count": 0}, "non_zero_property_extendedV2": {"skill_name": "non_zero_property_extendedV2", "marker": "lemma non_zero_property_extended:\n  fixes a :: real and n :: nat\n  assumes \"a \\<noteq> 0\"\n  shows \"(\\<forall>k. k < n \\<longrightarrow> 1 / a * a = 1)\"\nproof -\n  have \"1 / a * a = 1\" using assms by (simp)\n  then show ?thesis by (metis)\nqed", "description": "-", "full_code": "lemma non_zero_property_extended:\n  fixes a :: real and n :: nat\n  assumes \"a \\<noteq> 0\"\n  shows \"(\\<forall>k. k < n \\<longrightarrow> 1 / a * a = 1)\"\nproof -\n  have \"1 / a * a = 1\" using assms by (simp)\n  then show ?thesis by (metis)\nqed", "origin": "non_zero_property", "update_count": 0}, "sum_of_products_with_weight_generalized": {"skill_name": "sum_of_products_with_weight_generalized", "marker": "lemma sum_of_products_with_weight_generalized:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"c > 0\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * (x * c))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = c * (\\<Sum>i\\<in>A. a) * x\" using assms(4) by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_products_with_weight_generalized:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"c > 0\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * (x * c))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = c * (\\<Sum>i\\<in>A. a) * x\" using assms(4) by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "origin": "sum_of_products_with_weight", "update_count": 0}, "sum_of_weights": {"skill_name": "sum_of_weights", "marker": "lemma sum_of_weights:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = (\\<Sum>i\\<in>A. a * x * c)\" by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_weights:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = (\\<Sum>i\\<in>A. a * x * c)\" by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "origin": "sum_of_products_with_weight", "update_count": 0}, "nonzero_division_property_multi": {"skill_name": "nonzero_division_property_multi", "marker": "lemma nonzero_division_property_multi:\n  fixes a :: \"real set\" \n  assumes \"\\<forall> x. x \\<in> a \\<longrightarrow> x \\<noteq> 0\"\n  shows \"\\<forall> x \\<in> a. (1 / x) * x = 1\"\nproof -\n  have \"\\<forall> x. x \\<in> a \\<longrightarrow> 1 / x * x = 1\" \n  proof (rule allI, rule impI)\n    fix x\n    assume \"x \\<in> a\" \n    then show \"1 / x * x = 1\" using nonzero_division_property[of x] by (simp add: assms)\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma nonzero_division_property:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"1 / a * a = 1\"\nproof -\n  have \"1 / a \\<noteq> 0\" using assms by auto\n  then show ?thesis by (simp add: assms)\nqed\n\nlemma nonzero_division_property_multi:\n  fixes a :: \"real set\" \n  assumes \"\\<forall> x. x \\<in> a \\<longrightarrow> x \\<noteq> 0\"\n  shows \"\\<forall> x \\<in> a. (1 / x) * x = 1\"\nproof -\n  have \"\\<forall> x. x \\<in> a \\<longrightarrow> 1 / x * x = 1\" \n  proof (rule allI, rule impI)\n    fix x\n    assume \"x \\<in> a\" \n    then show \"1 / x * x = 1\" using nonzero_division_property[of x] by (simp add: assms)\n  qed\n  thus ?thesis by auto\nqed", "origin": "reciprocal_multiplication", "update_count": 0}, "product_non_zero": {"skill_name": "product_non_zero", "marker": "lemma product_non_zero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a * b \\<noteq> 0\"\nproof -\n  from assms show ?thesis by auto\nqed", "description": "-", "full_code": "lemma product_non_zero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a * b \\<noteq> 0\"\nproof -\n  from assms show ?thesis by auto\nqed", "origin": "non_zero_property_extendedV2", "update_count": 0}, "non_zero_product": {"skill_name": "non_zero_product", "marker": "lemma non_zero_product:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"(1 / a) * a = 1 \\<and> (1 / b) * b = 1\"\nproof -\n  have \"1 / a * a = 1\" using assms(1) by (simp)\n  have \"1 / b * b = 1\" using assms(2) by (simp)\n  then show ?thesis by (metis \\<open>1 / a * a = 1\\<close>)\nqed", "description": "-", "full_code": "lemma non_zero_product:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"(1 / a) * a = 1 \\<and> (1 / b) * b = 1\"\nproof -\n  have \"1 / a * a = 1\" using assms(1) by (simp)\n  have \"1 / b * b = 1\" using assms(2) by (simp)\n  then show ?thesis by (metis \\<open>1 / a * a = 1\\<close>)\nqed", "origin": "non_zero_property_extendedV2", "update_count": 0}, "product_of_inverses": {"skill_name": "product_of_inverses", "marker": "lemma product_of_inverses:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(1 / a) * (1 / b) = 1 / (a * b)\"\nproof -\n  have \"(1 / a) * (1 / b) = 1 / (a * b)\"\n    using assms by (simp add: field_simps)\n  then show ?thesis by (simp)\nqed", "description": "-", "full_code": "lemma product_of_inverses:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(1 / a) * (1 / b) = 1 / (a * b)\"\nproof -\n  have \"(1 / a) * (1 / b) = 1 / (a * b)\"\n    using assms by (simp add: field_simps)\n  then show ?thesis by (simp)\nqed", "origin": "non_zero_property_extendedV2", "update_count": 0}, "sum_linear_combination_general": {"skill_name": "sum_linear_combination_general", "marker": "lemma sum_linear_combination_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" and \"m * a + n * b / x = p\"\n  shows \"(\\<Sum>i\\<in>A. m * a * x + n * b) = (\\<Sum>i\\<in>A. p * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. x * (m * a + n * b / x)) = (\\<Sum>i\\<in>A. p * x)\"\n    using assms(2) by (metis assms(3) mult.commute)\n  then have \"(\\<Sum>i\\<in>A. x * m * a + x * (n * b / x)) = (\\<Sum>i\\<in>A. p * x)\"\n    by (simp add: distrib_left)\n  then show ?thesis using assms(1) \n    by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma sum_linear_combination:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" and \"a + b / x = c\"\n  shows \"(\\<Sum>i\\<in>A. a * x + b) = (\\<Sum>i\\<in>A. c * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. x * (a + b / x)) = (\\<Sum>i\\<in>A. c * x)\"\n    using assms(2) by (metis assms(3) mult.commute)\n  then have \"(\\<Sum>i\\<in>A. x * a + x * (b / x)) = (\\<Sum>i\\<in>A. c * x)\"\n    by (simp add: distrib_left)\n  then show ?thesis using assms(1) \n    by (simp add: mult.commute)\nqed\n\nlemma sum_linear_combination_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"finite A\" and \"m * a + n * b / x = p\"\n  shows \"(\\<Sum>i\\<in>A. m * a * x + n * b) = (\\<Sum>i\\<in>A. p * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. x * (m * a + n * b / x)) = (\\<Sum>i\\<in>A. p * x)\"\n    using assms(2) by (metis assms(3) mult.commute)\n  then have \"(\\<Sum>i\\<in>A. x * m * a + x * (n * b / x)) = (\\<Sum>i\\<in>A. p * x)\"\n    by (simp add: distrib_left)\n  then show ?thesis using assms(1) \n    by (auto simp: field_simps)\nqed", "origin": "cancle_div_multi", "update_count": 0}, "sum_of_products_multi": {"skill_name": "sum_of_products_multi", "marker": "lemma sum_of_products_multi:\n  fixes x a :: real\n  assumes \"x > 0\" \"finite A\" \"finite B\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. b) = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. a * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. b) = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. a * x)\" using assms(4) by simp\n  then show ?thesis by (simp add: sum.reindex)\nqed", "description": "-", "full_code": "lemma sum_of_products_multi:\n  fixes x a :: real\n  assumes \"x > 0\" \"finite A\" \"finite B\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. b) = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. a * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. b) = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. a * x)\" using assms(4) by simp\n  then show ?thesis by (simp add: sum.reindex)\nqed", "origin": "sum_of_productsV2", "update_count": 0}, "sum_of_products_multiV2": {"skill_name": "sum_of_products_multiV2", "marker": "lemma sum_of_products_multi:\n  fixes x a b :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\"\n  and \"(\\<Sum>i\\<in>A. b * x) = (\\<Sum>i\\<in>A. a * x^2)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\" using assms(3) by simp\n  then show \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\" by simp\nnext\n  have \"b * x = (a * x) * x\" using assms(3) by simp\n  then show \"(\\<Sum>i\\<in>A. b * x) = (\\<Sum>i\\<in>A. a * x^2)\" \n    using `finite A` by (metis mult.assoc power2_eq_square sum.cong)\nqed", "description": "-", "full_code": "lemma sum_of_products_multi:\n  fixes x a b :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\"\n  and \"(\\<Sum>i\\<in>A. b * x) = (\\<Sum>i\\<in>A. a * x^2)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\" using assms(3) by simp\n  then show \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\" by simp\nnext\n  have \"b * x = (a * x) * x\" using assms(3) by simp\n  then show \"(\\<Sum>i\\<in>A. b * x) = (\\<Sum>i\\<in>A. a * x^2)\" \n    using `finite A` by (metis mult.assoc power2_eq_square sum.cong)\nqed", "origin": "sum_of_productsV2", "update_count": 0}, "sum_of_products_multiV3": {"skill_name": "sum_of_products_multiV3", "marker": "lemma sum_of_products_multi:\n  fixes x :: real\n    and a :: \"nat \\<Rightarrow> real\"\n    and b :: \"nat \\<Rightarrow> real\"\n    and A :: \"nat set\"\n  assumes \"x > 0\" \"finite A\" \"\\<forall>i\\<in>A. b i = a i * x\"\n  shows \"(\\<Sum>i\\<in>A. b i) = (\\<Sum>i\\<in>A. a i * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b i) = (\\<Sum>i\\<in>A. a i * x)\" using assms(3) by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_products_multi:\n  fixes x :: real\n    and a :: \"nat \\<Rightarrow> real\"\n    and b :: \"nat \\<Rightarrow> real\"\n    and A :: \"nat set\"\n  assumes \"x > 0\" \"finite A\" \"\\<forall>i\\<in>A. b i = a i * x\"\n  shows \"(\\<Sum>i\\<in>A. b i) = (\\<Sum>i\\<in>A. a i * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b i) = (\\<Sum>i\\<in>A. a i * x)\" using assms(3) by simp\n  then show ?thesis by simp\nqed", "origin": "sum_of_productsV2", "update_count": 0}, "weighted_sum_of_products_generalized": {"skill_name": "weighted_sum_of_products_generalized", "marker": "lemma weighted_sum_of_products_generalized:\n  fixes A :: \"'a set\" and x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"c > 0\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * (x * c))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = c * x * (\\<Sum>i\\<in>A. a)\" by (simp add: sum_distrib_right)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma weighted_sum_of_products_generalized:\n  fixes A :: \"'a set\" and x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"c > 0\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * (x * c))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = c * x * (\\<Sum>i\\<in>A. a)\" by (simp add: sum_distrib_right)\n  finally show ?thesis by auto\nqed", "origin": "sum_of_products_with_weight_generalized", "update_count": 0}, "generalized_weighted_sum_properties": {"skill_name": "generalized_weighted_sum_properties", "marker": "lemma generalized_weighted_sum_properties:\n  fixes A :: \"'a set\" and x a b c d :: real\n  assumes \"x > 0\" \"y > 0\" \"finite A\" \"b = a * x\" \"d = c * y\"\n  shows \"(\\<Sum>i\\<in>A. b + d) = (\\<Sum>i\\<in>A. (a * x) + (c * y))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b + d) = (\\<Sum>i\\<in>A. ((a * x) + (c * y)))\" using assms(4) assms(5) by simp\n  also have \"... = (\\<Sum>i\\<in>A. (a * x)) + (\\<Sum>i\\<in>A. (c * y))\" by (auto simp: field_simps)\n  also have \"... = (\\<Sum>i\\<in>A. b) + (\\<Sum>i\\<in>A. d)\" using assms(4) assms(5) by simp\n  finally show ?thesis by (metis assms(4) assms(5))\nqed", "description": "-", "full_code": "lemma generalized_weighted_sum_properties:\n  fixes A :: \"'a set\" and x a b c d :: real\n  assumes \"x > 0\" \"y > 0\" \"finite A\" \"b = a * x\" \"d = c * y\"\n  shows \"(\\<Sum>i\\<in>A. b + d) = (\\<Sum>i\\<in>A. (a * x) + (c * y))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b + d) = (\\<Sum>i\\<in>A. ((a * x) + (c * y)))\" using assms(4) assms(5) by simp\n  also have \"... = (\\<Sum>i\\<in>A. (a * x)) + (\\<Sum>i\\<in>A. (c * y))\" by (auto simp: field_simps)\n  also have \"... = (\\<Sum>i\\<in>A. b) + (\\<Sum>i\\<in>A. d)\" using assms(4) assms(5) by simp\n  finally show ?thesis by (metis assms(4) assms(5))\nqed", "origin": "sum_of_products_with_weight_generalized", "update_count": 0}, "generalized_sum_of_products_with_weight": {"skill_name": "generalized_sum_of_products_with_weight", "marker": "lemma generalized_sum_of_products_with_weight:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"c > 0\" \"d > 0\"\n  shows \"(\\<Sum>i\\<in>A. b * c * d) = (\\<Sum>i\\<in>A. a * (x * c * d))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c * d) = (\\<Sum>i\\<in>A. (a * x) * c * d)\" using assms(3) by simp\n  also have \"... = d * (\\<Sum>i\\<in>A. (a * x) * c)\" by (simp add: sum_distrib_left)\n  also have \"... = d * c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_right)\n  also have \"... = c * d * (\\<Sum>i\\<in>A. a) * x\" using assms(4) by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma generalized_sum_of_products_with_weight:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"c > 0\" \"d > 0\"\n  shows \"(\\<Sum>i\\<in>A. b * c * d) = (\\<Sum>i\\<in>A. a * (x * c * d))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c * d) = (\\<Sum>i\\<in>A. (a * x) * c * d)\" using assms(3) by simp\n  also have \"... = d * (\\<Sum>i\\<in>A. (a * x) * c)\" by (simp add: sum_distrib_left)\n  also have \"... = d * c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_right)\n  also have \"... = c * d * (\\<Sum>i\\<in>A. a) * x\" using assms(4) by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "origin": "sum_of_products_with_weight_generalized", "update_count": 0}, "linear_congruence": {"skill_name": "linear_congruence", "marker": "lemma linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(\\<exists> x. x mod m = a) \\<longleftrightarrow> (a < m)\"\nproof\n  assume \"\\<exists> x. x mod m = a\"\n  then obtain x where \"x mod m = a\" by auto\n  hence \"a < m\" using assms by auto\n  thus \"a < m\" by simp\nnext\n  assume \"a < m\"\n  then have \"a mod m = a\" by (metis mod_less)\n  thus \"\\<exists> x. x mod m = a\" by (metis)\nqed", "description": "-", "full_code": "lemma linear_congruence:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(\\<exists> x. x mod m = a) \\<longleftrightarrow> (a < m)\"\nproof\n  assume \"\\<exists> x. x mod m = a\"\n  then obtain x where \"x mod m = a\" by auto\n  hence \"a < m\" using assms by auto\n  thus \"a < m\" by simp\nnext\n  assume \"a < m\"\n  then have \"a mod m = a\" by (metis mod_less)\n  thus \"\\<exists> x. x mod m = a\" by (metis)\nqed", "origin": "do_request", "update_count": 0}, "gcd_lcm_property": {"skill_name": "gcd_lcm_property", "marker": "lemma gcd_lcm_property:\n  fixes a b :: nat\n  shows \"gcd a b * lcm a b = a * b\"\n  by auto", "description": "-", "full_code": "lemma gcd_lcm_property:\n  fixes a b :: nat\n  shows \"gcd a b * lcm a b = a * b\"\n  by auto", "origin": "do_request", "update_count": 0}, "lcm_properties": {"skill_name": "lcm_properties", "marker": "lemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b * lcm a b = a * b\" using gcd_lcm_property by simp\n  then show ?thesis by (metis lcm_nat_def)\nqed", "description": "-", "full_code": "lemma gcd_lcm_property:\n  fixes a b :: nat\n  shows \"gcd a b * lcm a b = a * b\"\n  by auto\n\nlemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b * lcm a b = a * b\" using gcd_lcm_property by simp\n  then show ?thesis by (metis lcm_nat_def)\nqed", "origin": "do_request", "update_count": 0}, "generalized_sum_of_products_with_weight_multi": {"skill_name": "generalized_sum_of_products_with_weight_multi", "marker": "lemma generalized_sum_of_products_with_weight_multi:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"c > 0\" \"d > 0\"\n  shows \"(\\<Sum>i\\<in>A. b * c * d) = (\\<Sum>i\\<in>A. a * (x * c * d))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c * d) = (\\<Sum>i\\<in>A. (a * x) * c * d)\" using assms(3) by simp\n  also have \"... = d * (\\<Sum>i\\<in>A. (a * x) * c)\" by (simp add: sum_distrib_left)\n  also have \"... = d * c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_right)\n  also have \"... = c * d * (\\<Sum>i\\<in>A. a) * x\" using assms(4) by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed\nprimrec generalized_sum_of_products_with_weight_multi :: \"real list \\<Rightarrow> real \\<Rightarrow> real\" where\n  \"generalized_sum_of_products_with_weight_multi [] _ = 0\" |\n  \"generalized_sum_of_products_with_weight_multi (x # xs) a = (x * a) + generalized_sum_of_products_with_weight_multi xs a\"", "description": "-", "full_code": "lemma generalized_sum_of_products_with_weight_multi:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"c > 0\" \"d > 0\"\n  shows \"(\\<Sum>i\\<in>A. b * c * d) = (\\<Sum>i\\<in>A. a * (x * c * d))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c * d) = (\\<Sum>i\\<in>A. (a * x) * c * d)\" using assms(3) by simp\n  also have \"... = d * (\\<Sum>i\\<in>A. (a * x) * c)\" by (simp add: sum_distrib_left)\n  also have \"... = d * c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_right)\n  also have \"... = c * d * (\\<Sum>i\\<in>A. a) * x\" using assms(4) by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed\nprimrec generalized_sum_of_products_with_weight_multi :: \"real list \\<Rightarrow> real \\<Rightarrow> real\" where\n  \"generalized_sum_of_products_with_weight_multi [] _ = 0\" |\n  \"generalized_sum_of_products_with_weight_multi (x # xs) a = (x * a) + generalized_sum_of_products_with_weight_multi xs a\"", "origin": "generalized_sum_of_products_with_weight", "update_count": 0}, "cancel_div_general": {"skill_name": "cancel_div_general", "marker": "lemma cancel_div_general:\n  fixes x a b c d:: real\n  assumes \"x > 0\" \"a + b / x = c\" \"d > 0\"\n  shows \"a * x + b = c * x\" and \"d * (a + b / x) = d * c\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show \"a * x + b = c * x\"\n    using assms(1) by (simp add: mult.commute)\n  have \"d * (a + b / x) = d * c\"\n    using assms(2) by (simp add: distrib_left)\n  then show \"d * (a + b / x) = d * c\" by simp\nqed", "description": "-", "full_code": "lemma cancel_div_general:\n  fixes x a b c d:: real\n  assumes \"x > 0\" \"a + b / x = c\" \"d > 0\"\n  shows \"a * x + b = c * x\" and \"d * (a + b / x) = d * c\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show \"a * x + b = c * x\"\n    using assms(1) by (simp add: mult.commute)\n  have \"d * (a + b / x) = d * c\"\n    using assms(2) by (simp add: distrib_left)\n  then show \"d * (a + b / x) = d * c\" by simp\nqed", "origin": "cancle_div", "update_count": 0}, "sum_of_productsV3": {"skill_name": "sum_of_productsV3", "marker": "lemma sum_of_products:\n  fixes x :: real\n  assumes \"x > 0\" \"finite A\" \"finite B\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. b) = card B * (\\<Sum>i\\<in>A. b)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. b) = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. a * x)\" using assms(4) by simp\n  also have \"... = (\\<Sum>i\\<in>A. card B * (a * x))\" by (simp add: sum_constant)\n  finally show ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sum_of_products:\n  fixes x :: real\n  assumes \"x > 0\" \"finite A\" \"finite B\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. b) = card B * (\\<Sum>i\\<in>A. b)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. b) = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. a * x)\" using assms(4) by simp\n  also have \"... = (\\<Sum>i\\<in>A. card B * (a * x))\" by (simp add: sum_constant)\n  finally show ?thesis using assms by auto\nqed", "origin": "sum_of_products_multi", "update_count": 0}, "non_zero_product_property": {"skill_name": "non_zero_product_property", "marker": "lemma non_zero_product_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1 \\<and> b * (1 / b) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: field_simps)\n  moreover have \"b * (1 / b) = 1\" using assms(2) by (simp add: field_simps)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_zero_product_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1 \\<and> b * (1 / b) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: field_simps)\n  moreover have \"b * (1 / b) = 1\" using assms(2) by (simp add: field_simps)\n  ultimately show ?thesis by simp\nqed", "origin": "non_zero_property_extended", "update_count": 0}, "multiplicative_inverse": {"skill_name": "multiplicative_inverse", "marker": "lemma multiplicative_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"1 / a * a = 1\"\nproof -\n  have \"1 / a * a = 1\" using assms by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multiplicative_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"1 / a * a = 1\"\nproof -\n  have \"1 / a * a = 1\" using assms by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "non_zero_property_extended", "update_count": 0}, "sum_of_values_general": {"skill_name": "sum_of_values_general", "marker": "lemma sum_of_values_general:\n  fixes x y z :: nat\n  assumes \"x + y = z\"\n  shows \"y + x = z\"\nproof -\n  have \"y + x = z\" using assms by (simp add: add.commute)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_of_values_general:\n  fixes x y z :: nat\n  assumes \"x + y = z\"\n  shows \"y + x = z\"\nproof -\n  have \"y + x = z\" using assms by (simp add: add.commute)\n  thus ?thesis by auto\nqed", "origin": "sum_of_values", "update_count": 0}, "sum_of_values_for_n": {"skill_name": "sum_of_values_for_n", "marker": "lemma sum_of_values_for_n:\n  fixes n :: nat\n  assumes \"n = 21 + 45\"\n  shows \"n = 66\"\nproof -\n  have \"n = 21 + 45\" using assms by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_of_values_for_n:\n  fixes n :: nat\n  assumes \"n = 21 + 45\"\n  shows \"n = 66\"\nproof -\n  have \"n = 21 + 45\" using assms by simp\n  thus ?thesis by auto\nqed", "origin": "sum_of_values", "update_count": 0}, "sum_of_two_numbers": {"skill_name": "sum_of_two_numbers", "marker": "lemma sum_of_two_numbers:\n  fixes a b :: nat\n  shows \"a + b = b + a\"\nproof -\n  have \"a + b = b + a\" by (simp add: add.commute)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_of_two_numbers:\n  fixes a b :: nat\n  shows \"a + b = b + a\"\nproof -\n  have \"a + b = b + a\" by (simp add: add.commute)\n  thus ?thesis by auto\nqed", "origin": "sum_of_values", "update_count": 0}, "general_sum_property": {"skill_name": "general_sum_property", "marker": "theorem general_sum_property:\n  fixes a b c d :: nat\n  assumes \"a = 21\" \"b = 45\" \"c = 5\" \"d = 10\"\n  shows \"a + b + c + d = 81\"\nproof -\n  have \"a + b + c + d = 21 + 45 + 5 + 10\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem general_sum_property:\n  fixes a b c d :: nat\n  assumes \"a = 21\" \"b = 45\" \"c = 5\" \"d = 10\"\n  shows \"a + b + c + d = 81\"\nproof -\n  have \"a + b + c + d = 21 + 45 + 5 + 10\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "sum_of_values", "update_count": 0}, "sum_of_n_values": {"skill_name": "sum_of_n_values", "marker": "theorem sum_of_n_values:\n  fixes n1 n2 n3 :: nat\n  assumes \"n1 = 21\" \"n2 = 45\" \"n3 = 5\"\n  shows \"n1 + n2 + n3 = 71\"\nproof -\n  have \"n1 + n2 + n3 = 21 + 45 + 5\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem sum_of_n_values:\n  fixes n1 n2 n3 :: nat\n  assumes \"n1 = 21\" \"n2 = 45\" \"n3 = 5\"\n  shows \"n1 + n2 + n3 = 71\"\nproof -\n  have \"n1 + n2 + n3 = 21 + 45 + 5\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "sum_of_values", "update_count": 0}, "cancle_div_multiple": {"skill_name": "cancle_div_multiple", "marker": "lemma cancle_div_multiple:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"d > 0\"\n  shows \"d * (a * x + b) = d * (c * x)\"\nproof -\n  have \"d * (a * x + b) = d * (c * x)\"\n    using cancle_div_general[OF assms(1-2)] by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancle_div_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"k > 0\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed\n\nlemma cancle_div_multiple:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"d > 0\"\n  shows \"d * (a * x + b) = d * (c * x)\"\nproof -\n  have \"d * (a * x + b) = d * (c * x)\"\n    using cancle_div_general[OF assms(1-2)] by auto\n  then show ?thesis by simp\nqed", "origin": "cancle_div", "update_count": 0}, "sum_of_products_with_variable_weight": {"skill_name": "sum_of_products_with_variable_weight", "marker": "lemma sum_of_products_with_variable_weight:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"d = c * x\"\n  shows \"(\\<Sum>i\\<in>A. b * d) = (\\<Sum>i\\<in>A. a * x * c * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * d) = (\\<Sum>i\\<in>A. (a * x) * (c * x))\" using assms(3, 4) by simp\n  also have \"... = (\\<Sum>i\\<in>A. a * c * x^2)\" by (metis mult.assoc mult.left_commute power2_eq_square)\n  finally show ?thesis by (metis \\<open>(\\<Sum>i\\<in>A. b * d) = (\\<Sum>i\\<in>A. a * x * (c * x))\\<close> ab_semigroup_mult_class.mult_ac(1))\nqed", "description": "-", "full_code": "lemma sum_of_products_with_variable_weight:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"d = c * x\"\n  shows \"(\\<Sum>i\\<in>A. b * d) = (\\<Sum>i\\<in>A. a * x * c * x)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * d) = (\\<Sum>i\\<in>A. (a * x) * (c * x))\" using assms(3, 4) by simp\n  also have \"... = (\\<Sum>i\\<in>A. a * c * x^2)\" by (metis mult.assoc mult.left_commute power2_eq_square)\n  finally show ?thesis by (metis \\<open>(\\<Sum>i\\<in>A. b * d) = (\\<Sum>i\\<in>A. a * x * (c * x))\\<close> ab_semigroup_mult_class.mult_ac(1))\nqed", "origin": "sum_of_products_with_weight", "update_count": 0}, "generalized_weighted_sum": {"skill_name": "generalized_weighted_sum", "marker": "lemma generalized_weighted_sum:\n  fixes x y a b c :: real\n  assumes \"x > 0\" \"y > 0\" \"finite A\" \"b = a * x\" \"c = b * y\"\n  shows \"(\\<Sum>i\\<in>A. c) = (\\<Sum>i\\<in>A. a * x * y)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. c) = (\\<Sum>i\\<in>A. (b * y))\" using assms(5) by simp\n  also have \"... = (\\<Sum>i\\<in>A. (a * x * y))\" using assms(4) by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma generalized_weighted_sum:\n  fixes x y a b c :: real\n  assumes \"x > 0\" \"y > 0\" \"finite A\" \"b = a * x\" \"c = b * y\"\n  shows \"(\\<Sum>i\\<in>A. c) = (\\<Sum>i\\<in>A. a * x * y)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. c) = (\\<Sum>i\\<in>A. (b * y))\" using assms(5) by simp\n  also have \"... = (\\<Sum>i\\<in>A. (a * x * y))\" using assms(4) by simp\n  finally show ?thesis by simp\nqed", "origin": "sum_of_products_with_weight", "update_count": 0}, "range_of_values": {"skill_name": "range_of_values", "marker": "lemma range_of_values:\n  fixes N :: nat and a b c :: nat\n  assumes \"N = a + b * k\" \"N < c\" \"b > 0\"  \n  shows \"k < (c - a) / b\"\nproof -\n  from assms(1) have \"k = (N - a) / b\" \n    by (smt (verit) assms(3) diff_add_inverse nat_less_le nonzero_mult_div_cancel_left nonzero_mult_div_cancel_left of_nat_eq_0_iff of_nat_mult) \n  have \"N < c\" using assms(2) by assumption\n  then have \"a + b * k < c\" using assms(1) by simp\n  then have \"b * k < c - a\" by (simp add: field_simps)\n  then show ?thesis using `b > 0` by (metis less_imp_of_nat_less mult.commute mult_imp_less_div_pos of_nat_0_less_iff of_nat_mult)\nqed", "description": "-", "full_code": "lemma range_of_values:\n  fixes N :: nat and a b c :: nat\n  assumes \"N = a + b * k\" \"N < c\" \"b > 0\"  \n  shows \"k < (c - a) / b\"\nproof -\n  from assms(1) have \"k = (N - a) / b\" \n    by (smt (verit) assms(3) diff_add_inverse nat_less_le nonzero_mult_div_cancel_left nonzero_mult_div_cancel_left of_nat_eq_0_iff of_nat_mult) \n  have \"N < c\" using assms(2) by assumption\n  then have \"a + b * k < c\" using assms(1) by simp\n  then have \"b * k < c - a\" by (simp add: field_simps)\n  then show ?thesis using `b > 0` by (metis less_imp_of_nat_less mult.commute mult_imp_less_div_pos of_nat_0_less_iff of_nat_mult)\nqed", "origin": "do_request", "update_count": 0}, "logarithm_identity_generalV2": {"skill_name": "logarithm_identity_generalV2", "marker": "lemma logarithm_identity_general:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"c > 0\"\n  shows \"log a (b ^ c) = c * log a b\"\nproof -\n  have \"log a (b ^ c) = c * log a b\" by (metis assms(3) log_nat_power)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_identity_general:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"c > 0\"\n  shows \"log a (b ^ c) = c * log a b\"\nproof -\n  have \"log a (b ^ c) = c * log a b\" by (metis assms(3) log_nat_power)\n  thus ?thesis by simp\nqed", "origin": "logarithm_identity", "update_count": 0}, "gcd_lcm_propertyV2": {"skill_name": "gcd_lcm_propertyV2", "marker": "lemma gcd_lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"gcd a b * lcm a b = a * b\"\n  using assms\n  by auto", "description": "-", "full_code": "lemma gcd_lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"gcd a b * lcm a b = a * b\"\n  using assms\n  by auto", "origin": "do_request", "update_count": 0}, "lcm_definition": {"skill_name": "lcm_definition", "marker": "lemma lcm_definition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b * lcm a b = a * b\" using gcd_lcm_property assms by simp\n  hence \"lcm a b = (a * b) div gcd a b\" by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma gcd_lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"gcd a b * lcm a b = a * b\"\n  using assms\n  by auto\n\nlemma lcm_definition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b * lcm a b = a * b\" using gcd_lcm_property assms by simp\n  hence \"lcm a b = (a * b) div gcd a b\" by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "non_zero_product_propertyV2": {"skill_name": "non_zero_product_propertyV2", "marker": "lemma non_zero_product_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"(1 / a) * a = 1\" and \"(1 / b) * b = 1\"\nproof -\n  show \"(1 / a) * a = 1\" using assms(1) by (simp add: field_simps)\n  show \"(1 / b) * b = 1\" using assms(2) by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma non_zero_product_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"(1 / a) * a = 1\" and \"(1 / b) * b = 1\"\nproof -\n  show \"(1 / a) * a = 1\" using assms(1) by (simp add: field_simps)\n  show \"(1 / b) * b = 1\" using assms(2) by (simp add: field_simps)\nqed", "origin": "non_zero_property_in_multiple_dimensions", "update_count": 0}, "non_zero_product_propertyV3": {"skill_name": "non_zero_product_propertyV3", "marker": "lemma non_zero_product_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1 = (1 / a) * a\" and \"1 = (1 / b) * b\"\nproof -\n  show \"1 = (1 / a) * a\" using assms by (simp add: field_simps)\n  show \"1 = (1 / b) * b\" using assms by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma non_zero_product_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1 = (1 / a) * a\" and \"1 = (1 / b) * b\"\nproof -\n  show \"1 = (1 / a) * a\" using assms by (simp add: field_simps)\n  show \"1 = (1 / b) * b\" using assms by (simp add: field_simps)\nqed", "origin": "non_zero_property_in_multiple_dimensions", "update_count": 0}, "non_zero_product_propertyV4": {"skill_name": "non_zero_product_propertyV4", "marker": "lemma non_zero_product_property:\n  fixes A :: \"real list\"\n  assumes \"\\<forall>i. A ! i \\<noteq> 0\"\n  shows \"\\<forall> i. (A ! i) * (1 / (A ! i)) = 1\"\nproof -\n  show ?thesis\n  proof (rule allI)\n    fix i\n    have \"(A ! i) * (1 / (A ! i)) = 1\" using assms by (simp add: field_simps)\n    thus \"A ! i * (1 / (A ! i)) = 1\" by simp\n  qed\nqed", "description": "-", "full_code": "lemma non_zero_product_property:\n  fixes A :: \"real list\"\n  assumes \"\\<forall>i. A ! i \\<noteq> 0\"\n  shows \"\\<forall> i. (A ! i) * (1 / (A ! i)) = 1\"\nproof -\n  show ?thesis\n  proof (rule allI)\n    fix i\n    have \"(A ! i) * (1 / (A ! i)) = 1\" using assms by (simp add: field_simps)\n    thus \"A ! i * (1 / (A ! i)) = 1\" by simp\n  qed\nqed", "origin": "non_zero_property_in_multiple_dimensions", "update_count": 0}, "nat_inequality": {"skill_name": "nat_inequality", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 \\<le> b\"\nproof -\n  have \"a + 1 \\<le> b\" using assms\n  proof -\n    have \"a + 1 \\<le> a + 1 + (b - a - 1)\" \n      using assms by simp\n    also have \"... = b\" by (metis Suc_eq_plus1 Suc_eq_plus1_left Suc_leI assms cancel_ab_semigroup_add_class.diff_right_commute diff_diff_left le_add_diff_inverse)\n    ultimately show ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 \\<le> b\"\nproof -\n  have \"a + 1 \\<le> b\" using assms\n  proof -\n    have \"a + 1 \\<le> a + 1 + (b - a - 1)\" \n      using assms by simp\n    also have \"... = b\" by (metis Suc_eq_plus1 Suc_eq_plus1_left Suc_leI assms cancel_ab_semigroup_add_class.diff_right_commute diff_diff_left le_add_diff_inverse)\n    ultimately show ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "nat_inequalityV2": {"skill_name": "nat_inequalityV2", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 \\<le> b\"\nproof -\n  have \"a + 1 \\<le> a + 1 + (b - a - 1)\" using assms\n    by auto\n  also have \"... \\<le> b\" using assms by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 \\<le> b\"\nproof -\n  have \"a + 1 \\<le> a + 1 + (b - a - 1)\" using assms\n    by auto\n  also have \"... \\<le> b\" using assms by simp\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "log_power_generalization": {"skill_name": "log_power_generalization", "marker": "lemma log_power_generalization:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" and \"m > 0\"\n  shows \"log a (a^(n*m)) = n * m\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^(n*m)) = (n*m) * (log a a)\"\n    using log_nat_power[of a a \"n*m\"] by (simp add: assms(1))\n  then have c1: \"log a (a^(n*m)) = n * m\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "-", "full_code": "lemma log_power_generalization:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" and \"m > 0\"\n  shows \"log a (a^(n*m)) = n * m\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^(n*m)) = (n*m) * (log a a)\"\n    using log_nat_power[of a a \"n*m\"] by (simp add: assms(1))\n  then have c1: \"log a (a^(n*m)) = n * m\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "cancel_div_generalized": {"skill_name": "cancel_div_generalized", "marker": "lemma cancel_div_generalized:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"d > 0\" \"m * a + n * (b / x) = p\"\n  shows \"m * x * a + n * b = p * x\" and \"d * (m * a + n * (b / x)) = d * p\"\nproof -\n  have \"x * (m * a + n * (b / x)) = p * x\"\n    using assms(3) by auto\n  then have \"x * m * a + x * (n * (b / x)) = p * x\"\n    by (simp add: distrib_left)\n  then show \"m * x * a + n * b = p * x\"\n    using assms(1) by (simp add: mult.commute)\n  have \"d * (m * a + n * (b / x)) = d * p\"\n    using assms(3) by (simp add: distrib_left)\n  then show \"d * (m * a + n * (b / x)) = d * p\" by simp\nqed", "description": "-", "full_code": "lemma cancel_div_generalized:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"d > 0\" \"m * a + n * (b / x) = p\"\n  shows \"m * x * a + n * b = p * x\" and \"d * (m * a + n * (b / x)) = d * p\"\nproof -\n  have \"x * (m * a + n * (b / x)) = p * x\"\n    using assms(3) by auto\n  then have \"x * m * a + x * (n * (b / x)) = p * x\"\n    by (simp add: distrib_left)\n  then show \"m * x * a + n * b = p * x\"\n    using assms(1) by (simp add: mult.commute)\n  have \"d * (m * a + n * (b / x)) = d * p\"\n    using assms(3) by (simp add: distrib_left)\n  then show \"d * (m * a + n * (b / x)) = d * p\" by simp\nqed", "origin": "cancel_div_general", "update_count": 0}, "solve_congruences": {"skill_name": "solve_congruences", "marker": "lemma solve_congruences:\n  fixes k :: nat\n  assumes \"k mod 3 = 2\"\n  shows \"\\<exists>m. k = 3 * m + 2\"\nproof -\n  obtain m where \"k = 3 * m + (k mod 3)\" using assms\n    by (metis div_mod_decomp mult.commute nat_1_add_1)\n  then have \"k = 3 * m + 2\" using assms by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma solve_congruences:\n  fixes k :: nat\n  assumes \"k mod 3 = 2\"\n  shows \"\\<exists>m. k = 3 * m + 2\"\nproof -\n  obtain m where \"k = 3 * m + (k mod 3)\" using assms\n    by (metis div_mod_decomp mult.commute nat_1_add_1)\n  then have \"k = 3 * m + 2\" using assms by simp\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "express_in_terms_of_k": {"skill_name": "express_in_terms_of_k", "marker": "lemma express_in_terms_of_k:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N = 8 * k + 5\"\nproof -\n  show ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma express_in_terms_of_k:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N = 8 * k + 5\"\nproof -\n  show ?thesis using assms by simp\nqed", "origin": "do_request", "update_count": 0}, "integer_bounds": {"skill_name": "integer_bounds", "marker": "lemma integer_bounds:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> k. a + k < b\"\nproof -\n  have \"b > a\" using assms by simp\n  hence \"b - a > 0\" by auto\n  then obtain k where \"k = b - a - 1\" and \"k \\<ge> 0\" by auto\n  have \"a + k < b\" using `k = b - a - 1`\n    by (smt (verit) One_nat_def Suc_pred \\<open>0 < b - a\\<close> add_Suc_right assms lessI less_le_not_le ordered_cancel_comm_monoid_diff_class.add_diff_inverse)\n  thus ?thesis using `k = b - a - 1` by auto\nqed", "description": "-", "full_code": "lemma integer_bounds:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> k. a + k < b\"\nproof -\n  have \"b > a\" using assms by simp\n  hence \"b - a > 0\" by auto\n  then obtain k where \"k = b - a - 1\" and \"k \\<ge> 0\" by auto\n  have \"a + k < b\" using `k = b - a - 1`\n    by (smt (verit) One_nat_def Suc_pred \\<open>0 < b - a\\<close> add_Suc_right assms lessI less_le_not_le ordered_cancel_comm_monoid_diff_class.add_diff_inverse)\n  thus ?thesis using `k = b - a - 1` by auto\nqed", "origin": "do_request", "update_count": 0}, "congruence_8": {"skill_name": "congruence_8", "marker": "lemma congruence_8:\n  fixes k :: nat\n  shows \"\\<exists>N. N = 8 * k + 5\"\nproof -\n  let ?N = \"8 * k + 5\"\n  have \"?N = 8 * k + 5\" by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma congruence_8:\n  fixes k :: nat\n  shows \"\\<exists>N. N = 8 * k + 5\"\nproof -\n  let ?N = \"8 * k + 5\"\n  have \"?N = 8 * k + 5\" by simp\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sum_of_productsV4": {"skill_name": "sum_of_productsV4", "marker": "lemma sum_of_products:\n  fixes a b c :: real\n  assumes \"A \\<noteq> {}\" \"b = a * c\"\n  shows \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * c)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. (a * c))\" using assms(2) by simp\n  also have \"... = a * (\\<Sum>i\\<in>A. c)\" by (simp add: sum_distrib_left)\n  also have \"... = (\\<Sum>i\\<in>A. a * c)\" by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_products:\n  fixes a b c :: real\n  assumes \"A \\<noteq> {}\" \"b = a * c\"\n  shows \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * c)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. (a * c))\" using assms(2) by simp\n  also have \"... = a * (\\<Sum>i\\<in>A. c)\" by (simp add: sum_distrib_left)\n  also have \"... = (\\<Sum>i\\<in>A. a * c)\" by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "origin": "sum_of_weights", "update_count": 0}, "sum_of_weights_general": {"skill_name": "sum_of_weights_general", "marker": "lemma sum_of_weights_general:\n  fixes A :: \"'a set\" and a b x c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c)\" using sum_of_products assms by simp", "description": "-", "full_code": "lemma sum_of_products:\n  fixes A :: \"'a set\" and x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = (\\<Sum>i\\<in>A. a * x * c)\" by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed\n\nlemma sum_of_weights_general:\n  fixes A :: \"'a set\" and a b x c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c)\" using sum_of_products assms by simp", "origin": "sum_of_weights", "update_count": 0}, "sum_of_productsV5": {"skill_name": "sum_of_productsV5", "marker": "lemma sum_of_products:\n  fixes A :: \"'a set\" and x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = (\\<Sum>i\\<in>A. a * x * c)\" by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_products:\n  fixes A :: \"'a set\" and x a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * x * c)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = (\\<Sum>i\\<in>A. a * x * c)\" by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "origin": "sum_of_weights", "update_count": 0}, "weighted_sum_identity": {"skill_name": "weighted_sum_identity", "marker": "lemma weighted_sum_identity:\n  fixes a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = x * c * (\\<Sum>i\\<in>A. a)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = c * x * (\\<Sum>i\\<in>A. a)\" by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma weighted_sum_identity:\n  fixes a b c :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = x * c * (\\<Sum>i\\<in>A. a)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * c)\" using assms(3) by simp\n  also have \"... = c * (\\<Sum>i\\<in>A. a * x)\" by (simp add: sum_distrib_left)\n  also have \"... = c * x * (\\<Sum>i\\<in>A. a)\" by (simp add: sum_distrib_right)\n  finally show ?thesis by simp\nqed", "origin": "sum_of_weights", "update_count": 0}, "gcd_lcm_extended_property": {"skill_name": "gcd_lcm_extended_property", "marker": "lemma gcd_lcm_extended_property:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"gcd (a * c) (b * c) = c * gcd a b\"\nproof -\n  have \"gcd (a * c) (b * c) = gcd (c * a) (c * b)\" by (auto simp: field_simps)\n  also have \"... = c * gcd a b\"\n    using assms by (metis gcd_mult_distrib_nat)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma gcd_lcm_extended_property:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"gcd (a * c) (b * c) = c * gcd a b\"\nproof -\n  have \"gcd (a * c) (b * c) = gcd (c * a) (c * b)\" by (auto simp: field_simps)\n  also have \"... = c * gcd a b\"\n    using assms by (metis gcd_mult_distrib_nat)\n  finally show ?thesis .\nqed", "origin": "lcm_definition", "update_count": 0}, "logarithm_identity_generalV3": {"skill_name": "logarithm_identity_generalV3", "marker": "lemma logarithm_identity_general:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"c > 0\"\n  shows \"log a (a ^ c) = c\"\nproof -\n  have \"log a (a ^ c) = c * log a a\" by (metis assms(1) log_nat_power)\n  also have \"... = c * 1\" by (metis assms(1) assms(2) log_eq_one mult.comm_neutral mult.right_neutral)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_identity_general:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"c > 0\"\n  shows \"log a (a ^ c) = c\"\nproof -\n  have \"log a (a ^ c) = c * log a a\" by (metis assms(1) log_nat_power)\n  also have \"... = c * 1\" by (metis assms(1) assms(2) log_eq_one mult.comm_neutral mult.right_neutral)\n  finally show ?thesis by simp\nqed", "origin": "logarithm_identity", "update_count": 0}, "logarithm_identity_generalized": {"skill_name": "logarithm_identity_generalized", "marker": "lemma logarithm_identity_generalized:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"c > 0\"\n  shows \"log a (b ^ c) = c * log a b\"\nproof -\n  have \"log a (b ^ c) = c * log a b\" by (metis log_nat_power assms(1) assms(2) assms(3))\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_identity_generalized:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"c > 0\"\n  shows \"log a (b ^ c) = c * log a b\"\nproof -\n  have \"log a (b ^ c) = c * log a b\" by (metis log_nat_power assms(1) assms(2) assms(3))\n  thus ?thesis by simp\nqed", "origin": "logarithm_identity", "update_count": 0}, "modular_arithmetic": {"skill_name": "modular_arithmetic", "marker": "lemma modular_arithmetic:\n  fixes a b c :: nat\n  assumes \"a mod b = c\"\n  shows \"\\<exists>k. a = b * k + c\"\nproof -\n  have \"a = b * (a div b) + a mod b\"\n    by auto \n  then show ?thesis\n    using assms by auto\nqed", "description": "-", "full_code": "lemma modular_arithmetic:\n  fixes a b c :: nat\n  assumes \"a mod b = c\"\n  shows \"\\<exists>k. a = b * k + c\"\nproof -\n  have \"a = b * (a div b) + a mod b\"\n    by auto \n  then show ?thesis\n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "general_sum_propertyV2": {"skill_name": "general_sum_propertyV2", "marker": "theorem general_sum_property:\n  fixes a b c d :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"a + b + c + d = a + b + c + d\"\nproof -\n  show ?thesis by simp\nqed", "description": "-", "full_code": "theorem general_sum_property:\n  fixes a b c d :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"a + b + c + d = a + b + c + d\"\nproof -\n  show ?thesis by simp\nqed", "origin": "general_sum_property", "update_count": 0}, "sum_of_sumsV2": {"skill_name": "sum_of_sumsV2", "marker": "lemma sum_of_sums:\n  fixes A :: \"'a set\" and x a b :: real\n  assumes \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. a + b) = card A * a + card A * b\"\nproof -\n  have \"(\\<Sum>i\\<in>A. a + b) = (\\<Sum>i\\<in>A. a) + (\\<Sum>i\\<in>A. b)\" by (simp add: distrib_left)\n  then have \"(\\<Sum>i\\<in>A. a) = card A * a\" and \"(\\<Sum>i\\<in>A. b) = card A * b\" using assms by auto\n  then show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma sum_of_sums:\n  fixes A :: \"'a set\" and x a b :: real\n  assumes \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. a + b) = card A * a + card A * b\"\nproof -\n  have \"(\\<Sum>i\\<in>A. a + b) = (\\<Sum>i\\<in>A. a) + (\\<Sum>i\\<in>A. b)\" by (simp add: distrib_left)\n  then have \"(\\<Sum>i\\<in>A. a) = card A * a\" and \"(\\<Sum>i\\<in>A. b) = card A * b\" using assms by auto\n  then show ?thesis by (auto simp: field_simps)\nqed", "origin": "sum_of_sums", "update_count": 0}, "sum_of_scalars": {"skill_name": "sum_of_scalars", "marker": "lemma sum_of_scalars:\n  fixes A :: \"'a set\" and a b :: real\n  assumes \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. a * b) = card A * a * b\"\nproof -\n  have \"(\\<Sum>i\\<in>A. a * b) = (\\<Sum>i\\<in>A. a) * b\" by (simp add: distrib_left)\n  then show ?thesis by (simp add: card_image)\nqed", "description": "-", "full_code": "lemma sum_of_scalars:\n  fixes A :: \"'a set\" and a b :: real\n  assumes \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. a * b) = card A * a * b\"\nproof -\n  have \"(\\<Sum>i\\<in>A. a * b) = (\\<Sum>i\\<in>A. a) * b\" by (simp add: distrib_left)\n  then show ?thesis by (simp add: card_image)\nqed", "origin": "sum_of_sums", "update_count": 0}, "sum_of_sums_generalized": {"skill_name": "sum_of_sums_generalized", "marker": "lemma sum_of_sums_generalized:\n  fixes A :: \"'a set\" and f g :: real\n  assumes \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. f + g) = card A * f + card A * g\"\nproof -\n  have \"(\\<Sum>i\\<in>A. f + g) = (\\<Sum>i\\<in>A. f) + (\\<Sum>i\\<in>A. g)\" by (simp add: distrib_left)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_of_sums_generalized:\n  fixes A :: \"'a set\" and f g :: real\n  assumes \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. f + g) = card A * f + card A * g\"\nproof -\n  have \"(\\<Sum>i\\<in>A. f + g) = (\\<Sum>i\\<in>A. f) + (\\<Sum>i\\<in>A. g)\" by (simp add: distrib_left)\n  then show ?thesis by auto\nqed", "origin": "sum_of_sums", "update_count": 0}, "solve_linear_congruence": {"skill_name": "solve_linear_congruence", "marker": "lemma solve_linear_congruence:\n  fixes a b m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"(\\<exists>x. x mod m = b) \\<longleftrightarrow> (b < m)\"\nproof\n  assume \"b < m\"\n  then have \"b mod m = b\" by (simp add: mod_less)\n  then show \"\\<exists>x. x mod m = b\" \n    by (rule_tac x=b in exI) auto\nnext\n  assume \"\\<exists>x. x mod m = b\"\n  then obtain x where \"x mod m = b\" by auto\n  then have \"0 \\<le> b\" by auto\n  moreover have \"b < m\" \n  proof -\n    have \"x mod m < m\" by (metis \\<open>x mod m = b\\<close> assms(2) dual_order.strict_trans2 mod_less_divisor order_refl)\n    thus ?thesis using `x mod m = b` by simp\n  qed\n  ultimately show \"b < m\" by auto\nqed", "description": "-", "full_code": "lemma solve_linear_congruence:\n  fixes a b m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"(\\<exists>x. x mod m = b) \\<longleftrightarrow> (b < m)\"\nproof\n  assume \"b < m\"\n  then have \"b mod m = b\" by (simp add: mod_less)\n  then show \"\\<exists>x. x mod m = b\" \n    by (rule_tac x=b in exI) auto\nnext\n  assume \"\\<exists>x. x mod m = b\"\n  then obtain x where \"x mod m = b\" by auto\n  then have \"0 \\<le> b\" by auto\n  moreover have \"b < m\" \n  proof -\n    have \"x mod m < m\" by (metis \\<open>x mod m = b\\<close> assms(2) dual_order.strict_trans2 mod_less_divisor order_refl)\n    thus ?thesis using `x mod m = b` by simp\n  qed\n  ultimately show \"b < m\" by auto\nqed", "origin": "do_request", "update_count": 0}, "solve_linear_congruenceV2": {"skill_name": "solve_linear_congruenceV2", "marker": "lemma solve_linear_congruence:\n  fixes a b m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"(\\<exists>x. x mod m = b) \\<longleftrightarrow> (b < m)\"\nproof -\n  {\n    assume \"b < m\"\n    then have \"b mod m = b\" by (simp add: mod_less)\n    hence \"\\<exists>x. x mod m = b\" \n      by auto\n  }\n  moreover\n  {\n    assume \"\\<exists>x. x mod m = b\"\n    then obtain x where \"x mod m = b\" by auto\n    then have \"b < m\" \n      using assms by auto\n  }\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma solve_linear_congruence:\n  fixes a b m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"(\\<exists>x. x mod m = b) \\<longleftrightarrow> (b < m)\"\nproof -\n  {\n    assume \"b < m\"\n    then have \"b mod m = b\" by (simp add: mod_less)\n    hence \"\\<exists>x. x mod m = b\" \n      by auto\n  }\n  moreover\n  {\n    assume \"\\<exists>x. x mod m = b\"\n    then obtain x where \"x mod m = b\" by auto\n    then have \"b < m\" \n      using assms by auto\n  }\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_add": {"skill_name": "mod_add", "marker": "lemma mod_add:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"(a + c) mod m = (a mod m + c) mod m\"\n    by (metis mod_add_left_eq)\n  also have \"... = (b + c) mod m\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"(a + c) mod m = (a mod m + c) mod m\"\n    by (metis mod_add_left_eq)\n  also have \"... = (b + c) mod m\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sum_of_weights_variable": {"skill_name": "sum_of_weights_variable", "marker": "lemma sum_of_weights_variable:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"c = d * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * d * x^2)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * (d * x))\" using assms(3) and assms(4) by simp\n  also have \"... = (\\<Sum>i\\<in>A. a * d * x^2)\" by (metis mult.assoc mult.left_commute power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_weights_variable:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\" \"c = d * x\"\n  shows \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. a * d * x^2)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b * c) = (\\<Sum>i\\<in>A. (a * x) * (d * x))\" using assms(3) and assms(4) by simp\n  also have \"... = (\\<Sum>i\\<in>A. a * d * x^2)\" by (metis mult.assoc mult.left_commute power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "sum_of_weights", "update_count": 0}, "mod_addV2": {"skill_name": "mod_addV2", "marker": "lemma mod_add:\n  fixes x y n :: nat\n  assumes \"n > 0\"\n  shows \"(x + y) mod n = ((x mod n) + (y mod n)) mod n\"\nproof -\n  have \"x + y = (x mod n) + (y mod n) + n * ((x div n) + (y div n))\"\n    by (auto simp: field_simps)\n  then have \"(x + y) mod n = (((x mod n) + (y mod n)) + n * ((x div n) + (y div n))) mod n\"\n    by simp\n  also have \"... = ((x mod n) + (y mod n)) mod n\"\n    using `n > 0` by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes x y n :: nat\n  assumes \"n > 0\"\n  shows \"(x + y) mod n = ((x mod n) + (y mod n)) mod n\"\nproof -\n  have \"x + y = (x mod n) + (y mod n) + n * ((x div n) + (y div n))\"\n    by (auto simp: field_simps)\n  then have \"(x + y) mod n = (((x mod n) + (y mod n)) + n * ((x div n) + (y div n))) mod n\"\n    by simp\n  also have \"... = ((x mod n) + (y mod n)) mod n\"\n    using `n > 0` by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_simplification": {"skill_name": "mod_simplification", "marker": "lemma mod_simplification:\n  fixes x y a :: nat\n  assumes \"x mod y = a\" \"y > 0\"\n  shows \"\\<exists>k. x = k * y + a\"\nproof -\n  have \"x = y * (x div y) + x mod y\"\n    by auto\n  then have \"x = y * (x div y) + a\"\n    using assms(1) by auto\n  then show ?thesis\n    by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma mod_simplification:\n  fixes x y a :: nat\n  assumes \"x mod y = a\" \"y > 0\"\n  shows \"\\<exists>k. x = k * y + a\"\nproof -\n  have \"x = y * (x div y) + x mod y\"\n    by auto\n  then have \"x = y * (x div y) + a\"\n    using assms(1) by auto\n  then show ?thesis\n    by (auto simp: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "sum_of_n_values_extended": {"skill_name": "sum_of_n_values_extended", "marker": "theorem sum_of_n_values_extended:\n  fixes n1 n2 n3 n4 :: nat\n  assumes \"n1 = 21\" \"n2 = 45\" \"n3 = 5\" \"n4 = 10\"\n  shows \"n1 + n2 + n3 + n4 = 81\"\nproof -\n  have \"n1 + n2 + n3 + n4 = 21 + 45 + 5 + 10\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem sum_of_n_values_extended:\n  fixes n1 n2 n3 n4 :: nat\n  assumes \"n1 = 21\" \"n2 = 45\" \"n3 = 5\" \"n4 = 10\"\n  shows \"n1 + n2 + n3 + n4 = 81\"\nproof -\n  have \"n1 + n2 + n3 + n4 = 21 + 45 + 5 + 10\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "sum_of_n_values", "update_count": 0}, "mod_add_generalized": {"skill_name": "mod_add_generalized", "marker": "lemma mod_add_generalized:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  have \"c mod m = d\" by (simp add: assms(2))\n  have \"(a + c) mod m = (a mod m + c mod m) mod m\"\n    by presburger\n  also have \"... = (b + d) mod m\"\n    using assms by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add_generalized:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  have \"c mod m = d\" by (simp add: assms(2))\n  have \"(a + c) mod m = (a mod m + c mod m) mod m\"\n    by presburger\n  also have \"... = (b + d) mod m\"\n    using assms by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "origin": "mod_add", "update_count": 0}, "mod_addV3": {"skill_name": "mod_addV3", "marker": "lemma mod_add:\n  fixes a b c :: nat\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof (cases \"c = 0\")\n  case True\n  then show ?thesis by simp\nnext\n  case False\n  then have \"c > 0\" by simp\n  have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod c = (((a mod c) + (b mod c)) + c * ((a div c) + (b div c))) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    using `c > 0` by (simp add: mod_add_left_eq)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c :: nat\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof (cases \"c = 0\")\n  case True\n  then show ?thesis by simp\nnext\n  case False\n  then have \"c > 0\" by simp\n  have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod c = (((a mod c) + (b mod c)) + c * ((a div c) + (b div c))) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    using `c > 0` by (simp add: mod_add_left_eq)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_addV4": {"skill_name": "mod_addV4", "marker": "lemma mod_add:\n  fixes a b c :: nat\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod c = (((a mod c) + (b mod c)) + c * ((a div c) + (b div c))) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n  proof (cases \"c * ((a div c) + (b div c)) mod c = 0\")\n    case True\n    then show ?thesis\n      by (simp add: mod_0)\n  next\n    case False\n    then have \"c * ((a div c) + (b div c)) mod c = 0\"\n      by (simp add: mod_mult_self1)\n    then show ?thesis\n      by (simp add: mod_add_eq)\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c :: nat\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod c = (((a mod c) + (b mod c)) + c * ((a div c) + (b div c))) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n  proof (cases \"c * ((a div c) + (b div c)) mod c = 0\")\n    case True\n    then show ?thesis\n      by (simp add: mod_0)\n  next\n    case False\n    then have \"c * ((a div c) + (b div c)) mod c = 0\"\n      by (simp add: mod_mult_self1)\n    then show ?thesis\n      by (simp add: mod_add_eq)\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "express_in_terms_of_k_m": {"skill_name": "express_in_terms_of_k_m", "marker": "lemma express_in_terms_of_k_m:\n  fixes k m :: nat\n  shows \"\\<exists>N. N = 24 * m + 21\"\nproof -\n  let ?N = \"24 * m + 21\"\n  have \"?N = 24 * m + 21\" by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma express_in_terms_of_k_m:\n  fixes k m :: nat\n  shows \"\\<exists>N. N = 24 * m + 21\"\nproof -\n  let ?N = \"24 * m + 21\"\n  have \"?N = 24 * m + 21\" by simp\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_simplification_extended": {"skill_name": "mod_simplification_extended", "marker": "lemma mod_simplification_extended:\n  fixes x y a d :: nat\n  assumes \"y > 0\" and \"x mod y = a\" and \"x mod d = a\"\n  shows \"\\<exists>k. x = k * y + a\" and \"\\<exists>m. x = m * d + a\"\nproof -\n  have \"x = y * (x div y) + x mod y\"\n    by auto\n  then have \"x = y * (x div y) + a\"\n    using assms(2) by auto\n  have \"x = d * (x div d) + x mod d\"\n    by auto\n  then have \"x = d * (x div d) + a\"\n    using assms(3) by auto\n  show \"\\<exists>k. x = k * y + a\" \n    by (metis \\<open>x = y * (x div y) + a\\<close> mult.commute)\n  show \"\\<exists>m. x = m * d + a\" \n    by (metis \\<open>x = d * (x div d) + a\\<close> mult.commute)\nqed", "description": "-", "full_code": "lemma mod_simplification_extended:\n  fixes x y a d :: nat\n  assumes \"y > 0\" and \"x mod y = a\" and \"x mod d = a\"\n  shows \"\\<exists>k. x = k * y + a\" and \"\\<exists>m. x = m * d + a\"\nproof -\n  have \"x = y * (x div y) + x mod y\"\n    by auto\n  then have \"x = y * (x div y) + a\"\n    using assms(2) by auto\n  have \"x = d * (x div d) + x mod d\"\n    by auto\n  then have \"x = d * (x div d) + a\"\n    using assms(3) by auto\n  show \"\\<exists>k. x = k * y + a\" \n    by (metis \\<open>x = y * (x div y) + a\\<close> mult.commute)\n  show \"\\<exists>m. x = m * d + a\" \n    by (metis \\<open>x = d * (x div d) + a\\<close> mult.commute)\nqed", "origin": "mod_simplification", "update_count": 0}, "mod_simplification_generalized": {"skill_name": "mod_simplification_generalized", "marker": "lemma mod_simplification_generalized:\n  fixes x y a :: nat\n  assumes \"y > 0\"\n  shows \"\\<exists>k. x = k * y + (x mod y)\"\nproof -\n  let ?a = \"x mod y\"\n  have \"x = y * (x div y) + ?a\" by auto\n  then show ?thesis by (metis div_mod_decomp)\nqed", "description": "-", "full_code": "lemma mod_simplification_generalized:\n  fixes x y a :: nat\n  assumes \"y > 0\"\n  shows \"\\<exists>k. x = k * y + (x mod y)\"\nproof -\n  let ?a = \"x mod y\"\n  have \"x = y * (x div y) + ?a\" by auto\n  then show ?thesis by (metis div_mod_decomp)\nqed", "origin": "mod_simplification", "update_count": 0}, "mod_simplification_multiple": {"skill_name": "mod_simplification_multiple", "marker": "lemma mod_simplification_multiple:\n  fixes x y z a b :: nat\n  assumes \"y > 0\" \"z > 0\"\n  shows \"\\<exists>k1 k2. x = k1 * y + (x mod y) \\<and> x = k2 * z + (x mod z)\"\nproof -\n  obtain k1 where \"x = k1 * y + (x mod y)\" \n    using mod_simplification_generalized[OF assms(1)] by auto\n  obtain k2 where \"x = k2 * z + (x mod z)\" \n    using mod_simplification_generalized[OF assms(2)] by auto\n  thus ?thesis by (metis \\<open>\\<And>thesis. (\\<And>k1. x = k1 * y + x mod y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close> \\<open>\\<And>thesis. (\\<And>k2. x = k2 * z + x mod z \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>)\nqed", "description": "-", "full_code": "lemma mod_simplification_generalized:\n  fixes x y a :: nat\n  assumes \"y > 0\"\n  shows \"\\<exists>k. x = k * y + (x mod y)\"\nproof -\n  let ?a = \"x mod y\"\n  have \"x = y * (x div y) + ?a\" by auto\n  then show ?thesis by (metis div_mod_decomp)\nqed\n\nlemma mod_simplification_multiple:\n  fixes x y z a b :: nat\n  assumes \"y > 0\" \"z > 0\"\n  shows \"\\<exists>k1 k2. x = k1 * y + (x mod y) \\<and> x = k2 * z + (x mod z)\"\nproof -\n  obtain k1 where \"x = k1 * y + (x mod y)\" \n    using mod_simplification_generalized[OF assms(1)] by auto\n  obtain k2 where \"x = k2 * z + (x mod z)\" \n    using mod_simplification_generalized[OF assms(2)] by auto\n  thus ?thesis by (metis \\<open>\\<And>thesis. (\\<And>k1. x = k1 * y + x mod y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close> \\<open>\\<And>thesis. (\\<And>k2. x = k2 * z + x mod z \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>)\nqed", "origin": "mod_simplification", "update_count": 0}, "sum_of_four_numbers": {"skill_name": "sum_of_four_numbers", "marker": "lemma sum_of_four_numbers:\n  fixes a b c d :: nat\n  assumes \"a = 21\" \"b = 45\" \"c = 5\" \"d = 10\"\n  shows \"a + b + c + d = 81\"\nproof -\n  have \"a + b + c + d = 21 + 45 + 5 + 10\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_four_numbers:\n  fixes a b c d :: nat\n  assumes \"a = 21\" \"b = 45\" \"c = 5\" \"d = 10\"\n  shows \"a + b + c + d = 81\"\nproof -\n  have \"a + b + c + d = 21 + 45 + 5 + 10\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "general_sum_property", "update_count": 0}, "mod_properties": {"skill_name": "mod_properties", "marker": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a = (a mod c) + c * (a div c)\"\n    using assms by auto\n  have \"b = (b mod c) + c * (b div c)\"\n    using assms by auto\n  then have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\"\n    using `a > 0` `b > 0` by (auto simp: field_simps)\n  then have \"(a + b) mod c = (((a mod c) + (b mod c)) + c * ((a div c) + (b div c))) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n  proof (cases \"c * ((a div c) + (b div c)) mod c = 0\")\n    case True\n    then show ?thesis\n      by (simp add: mod_0)\n  next\n    case False\n    then have \"c * ((a div c) + (b div c)) mod c = 0\"\n      by (simp add: mod_mult_self1)\n    then show ?thesis\n      by (simp add: mod_add_eq)\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a = (a mod c) + c * (a div c)\"\n    using assms by auto\n  have \"b = (b mod c) + c * (b div c)\"\n    using assms by auto\n  then have \"a + b = (a mod c) + (b mod c) + c * ((a div c) + (b div c))\"\n    using `a > 0` `b > 0` by (auto simp: field_simps)\n  then have \"(a + b) mod c = (((a mod c) + (b mod c)) + c * ((a div c) + (b div c))) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n  proof (cases \"c * ((a div c) + (b div c)) mod c = 0\")\n    case True\n    then show ?thesis\n      by (simp add: mod_0)\n  next\n    case False\n    then have \"c * ((a div c) + (b div c)) mod c = 0\"\n      by (simp add: mod_mult_self1)\n    then show ?thesis\n      by (simp add: mod_add_eq)\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sum_product_of_constants": {"skill_name": "sum_product_of_constants", "marker": "lemma sum_product_of_constants:\n  fixes a b :: real\n  assumes \"x > 0\" \"finite A\" \"finite B\"\n  shows \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. a * b) = card A * card B * a * b\"\nproof -\n  have \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. a * b) = (\\<Sum>i\\<in>A. card B * (a * b))\" by (simp add: sum_constant)\n  also have \"... = card A * card B * a * b\" by (simp add: sum_constant)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_product_of_constants:\n  fixes a b :: real\n  assumes \"x > 0\" \"finite A\" \"finite B\"\n  shows \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. a * b) = card A * card B * a * b\"\nproof -\n  have \"(\\<Sum>i\\<in>A. \\<Sum>j\\<in>B. a * b) = (\\<Sum>i\\<in>A. card B * (a * b))\" by (simp add: sum_constant)\n  also have \"... = card A * card B * a * b\" by (simp add: sum_constant)\n  finally show ?thesis by auto\nqed", "origin": "sum_of_productsV3", "update_count": 0}, "sum_of_productsV6": {"skill_name": "sum_of_productsV6", "marker": "lemma sum_of_products:\n  fixes x a b :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b) = card A * a * x\"\n  and \"(\\<Sum>i\\<in>A. b * x) = card A * a * x^2\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\" using assms(3) by simp\n  then have \"(\\<Sum>i\\<in>A. b) = card A * a * x\" using `finite A` by auto\n  then show \"(\\<Sum>i\\<in>A. b) = card A * a * x\" by simp\nnext\n  have \"b * x = (a * x) * x\" using assms(3) by simp\n  then show \"(\\<Sum>i\\<in>A. b * x) = card A * a * x^2\" \n    using `finite A` by (metis assms(3) mult.assoc mult.commute mult.left_commute power2_eq_square sum_constant)\nqed", "description": "-", "full_code": "lemma sum_of_products:\n  fixes x a b :: real\n  assumes \"x > 0\" \"finite A\" \"b = a * x\"\n  shows \"(\\<Sum>i\\<in>A. b) = card A * a * x\"\n  and \"(\\<Sum>i\\<in>A. b * x) = card A * a * x^2\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b) = (\\<Sum>i\\<in>A. a * x)\" using assms(3) by simp\n  then have \"(\\<Sum>i\\<in>A. b) = card A * a * x\" using `finite A` by auto\n  then show \"(\\<Sum>i\\<in>A. b) = card A * a * x\" by simp\nnext\n  have \"b * x = (a * x) * x\" using assms(3) by simp\n  then show \"(\\<Sum>i\\<in>A. b * x) = card A * a * x^2\" \n    using `finite A` by (metis assms(3) mult.assoc mult.commute mult.left_commute power2_eq_square sum_constant)\nqed", "origin": "sum_of_products_multiV2", "update_count": 0}, "sum_non_negativity": {"skill_name": "sum_non_negativity", "marker": "lemma sum_non_negativity:\n  fixes a b c d :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"a + b + c + d > 0\"\nproof -\n  have \"a + b > 0\" using assms by simp\n  then have \"a + b + c > 0\" using assms by simp\n  then show ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma sum_non_negativity:\n  fixes a b c d :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"a + b + c + d > 0\"\nproof -\n  have \"a + b > 0\" using assms by simp\n  then have \"a + b + c > 0\" using assms by simp\n  then show ?thesis using assms by simp\nqed", "origin": "general_sum_propertyV2", "update_count": 0}, "sum_positive": {"skill_name": "sum_positive", "marker": "lemma sum_positive:\n  fixes a b c d :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"a + b + c + d > 0\"\nproof -\n  have \"a + b > 0\" using assms by simp\n  then have \"a + b + c > 0\" using assms(3) by simp\n  then have \"a + b + c + d > 0\" using assms(4) by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_positive:\n  fixes a b c d :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"a + b + c + d > 0\"\nproof -\n  have \"a + b > 0\" using assms by simp\n  then have \"a + b + c > 0\" using assms(3) by simp\n  then have \"a + b + c + d > 0\" using assms(4) by simp\n  thus ?thesis by simp\nqed", "origin": "general_sum_propertyV2", "update_count": 0}, "multiplicative_inverse_properties": {"skill_name": "multiplicative_inverse_properties", "marker": "lemma multiplicative_inverse_properties:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(1 / a) * a = 1 \\<and> (1 / b) * b = 1\"\nproof -\n  have prop_a: \"(1 / a) * a = 1\" using multiplicative_inverse_property[of a] assms(1) by simp\n  have prop_b: \"(1 / b) * b = 1\" using multiplicative_inverse_property[of b] assms(2) by simp\n  show ?thesis by (metis prop_a prop_b)\nqed", "description": "-", "full_code": "lemma nonzero_multiplicative_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"1 / a \\<noteq> 0\" using assms by auto\n  then show ?thesis by (simp add: assms)\nqed\n\nlemma multiplicative_inverse_property:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(1 / a) * a = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using nonzero_multiplicative_inverse assms by simp\n  then show ?thesis using assms by (simp add: field_simps)\nqed\n\nlemma multiplicative_inverse_properties:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(1 / a) * a = 1 \\<and> (1 / b) * b = 1\"\nproof -\n  have prop_a: \"(1 / a) * a = 1\" using multiplicative_inverse_property[of a] assms(1) by simp\n  have prop_b: \"(1 / b) * b = 1\" using multiplicative_inverse_property[of b] assms(2) by simp\n  show ?thesis by (metis prop_a prop_b)\nqed", "origin": "multiplicative_inverse_property", "update_count": 0}, "bound_check": {"skill_name": "bound_check", "marker": "lemma bound_check:\n  fixes n k c :: nat\n  assumes \"n < k\"\n  shows \"n + c < k + c\"\nproof -\n  have \"n + c < k + c\" \n  proof -\n    have \"n < k\" using assms by simp\n    hence \"n + c < k + c\" \n      using add_strict_mono by auto\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma bound_check:\n  fixes n k c :: nat\n  assumes \"n < k\"\n  shows \"n + c < k + c\"\nproof -\n  have \"n + c < k + c\" \n  proof -\n    have \"n < k\" using assms by simp\n    hence \"n + c < k + c\" \n      using add_strict_mono by auto\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "bound_checkV2": {"skill_name": "bound_checkV2", "marker": "lemma bound_check:\n  fixes n k c :: nat\n  assumes \"n < k\"\n  shows \"n + c < k + c\"\nproof -\n  have \"n + c < k + c\" using assms\n  proof -\n    have \"n < k\" by (simp add: assms)\n    then have \"n + c + 0 < k + c + 0\" by auto\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma bound_check:\n  fixes n k c :: nat\n  assumes \"n < k\"\n  shows \"n + c < k + c\"\nproof -\n  have \"n + c < k + c\" using assms\n  proof -\n    have \"n < k\" by (simp add: assms)\n    then have \"n + c + 0 < k + c + 0\" by auto\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "bound_checkV3": {"skill_name": "bound_checkV3", "marker": "lemma bound_check:\n  fixes n k c :: nat\n  assumes \"n < k\"\n  shows \"n + c < k + c\"\nproof -\n  have \"n + c < k + c\" using assms\n  proof -\n    have \"n < k\" using assms by simp\n    hence \"n + c < k + c\" \n      by auto\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma bound_check:\n  fixes n k c :: nat\n  assumes \"n < k\"\n  shows \"n + c < k + c\"\nproof -\n  have \"n + c < k + c\" using assms\n  proof -\n    have \"n < k\" using assms by simp\n    hence \"n + c < k + c\" \n      by auto\n    thus ?thesis by simp\n  qed\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "logarithm_identity_exponentiation": {"skill_name": "logarithm_identity_exponentiation", "marker": "lemma logarithm_identity_exponentiation:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"c > 0\"\n  shows \"log a (a ^ c) = c\"\nproof -\n  have \"log a (a ^ c) = c * log a a\" by (metis assms(1) log_nat_power)\n  also have \"... = c * 1\" by (metis assms(1) assms(2) log_eq_one mult.comm_neutral mult.right_neutral)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_identity_exponentiation:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"c > 0\"\n  shows \"log a (a ^ c) = c\"\nproof -\n  have \"log a (a ^ c) = c * log a a\" by (metis assms(1) log_nat_power)\n  also have \"... = c * 1\" by (metis assms(1) assms(2) log_eq_one mult.comm_neutral mult.right_neutral)\n  finally show ?thesis by simp\nqed", "origin": "logarithm_identity_generalV3", "update_count": 0}, "gcd_positive": {"skill_name": "gcd_positive", "marker": "lemma gcd_positive:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"gcd a b > 0\"\nproof -\n  from assms show ?thesis by (simp add: gcd_pos_nat)\nqed", "description": "-", "full_code": "lemma gcd_positive:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"gcd a b > 0\"\nproof -\n  from assms show ?thesis by (simp add: gcd_pos_nat)\nqed", "origin": "do_request", "update_count": 0}, "gcd_positiveV2": {"skill_name": "gcd_positiveV2", "marker": "lemma gcd_positive:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"gcd a b > 0\"\n  using assms by auto", "description": "-", "full_code": "lemma gcd_positive:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"gcd a b > 0\"\n  using assms by auto", "origin": "do_request", "update_count": 0}, "inequality_bounds": {"skill_name": "inequality_bounds", "marker": "lemma inequality_bounds:\n  fixes x :: nat\n  assumes \"x < c\" \"x = a + b\"\n  shows \"a < c \\<and> b < c\"\nproof -\n  obtain k where \"x = a + b\" using assms(2) by auto\n  have \"a + b < c\" using assms(1) by (metis assms(2))\n  then have \"a < c\" \n  proof -\n    have \"b < c - a\" using `a + b < c` by auto\n    thus \"a < c\" using `x = a + b` by auto\n  qed\n  moreover have \"b < c\" \n  proof -\n    have \"a < c - b\" using `a + b < c` by auto\n    thus \"b < c\" using `x = a + b` by auto\n  qed\n  ultimately show \"a < c \\<and> b < c\" by simp\nqed", "description": "-", "full_code": "lemma inequality_bounds:\n  fixes x :: nat\n  assumes \"x < c\" \"x = a + b\"\n  shows \"a < c \\<and> b < c\"\nproof -\n  obtain k where \"x = a + b\" using assms(2) by auto\n  have \"a + b < c\" using assms(1) by (metis assms(2))\n  then have \"a < c\" \n  proof -\n    have \"b < c - a\" using `a + b < c` by auto\n    thus \"a < c\" using `x = a + b` by auto\n  qed\n  moreover have \"b < c\" \n  proof -\n    have \"a < c - b\" using `a + b < c` by auto\n    thus \"b < c\" using `x = a + b` by auto\n  qed\n  ultimately show \"a < c \\<and> b < c\" by simp\nqed", "origin": "do_request", "update_count": 0}, "divisibility_properties": {"skill_name": "divisibility_properties", "marker": "lemma divisibility_properties:\n  fixes a b d :: nat\n  assumes \"a mod d = 0\" and \"b mod d = 0\"\n  shows \"(a + b) mod d = 0\"\nproof -\n  have \"a = d * (a div d)\" using assms(1) by auto\n  have \"b = d * (b div d)\" using assms(2) by auto\n  then have \"a + b = d * (a div d + b div d)\" by (metis \\<open>a = d * (a div d)\\<close> add.commute add_left_imp_eq add_mult_distrib2)\n  then have \"(a + b) mod d = (d * (a div d + b div d)) mod d\"\n    by simp\n  also have \"... = 0\" by (simp add: mod_mult_self2)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma divisibility_properties:\n  fixes a b d :: nat\n  assumes \"a mod d = 0\" and \"b mod d = 0\"\n  shows \"(a + b) mod d = 0\"\nproof -\n  have \"a = d * (a div d)\" using assms(1) by auto\n  have \"b = d * (b div d)\" using assms(2) by auto\n  then have \"a + b = d * (a div d + b div d)\" by (metis \\<open>a = d * (a div d)\\<close> add.commute add_left_imp_eq add_mult_distrib2)\n  then have \"(a + b) mod d = (d * (a div d + b div d)) mod d\"\n    by simp\n  also have \"... = 0\" by (simp add: mod_mult_self2)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "divisibility_propertiesV2": {"skill_name": "divisibility_propertiesV2", "marker": "lemma divisibility_properties:\n  fixes a b d :: nat\n  assumes \"a mod d = 0\" and \"b mod d = 0\"\n  shows \"(a + b) mod d = 0\"\nproof -\n  have \"a mod d = 0\" using assms(1) by simp\n  hence \"a = d * (a div d)\" by auto\n  have \"b mod d = 0\" using assms(2) by simp\n  hence \"b = d * (b div d)\" by auto\n  have \"a + b = d * (a div d) + d * (b div d)\"\n    using `a = d * (a div d)` `b = d * (b div d)` by simp\n  then have \"a + b = d * ((a div d) + (b div d))\" by (simp add: algebra_simps)\n  thus ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma divisibility_properties:\n  fixes a b d :: nat\n  assumes \"a mod d = 0\" and \"b mod d = 0\"\n  shows \"(a + b) mod d = 0\"\nproof -\n  have \"a mod d = 0\" using assms(1) by simp\n  hence \"a = d * (a div d)\" by auto\n  have \"b mod d = 0\" using assms(2) by simp\n  hence \"b = d * (b div d)\" by auto\n  have \"a + b = d * (a div d) + d * (b div d)\"\n    using `a = d * (a div d)` `b = d * (b div d)` by simp\n  then have \"a + b = d * ((a div d) + (b div d))\" by (simp add: algebra_simps)\n  thus ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "divisibility_propertiesV3": {"skill_name": "divisibility_propertiesV3", "marker": "lemma divisibility_properties:\n  fixes a b d :: nat\n  assumes \"a mod d = 0\" and \"b mod d = 0\"\n  shows \"(a + b) mod d = 0\"\nproof -\n  obtain k1 where \"a = d * k1\" \n    using assms(1) by auto\n  obtain k2 where \"b = d * k2\" \n    using assms(2) by auto\n  have \"a + b = (d * k1) + (d * k2)\"\n    by (metis `a = d * k1` `b = d * k2` algebra_simps)\n  then have \"a + b = d * (k1 + k2)\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod d = (d * (k1 + k2)) mod d\"\n    by simp\n  also have \"... = 0\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma divisibility_properties:\n  fixes a b d :: nat\n  assumes \"a mod d = 0\" and \"b mod d = 0\"\n  shows \"(a + b) mod d = 0\"\nproof -\n  obtain k1 where \"a = d * k1\" \n    using assms(1) by auto\n  obtain k2 where \"b = d * k2\" \n    using assms(2) by auto\n  have \"a + b = (d * k1) + (d * k2)\"\n    by (metis `a = d * k1` `b = d * k2` algebra_simps)\n  then have \"a + b = d * (k1 + k2)\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod d = (d * (k1 + k2)) mod d\"\n    by simp\n  also have \"... = 0\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "express_in_terms_of_k_mV2": {"skill_name": "express_in_terms_of_k_mV2", "marker": "lemma express_in_terms_of_k_m:\n  fixes k m :: nat\n  shows \"\\<exists>N. N = 24 * m + 21\"\nproof -\n  let ?N = \"24 * m + 21\"\n  show \"\\<exists>N. N = 24 * m + 21\" by (rule exI[of _ ?N]) simp\nqed", "description": "-", "full_code": "lemma express_in_terms_of_k_m:\n  fixes k m :: nat\n  shows \"\\<exists>N. N = 24 * m + 21\"\nproof -\n  let ?N = \"24 * m + 21\"\n  show \"\\<exists>N. N = 24 * m + 21\" by (rule exI[of _ ?N]) simp\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_generalized_with_parameters": {"skill_name": "cancel_div_generalized_with_parameters", "marker": "lemma cancel_div_generalized_with_parameters:\n  fixes x a b c d p :: real\n  assumes \"x > 0\" \"d > 0\" \"m * a + n * (b / x) = p\"\n  shows \"m * x * a + n * b = p * x\" and \"d * (m * a + n * (b / x)) = d * p\"\nproof -\n  have \"x * (m * a + n * (b / x)) = p * x\"\n    using assms(3) by auto\n  then have \"m * x * a + n * b = p * x\"\n    by (smt (verit) assms(1) assms(3) cancel_div_generalized_with_coefficients(1))\n  thus \"m * x * a + n * b = p * x\" using assms(1) by auto\n  have \"d * (m * a + n * (b / x)) = d * p\"\n    using assms(3) by (simp add: distrib_left)\n  thus \"d * (m * a + n * (b / x)) = d * p\" by simp\nqed", "description": "-", "full_code": "lemma cancel_div_generalized_with_coefficients:\n  fixes x a b c d m n :: real\n  assumes \"x > 0\" \"d > 0\" \"m * a + n * (b / x) = p\"\n  shows \"m * x * a + n * b = p * x\" and \"d * (m * a + n * (b / x)) = d * p\"\nproof -\n  have \"x * (m * a + n * (b / x)) = p * x\"\n    using assms(3) by auto\n  then have \"x * m * a + x * (n * (b / x)) = p * x\"\n    by (simp add: distrib_left)\n  then show \"m * x * a + n * b = p * x\"\n    using assms(1) by (simp add: mult.commute)\n  have \"d * (m * a + n * (b / x)) = d * p\"\n    using assms(3) by (simp add: distrib_left)\n  then show \"d * (m * a + n * (b / x)) = d * p\" by simp\nqed\n\nlemma cancel_div_generalized_with_parameters:\n  fixes x a b c d p :: real\n  assumes \"x > 0\" \"d > 0\" \"m * a + n * (b / x) = p\"\n  shows \"m * x * a + n * b = p * x\" and \"d * (m * a + n * (b / x)) = d * p\"\nproof -\n  have \"x * (m * a + n * (b / x)) = p * x\"\n    using assms(3) by auto\n  then have \"m * x * a + n * b = p * x\"\n    by (smt (verit) assms(1) assms(3) cancel_div_generalized_with_coefficients(1))\n  thus \"m * x * a + n * b = p * x\" using assms(1) by auto\n  have \"d * (m * a + n * (b / x)) = d * p\"\n    using assms(3) by (simp add: distrib_left)\n  thus \"d * (m * a + n * (b / x)) = d * p\" by simp\nqed", "origin": "cancel_div_generalized", "update_count": 0}, "mod_addV5": {"skill_name": "mod_addV5", "marker": "lemma mod_add:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a + c = (a mod m + c) + (a div m) * m\"\n    by auto\n  then have \"(a + c) mod m = ((a mod m + c) + (a div m) * m) mod m\"\n    by simp\n  also have \"... = (a mod m + c) mod m\"\n    by presburger\n  also have \"... = (b + c) mod m\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a + c = (a mod m + c) + (a div m) * m\"\n    by auto\n  then have \"(a + c) mod m = ((a mod m + c) + (a div m) * m) mod m\"\n    by simp\n  also have \"... = (a mod m + c) mod m\"\n    by presburger\n  also have \"... = (b + c) mod m\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "rearrange_congruence": {"skill_name": "rearrange_congruence", "marker": "lemma rearrange_congruence:\n  fixes k :: nat\n  assumes \"2 * k + 5 mod 6 = 3\"\n  shows \"2 * k mod 6 = 4\"\nproof -\n  have \"2 * k + 5 mod 6 = 3\" using assms by simp\n  then have \"2 * k + 5 = 6 * n + 3\" for n :: nat\n    by auto\n  then have \"2 * k = 6 * n + 3 - 5\" for n :: nat\n    by simp\n  hence \"2 * k = 6 * n - 2\" for n :: nat\n    by simp\n  thus \"2 * k mod 6 = 4\" \n    by presburger\nqed", "description": "-", "full_code": "lemma rearrange_congruence:\n  fixes k :: nat\n  assumes \"2 * k + 5 mod 6 = 3\"\n  shows \"2 * k mod 6 = 4\"\nproof -\n  have \"2 * k + 5 mod 6 = 3\" using assms by simp\n  then have \"2 * k + 5 = 6 * n + 3\" for n :: nat\n    by auto\n  then have \"2 * k = 6 * n + 3 - 5\" for n :: nat\n    by simp\n  hence \"2 * k = 6 * n - 2\" for n :: nat\n    by simp\n  thus \"2 * k mod 6 = 4\" \n    by presburger\nqed", "origin": "do_request", "update_count": 0}, "mod_simplification_extendedV2": {"skill_name": "mod_simplification_extendedV2", "marker": "lemma mod_simplification_extended:\n  fixes x y a k :: nat\n  assumes \"x mod y = a\" \"y > 0\"\n  shows \"x = k * y + a \\<longleftrightarrow> k = x div y\"\nproof -\n  have \"x = y * (x div y) + x mod y\" by auto\n  then have \"x = y * (x div y) + a\" using assms(1) by auto\n  thus \"x = k * y + a \\<longleftrightarrow> k = x div y\" \n    by (metis Suc_le_D \\<open>x = y * (x div y) + x mod y\\<close> add_0_iff assms(1) assms(2) div_mult_self3 mod_eq_self_iff_div_eq_0 mod_less_divisor mod_mult_self3 mult.commute nat.distinct(1) not_less_eq_eq verit_comp_simplify1(3))\nqed", "description": "-", "full_code": "lemma mod_simplification_extended:\n  fixes x y a k :: nat\n  assumes \"x mod y = a\" \"y > 0\"\n  shows \"x = k * y + a \\<longleftrightarrow> k = x div y\"\nproof -\n  have \"x = y * (x div y) + x mod y\" by auto\n  then have \"x = y * (x div y) + a\" using assms(1) by auto\n  thus \"x = k * y + a \\<longleftrightarrow> k = x div y\" \n    by (metis Suc_le_D \\<open>x = y * (x div y) + x mod y\\<close> add_0_iff assms(1) assms(2) div_mult_self3 mod_eq_self_iff_div_eq_0 mod_less_divisor mod_mult_self3 mult.commute nat.distinct(1) not_less_eq_eq verit_comp_simplify1(3))\nqed", "origin": "mod_simplification", "update_count": 0}, "nat_successor_inequality": {"skill_name": "nat_successor_inequality", "marker": "lemma nat_successor_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 < b + 1\"\nproof -\n  have \"a + 1 < b + 1\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma nat_successor_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 < b + 1\"\nproof -\n  have \"a + 1 < b + 1\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "nat_inequalityV2", "update_count": 0}, "nat_successor_inequalityV2": {"skill_name": "nat_successor_inequalityV2", "marker": "lemma nat_successor_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"b = a + Suc c\" using assms by (metis add_Suc_right less_iff_Suc_add)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma nat_successor_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"\\<exists> c. a + c < b\"\nproof -\n  obtain c where \"b = a + Suc c\" using assms by (metis add_Suc_right less_iff_Suc_add)\n  then show ?thesis by auto\nqed", "origin": "nat_inequalityV2", "update_count": 0}, "sum_of_n_valuesV2": {"skill_name": "sum_of_n_valuesV2", "marker": "theorem sum_of_n_values:\n  fixes n1 n2 n3 n4 :: nat\n  shows \"n1 + n2 + n3 + n4 = (n1 + n2 + n3 + n4)\"\nproof -\n  show ?thesis by simp\nqed", "description": "-", "full_code": "theorem sum_of_n_values:\n  fixes n1 n2 n3 n4 :: nat\n  shows \"n1 + n2 + n3 + n4 = (n1 + n2 + n3 + n4)\"\nproof -\n  show ?thesis by simp\nqed", "origin": "sum_of_n_values_extended", "update_count": 0}, "sum_of_n_values_extendedV2": {"skill_name": "sum_of_n_values_extendedV2", "marker": "theorem sum_of_n_values_extended:\n  fixes n1 n2 n3 n4 :: nat\n  assumes \"n1 = a\" \"n2 = b\" \"n3 = c\" \"n4 = d\"\n  shows \"n1 + n2 + n3 + n4 = a + b + c + d\"\nproof -\n  have \"n1 + n2 + n3 + n4 = a + b + c + d\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem sum_of_n_values_extended:\n  fixes n1 n2 n3 n4 :: nat\n  assumes \"n1 = a\" \"n2 = b\" \"n3 = c\" \"n4 = d\"\n  shows \"n1 + n2 + n3 + n4 = a + b + c + d\"\nproof -\n  have \"n1 + n2 + n3 + n4 = a + b + c + d\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "sum_of_n_values_extended", "update_count": 0}, "properties_of_mod": {"skill_name": "properties_of_mod", "marker": "lemma properties_of_mod:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  have \"a = m * (a div m) + (a mod m)\" \n    by auto \n  also have \"... = m * (a div m) + b\" \n    using assms(1) by auto\n  finally show ?thesis \n    by (auto simp: field_simps) \nqed", "description": "-", "full_code": "lemma properties_of_mod:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  have \"a = m * (a div m) + (a mod m)\" \n    by auto \n  also have \"... = m * (a div m) + b\" \n    using assms(1) by auto\n  finally show ?thesis \n    by (auto simp: field_simps) \nqed", "origin": "do_request", "update_count": 0}, "properties_of_modV2": {"skill_name": "properties_of_modV2", "marker": "lemma properties_of_mod:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  have \"a = (a div m) * m + a mod m\"\n    by (metis div_mult_mod_eq)\n  then show ?thesis\n    using assms by auto\nqed", "description": "-", "full_code": "lemma properties_of_mod:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  have \"a = (a div m) * m + a mod m\"\n    by (metis div_mult_mod_eq)\n  then show ?thesis\n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "properties_of_modV3": {"skill_name": "properties_of_modV3", "marker": "lemma properties_of_mod:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  have \"a = m * (a div m) + a mod m\"\n    by (auto)\n  then have \"a = m * (a div m) + b\"\n    using assms(1) by auto\n  then show ?thesis\n    by (auto simp: field_simps) \nqed", "description": "-", "full_code": "lemma properties_of_mod:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  have \"a = m * (a div m) + a mod m\"\n    by (auto)\n  then have \"a = m * (a div m) + b\"\n    using assms(1) by auto\n  then show ?thesis\n    by (auto simp: field_simps) \nqed", "origin": "do_request", "update_count": 0}, "logarithm_properties": {"skill_name": "logarithm_properties", "marker": "lemma logarithm_properties:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\" and \"c = log a b\"\nproof -\n  have \"b = a ^ c\" using assms by (metis powr_log_cancel powr_realpow)\n  then show \"b = a ^ c\" by auto\n  show \"c = log a b\" using assms by auto\nqed", "description": "-", "full_code": "lemma logarithm_properties:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\" and \"c = log a b\"\nproof -\n  have \"b = a ^ c\" using assms by (metis powr_log_cancel powr_realpow)\n  then show \"b = a ^ c\" by auto\n  show \"c = log a b\" using assms by auto\nqed", "origin": "logarithm_exponentiation", "update_count": 0}, "logarithm_identityV2": {"skill_name": "logarithm_identityV2", "marker": "lemma logarithm_identity:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nproof -\n  have \"log a b = c\" by (simp add: assms)\n  then show ?thesis using assms by (metis powr_log_cancel powr_realpow)\nqed", "description": "-", "full_code": "lemma logarithm_identity:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nproof -\n  have \"log a b = c\" by (simp add: assms)\n  then show ?thesis using assms by (metis powr_log_cancel powr_realpow)\nqed", "origin": "logarithm_exponentiation", "update_count": 0}, "logarithm_propertiesV2": {"skill_name": "logarithm_propertiesV2", "marker": "lemma logarithm_properties:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b * c) = log a b + log a c\"\n  using assms\n  by (metis log_mult)", "description": "-", "full_code": "lemma logarithm_properties:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b * c) = log a b + log a c\"\n  using assms\n  by (metis log_mult)", "origin": "logarithm_exponentiation", "update_count": 0}}
{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "division_property_for_nonnegative": {"skill_name": "division_property_for_nonnegative", "marker": "lemma division_property_for_nonnegative:\n  fixes x a b c :: real\n  assumes \"x \\<ge> 0\" \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(3) by auto\n  then have \"x * a + b = c * x\" by (smt (verit) assms(1) assms(2) assms(3) division_property_for_positive mult.commute order_le_imp_less_or_eq)\n  thus ?thesis using assms(2) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma division_property_for_positive:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed\n\nlemma division_property_for_nonnegative:\n  fixes x a b c :: real\n  assumes \"x \\<ge> 0\" \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(3) by auto\n  then have \"x * a + b = c * x\" by (smt (verit) assms(1) assms(2) assms(3) division_property_for_positive mult.commute order_le_imp_less_or_eq)\n  thus ?thesis using assms(2) by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "division_property_for_positive": {"skill_name": "division_property_for_positive", "marker": "lemma division_property_for_positive:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma division_property_for_positive:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "divide_cancel_for_nonnegative": {"skill_name": "divide_cancel_for_nonnegative", "marker": "lemma divide_cancel_for_nonnegative:\n  fixes x a b c :: real\n  assumes \"x \\<ge> 0\" \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(3) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  thus ?thesis using assms(2) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma divide_cancel_for_nonnegative:\n  fixes x a b c :: real\n  assumes \"x \\<ge> 0\" \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(3) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  thus ?thesis using assms(2) by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "distinct_nonzero": {"skill_name": "distinct_nonzero", "marker": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  from assms(1) and assms(2) have \"x \\<noteq> 0\" and \"y \\<noteq> 0\" by auto\n  thus ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  from assms(1) and assms(2) have \"x \\<noteq> 0\" and \"y \\<noteq> 0\" by auto\n  thus ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "distinct_nonzeroV2": {"skill_name": "distinct_nonzeroV2", "marker": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  have \"x \\<noteq> 0\" using assms(1) by auto\n  have \"y \\<noteq> 0\" using assms(2) by auto\n  thus ?thesis using assms(1) assms(2) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  have \"x \\<noteq> 0\" using assms(1) by auto\n  have \"y \\<noteq> 0\" using assms(2) by auto\n  thus ?thesis using assms(1) assms(2) by (simp add: mult.commute)\nqed", "origin": "do_request", "update_count": 0}, "division_property_for_dimensions": {"skill_name": "division_property_for_dimensions", "marker": "lemma division_property_for_dimensions:\n  fixes x a b c :: \"real list\"\n  assumes \"length x = length a\" \"length x = length b\" \"length x = length c\"\n    and \"\\<forall>i. x ! i > 0 \\<longrightarrow> (a ! i + b ! i / x ! i = c ! i)\"\n  shows \"\\<forall>i. x ! i > 0 \\<longrightarrow> (a ! i * x ! i + b ! i = c ! i * x ! i)\"\nproof -\n  have \"(\\<forall>i. x ! i > 0 \\<longrightarrow> (a ! i + b ! i / x ! i = c ! i))\" using assms(4) by auto\n  hence \"(\\<forall>i. x ! i > 0 \\<longrightarrow> (a ! i * x ! i + b ! i = c ! i * x ! i))\"\n    by (metis division_property_for_positive) \n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma division_property_for_positive:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed\n\nlemma division_property_for_dimensions:\n  fixes x a b c :: \"real list\"\n  assumes \"length x = length a\" \"length x = length b\" \"length x = length c\"\n    and \"\\<forall>i. x ! i > 0 \\<longrightarrow> (a ! i + b ! i / x ! i = c ! i)\"\n  shows \"\\<forall>i. x ! i > 0 \\<longrightarrow> (a ! i * x ! i + b ! i = c ! i * x ! i)\"\nproof -\n  have \"(\\<forall>i. x ! i > 0 \\<longrightarrow> (a ! i + b ! i / x ! i = c ! i))\" using assms(4) by auto\n  hence \"(\\<forall>i. x ! i > 0 \\<longrightarrow> (a ! i * x ! i + b ! i = c ! i * x ! i))\"\n    by (metis division_property_for_positive) \n  thus ?thesis by auto\nqed", "origin": "division_property_for_nonnegative", "update_count": 0}, "isolate_variable": {"skill_name": "isolate_variable", "marker": "lemma isolate_variable:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2 * (x - y)) / (x * y)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by auto\n  hence \"x - y + (2/x - 2/y) = 0\" by (simp add: algebra_simps)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma isolate_variable:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2 * (x - y)) / (x * y)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by auto\n  hence \"x - y + (2/x - 2/y) = 0\" by (simp add: algebra_simps)\n  thus ?thesis by sos\nqed", "origin": "do_request", "update_count": 0}, "cancel_division_complex": {"skill_name": "cancel_division_complex", "marker": "lemma cancel_division_complex:\n  fixes z a b c :: complex\n  assumes \"z \\<noteq> 0\" \"a + b / z = c\"\n  shows \"a * z + b = c * z\"\nproof -\n  have \"z * (a + b / z) = c * z\" using assms(2) by auto\n  then have \"z * a + b = c * z\" \n    using assms(1) by (simp add: distrib_left)\n  thus ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma cancel_division_complex:\n  fixes z a b c :: complex\n  assumes \"z \\<noteq> 0\" \"a + b / z = c\"\n  shows \"a * z + b = c * z\"\nproof -\n  have \"z * (a + b / z) = c * z\" using assms(2) by auto\n  then have \"z * a + b = c * z\" \n    using assms(1) by (simp add: distrib_left)\n  thus ?thesis by (auto simp: field_simps)\nqed", "origin": "cancle_div", "update_count": 0}, "cancel_division_real": {"skill_name": "cancel_division_real", "marker": "lemma cancel_division_real:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" \n    using assms(1) by (simp add: distrib_left)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma cancel_division_real:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" \n    using assms(1) by (simp add: distrib_left)\n  thus ?thesis by sos\nqed", "origin": "cancle_div", "update_count": 0}, "manipulate_division_and_addition": {"skill_name": "manipulate_division_and_addition", "marker": "lemma manipulate_division_and_addition:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"d = a * x + b\"\n  shows \"d = c * x\"\nproof -\n  have \"d = a * x + b\" using assms(3) by simp\n  also have \"... = c * x\" using cancel_division_real_general assms by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancel_division_real_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" \n    using assms(1) by (simp add: distrib_left)\n  thus ?thesis by sos\nqed\n\nlemma manipulate_division_and_addition:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"d = a * x + b\"\n  shows \"d = c * x\"\nproof -\n  have \"d = a * x + b\" using assms(3) by simp\n  also have \"... = c * x\" using cancel_division_real_general assms by simp\n  finally show ?thesis by simp\nqed", "origin": "cancel_division_real", "update_count": 0}, "distinct_elements": {"skill_name": "distinct_elements", "marker": "lemma distinct_elements:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\"\n  shows \"x - y \\<noteq> 0\"\nproof -\n  have \"x - y = 0 \\<Longrightarrow> x = y\" by simp\n  with assms show ?thesis by (simp)\nqed", "description": "-", "full_code": "lemma distinct_elements:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\"\n  shows \"x - y \\<noteq> 0\"\nproof -\n  have \"x - y = 0 \\<Longrightarrow> x = y\" by simp\n  with assms show ?thesis by (simp)\nqed", "origin": "do_request", "update_count": 0}, "distinct_elementsV2": {"skill_name": "distinct_elementsV2", "marker": "lemma distinct_elements:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\"\n  shows \"x - y \\<noteq> 0\"\nproof -\n  have \"x - y = 0 \\<longleftrightarrow> x = y\" by (simp add: algebra_simps)\n  thus ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma distinct_elements:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\"\n  shows \"x - y \\<noteq> 0\"\nproof -\n  have \"x - y = 0 \\<longleftrightarrow> x = y\" by (simp add: algebra_simps)\n  thus ?thesis using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "common_denominator": {"skill_name": "common_denominator", "marker": "lemma common_denominator:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    using assms by (simp add: field_simps)\n  then have \"... = (a * d - c * b) / (b * d)\"\n    by (simp add: field_simps)\n  thus ?thesis by (metis \\<open>a / b - c / d = a * d / (b * d) - c * b / (b * d)\\<close> add_divide_eq_if_simps(4) mult.commute mult_delta_right)\nqed", "description": "-", "full_code": "lemma common_denominator:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    using assms by (simp add: field_simps)\n  then have \"... = (a * d - c * b) / (b * d)\"\n    by (simp add: field_simps)\n  thus ?thesis by (metis \\<open>a / b - c / d = a * d / (b * d) - c * b / (b * d)\\<close> add_divide_eq_if_simps(4) mult.commute mult_delta_right)\nqed", "origin": "do_request", "update_count": 0}, "common_denominatorV2": {"skill_name": "common_denominatorV2", "marker": "lemma common_denominator:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = a / b - (c * (b / d)) / b\" \n    using assms(2) by (metis assms(1) divide_divide_eq_left' mult.right_neutral nonzero_divide_mult_cancel_left times_divide_eq_right)\n  also have \"... = (a * d - c * b) / (b * d)\" \n    using assms(1) by (smt (verit) assms(2) calculation diff_frac_eq)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma common_denominator:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = a / b - (c * (b / d)) / b\" \n    using assms(2) by (metis assms(1) divide_divide_eq_left' mult.right_neutral nonzero_divide_mult_cancel_left times_divide_eq_right)\n  also have \"... = (a * d - c * b) / (b * d)\" \n    using assms(1) by (smt (verit) assms(2) calculation diff_frac_eq)\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "common_denominatorV3": {"skill_name": "common_denominatorV3", "marker": "lemma common_denominator:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  also have \"... = (a * d - c * b) / (b * d)\"\n    by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma common_denominator:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  also have \"... = (a * d - c * b) / (b * d)\"\n    by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "amc12a_2013_p8": {"skill_name": "amc12a_2013_p8", "marker": "theorem amc12a_2013_p8:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged by sos\n  have factored: \"(x - y) * x * y = 2 * (x - y)\"\n    using cross_mult by (simp add: field_simps)\n  have \"x * y = 2\" \n    using factored h2 by sos\n  thus ?thesis by simp\nqed", "description": "", "full_code": "theorem amc12a_2013_p8:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged by sos\n  have factored: \"(x - y) * x * y = 2 * (x - y)\"\n    using cross_mult by (simp add: field_simps)\n  have \"x * y = 2\" \n    using factored h2 by sos\n  thus ?thesis by simp\nqed", "origin": "data/full_data/debug/valid_rand/amc12a_2013_p8.json_v4", "update_count": -1}, "amc12a_2013_p8_complex": {"skill_name": "amc12a_2013_p8_complex", "marker": "theorem amc12a_2013_p8_complex:\n  fixes x y :: complex\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged by (smt (verit) divide_cancel_right divide_diff_eq_iff eq_divide_imp h0 h1 left_diff_distrib' right_diff_distrib' times_divide_eq_left)\n  have factored: \"(x - y) * x * y = 2 * (x - y)\"\n    using cross_mult by (simp add: field_simps)\n  have \"x * y = 2\" \n    using factored h2 by (smt (verit) eq_divide_imp eq_iff_diff_eq_0 h0 mult.commute no_zero_divisors nonzero_mult_div_cancel_left nonzero_mult_divide_mult_cancel_right2 times_divide_eq_left)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_complex:\n  fixes x y :: complex\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged by (smt (verit) divide_cancel_right divide_diff_eq_iff eq_divide_imp h0 h1 left_diff_distrib' right_diff_distrib' times_divide_eq_left)\n  have factored: \"(x - y) * x * y = 2 * (x - y)\"\n    using cross_mult by (simp add: field_simps)\n  have \"x * y = 2\" \n    using factored h2 by (smt (verit) eq_divide_imp eq_iff_diff_eq_0 h0 mult.commute no_zero_divisors nonzero_mult_div_cancel_left nonzero_mult_divide_mult_cancel_right2 times_divide_eq_left)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_evolved": {"skill_name": "amc12a_2013_p8_evolved", "marker": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\"\n    using rearranged by sos\n  have factored: \"(x - y) * x * y = 2 * (x - y)\" \n    using cross_mult by simp\n  have \"x * y = 2\" \n    using factored h2 by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\"\n    using rearranged by sos\n  have factored: \"(x - y) * x * y = 2 * (x - y)\" \n    using cross_mult by simp\n  have \"x * y = 2\" \n    using factored h2 by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_evolvedV2": {"skill_name": "amc12a_2013_p8_evolvedV2", "marker": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\"\n    and h1: \"y \\<noteq> 0\"\n    and h2: \"x \\<noteq> y\"\n    and h3: \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  thus \"x * y = 2\" \n    using h2 by sos\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\"\n    and h1: \"y \\<noteq> 0\"\n    and h2: \"x \\<noteq> y\"\n    and h3: \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  thus \"x * y = 2\" \n    using h2 by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiply_rearrange": {"skill_name": "cross_multiply_rearrange", "marker": "lemma cross_multiply_rearrange:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \"a / b = c / d\"\n  shows \"a * d = c * b\"\nproof -\n  have \"a / b = c / d \\<longleftrightarrow> a * d = c * b\" using assms by (simp add: field_simps)\n  thus ?thesis by (metis assms(3))\nqed", "description": "-", "full_code": "lemma cross_multiply_rearrange:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \"a / b = c / d\"\n  shows \"a * d = c * b\"\nproof -\n  have \"a / b = c / d \\<longleftrightarrow> a * d = c * b\" using assms by (simp add: field_simps)\n  thus ?thesis by (metis assms(3))\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "product_sum_equivalence": {"skill_name": "product_sum_equivalence", "marker": "lemma product_sum_equivalence:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\" \n    and \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using assms(4) by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged by sos\n  have factored: \"(x - y) * x * y = 2 * (x - y)\" \n    using cross_mult by (simp add: field_simps)\n  hence \"x * y = 2\" \n    using assms(3) by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma product_sum_equivalence:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\" \n    and \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using assms(4) by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged by sos\n  have factored: \"(x - y) * x * y = 2 * (x - y)\" \n    using cross_mult by (simp add: field_simps)\n  hence \"x * y = 2\" \n    using assms(3) by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiply_and_rearrange": {"skill_name": "cross_multiply_and_rearrange", "marker": "lemma cross_multiply_and_rearrange:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \"a / b = c / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a / b = c / d\" using assms by auto\n  then have \"a * d = c * b\" by (metis assms(1) assms(2) frac_eq_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma cross_multiply_and_rearrange:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \"a / b = c / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a / b = c / d\" using assms by auto\n  then have \"a * d = c * b\" by (metis assms(1) assms(2) frac_eq_eq)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "rearrangement_of_equation": {"skill_name": "rearrangement_of_equation", "marker": "lemma rearrangement_of_equation:\n  fixes x y z :: real\n  assumes \"x + 2/x = y + 2/y\" \n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrangement_of_equation:\n  fixes x y z :: real\n  assumes \"x + 2/x = y + 2/y\" \n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiply_difference": {"skill_name": "cross_multiply_difference", "marker": "lemma cross_multiply_difference:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \"a + b = c + d\"\n  shows \"(a - c) * b * d = b * d * (a - c)\"\nproof -\n  have \"a + b - (c + d) = 0\" using assms by simp\n  then have \"a - c = d - b\" using assms by simp\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma cross_multiply_difference:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \"a + b = c + d\"\n  shows \"(a - c) * b * d = b * d * (a - c)\"\nproof -\n  have \"a + b - (c + d) = 0\" using assms by simp\n  then have \"a - c = d - b\" using assms by simp\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_evolvedV3": {"skill_name": "amc12a_2013_p8_evolvedV3", "marker": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  hence rearranged: \"x - y = (2/y - 2/x)\" \n    by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged by sos\n  have factored: \"(x - y) * x * y = 2 * (x - y)\" \n    using cross_mult by (simp add: field_simps)\n  have \"x * y \\<noteq> 0\" using h0 h1 by auto\n  then have \"x * y = 2\" \n    using factored h2 by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  hence rearranged: \"x - y = (2/y - 2/x)\" \n    by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged by sos\n  have factored: \"(x - y) * x * y = 2 * (x - y)\" \n    using cross_mult by (simp add: field_simps)\n  have \"x * y \\<noteq> 0\" using h0 h1 by auto\n  then have \"x * y = 2\" \n    using factored h2 by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiplication": {"skill_name": "cross_multiplication", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\" and \"a/b = c/d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a / b = c / d\" using assms by simp\n  then show ?thesis by (metis assms(1) assms(2) div_0 divide_divide_eq_left' divide_divide_eq_right divide_divide_times_eq divide_eq_0_iff frac_eq_eq mult.commute mult_eq_0_iff mult_zero_right nonzero_divide_eq_eq times_divide_eq_left times_divide_times_eq)\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\" and \"a/b = c/d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a / b = c / d\" using assms by simp\n  then show ?thesis by (metis assms(1) assms(2) div_0 divide_divide_eq_left' divide_divide_eq_right divide_divide_times_eq divide_eq_0_iff frac_eq_eq mult.commute mult_eq_0_iff mult_zero_right nonzero_divide_eq_eq times_divide_eq_left times_divide_times_eq)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "simplified_product_of_x_and_y": {"skill_name": "simplified_product_of_x_and_y", "marker": "lemma simplified_product_of_x_and_y:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" and \"x \\<noteq> y\" and \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using assms(1) by auto\n  have \"x - y = (2/y - 2/x)\" using eq by (simp add: algebra_simps)\n  hence \"(x - y) * (x * y) = 2 * (x - y)\" \n    by sos\n  then show \"x * y = 2\" using assms(2) by sos\nqed", "description": "-", "full_code": "lemma simplified_product_of_x_and_y:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" and \"x \\<noteq> y\" and \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using assms(1) by auto\n  have \"x - y = (2/y - 2/x)\" using eq by (simp add: algebra_simps)\n  hence \"(x - y) * (x * y) = 2 * (x - y)\" \n    by sos\n  then show \"x * y = 2\" using assms(2) by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_improved": {"skill_name": "amc12a_2013_p8_improved", "marker": "theorem amc12a_2013_p8_improved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have \"x * y * (x - y) = (x - y) * 2\" \n    using rearranged by sos\n  then have \"x * y * (x - y) - (x - y) * 2 = 0\" by simp\n  then have \"x * y - 2 = 0\" \n    using h2 by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_improved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have \"x * y * (x - y) = (x - y) * 2\" \n    using rearranged by sos\n  then have \"x * y * (x - y) - (x - y) * 2 = 0\" by simp\n  then have \"x * y - 2 = 0\" \n    using h2 by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_extended": {"skill_name": "amc12a_2013_p8_extended", "marker": "theorem amc12a_2013_p8_extended:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\"\n    and h4 : \"y\\<noteq>z\"\n    and h5 : \"x + 2/x = y + 2/y\"\n    and h6 : \"y + 2/y = z + 2/z\"\n  shows \"x * y = 2 \\<and> y * z = 2\"\nproof -\n  have eq1: \"x + 2/x = y + 2/y\" using h5 by auto\n  have eq2: \"y + 2/y = z + 2/z\" using h6 by auto\n  have rearranged1: \"x - y = (2/y - 2/x)\" \n    using eq1 by (simp add: algebra_simps)\n  have rearranged2: \"y - z = (2/z - 2/y)\" \n    using eq2 by (simp add: algebra_simps)\n  have cross_mult1: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged1 by sos\n  have cross_mult2: \"(y - z) * y * z = 2 * y - 2 * z\" \n    using rearranged2 by sos\n  have factored1: \"(x - y) * x * y = 2 * (x - y)\"\n    using cross_mult1 by (simp add: field_simps)\n  have factored2: \"(y - z) * y * z = 2 * (y - z)\"\n    using cross_mult2 by (simp add: field_simps)\n  have \"x * y = 2\" \n    using factored1 h3 by sos\n  have \"y * z = 2\" \n    using factored2 h4 by sos\n  thus ?thesis by (metis \\<open>x * y = 2\\<close>)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_extended:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\"\n    and h4 : \"y\\<noteq>z\"\n    and h5 : \"x + 2/x = y + 2/y\"\n    and h6 : \"y + 2/y = z + 2/z\"\n  shows \"x * y = 2 \\<and> y * z = 2\"\nproof -\n  have eq1: \"x + 2/x = y + 2/y\" using h5 by auto\n  have eq2: \"y + 2/y = z + 2/z\" using h6 by auto\n  have rearranged1: \"x - y = (2/y - 2/x)\" \n    using eq1 by (simp add: algebra_simps)\n  have rearranged2: \"y - z = (2/z - 2/y)\" \n    using eq2 by (simp add: algebra_simps)\n  have cross_mult1: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged1 by sos\n  have cross_mult2: \"(y - z) * y * z = 2 * y - 2 * z\" \n    using rearranged2 by sos\n  have factored1: \"(x - y) * x * y = 2 * (x - y)\"\n    using cross_mult1 by (simp add: field_simps)\n  have factored2: \"(y - z) * y * z = 2 * (y - z)\"\n    using cross_mult2 by (simp add: field_simps)\n  have \"x * y = 2\" \n    using factored1 h3 by sos\n  have \"y * z = 2\" \n    using factored2 h4 by sos\n  thus ?thesis by (metis \\<open>x * y = 2\\<close>)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_generalized": {"skill_name": "amc12a_generalized", "marker": "theorem amc12a_generalized:\n  fixes x1 x2 :: real\n  assumes h0: \"x1 \\<noteq> 0\" \n      and h1: \"x2 \\<noteq> 0\" \n      and h2: \"x1 \\<noteq> x2\" \n      and h3: \"x1 + 2/x1 = x2 + 2/x2\"\n  shows \"x1 * x2 = 2\"\nproof -\n  have eq: \"x1 + 2/x1 = x2 + 2/x2\" using h3 by auto\n  have rearranged: \"x1 - x2 = (2/x2 - 2/x1)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x1 - x2) * x1 * x2 = 2 * x1 - 2 * x2\" \n    using rearranged by sos\n  have factored: \"(x1 - x2) * x1 * x2 = 2 * (x1 - x2)\"\n    using cross_mult by (simp add: field_simps)\n  have \"x1 * x2 = 2\" \n    using factored h2 by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_generalized:\n  fixes x1 x2 :: real\n  assumes h0: \"x1 \\<noteq> 0\" \n      and h1: \"x2 \\<noteq> 0\" \n      and h2: \"x1 \\<noteq> x2\" \n      and h3: \"x1 + 2/x1 = x2 + 2/x2\"\n  shows \"x1 * x2 = 2\"\nproof -\n  have eq: \"x1 + 2/x1 = x2 + 2/x2\" using h3 by auto\n  have rearranged: \"x1 - x2 = (2/x2 - 2/x1)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x1 - x2) * x1 * x2 = 2 * x1 - 2 * x2\" \n    using rearranged by sos\n  have factored: \"(x1 - x2) * x1 * x2 = 2 * (x1 - x2)\"\n    using cross_mult by (simp add: field_simps)\n  have \"x1 * x2 = 2\" \n    using factored h2 by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_simple": {"skill_name": "amc12a_2013_p8_simple", "marker": "theorem amc12a_2013_p8_simple:\n  fixes x y :: real\n  assumes h0 : \"x > 0\"\n    and h1 : \"y > 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  thus ?thesis using h2 by sos\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_simple:\n  fixes x y :: real\n  assumes h0 : \"x > 0\"\n    and h1 : \"y > 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * (x - y)\" \n    using rearranged by sos\n  thus ?thesis using h2 by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "symmetric_rearrangement": {"skill_name": "symmetric_rearrangement", "marker": "lemma symmetric_rearrangement:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma symmetric_rearrangement:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiply_inequality": {"skill_name": "cross_multiply_inequality", "marker": "lemma cross_multiply_inequality:\n  fixes x y z :: real\n  assumes h1: \"x > 0\" and h2: \"y > 0\"\n  shows \"x * y > 0\"\nproof -\n  have \"x * y > 0\" using h1 h2 by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma cross_multiply_inequality:\n  fixes x y z :: real\n  assumes h1: \"x > 0\" and h2: \"y > 0\"\n  shows \"x * y > 0\"\nproof -\n  have \"x * y > 0\" using h1 h2 by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "manipulate_equation": {"skill_name": "manipulate_equation", "marker": "lemma manipulate_equation:\n  fixes a b c d :: real\n  assumes h0: \"a + b = c + d\"\n  shows \"a - c = d - b\"\nproof -\n  have \"a - c = d - b\" using h0 by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma manipulate_equation:\n  fixes a b c d :: real\n  assumes h0: \"a + b = c + d\"\n  shows \"a - c = d - b\"\nproof -\n  have \"a - c = d - b\" using h0 by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_extendedV2": {"skill_name": "amc12a_2013_p8_extendedV2", "marker": "theorem amc12a_2013_p8_extended:\n  fixes x1 x2 y1 y2 :: real\n  assumes h0 : \"x1 \\<noteq> 0\" \n    and h1 : \"x2 \\<noteq> 0\" \n    and h2 : \"y1 \\<noteq> 0\" \n    and h3 : \"y2 \\<noteq> 0\" \n    and h4 : \"x1 \\<noteq> y1\" \n    and h5 : \"x2 \\<noteq> y2\" \n    and h6 : \"x1 + 2/x1 = y1 + 2/y1\" \n    and h7 : \"x2 + 2/x2 = y2 + 2/y2\"\n  shows \"x1 * y1 = 2 \\<and> x2 * y2 = 2\"\nproof -\n  have eq1: \"x1 + 2/x1 = y1 + 2/y1\" using h6 by auto\n  have eq2: \"x2 + 2/x2 = y2 + 2/y2\" using h7 by auto\n  have rearranged1: \"x1 - y1 = (2/y1 - 2/x1)\" \n    using eq1 by (simp add: algebra_simps)\n  have rearranged2: \"x2 - y2 = (2/y2 - 2/x2)\" \n    using eq2 by (simp add: algebra_simps)\n  have cross_mult1: \"(x1 - y1) * x1 * y1 = 2 * x1 - 2 * y1\" \n    using rearranged1 by sos\n  have cross_mult2: \"(x2 - y2) * x2 * y2 = 2 * x2 - 2 * y2\" \n    using rearranged2 by sos\n  have factored1: \"(x1 - y1) * x1 * y1 = 2 * (x1 - y1)\" \n    using cross_mult1 h4 by (simp add: field_simps)\n  have factored2: \"(x2 - y2) * x2 * y2 = 2 * (x2 - y2)\" \n    using cross_mult2 h5 by (simp add: field_simps)\n  have \"x1 * y1 = 2\" \n    using factored1 h4 by sos\n  have \"x2 * y2 = 2\" \n    using factored2 h5 by sos\n  thus ?thesis by (metis \\<open>x1 * y1 = 2\\<close>)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_extended:\n  fixes x1 x2 y1 y2 :: real\n  assumes h0 : \"x1 \\<noteq> 0\" \n    and h1 : \"x2 \\<noteq> 0\" \n    and h2 : \"y1 \\<noteq> 0\" \n    and h3 : \"y2 \\<noteq> 0\" \n    and h4 : \"x1 \\<noteq> y1\" \n    and h5 : \"x2 \\<noteq> y2\" \n    and h6 : \"x1 + 2/x1 = y1 + 2/y1\" \n    and h7 : \"x2 + 2/x2 = y2 + 2/y2\"\n  shows \"x1 * y1 = 2 \\<and> x2 * y2 = 2\"\nproof -\n  have eq1: \"x1 + 2/x1 = y1 + 2/y1\" using h6 by auto\n  have eq2: \"x2 + 2/x2 = y2 + 2/y2\" using h7 by auto\n  have rearranged1: \"x1 - y1 = (2/y1 - 2/x1)\" \n    using eq1 by (simp add: algebra_simps)\n  have rearranged2: \"x2 - y2 = (2/y2 - 2/x2)\" \n    using eq2 by (simp add: algebra_simps)\n  have cross_mult1: \"(x1 - y1) * x1 * y1 = 2 * x1 - 2 * y1\" \n    using rearranged1 by sos\n  have cross_mult2: \"(x2 - y2) * x2 * y2 = 2 * x2 - 2 * y2\" \n    using rearranged2 by sos\n  have factored1: \"(x1 - y1) * x1 * y1 = 2 * (x1 - y1)\" \n    using cross_mult1 h4 by (simp add: field_simps)\n  have factored2: \"(x2 - y2) * x2 * y2 = 2 * (x2 - y2)\" \n    using cross_mult2 h5 by (simp add: field_simps)\n  have \"x1 * y1 = 2\" \n    using factored1 h4 by sos\n  have \"x2 * y2 = 2\" \n    using factored2 h5 by sos\n  thus ?thesis by (metis \\<open>x1 * y1 = 2\\<close>)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "fraction_equivalence": {"skill_name": "fraction_equivalence", "marker": "lemma fraction_equivalence:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a * b) / a = b\"\nproof -\n  have \"a * b / a = b\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma fraction_equivalence:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a * b) / a = b\"\nproof -\n  have \"a * b / a = b\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_simpler": {"skill_name": "amc12a_2013_p8_simpler", "marker": "theorem amc12a_2013_p8_simpler:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x = y\"\n  shows \"x * y = x^2\"\nproof -\n  have \"x * y = x^2\" using h2 by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_simpler:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x = y\"\n  shows \"x * y = x^2\"\nproof -\n  have \"x * y = x^2\" using h2 by sos\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_generalized": {"skill_name": "amc12a_2013_p8_generalized", "marker": "theorem amc12a_2013_p8_generalized:\n  fixes x y z :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"z \\<noteq> 0\"\n    and h3 : \"x + 2/x = y + 2/y\"\n    and h4 : \"x + 2/x = z + 2/z\"\n    and h5 : \"x \\<noteq> y\" and h6: \"x \\<noteq> z\" and h7: \"y \\<noteq> z\"\n  shows \"x * y * z = 2 * (x + y + z)/(x + y + z - 3)\"\nproof -\n  have eq1: \"x + 2/x = y + 2/y\" using h3 by auto\n  have eq2: \"x + 2/x = z + 2/z\" using h4 by auto\n  have rearranged1: \"x - y = (2/y - 2/x)\" using eq1 by (simp add: algebra_simps)\n  have rearranged2: \"x - z = (2/z - 2/x)\" using eq2 by (simp add: algebra_simps)\n  have cross_mult1: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged1 by sos\n  have cross_mult2: \"(x - z) * x * z = 2 * x - 2 * z\" \n    using rearranged2 by sos\n  have factored1: \"(x - y) * x * y = 2 * (x - y)\" \n    using cross_mult1 by (simp add: field_simps)\n  have factored2: \"(x - z) * x * z = 2 * (x - z)\" \n    using cross_mult2 by (simp add: field_simps)\n  then have \"x * y = 2\" using h2 h5 by (metis amc12a_2013_p8_evolved h0 h1 h3)\n  then have \"x * z = 2\" using h2 h6 by (metis amc12a_2013_p8_evolved h0 h4)\n  then have \"y * z = 2\" using h2 h7 by (metis amc12a_2013_p8_evolved h1 h3 h4)\n  thus \"x * y * z = 2 * (x + y + z)/(x + y + z - 3)\" \n    using h2 by (metis \\<open>x * z = 2\\<close> divide_eq_eq h5 one_add_one)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by auto\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: algebra_simps)\n  have cross_mult: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged by sos\n  have factored: \"(x - y) * x * y = 2 * (x - y)\"\n    using cross_mult by (simp add: field_simps)\n  then show \"x * y = 2\" \n    using h2 by sos\nqed\n\ntheorem amc12a_2013_p8_generalized:\n  fixes x y z :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"z \\<noteq> 0\"\n    and h3 : \"x + 2/x = y + 2/y\"\n    and h4 : \"x + 2/x = z + 2/z\"\n    and h5 : \"x \\<noteq> y\" and h6: \"x \\<noteq> z\" and h7: \"y \\<noteq> z\"\n  shows \"x * y * z = 2 * (x + y + z)/(x + y + z - 3)\"\nproof -\n  have eq1: \"x + 2/x = y + 2/y\" using h3 by auto\n  have eq2: \"x + 2/x = z + 2/z\" using h4 by auto\n  have rearranged1: \"x - y = (2/y - 2/x)\" using eq1 by (simp add: algebra_simps)\n  have rearranged2: \"x - z = (2/z - 2/x)\" using eq2 by (simp add: algebra_simps)\n  have cross_mult1: \"(x - y) * x * y = 2 * x - 2 * y\" \n    using rearranged1 by sos\n  have cross_mult2: \"(x - z) * x * z = 2 * x - 2 * z\" \n    using rearranged2 by sos\n  have factored1: \"(x - y) * x * y = 2 * (x - y)\" \n    using cross_mult1 by (simp add: field_simps)\n  have factored2: \"(x - z) * x * z = 2 * (x - z)\" \n    using cross_mult2 by (simp add: field_simps)\n  then have \"x * y = 2\" using h2 h5 by (metis amc12a_2013_p8_evolved h0 h1 h3)\n  then have \"x * z = 2\" using h2 h6 by (metis amc12a_2013_p8_evolved h0 h4)\n  then have \"y * z = 2\" using h2 h7 by (metis amc12a_2013_p8_evolved h1 h3 h4)\n  thus \"x * y * z = 2 * (x + y + z)/(x + y + z - 3)\" \n    using h2 by (metis \\<open>x * z = 2\\<close> divide_eq_eq h5 one_add_one)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "algebraic_identity": {"skill_name": "algebraic_identity", "marker": "lemma algebraic_identity:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"a + b = a + b\" by simp\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma algebraic_identity:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2 * a * b + b^2\"\nproof -\n  have \"a + b = a + b\" by simp\n  then show ?thesis by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "factorization_difference": {"skill_name": "factorization_difference", "marker": "lemma factorization_difference:\n  fixes a b :: real\n  assumes \"b \\<noteq> a\"\n  shows \"a - b = (a - b) * 1\"\nproof -\n  have \"a - b = (a - b) * (1)\" by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma factorization_difference:\n  fixes a b :: real\n  assumes \"b \\<noteq> a\"\n  shows \"a - b = (a - b) * 1\"\nproof -\n  have \"a - b = (a - b) * (1)\" by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiplicationV2": {"skill_name": "cross_multiplicationV2", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(a = c) \\<Longrightarrow> (a * b = c * d) = (b * a = d * c)\"\nproof -\n  assume \"a = c\"\n  then show \"(a * b = c * d) = (b * a = d * c)\"\n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(a = c) \\<Longrightarrow> (a * b = c * d) = (b * a = d * c)\"\nproof -\n  assume \"a = c\"\n  then show \"(a * b = c * d) = (b * a = d * c)\"\n    by (simp add: algebra_simps)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiplicationV3": {"skill_name": "cross_multiplicationV3", "marker": "lemma cross_multiplication:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> y\"\n  shows \"(x - y) * x * y = 2 * (x - y) \\<longleftrightarrow> x * y = 2\"\nproof -\n  have \"x - y \\<noteq> 0\" using h0 by simp\n  have \"x * y = 2 \\<longrightarrow> (x - y) * x * y = 2 * (x - y)\"\n    by (simp add: field_simps)\n  moreover\n  have \"((x - y) * x * y = 2 * (x - y)) \\<longrightarrow> x * y = 2\"\n    using h0 by sos\n  ultimately show ?thesis by blast\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> y\"\n  shows \"(x - y) * x * y = 2 * (x - y) \\<longleftrightarrow> x * y = 2\"\nproof -\n  have \"x - y \\<noteq> 0\" using h0 by simp\n  have \"x * y = 2 \\<longrightarrow> (x - y) * x * y = 2 * (x - y)\"\n    by (simp add: field_simps)\n  moreover\n  have \"((x - y) * x * y = 2 * (x - y)) \\<longrightarrow> x * y = 2\"\n    using h0 by sos\n  ultimately show ?thesis by blast\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiply_nonzero": {"skill_name": "cross_multiply_nonzero", "marker": "lemma cross_multiply_nonzero:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\" and \"a / b = c / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a * d = (c / d) * d * b\" using assms by (simp add: field_simps)\n  also have \"... = c * b\" by (metis assms(1) assms(2) divide_divide_eq_left' divide_eq_0_iff frac_eq_eq mult.commute mult.left_commute nonzero_divide_eq_eq nonzero_mult_divide_mult_cancel_right times_divide_eq_left times_divide_times_eq)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cross_multiply_nonzero:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\" and \"a / b = c / d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a * d = (c / d) * d * b\" using assms by (simp add: field_simps)\n  also have \"... = c * b\" by (metis assms(1) assms(2) divide_divide_eq_left' divide_eq_0_iff frac_eq_eq mult.commute mult.left_commute nonzero_divide_eq_eq nonzero_mult_divide_mult_cancel_right times_divide_eq_left times_divide_times_eq)\n  finally show ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}}
{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "log_and_exponential_relationship": {"skill_name": "log_and_exponential_relationship", "marker": "lemma log_and_exponential_relationship:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c = log a b\"\n  shows \"b = a ^ c\"\n  using assms by (metis powr_log_cancel powr_realpow)", "description": "-", "full_code": "lemma log_and_exponential_relationship:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c = log a b\"\n  shows \"b = a ^ c\"\n  using assms by (metis powr_log_cancel powr_realpow)", "origin": "cal_log_value", "update_count": 0}, "cancel_div_with_params": {"skill_name": "cancel_div_with_params", "marker": "lemma cancel_div_with_params:\n  fixes x a b c p q :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"p = a\" \"q = b\"\n  shows \"p * x + q = c * x\"\n  using cancel_div_general[of x a b c] assms(1,2) by (metis assms(3) assms(4))", "description": "-", "full_code": "lemma cancel_div_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed\n\nlemma cancel_div_with_params:\n  fixes x a b c p q :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"p = a\" \"q = b\"\n  shows \"p * x + q = c * x\"\n  using cancel_div_general[of x a b c] assms(1,2) by (metis assms(3) assms(4))", "origin": "cancle_div", "update_count": 0}, "linear_transformation": {"skill_name": "linear_transformation", "marker": "lemma linear_transformation:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + (x * (b / x)) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma linear_transformation:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + (x * (b / x)) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "cancel_div_for_inequalities": {"skill_name": "cancel_div_for_inequalities", "marker": "lemma cancel_div_for_inequalities:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x < c\" \"d = a\" \"e = b\"\n  shows \"d * x + e < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\" by (simp add: distrib_left)\n  then show ?thesis using assms(1) by (metis add.commute assms(2) assms(3) assms(4) distrib_left divide_add_eq_iff less_numeral_extra(3) mult_eq_0_iff pos_divide_less_eq)\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x < c\" \"d = a\" \"e = b\"\n  shows \"d * x + e < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\" by (simp add: distrib_left)\n  then show ?thesis using assms(1) by (metis add.commute assms(2) assms(3) assms(4) distrib_left divide_add_eq_iff less_numeral_extra(3) mult_eq_0_iff pos_divide_less_eq)\nqed", "origin": "cancel_div_with_params", "update_count": 0}, "cancel_div_with_paramsV2": {"skill_name": "cancel_div_with_paramsV2", "marker": "lemma cancel_div_with_params:\n  fixes x a b c p q :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"p = a\" \"q = b\"\n  shows \"p * x + q = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  then show ?thesis using assms(1) by (metis add.commute assms(3) assms(4) divide_divide_eq_left' divide_divide_eq_right divide_less_eq_1_pos divide_self_if mult.commute mult.right_neutral real_divide_square_eq times_divide_eq_left times_divide_eq_right verit_comp_simplify1(1) zero_less_one)\nqed", "description": "-", "full_code": "lemma cancel_div_with_params:\n  fixes x a b c p q :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"p = a\" \"q = b\"\n  shows \"p * x + q = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  then show ?thesis using assms(1) by (metis add.commute assms(3) assms(4) divide_divide_eq_left' divide_divide_eq_right divide_less_eq_1_pos divide_self_if mult.commute mult.right_neutral real_divide_square_eq times_divide_eq_left times_divide_eq_right verit_comp_simplify1(1) zero_less_one)\nqed", "origin": "cancel_div_with_params", "update_count": 0}, "cancel_div_general_inequality": {"skill_name": "cancel_div_general_inequality", "marker": "lemma cancel_div_general_inequality:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x < c\"\n  shows \"a * x + b < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\"\n    using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancel_div_general_inequality:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x < c\"\n  shows \"a * x + b < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\"\n    using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "cancel_div_with_params", "update_count": 0}, "cancel_div_general_with_zero": {"skill_name": "cancel_div_general_with_zero", "marker": "lemma cancel_div_general_with_zero:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    by (smt (verit) add_divide_eq_iff assms(1) assms(2) nonzero_eq_divide_eq)\nqed", "description": "-", "full_code": "lemma cancel_div_general_with_zero:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    by (smt (verit) add_divide_eq_iff assms(1) assms(2) nonzero_eq_divide_eq)\nqed", "origin": "cancel_div_with_params", "update_count": 0}, "mod_add_power_general": {"skill_name": "mod_add_power_general", "marker": "lemma mod_add_power_general:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = (((a + b)^c) mod n + d) mod n\"\n    using mod_add_power[of x n a b c] assms by (smt (verit) add.commute mod_add_cong mod_add_right_eq power_mod)\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_general:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = (((a + b)^c) mod n + d) mod n\"\n    using mod_add_power[of x n a b c] assms by (smt (verit) add.commute mod_add_cong mod_add_right_eq power_mod)\n  finally show ?thesis by presburger\nqed", "origin": "mod_add_power", "update_count": 0}, "cancel_div_with_params_multi": {"skill_name": "cancel_div_with_params_multi", "marker": "lemma cancel_div_with_params_multi:\n  fixes x a b c p q :: real\n    and n :: nat\n  assumes \"x > 0\" \"a + b / x = c\" \"p = a\" \"q = b\"\n  shows \"(\\<Sum>i=1..n. p * x + q) = (\\<Sum>i=1..n. c * x)\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  then have \"p * x + q = c * x\" using assms(3) assms(4) by (metis add.commute assms(1) divide_divide_eq_left' divide_divide_eq_right divide_less_eq_1_pos divide_self_if less_numeral_extra(1) mult.commute mult.right_neutral real_divide_square_eq times_divide_eq_left times_divide_eq_right verit_comp_simplify1(1))\n  hence \"(\\<Sum>i=1..n. p * x + q) = (\\<Sum>i=1..n. c * x)\" \n    by (simp add: sum.cong)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma cancel_div_with_params_multi:\n  fixes x a b c p q :: real\n    and n :: nat\n  assumes \"x > 0\" \"a + b / x = c\" \"p = a\" \"q = b\"\n  shows \"(\\<Sum>i=1..n. p * x + q) = (\\<Sum>i=1..n. c * x)\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  then have \"p * x + q = c * x\" using assms(3) assms(4) by (metis add.commute assms(1) divide_divide_eq_left' divide_divide_eq_right divide_less_eq_1_pos divide_self_if less_numeral_extra(1) mult.commute mult.right_neutral real_divide_square_eq times_divide_eq_left times_divide_eq_right verit_comp_simplify1(1))\n  hence \"(\\<Sum>i=1..n. p * x + q) = (\\<Sum>i=1..n. c * x)\" \n    by (simp add: sum.cong)\n  thus ?thesis by auto\nqed", "origin": "cancel_div_with_paramsV2", "update_count": 0}, "division_property": {"skill_name": "division_property", "marker": "lemma division_property:\n  fixes a b c x :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"b = x * (c - a)\"\nproof -\n  have \"b / x = c - a\" using assms by simp\n  then show ?thesis using assms(1) by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma division_property:\n  fixes a b c x :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"b = x * (c - a)\"\nproof -\n  have \"b / x = c - a\" using assms by simp\n  then show ?thesis using assms(1) by (auto simp: field_simps)\nqed", "origin": "cancel_div_with_paramsV2", "update_count": 0}, "division_and_multiplication": {"skill_name": "division_and_multiplication", "marker": "lemma division_and_multiplication:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"c = a + b / x\"\n  shows \"a = c - b / x\"\nproof -\n  have \"a = c - b / x\" using assms by (simp add: assms(2) algebra_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma division_and_multiplication:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"c = a + b / x\"\n  shows \"a = c - b / x\"\nproof -\n  have \"a = c - b / x\" using assms by (simp add: assms(2) algebra_simps)\n  then show ?thesis by simp\nqed", "origin": "cancel_div_with_paramsV2", "update_count": 0}, "division_propertyV2": {"skill_name": "division_propertyV2", "marker": "lemma division_property:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"a / b = c \\<longleftrightarrow> a = c * b\"\nproof -\n  have \"b * (a / b) = a\" using assms by auto\n  then show ?thesis by (metis assms less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_left)\nqed", "description": "-", "full_code": "lemma division_property:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"a / b = c \\<longleftrightarrow> a = c * b\"\nproof -\n  have \"b * (a / b) = a\" using assms by auto\n  then show ?thesis by (metis assms less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_left)\nqed", "origin": "cancel_div_with_paramsV2", "update_count": 0}, "product_prime": {"skill_name": "product_prime", "marker": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\" and \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p = a * b\" using assms(3) by simp\n  then have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_nat_iff)\n  then have \"a = 1 \\<or> b = 1\" using assms(4) prime_def by (metis assms(3) prime_product)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"a > 0\" and \"b > 0\" and \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p = a * b\" using assms(3) by simp\n  then have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_nat_iff)\n  then have \"a = 1 \\<or> b = 1\" using assms(4) prime_def by (metis assms(3) prime_product)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_for_inequalities_general": {"skill_name": "cancel_div_for_inequalities_general", "marker": "lemma cancel_div_for_inequalities_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x < c\"\n  shows \"a * x + b < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\" by (simp add: distrib_left)\n  then show ?thesis by (metis add.commute add_frac_num assms(1) assms(2) distrib_left less_numeral_extra(3) mult_eq_0_iff pos_divide_less_eq)\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x < c\"\n  shows \"a * x + b < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\" by (simp add: distrib_left)\n  then show ?thesis by (metis add.commute add_frac_num assms(1) assms(2) distrib_left less_numeral_extra(3) mult_eq_0_iff pos_divide_less_eq)\nqed", "origin": "cancel_div_for_inequalities", "update_count": 0}, "mod_power_sum": {"skill_name": "mod_power_sum", "marker": "theorem mod_power_sum:\n  fixes x y n c :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\"\n  shows \"((x + y)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + y)^c) mod n = (((x mod n) + (y mod n))^c) mod n\"\n    by (smt (verit) mod_add_left_eq mod_add_right_eq power_mod)\n  also have \"... = ((a + b)^c) mod n\"\n    using assms by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "theorem mod_power_sum:\n  fixes x y n c :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\"\n  shows \"((x + y)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + y)^c) mod n = (((x mod n) + (y mod n))^c) mod n\"\n    by (smt (verit) mod_add_left_eq mod_add_right_eq power_mod)\n  also have \"... = ((a + b)^c) mod n\"\n    using assms by auto\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_special_case": {"skill_name": "mod_add_power_special_case", "marker": "theorem mod_add_power_special_case:\n  fixes x b c :: nat\n  assumes \"b > 0\" \"c > 0\" \"x mod 5 = 2\"\n  shows \"((x + b)^c) mod 5 = ((2 + b)^c) mod 5\"\n  using mod_add_power_general[of x 5 2 b c] \n  by (smt (verit) assms(1) assms(2) assms(3) mod_add_power_general zero_less_numeral)", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed\n\ntheorem mod_add_power_special_case:\n  fixes x b c :: nat\n  assumes \"b > 0\" \"c > 0\" \"x mod 5 = 2\"\n  shows \"((x + b)^c) mod 5 = ((2 + b)^c) mod 5\"\n  using mod_add_power_general[of x 5 2 b c] \n  by (smt (verit) assms(1) assms(2) assms(3) mod_add_power_general zero_less_numeral)", "origin": "mod_add_power", "update_count": 0}, "product_equals_two": {"skill_name": "product_equals_two", "marker": "lemma product_equals_two:\n  fixes a b :: nat\n  assumes \"a * b = 2\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms by simp\n  then show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then have \"2 = 0\" using `a * b = 2` by auto\n    thus ?thesis by (metis zero_neq_numeral)\n  next\n    case False\n    then have \"a > 0\" by simp\n    then have \"b > 0\" using `a * b = 2` by (metis mult_is_0 zero_less_iff_neq_zero zero_neq_numeral)\n    then obtain a' b' where \"a' = a\" and \"b' = b\" and \"a' * b' = 2\" by (metis assms)\n    then show ?thesis\n    proof (cases \"a = 1\")\n      case True\n      then show ?thesis by (metis Suc_1 Suc_eq_plus1 assms mult_2_right mult_left_cancel zero_neq_one)\n    next\n      case False\n      then have \"a > 1\" by (metis \\<open>0 < a\\<close> less_numeral_extra(3) less_one linorder_neq_iff)\n      then have \"b < 2\" using `a * b = 2` by (metis Ex_less_Suc False Suc_1 Suc_lessD \\<open>0 < a\\<close> \\<open>0 < b\\<close> \\<open>\\<And>thesis. (\\<And>a' b'. \\<lbrakk>a' = a; b' = b; a' * b' = 2\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close> less_Suc_eq less_trans_Suc less_zeroE n_less_m_mult_n nat_induct_non_zero nat_less_induct nat_mult_1_right nat_mult_less_cancel_disj nat_neq_iff numeral_1_eq_Suc_0 one_eq_numeral_iff pos2 zero_less_iff_neq_zero)\n      then have \"b = 1\" using `b > 0` by auto\n      then show ?thesis by (metis Suc_1 \\<open>a' * b' = 2\\<close> \\<open>a' = a\\<close> \\<open>b' = b\\<close> mult.comm_neutral)\n    qed\n  qed\nqed", "description": "-", "full_code": "lemma product_equals_two:\n  fixes a b :: nat\n  assumes \"a * b = 2\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms by simp\n  then show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then have \"2 = 0\" using `a * b = 2` by auto\n    thus ?thesis by (metis zero_neq_numeral)\n  next\n    case False\n    then have \"a > 0\" by simp\n    then have \"b > 0\" using `a * b = 2` by (metis mult_is_0 zero_less_iff_neq_zero zero_neq_numeral)\n    then obtain a' b' where \"a' = a\" and \"b' = b\" and \"a' * b' = 2\" by (metis assms)\n    then show ?thesis\n    proof (cases \"a = 1\")\n      case True\n      then show ?thesis by (metis Suc_1 Suc_eq_plus1 assms mult_2_right mult_left_cancel zero_neq_one)\n    next\n      case False\n      then have \"a > 1\" by (metis \\<open>0 < a\\<close> less_numeral_extra(3) less_one linorder_neq_iff)\n      then have \"b < 2\" using `a * b = 2` by (metis Ex_less_Suc False Suc_1 Suc_lessD \\<open>0 < a\\<close> \\<open>0 < b\\<close> \\<open>\\<And>thesis. (\\<And>a' b'. \\<lbrakk>a' = a; b' = b; a' * b' = 2\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close> less_Suc_eq less_trans_Suc less_zeroE n_less_m_mult_n nat_induct_non_zero nat_less_induct nat_mult_1_right nat_mult_less_cancel_disj nat_neq_iff numeral_1_eq_Suc_0 one_eq_numeral_iff pos2 zero_less_iff_neq_zero)\n      then have \"b = 1\" using `b > 0` by auto\n      then show ?thesis by (metis Suc_1 \\<open>a' * b' = 2\\<close> \\<open>a' = a\\<close> \\<open>b' = b\\<close> mult.comm_neutral)\n    qed\n  qed\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_general_with_zero_multi_dim": {"skill_name": "cancel_div_general_with_zero_multi_dim", "marker": "lemma cancel_div_general_with_zero_multi_dim:\n  fixes x :: \"real list\" and a b c :: \"real list\"\n  assumes \"\\<forall>i. x ! i \\<noteq> 0\" \"\\<forall>i. a ! i + b ! i / (x ! i) = c ! i\"\n  shows \"\\<forall>i. a ! i * (x ! i) + b ! i = c ! i * (x ! i)\"\nproof -\n  have \"\\<forall>i. (x ! i) * (a ! i + b ! i / (x ! i)) = c ! i * (x ! i)\"\n    using assms(2) by auto\n  then have \"\\<forall>i. (x ! i) * a ! i + (x ! i) * (b ! i / (x ! i)) = c ! i * (x ! i)\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    by (metis add.commute add_divide_eq_if_simps(2) assms(1) assms(2) crossproduct_noteq div_by_1 frac_eq_eq mult.commute mult_cancel_right1 mult_delta_left mult_right_cancel zero_neq_numeral zero_neq_one)\nqed", "description": "-", "full_code": "lemma cancel_div_general_with_zero_multi:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    by (smt (verit) add_divide_eq_iff assms(1) assms(2) nonzero_eq_divide_eq)\nqed\n\nlemma cancel_div_general_with_zero_multi_dim:\n  fixes x :: \"real list\" and a b c :: \"real list\"\n  assumes \"\\<forall>i. x ! i \\<noteq> 0\" \"\\<forall>i. a ! i + b ! i / (x ! i) = c ! i\"\n  shows \"\\<forall>i. a ! i * (x ! i) + b ! i = c ! i * (x ! i)\"\nproof -\n  have \"\\<forall>i. (x ! i) * (a ! i + b ! i / (x ! i)) = c ! i * (x ! i)\"\n    using assms(2) by auto\n  then have \"\\<forall>i. (x ! i) * a ! i + (x ! i) * (b ! i / (x ! i)) = c ! i * (x ! i)\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    by (metis add.commute add_divide_eq_if_simps(2) assms(1) assms(2) crossproduct_noteq div_by_1 frac_eq_eq mult.commute mult_cancel_right1 mult_delta_left mult_right_cancel zero_neq_numeral zero_neq_one)\nqed", "origin": "cancel_div_general_with_zero", "update_count": 0}, "cancel_div_general_with_nonzero": {"skill_name": "cancel_div_general_with_nonzero", "marker": "lemma cancel_div_general_with_nonzero:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + b = c * x\"\n    by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(2) mult.commute nonzero_eq_divide_eq)\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma cancel_div_general_with_nonzero:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + b = c * x\"\n    by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(2) mult.commute nonzero_eq_divide_eq)\n  then show ?thesis by sos\nqed", "origin": "cancel_div_general_with_zero", "update_count": 0}, "distributive_property": {"skill_name": "distributive_property", "marker": "lemma distributive_property:\n  fixes a b c :: complex\n  shows \"(a + b) * c = a * c + b * c\"\n  by (auto simp: field_simps)", "description": "-", "full_code": "lemma distributive_property:\n  fixes a b c :: complex\n  shows \"(a + b) * c = a * c + b * c\"\n  by (auto simp: field_simps)", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib": {"skill_name": "multi_distrib", "marker": "lemma multi_distrib:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"((a + b) * c) + ((a + b) * d) = (a * c + b * c) + (a * d + b * d)\"\n    by (auto simp: field_simps)\n  then show ?thesis by (simp add: distrib_left)\nqed", "description": "-", "full_code": "lemma multi_distrib:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"((a + b) * c) + ((a + b) * d) = (a * c + b * c) + (a * d + b * d)\"\n    by (auto simp: field_simps)\n  then show ?thesis by (simp add: distrib_left)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "cancel_div_general": {"skill_name": "cancel_div_general", "marker": "lemma cancel_div_general:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"b = x * (c - a)\"\nproof -\n  have \"a + b / x = c\" using assms(2) by simp\n  then have \"b / x = c - a\" by simp\n  then have \"b = x * (c - a)\" using assms(1) by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancel_div_general:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"b = x * (c - a)\"\nproof -\n  have \"a + b / x = c\" using assms(2) by simp\n  then have \"b / x = c - a\" by simp\n  then have \"b = x * (c - a)\" using assms(1) by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "origin": "cancel_div_general_with_zero", "update_count": 0}, "solve_product_eq": {"skill_name": "solve_product_eq", "marker": "lemma solve_product_eq:\n  fixes a b :: nat\n  assumes \"a * b = 2\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms by simp\n  then show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then have \"2 = 0\" using `a * b = 2` by auto\n    thus ?thesis by (metis zero_neq_numeral)\n  next\n    case False\n    then have \"a > 0\" by simp\n    then have \"b > 0\" using `a * b = 2` by (metis mult_is_0 zero_less_iff_neq_zero zero_neq_numeral)\n    then show ?thesis\n    proof (cases \"a = 1\")\n      case True\n      then have \"b = 2\" using `a * b = 2` by auto\n      thus ?thesis by (metis True)\n    next\n      case False\n      then have \"a > 1\" by (metis `a > 0` less_numeral_extra(3) less_one linorder_neq_iff)\n      then have \"b < 2\" using `a * b = 2` by (metis Ex_less_Suc False Suc_1 Suc_lessD \\<open>0 < a\\<close> \\<open>0 < b\\<close> less_Suc_eq less_trans_Suc mult.comm_neutral n_less_m_mult_n nat_induct_non_zero nat_less_induct nat_mult_less_cancel_disj nat_neq_iff not_less0 numeral_1_eq_Suc_0 one_eq_numeral_iff pos2 zero_less_iff_neq_zero)\n      then have \"b = 1\" using `b > 0` by auto\n      then show ?thesis by (metis Suc_1 assms nat_mult_1_right)\n    qed\n  qed\nqed", "description": "-", "full_code": "lemma solve_product_eq:\n  fixes a b :: nat\n  assumes \"a * b = 2\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms by simp\n  then show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then have \"2 = 0\" using `a * b = 2` by auto\n    thus ?thesis by (metis zero_neq_numeral)\n  next\n    case False\n    then have \"a > 0\" by simp\n    then have \"b > 0\" using `a * b = 2` by (metis mult_is_0 zero_less_iff_neq_zero zero_neq_numeral)\n    then show ?thesis\n    proof (cases \"a = 1\")\n      case True\n      then have \"b = 2\" using `a * b = 2` by auto\n      thus ?thesis by (metis True)\n    next\n      case False\n      then have \"a > 1\" by (metis `a > 0` less_numeral_extra(3) less_one linorder_neq_iff)\n      then have \"b < 2\" using `a * b = 2` by (metis Ex_less_Suc False Suc_1 Suc_lessD \\<open>0 < a\\<close> \\<open>0 < b\\<close> less_Suc_eq less_trans_Suc mult.comm_neutral n_less_m_mult_n nat_induct_non_zero nat_less_induct nat_mult_less_cancel_disj nat_neq_iff not_less0 numeral_1_eq_Suc_0 one_eq_numeral_iff pos2 zero_less_iff_neq_zero)\n      then have \"b = 1\" using `b > 0` by auto\n      then show ?thesis by (metis Suc_1 assms nat_mult_1_right)\n    qed\n  qed\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_general_inequality_n_dimensions": {"skill_name": "cancel_div_general_inequality_n_dimensions", "marker": "lemma cancel_div_general_inequality_n_dimensions:\n  fixes x a b c :: \"real list\"\n  assumes \"\\<forall>i. x ! i > 0\" \"\\<forall>i. a ! i + b ! i / x ! i < c ! i\"\n  shows \"\\<forall>i. a ! i * x ! i + b ! i < c ! i * x ! i\"\nproof -\n  have \"\\<forall>i. x ! i * (a ! i + b ! i / x ! i) < c ! i * x ! i\"\n    using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_right)\n  then have \"\\<forall>i. x ! i * a ! i + x ! i * (b ! i / x ! i) < c ! i * x ! i\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (metis add.commute assms(2) divide_add_eq_iff less_numeral_extra(3) pos_divide_less_eq)\nqed", "description": "-", "full_code": "lemma cancel_div_general_inequality_n_dimensions:\n  fixes x a b c :: \"real list\"\n  assumes \"\\<forall>i. x ! i > 0\" \"\\<forall>i. a ! i + b ! i / x ! i < c ! i\"\n  shows \"\\<forall>i. a ! i * x ! i + b ! i < c ! i * x ! i\"\nproof -\n  have \"\\<forall>i. x ! i * (a ! i + b ! i / x ! i) < c ! i * x ! i\"\n    using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_right)\n  then have \"\\<forall>i. x ! i * a ! i + x ! i * (b ! i / x ! i) < c ! i * x ! i\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (metis add.commute assms(2) divide_add_eq_iff less_numeral_extra(3) pos_divide_less_eq)\nqed", "origin": "cancel_div_general_inequality", "update_count": 0}, "even_odd_product": {"skill_name": "even_odd_product", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  then have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by (simp add: algebra_simps)\n  then have \"a * b = 2 * (k * (2 * m + 1))\" by (simp add: right_diff_distrib)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  then have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by (simp add: algebra_simps)\n  then have \"a * b = 2 * (k * (2 * m + 1))\" by (simp add: right_diff_distrib)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "even_odd_productV2": {"skill_name": "even_odd_productV2", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  hence \"a * b = 2 * k * (2 * m + 1)\" by simp\n  thus \"even (a * b)\" by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  hence \"a * b = 2 * k * (2 * m + 1)\" by simp\n  thus \"even (a * b)\" by auto\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_inequality": {"skill_name": "cancel_div_inequality", "marker": "lemma cancel_div_inequality:\n  fixes a b c x :: real\n  assumes \"x > 0\" \"a + b / x < c\"\n  shows \"a * x + b < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\"\n    using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + b < c * x\"\n    by sos\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma cancel_div_inequality:\n  fixes a b c x :: real\n  assumes \"x > 0\" \"a + b / x < c\"\n  shows \"a * x + b < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\"\n    using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + b < c * x\"\n    by sos\n  then show ?thesis by sos\nqed", "origin": "cancel_div_general_inequality_n_dimensions", "update_count": 0}, "even_odd_productV3": {"skill_name": "even_odd_productV3", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  then have \"a * b = (2 * k) * (2 * m + 1)\" by (simp add: `a = 2 * k`)\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" by (simp add: distrib_left)\n  then have \"a * b = 2 * (k * (2 * m) + k)\" by (simp add: distrib_left)\n  thus \"even (a * b)\" by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  then have \"a * b = (2 * k) * (2 * m + 1)\" by (simp add: `a = 2 * k`)\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" by (simp add: distrib_left)\n  then have \"a * b = 2 * (k * (2 * m) + k)\" by (simp add: distrib_left)\n  thus \"even (a * b)\" by auto\nqed", "origin": "do_request", "update_count": 0}, "even_odd_productV4": {"skill_name": "even_odd_productV4", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by (simp add: distrib_left)\n  then have \"a * b = 2 * (k * (2 * m + 1))\" by (simp add: mult.assoc)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by (simp add: distrib_left)\n  then have \"a * b = 2 * (k * (2 * m + 1))\" by (simp add: mult.assoc)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "product_prime_natural": {"skill_name": "product_prime_natural", "marker": "lemma product_prime_natural:\n  fixes a b p :: nat\n  assumes \"a > 0\" and \"b > 0\" and \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  obtain k where \"p = 1 + k\" using assms(4) by (metis not0_implies_Suc not_prime_0 plus_1_eq_Suc)\n  have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_gt_1_nat)\n  thus \"a = 1 \\<or> b = 1\" using prime_def by (metis assms(1) assms(2) assms(3) assms(4) product_prime_extended)\nqed", "description": "-", "full_code": "lemma product_prime_extended:\n  fixes a b p :: nat\n  assumes \"a > 0\" and \"b > 0\" and \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p = a * b\" using assms(3) by simp\n  then have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_nat_iff)\n  hence \"a = 1 \\<or> b = 1\" using assms(4) prime_def by (metis assms(3) prime_product)\n  thus ?thesis by auto\nqed\n\nlemma product_prime_natural:\n  fixes a b p :: nat\n  assumes \"a > 0\" and \"b > 0\" and \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  obtain k where \"p = 1 + k\" using assms(4) by (metis not0_implies_Suc not_prime_0 plus_1_eq_Suc)\n  have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_gt_1_nat)\n  thus \"a = 1 \\<or> b = 1\" using prime_def by (metis assms(1) assms(2) assms(3) assms(4) product_prime_extended)\nqed", "origin": "product_prime", "update_count": 0}, "product_prime_extended": {"skill_name": "product_prime_extended", "marker": "lemma product_prime_extended:\n  fixes a b p q :: nat\n  assumes \"a > 0\" \"b > 0\" \"p > 0\" \"q > 0\" \"a * b = p\" \"p * q = r\" \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"r = (a * b) * q\" using assms(5) by (metis assms(6))\n  then have \"1 < a * b * q\" using assms(1) assms(2) assms(4) by (metis assms(5) assms(6) assms(7) less_numeral_extra(3) less_one mult.commute mult.left_commute mult_1 mult_eq_0_iff nat_1_eq_mult_iff nat_less_le nat_mult_1_right not_prime_0 not_prime_1 prime_product verit_comp_simplify1(3))\n  moreover have \"p * q > 1\" using assms(7) by (metis Primes.prime_nat_def assms(4) assms(6) dvd_imp_le gr_zeroI less_numeral_extra(3) mult_eq_0_iff nat_1_eq_mult_iff nat_less_le not_prime_0 not_prime_1 one_dvd)\n  ultimately have \"a = 1 \\<or> b = 1\" using prime_def by (metis assms(1) assms(2) assms(5) assms(7) product_prime_simple)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma product_prime_simple:\n  fixes p a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"a * b = p\" \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p = a * b\" using assms(3) by simp\n  then have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_nat_iff)\n  moreover have \"p > 1\" using assms(4) by (metis prime_gt_1_nat)\n  ultimately have \"a = 1 \\<or> b = 1\" using prime_def by (metis assms(3) assms(4) prime_product)\n  thus ?thesis by auto\nqed\n\nlemma product_prime_extended:\n  fixes a b p q :: nat\n  assumes \"a > 0\" \"b > 0\" \"p > 0\" \"q > 0\" \"a * b = p\" \"p * q = r\" \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"r = (a * b) * q\" using assms(5) by (metis assms(6))\n  then have \"1 < a * b * q\" using assms(1) assms(2) assms(4) by (metis assms(5) assms(6) assms(7) less_numeral_extra(3) less_one mult.commute mult.left_commute mult_1 mult_eq_0_iff nat_1_eq_mult_iff nat_less_le nat_mult_1_right not_prime_0 not_prime_1 prime_product verit_comp_simplify1(3))\n  moreover have \"p * q > 1\" using assms(7) by (metis Primes.prime_nat_def assms(4) assms(6) dvd_imp_le gr_zeroI less_numeral_extra(3) mult_eq_0_iff nat_1_eq_mult_iff nat_less_le not_prime_0 not_prime_1 one_dvd)\n  ultimately have \"a = 1 \\<or> b = 1\" using prime_def by (metis assms(1) assms(2) assms(5) assms(7) product_prime_simple)\n  thus ?thesis by auto\nqed", "origin": "product_prime", "update_count": 0}, "product_prime_simple": {"skill_name": "product_prime_simple", "marker": "lemma product_prime_simple:\n  fixes p a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"a * b = p\" \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p = a * b\" using assms(3) by simp\n  then have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_nat_iff)\n  moreover have \"p > 1\" using assms(4) by (metis prime_gt_1_nat)\n  ultimately have \"a = 1 \\<or> b = 1\" using prime_def by (metis assms(3) assms(4) prime_product)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma product_prime_simple:\n  fixes p a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"a * b = p\" \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p = a * b\" using assms(3) by simp\n  then have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_nat_iff)\n  moreover have \"p > 1\" using assms(4) by (metis prime_gt_1_nat)\n  ultimately have \"a = 1 \\<or> b = 1\" using prime_def by (metis assms(3) assms(4) prime_product)\n  thus ?thesis by auto\nqed", "origin": "product_prime", "update_count": 0}, "division_and_multiplication_extended": {"skill_name": "division_and_multiplication_extended", "marker": "lemma division_and_multiplication_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"c = a + b / x\" \"d = b / x\"\n  shows \"a = c - d\"\nproof -\n  have \"d = b / x\" using assms(3) by simp\n  then show ?thesis using assms(2) by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma division_and_multiplication_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"c = a + b / x\" \"d = b / x\"\n  shows \"a = c - d\"\nproof -\n  have \"d = b / x\" using assms(3) by simp\n  then show ?thesis using assms(2) by (simp add: algebra_simps)\nqed", "origin": "division_and_multiplication", "update_count": 0}, "division_and_multiplication_extendedV2": {"skill_name": "division_and_multiplication_extendedV2", "marker": "lemma division_and_multiplication_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"c = a + b / x\" \"d = c * x\"\n  shows \"a = c - b / x \\<and> d = c * x\"\nproof -\n  have \"a = c - b / x\" using assms(2) by (simp add: algebra_simps)\n  moreover have \"d = c * x\" using assms(3) by simp\n  ultimately show ?thesis by blast\nqed", "description": "-", "full_code": "lemma division_and_multiplication_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"c = a + b / x\" \"d = c * x\"\n  shows \"a = c - b / x \\<and> d = c * x\"\nproof -\n  have \"a = c - b / x\" using assms(2) by (simp add: algebra_simps)\n  moreover have \"d = c * x\" using assms(3) by simp\n  ultimately show ?thesis by blast\nqed", "origin": "division_and_multiplication", "update_count": 0}, "extended_division_property": {"skill_name": "extended_division_property", "marker": "lemma extended_division_property:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"c = a + b / x\" \"d > 0\"\n  shows \"a = c - b / x \\<and> d * a = d * (c - b / x)\"\nproof -\n  have \"a = c - b / x\" using assms(2) by (simp add: algebra_simps)\n  then have \"d * a = d * (c - b / x)\" using assms(3) by auto\n  thus ?thesis by (metis \\<open>a = c - b / x\\<close>)\nqed", "description": "-", "full_code": "lemma extended_division_property:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"c = a + b / x\" \"d > 0\"\n  shows \"a = c - b / x \\<and> d * a = d * (c - b / x)\"\nproof -\n  have \"a = c - b / x\" using assms(2) by (simp add: algebra_simps)\n  then have \"d * a = d * (c - b / x)\" using assms(3) by auto\n  thus ?thesis by (metis \\<open>a = c - b / x\\<close>)\nqed", "origin": "division_and_multiplication", "update_count": 0}, "mod_add_power_special_case_for_11": {"skill_name": "mod_add_power_special_case_for_11", "marker": "theorem mod_add_power_special_case_for_11:\n  fixes x b c :: nat\n  assumes \"b > 0\" \"c > 0\" \"x mod 11 = 5\"\n  shows \"((x + b)^c) mod 11 = ((5 + b)^c) mod 11\"\n  using mod_add_power_generalized[of x 11 5 b c]\n  by (smt (verit) assms(1) assms(2) assms(3) mod_add_power_generalized zero_less_numeral)", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = ((x mod n + b) mod n)^c mod n\"\n    by (metis mod_add_left_eq power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\"\n    using assms(4) by auto\n  also have \"... = (a + b)^c mod n\"\n    by (metis power_mod)\n  finally show ?thesis by auto\nqed\n\ntheorem mod_add_power_special_case_for_11:\n  fixes x b c :: nat\n  assumes \"b > 0\" \"c > 0\" \"x mod 11 = 5\"\n  shows \"((x + b)^c) mod 11 = ((5 + b)^c) mod 11\"\n  using mod_add_power_generalized[of x 11 5 b c]\n  by (smt (verit) assms(1) assms(2) assms(3) mod_add_power_generalized zero_less_numeral)", "origin": "mod_add_power_special_case", "update_count": 0}, "mod_add_power_special_case_for_7": {"skill_name": "mod_add_power_special_case_for_7", "marker": "theorem mod_add_power_special_case_for_7:\n  fixes x b c :: nat\n  assumes \"b > 0\" \"c > 0\" \"x mod 7 = 3\"\n  shows \"((x + b)^c) mod 7 = ((3 + b)^c) mod 7\"\n  using mod_add_power_generalized[of x 7 3 b c] \n  by (smt (verit) assms(1) assms(2) assms(3) mod_add_power_generalized zero_less_numeral)", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = ((x mod n + b) mod n)^c mod n\"\n    by (metis mod_add_left_eq power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\"\n    using assms(4) by auto\n  also have \"... = (a + b)^c mod n\"\n    by (metis power_mod)\n  finally show ?thesis by auto\nqed\n\ntheorem mod_add_power_special_case_for_7:\n  fixes x b c :: nat\n  assumes \"b > 0\" \"c > 0\" \"x mod 7 = 3\"\n  shows \"((x + b)^c) mod 7 = ((3 + b)^c) mod 7\"\n  using mod_add_power_generalized[of x 7 3 b c] \n  by (smt (verit) assms(1) assms(2) assms(3) mod_add_power_generalized zero_less_numeral)", "origin": "mod_add_power_special_case", "update_count": 0}, "mod_add_power_generalized": {"skill_name": "mod_add_power_generalized", "marker": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = ((x mod n + b) mod n)^c mod n\"\n    by (metis mod_add_left_eq power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\"\n    using assms(4) by auto\n  also have \"... = (a + b)^c mod n\"\n    by (metis power_mod)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = ((x mod n + b) mod n)^c mod n\"\n    by (metis mod_add_left_eq power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\"\n    using assms(4) by auto\n  also have \"... = (a + b)^c mod n\"\n    by (metis power_mod)\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power_special_case", "update_count": 0}, "mod_add_power_special_caseV2": {"skill_name": "mod_add_power_special_caseV2", "marker": "theorem mod_add_power_special_case:\n  fixes x b c :: nat\n  assumes \"b > 0\" \"c > 0\" \"x mod 5 = a\" \n  shows \"((x + b)^c) mod 5 = ((a + b)^c) mod 5\"\n  using mod_add_power_generalized[of x 5 a b c] \n  by (smt (verit) assms(1) assms(2) assms(3) mod_add_power_generalized zero_less_numeral)", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed\n\ntheorem mod_add_power_special_case:\n  fixes x b c :: nat\n  assumes \"b > 0\" \"c > 0\" \"x mod 5 = a\" \n  shows \"((x + b)^c) mod 5 = ((a + b)^c) mod 5\"\n  using mod_add_power_generalized[of x 5 a b c] \n  by (smt (verit) assms(1) assms(2) assms(3) mod_add_power_generalized zero_less_numeral)", "origin": "mod_add_power_special_case", "update_count": 0}, "cancel_div_general_with_zero_for_complex": {"skill_name": "cancel_div_general_with_zero_for_complex", "marker": "lemma cancel_div_general_with_zero_for_complex:\n  fixes x a b c :: complex\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancel_div_general_with_zero_for_complex:\n  fixes x a b c :: complex\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "origin": "cancel_div_general_with_zero", "update_count": 0}, "cancel_div_general_with_nonzeroV2": {"skill_name": "cancel_div_general_with_nonzeroV2", "marker": "lemma cancel_div_general_with_nonzero:\n  fixes x y a b c :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c / y\"\n  shows \"a * (x * y) + b * y = c * x\"\nproof -\n  have \"(x * y) * (a + b / x) = c * x\" using assms(3)\n    by (metis assms(2) diff_minus_eq_add divide_cancel_left mult.assoc mult.commute nonzero_divide_eq_eq)\n  then have \"(x * y) * a + (x * y) * (b / x) = c * x\" by (simp add: distrib_left)\n  hence \"y * (x * a) + b * y = c * x\" using assms(1) by (auto simp: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma cancel_div_general_with_nonzero:\n  fixes x y a b c :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c / y\"\n  shows \"a * (x * y) + b * y = c * x\"\nproof -\n  have \"(x * y) * (a + b / x) = c * x\" using assms(3)\n    by (metis assms(2) diff_minus_eq_add divide_cancel_left mult.assoc mult.commute nonzero_divide_eq_eq)\n  then have \"(x * y) * a + (x * y) * (b / x) = c * x\" by (simp add: distrib_left)\n  hence \"y * (x * a) + b * y = c * x\" using assms(1) by (auto simp: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "cancel_div_general_with_zero", "update_count": 0}, "cancel_div_for_inequalities_generalized": {"skill_name": "cancel_div_for_inequalities_generalized", "marker": "lemma cancel_div_for_inequalities_generalized:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x < c\"\n  shows \"a * x + b < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + (b) < c * x\" by sos\n  then show ?thesis by (metis add.commute add_frac_num assms(1) assms(2) distrib_left less_numeral_extra(3) mult_eq_0_iff pos_divide_less_eq)\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_generalized:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x < c\"\n  shows \"a * x + b < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + (b) < c * x\" by sos\n  then show ?thesis by (metis add.commute add_frac_num assms(1) assms(2) distrib_left less_numeral_extra(3) mult_eq_0_iff pos_divide_less_eq)\nqed", "origin": "cancel_div_for_inequalities_general", "update_count": 0}, "cancel_div_for_inequalities_specific": {"skill_name": "cancel_div_for_inequalities_specific", "marker": "lemma cancel_div_for_inequalities_specific:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x < c\"\n  shows \"x * a + b < c * x\"\n  using cancel_div_for_inequalities_general[of x a b c] by (metis add.commute add_frac_num assms(1) assms(2) less_numeral_extra(3) mult.commute pos_divide_less_eq)", "description": "-", "full_code": "lemma cancel_div_for_inequalities_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x < c\"\n  shows \"a * x + b < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\" by (simp add: distrib_left)\n  then show ?thesis by (metis add.commute add_frac_num assms(1) assms(2) distrib_left less_numeral_extra(3) mult_eq_0_iff pos_divide_less_eq)\nqed\n\nlemma cancel_div_for_inequalities_specific:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x < c\"\n  shows \"x * a + b < c * x\"\n  using cancel_div_for_inequalities_general[of x a b c] by (metis add.commute add_frac_num assms(1) assms(2) less_numeral_extra(3) mult.commute pos_divide_less_eq)", "origin": "cancel_div_for_inequalities_general", "update_count": 0}, "a_times_vera_extended": {"skill_name": "a_times_vera_extended", "marker": "lemma a_times_vera_extended:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" \n     and \"b * (1 / b) = 1\"\n  by (metis assms(1) field_simps) (metis assms(2) field_simps)", "description": "-", "full_code": "lemma a_times_vera_extended:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" \n     and \"b * (1 / b) = 1\"\n  by (metis assms(1) field_simps) (metis assms(2) field_simps)", "origin": "a_times_vera", "update_count": 0}, "a_times_vera_extendedV2": {"skill_name": "a_times_vera_extendedV2", "marker": "lemma a_times_vera_extended:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (b / a) = b\"\n  using assms nonzero_division by simp", "description": "-", "full_code": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b. (b / a) * a = b\"\n  using assms by (metis field_simps)\n\nlemma a_times_vera_extended:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (b / a) = b\"\n  using assms nonzero_division by simp", "origin": "a_times_vera", "update_count": 0}, "nonzero_division": {"skill_name": "nonzero_division", "marker": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b. (b / a) * a = b\"\n  using assms by (metis field_simps)", "description": "-", "full_code": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b. (b / a) * a = b\"\n  using assms by (metis field_simps)", "origin": "a_times_vera", "update_count": 0}, "non_zero_scalar_multiplication": {"skill_name": "non_zero_scalar_multiplication", "marker": "lemma non_zero_scalar_multiplication:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(a * b) / a = b\"\n  using assms by (simp add: field_simps)", "description": "-", "full_code": "lemma non_zero_scalar_multiplication:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(a * b) / a = b\"\n  using assms by (simp add: field_simps)", "origin": "a_times_vera", "update_count": 0}, "cancel_div_with_variables": {"skill_name": "cancel_div_with_variables", "marker": "lemma cancel_div_with_variables:\n  fixes x a b c d :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d = c - a\"\n  shows \"b = x * d\"\nproof -\n  have \"a + b / x = c\" using assms(2) by simp\n  then have \"b / x = c - a\" by simp\n  then have \"b = x * (c - a)\" using assms(1) by (auto simp: field_simps)\n  also have \"... = x * d\" using assms(3) by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancel_div_with_variables:\n  fixes x a b c d :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d = c - a\"\n  shows \"b = x * d\"\nproof -\n  have \"a + b / x = c\" using assms(2) by simp\n  then have \"b / x = c - a\" by simp\n  then have \"b = x * (c - a)\" using assms(1) by (auto simp: field_simps)\n  also have \"... = x * d\" using assms(3) by simp\n  finally show ?thesis by simp\nqed", "origin": "cancel_div_general", "update_count": 0}, "solve_for_b": {"skill_name": "solve_for_b", "marker": "lemma solve_for_b:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"b = x * (c - a)\"\n  using cancel_div_generalized[of x a b c] assms by simp", "description": "-", "full_code": "lemma cancel_div_generalized:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"b = x * (c - a)\"\nproof -\n  have \"a + b / x = c\" using assms(2) by simp\n  then have \"b / x = c - a\" by simp\n  then have \"b = x * (c - a)\" using assms(1) by (auto simp: field_simps)\n  then show ?thesis by simp\nqed\n\nlemma solve_for_b:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"b = x * (c - a)\"\n  using cancel_div_generalized[of x a b c] assms by simp", "origin": "cancel_div_general", "update_count": 0}, "cancel_div_for_inequalities_extended": {"skill_name": "cancel_div_for_inequalities_extended", "marker": "lemma cancel_div_for_inequalities_extended:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"a + b / x < c\" \"d = a\" \"e = b\"\n  shows \"d * x + e < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\" by (simp add: distrib_left)\n  then have \"x * a + b < c * x\" using assms(1) by auto\n  then show ?thesis using assms(3) assms(4) by sos\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_extended:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"a + b / x < c\" \"d = a\" \"e = b\"\n  shows \"d * x + e < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\" by (simp add: distrib_left)\n  then have \"x * a + b < c * x\" using assms(1) by auto\n  then show ?thesis using assms(3) assms(4) by sos\nqed", "origin": "cancel_div_for_inequalities", "update_count": 0}, "improve_cancel_div_for_inequalities": {"skill_name": "improve_cancel_div_for_inequalities", "marker": "lemma improve_cancel_div_for_inequalities:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"a + b / x < c\" \"d = a\" \"e = b\"\n  shows \"c * x > d * x + e\"\nproof -\n  have \"c * x > a * x + b\" using assms(2) by (metis add.commute assms(1) divide_add_eq_iff less_numeral_extra(3) pos_divide_less_eq)\n  then show ?thesis using assms(3) assms(4) by (metis distrib_left)\nqed", "description": "-", "full_code": "lemma improve_cancel_div_for_inequalities:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"a + b / x < c\" \"d = a\" \"e = b\"\n  shows \"c * x > d * x + e\"\nproof -\n  have \"c * x > a * x + b\" using assms(2) by (metis add.commute assms(1) divide_add_eq_iff less_numeral_extra(3) pos_divide_less_eq)\n  then show ?thesis using assms(3) assms(4) by (metis distrib_left)\nqed", "origin": "cancel_div_for_inequalities", "update_count": 0}, "add_and_cancel_div_for_inequalities": {"skill_name": "add_and_cancel_div_for_inequalities", "marker": "lemma add_and_cancel_div_for_inequalities:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"a + b / x < c\" \"d = a\" \"e = b\"\n  shows \"d * x + e < c * x\"\n  using cancel_div_for_inequalities[of x a b c d e] assms by auto", "description": "-", "full_code": "lemma cancel_div_for_inequalities:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"a + b / x < c\" \"d = a\" \"e = b\"\n  shows \"d * x + e < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\" by (simp add: distrib_left)\n  then show ?thesis using assms(1) by (metis add.commute add_frac_num assms(2) assms(3) assms(4) less_numeral_extra(3) mult_eq_0_iff pos_divide_less_eq ring_class.ring_distribs(1))\nqed\n\nlemma add_and_cancel_div_for_inequalities:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"a + b / x < c\" \"d = a\" \"e = b\"\n  shows \"d * x + e < c * x\"\n  using cancel_div_for_inequalities[of x a b c d e] assms by auto", "origin": "cancel_div_for_inequalities", "update_count": 0}, "cancel_div_for_inequalitiesV2": {"skill_name": "cancel_div_for_inequalitiesV2", "marker": "lemma cancel_div_for_inequalities:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"a + b / x < c\" \"d = a\" \"e = b\"\n  shows \"d * x + e < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\" by (simp add: distrib_left)\n  then show ?thesis using assms(1) by (metis add.commute add_frac_num assms(2) assms(3) assms(4) less_numeral_extra(3) mult_eq_0_iff pos_divide_less_eq ring_class.ring_distribs(1))\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"a + b / x < c\" \"d = a\" \"e = b\"\n  shows \"d * x + e < c * x\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + x * (b / x) < c * x\" by (simp add: distrib_left)\n  then show ?thesis using assms(1) by (metis add.commute add_frac_num assms(2) assms(3) assms(4) less_numeral_extra(3) mult_eq_0_iff pos_divide_less_eq ring_class.ring_distribs(1))\nqed", "origin": "cancel_div_for_inequalities", "update_count": 0}, "inequality_cancel_div": {"skill_name": "inequality_cancel_div", "marker": "lemma inequality_cancel_div:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a < c - b / x\" \"d = a\" \"e = b\"\n  shows \"d * x < c * x - e\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + b < c * x\" by sos\n  then have \"d * x + e < c * x\" using assms(3) assms(4) by sos\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_cancel_div:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a < c - b / x\" \"d = a\" \"e = b\"\n  shows \"d * x < c * x - e\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(2) by (smt (verit) assms(1) mult.commute mult_less_cancel_left order_less_le_subst2 verit_comp_simplify1(3))\n  then have \"x * a + b < c * x\" by sos\n  then have \"d * x + e < c * x\" using assms(3) assms(4) by sos\n  then show ?thesis by simp\nqed", "origin": "cancel_div_for_inequalities", "update_count": 0}, "nonzero_division_extended": {"skill_name": "nonzero_division_extended", "marker": "lemma nonzero_division_extended:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(\\<forall>b. (b / a) * a = b) \\<and> (\\<forall>c. (c / a) * a = c)\"\nproof -\n  have \"(\\<forall>b. (b / a) * a = b)\" using nonzero_division_general assms by auto\n  have \"(\\<forall>c. (c / a) * a = c)\" using nonzero_division_general assms by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma nonzero_division_general:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b. (b / a) * a = b\"\n  using assms by (metis field_simps)\n\nlemma nonzero_division_extended:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(\\<forall>b. (b / a) * a = b) \\<and> (\\<forall>c. (c / a) * a = c)\"\nproof -\n  have \"(\\<forall>b. (b / a) * a = b)\" using nonzero_division_general assms by auto\n  have \"(\\<forall>c. (c / a) * a = c)\" using nonzero_division_general assms by auto\n  thus ?thesis by auto\nqed", "origin": "nonzero_division", "update_count": 0}, "nonzero_division_extendedV2": {"skill_name": "nonzero_division_extendedV2", "marker": "lemma nonzero_division_extended:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b c. (b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using nonzero_division[OF assms] by auto\n  have \"c / a * a = c\" using nonzero_division[OF assms] by auto\n  then show ?thesis by (smt (verit) assms nonzero_division)\nqed", "description": "-", "full_code": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b. (b / a) * a = b\"\n  using assms by (metis field_simps)\n\nlemma nonzero_division_extended:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b c. (b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using nonzero_division[OF assms] by auto\n  have \"c / a * a = c\" using nonzero_division[OF assms] by auto\n  then show ?thesis by (smt (verit) assms nonzero_division)\nqed", "origin": "nonzero_division", "update_count": 0}, "cancel_div_general_with_nonzero_extended": {"skill_name": "cancel_div_general_with_nonzero_extended", "marker": "lemma cancel_div_general_with_nonzero_extended:\n  fixes x y a b c d :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c / y\" \"d \\<noteq> 0\"\n  shows \"a * (x * y * d) + b * y * d = c * x * d\"\nproof -\n  have \"d * (a + b / x) = (c / y) * d\" by (metis assms(3) mult.commute)\n  then have \"(x * y * d) * (a + b / x) = c * x * d\" using assms(3) by (smt (verit) assms(1) assms(2) assms(4) divide_cancel_right divisors_zero mult.commute nonzero_mult_div_cancel_left nonzero_mult_divide_mult_cancel_left nonzero_mult_divide_mult_cancel_right)\n  then have \"(x * y * d) * a + (x * y * d) * (b / x) = c * x * d\" by (simp add: distrib_left)\n  hence \"y * (x * a * d) + b * y * d = c * x * d\" using assms(1) by (auto simp: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma cancel_div_general_with_nonzero:\n  fixes x y a b c d :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c / y\"\n  shows \"a * (x * y) + b * y = c * x\"\nproof -\n  have \"(x * y) * (a + b / x) = c * x\" using assms(3)\n    by (metis assms(2) diff_minus_eq_add divide_cancel_left mult.assoc mult.commute nonzero_divide_eq_eq)\n  then have \"(x * y) * a + (x * y) * (b / x) = c * x\" by (simp add: distrib_left)\n  hence \"y * (x * a) + b * y = c * x\" using assms(1) by (auto simp: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed\n\nlemma cancel_div_general_with_nonzero_extended:\n  fixes x y a b c d :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c / y\" \"d \\<noteq> 0\"\n  shows \"a * (x * y * d) + b * y * d = c * x * d\"\nproof -\n  have \"d * (a + b / x) = (c / y) * d\" by (metis assms(3) mult.commute)\n  then have \"(x * y * d) * (a + b / x) = c * x * d\" using assms(3) by (smt (verit) assms(1) assms(2) assms(4) divide_cancel_right divisors_zero mult.commute nonzero_mult_div_cancel_left nonzero_mult_divide_mult_cancel_left nonzero_mult_divide_mult_cancel_right)\n  then have \"(x * y * d) * a + (x * y * d) * (b / x) = c * x * d\" by (simp add: distrib_left)\n  hence \"y * (x * a * d) + b * y * d = c * x * d\" using assms(1) by (auto simp: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "cancel_div_general_with_nonzeroV2", "update_count": 0}, "mod_add_power_with_var_generalized": {"skill_name": "mod_add_power_with_var_generalized", "marker": "lemma mod_add_power_with_var_generalized:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = (((a + b)^c + d) mod n)\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c) mod n + d mod n) mod n\"\n    by presburger\n  also have \"... = (((a + b)^c) mod n + d) mod n\"\n    using mod_add_power_generalized[of x n a b c] assms(4) by (smt (verit) add.commute assms(5) mod_add_right_eq power_mod)\n  also have \"... = (((a + b)^c + d) mod n)\"\n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = ((x mod n + b) mod n)^c mod n\"\n    by (metis mod_add_left_eq power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\"\n    using assms(4) by auto\n  also have \"... = (a + b)^c mod n\"\n    by (metis power_mod)\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_with_var_generalized:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = (((a + b)^c + d) mod n)\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c) mod n + d mod n) mod n\"\n    by presburger\n  also have \"... = (((a + b)^c) mod n + d) mod n\"\n    using mod_add_power_generalized[of x n a b c] assms(4) by (smt (verit) add.commute assms(5) mod_add_right_eq power_mod)\n  also have \"... = (((a + b)^c + d) mod n)\"\n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "mod_add_power_generalized", "update_count": 0}, "mod_add_power_generalized_with_variables": {"skill_name": "mod_add_power_generalized_with_variables", "marker": "lemma mod_add_power_generalized_with_variables:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_generalized[of x n a b c] by (smt (verit) assms(1) assms(2) assms(3) assms(4) mod_add_power_generalized)", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = ((x mod n + b) mod n)^c mod n\"\n    by (metis mod_add_left_eq power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\"\n    using assms(4) by auto\n  also have \"... = (a + b)^c mod n\"\n    by (metis power_mod)\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_generalized_with_variables:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_generalized[of x n a b c] by (smt (verit) assms(1) assms(2) assms(3) assms(4) mod_add_power_generalized)", "origin": "mod_add_power_generalized", "update_count": 0}, "prime_properties": {"skill_name": "prime_properties", "marker": "lemma prime_properties:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\nproof -\n  have \"p > 1\" using assms by (metis prime_gt_1_nat)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma prime_properties:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\nproof -\n  have \"p > 1\" using assms by (metis prime_gt_1_nat)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "prime_propertiesV2": {"skill_name": "prime_propertiesV2", "marker": "lemma prime_properties:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\nproof -\n  obtain k where \"p = 1 + k\" using assms by (metis not0_implies_Suc not_prime_0 plus_1_eq_Suc)\n  have \"k > 0\" using assms by (metis \\<open>p = 1 + k\\<close> add_cancel_right_right not_prime_1 zero_less_iff_neq_zero)\n  thus \"p > 1\" by (metis assms prime_gt_1_nat)\nqed", "description": "-", "full_code": "lemma prime_properties:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\nproof -\n  obtain k where \"p = 1 + k\" using assms by (metis not0_implies_Suc not_prime_0 plus_1_eq_Suc)\n  have \"k > 0\" using assms by (metis \\<open>p = 1 + k\\<close> add_cancel_right_right not_prime_1 zero_less_iff_neq_zero)\n  thus \"p > 1\" by (metis assms prime_gt_1_nat)\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_general_with_nonzero_multi_list": {"skill_name": "cancel_div_general_with_nonzero_multi_list", "marker": "fun cancel_div_general_with_nonzero_multi_list :: \"real list \\<Rightarrow> real list \\<Rightarrow> real list\" where\n  \"cancel_div_general_with_nonzero_multi_list [] _ = []\" |\n  \"cancel_div_general_with_nonzero_multi_list _ [] = []\" |\n  \"cancel_div_general_with_nonzero_multi_list (x # xs) (a # b # c # bs) = \n     (if x \\<noteq> 0 then \n        (let new_val = a * x + b in \n        new_val # cancel_div_general_with_nonzero_multi_list xs (c # bs))\n     else \n        cancel_div_general_with_nonzero_multi_list xs (c # bs))\"", "description": "-", "full_code": "lemma cancel_div_general_with_nonzero_multi:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + b = c * x\"\n    by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(2) mult.commute nonzero_eq_divide_eq)\n  then show ?thesis by sos\nqed\n\nfun cancel_div_general_with_nonzero_multi_list :: \"real list \\<Rightarrow> real list \\<Rightarrow> real list\" where\n  \"cancel_div_general_with_nonzero_multi_list [] _ = []\" |\n  \"cancel_div_general_with_nonzero_multi_list _ [] = []\" |\n  \"cancel_div_general_with_nonzero_multi_list (x # xs) (a # b # c # bs) = \n     (if x \\<noteq> 0 then \n        (let new_val = a * x + b in \n        new_val # cancel_div_general_with_nonzero_multi_list xs (c # bs))\n     else \n        cancel_div_general_with_nonzero_multi_list xs (c # bs))\"", "origin": "cancel_div_general_with_nonzero", "update_count": 0}, "prime_propertiesV3": {"skill_name": "prime_propertiesV3", "marker": "lemma prime_properties:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\nproof -\n  have \"p = 1 + (p - 1)\" by (metis Suc_diff_1 assms not_prime_0 plus_1_eq_Suc zero_less_iff_neq_zero)\n  moreover have \"p - 1 > 0\" using assms prime_def by (metis add_0_iff calculation not_prime_1 zero_less_iff_neq_zero)\n  ultimately show \"p > 1\" by (simp add: Suc_pred)\nqed", "description": "-", "full_code": "lemma prime_properties:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\nproof -\n  have \"p = 1 + (p - 1)\" by (metis Suc_diff_1 assms not_prime_0 plus_1_eq_Suc zero_less_iff_neq_zero)\n  moreover have \"p - 1 > 0\" using assms prime_def by (metis add_0_iff calculation not_prime_1 zero_less_iff_neq_zero)\n  ultimately show \"p > 1\" by (simp add: Suc_pred)\nqed", "origin": "do_request", "update_count": 0}, "prime_propertiesV4": {"skill_name": "prime_propertiesV4", "marker": "lemma prime_properties:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\nproof -\n  have \"p = 1 + (p - 1)\" by (metis Suc_diff_1 assms not_prime_0 plus_1_eq_Suc zero_less_iff_neq_zero)\n  hence \"p > 1\" using assms prime_def by (metis prime_gt_1_nat)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma prime_properties:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\nproof -\n  have \"p = 1 + (p - 1)\" by (metis Suc_diff_1 assms not_prime_0 plus_1_eq_Suc zero_less_iff_neq_zero)\n  hence \"p > 1\" using assms prime_def by (metis prime_gt_1_nat)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_with_nonzero_extended": {"skill_name": "cancel_div_with_nonzero_extended", "marker": "lemma cancel_div_with_nonzero_extended:\n  fixes x y a b c d :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c / y\" \"d \\<noteq> 0\"\n  shows \"a * (x * y * d) + b * y * d = c * x * d\"\nproof -\n  have \"d * (a + b / x) = (c / y) * d\" using assms(3) by (metis mult.commute)\n  then have \"y * (d * a * x + d * b) = c * x * d\" using assms(1,2,4)\n    by (auto simp: field_simps)\n  then show ?thesis\n    by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma cancel_div_with_nonzero:\n  fixes x y a b c :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c / y\"\n  shows \"a * (x * y) + b * y = c * x\"\nproof -\n  have \"y * (a * x + b) = c * x\" using assms\n    by (auto simp: field_simps)\n  then show ?thesis\n    by (simp add: field_simps)\nqed\n\nlemma cancel_div_with_nonzero_extended:\n  fixes x y a b c d :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c / y\" \"d \\<noteq> 0\"\n  shows \"a * (x * y * d) + b * y * d = c * x * d\"\nproof -\n  have \"d * (a + b / x) = (c / y) * d\" using assms(3) by (metis mult.commute)\n  then have \"y * (d * a * x + d * b) = c * x * d\" using assms(1,2,4)\n    by (auto simp: field_simps)\n  then show ?thesis\n    by (simp add: field_simps)\nqed", "origin": "cancel_div_general_with_nonzero_extended", "update_count": 0}, "cancel_div_with_nonzero": {"skill_name": "cancel_div_with_nonzero", "marker": "lemma cancel_div_with_nonzero:\n  fixes x y a b c :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c / y\"\n  shows \"a * (x * y) + b * y = c * x\"\nproof -\n  have \"y * (a * x + b) = c * x\" using assms\n    by (auto simp: field_simps)\n  then show ?thesis\n    by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma cancel_div_with_nonzero:\n  fixes x y a b c :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c / y\"\n  shows \"a * (x * y) + b * y = c * x\"\nproof -\n  have \"y * (a * x + b) = c * x\" using assms\n    by (auto simp: field_simps)\n  then show ?thesis\n    by (simp add: field_simps)\nqed", "origin": "cancel_div_general_with_nonzero_extended", "update_count": 0}, "product_equals_twoV2": {"skill_name": "product_equals_twoV2", "marker": "lemma product_equals_two:\n  fixes a b :: nat\n  assumes \"a * b = 2\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms by simp\n  then show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then have \"2 = 0\" using `a * b = 2` by auto\n    thus ?thesis by (metis zero_neq_numeral)\n  next\n    case False\n    then have \"a > 0\" by simp\n    then have \"b > 0\" using `a * b = 2` by (metis mult_is_0 zero_less_iff_neq_zero zero_neq_numeral)\n    have \"a \\<le> 2\" using `a * b = 2` by (metis dual_order.trans le_zero_eq less_eq_nat.simps(1) less_one linorder_le_less_linear linorder_linear mult.comm_neutral mult_0_right mult_le_mono2 order.strict_iff_order self_le_ge2_pow verit_comp_simplify1(1) zero_power)\n    then show ?thesis\n    proof (cases \"a = 1\")\n      case True\n      then have \"b = 2\" using `a * b = 2` by auto\n      thus ?thesis by (metis True)\n    next\n      case False\n      then have \"a > 1\" by (metis `a > 0` less_numeral_extra(3) less_one linorder_neq_iff)\n      then have \"b < 2\" using `a * b = 2` by (smt (verit) \\<open>0 < a\\<close> add_less_mono add_mult_distrib2 dual_order.strict_iff_not mult.comm_neutral mult_left_less_imp_less nat_1_add_1)\n      then have \"b = 1\" using `b > 0` by auto\n      then show ?thesis by (metis `a * b = 2` `b = 1` nat_mult_1_right)\n    qed\n  qed\nqed", "description": "-", "full_code": "lemma product_equals_two:\n  fixes a b :: nat\n  assumes \"a * b = 2\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms by simp\n  then show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then have \"2 = 0\" using `a * b = 2` by auto\n    thus ?thesis by (metis zero_neq_numeral)\n  next\n    case False\n    then have \"a > 0\" by simp\n    then have \"b > 0\" using `a * b = 2` by (metis mult_is_0 zero_less_iff_neq_zero zero_neq_numeral)\n    have \"a \\<le> 2\" using `a * b = 2` by (metis dual_order.trans le_zero_eq less_eq_nat.simps(1) less_one linorder_le_less_linear linorder_linear mult.comm_neutral mult_0_right mult_le_mono2 order.strict_iff_order self_le_ge2_pow verit_comp_simplify1(1) zero_power)\n    then show ?thesis\n    proof (cases \"a = 1\")\n      case True\n      then have \"b = 2\" using `a * b = 2` by auto\n      thus ?thesis by (metis True)\n    next\n      case False\n      then have \"a > 1\" by (metis `a > 0` less_numeral_extra(3) less_one linorder_neq_iff)\n      then have \"b < 2\" using `a * b = 2` by (smt (verit) \\<open>0 < a\\<close> add_less_mono add_mult_distrib2 dual_order.strict_iff_not mult.comm_neutral mult_left_less_imp_less nat_1_add_1)\n      then have \"b = 1\" using `b > 0` by auto\n      then show ?thesis by (metis `a * b = 2` `b = 1` nat_mult_1_right)\n    qed\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mod_add_power_general_multi_dim": {"skill_name": "mod_add_power_general_multi_dim", "marker": "lemma mod_add_power_general_multi_dim:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b + d)^c) mod n = ((a + b + d)^c) mod n\"\nproof -\n  have \"((x + b + d)^c) mod n = (((x + b) + d)^c) mod n\"\n    by (metis add.assoc)\n  also have \"... = ((x mod n + b + d)^c) mod n\"\n    by (smt (verit) assms(1) assms(3) assms(4) mod_add_left_eq mod_add_power_general_multi)\n  also have \"... = ((a + b + d)^c) mod n\"\n    using assms(5) by auto\n  finally show ?thesis by (metis \\<open>(x + b + d) ^ c mod n = (x mod n + b + d) ^ c mod n\\<close> add.commute add.left_commute assms(5))\nqed", "description": "-", "full_code": "lemma mod_add_power_general_multi:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_general_multi_dim:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b + d)^c) mod n = ((a + b + d)^c) mod n\"\nproof -\n  have \"((x + b + d)^c) mod n = (((x + b) + d)^c) mod n\"\n    by (metis add.assoc)\n  also have \"... = ((x mod n + b + d)^c) mod n\"\n    by (smt (verit) assms(1) assms(3) assms(4) mod_add_left_eq mod_add_power_general_multi)\n  also have \"... = ((a + b + d)^c) mod n\"\n    using assms(5) by auto\n  finally show ?thesis by (metis \\<open>(x + b + d) ^ c mod n = (x mod n + b + d) ^ c mod n\\<close> add.commute add.left_commute assms(5))\nqed", "origin": "mod_add_power_special_case", "update_count": 0}, "cancel_div_for_inequalities_reverse": {"skill_name": "cancel_div_for_inequalities_reverse", "marker": "lemma cancel_div_for_inequalities_reverse:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a * x + b < c * x\" \n  shows \"a + b / x < c\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(1) assms(2) by sos\n  thus ?thesis by (metis add.commute add_frac_num assms(1) assms(2) divide_less_eq order_less_le)\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_reverse:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a * x + b < c * x\" \n  shows \"a + b / x < c\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(1) assms(2) by sos\n  thus ?thesis by (metis add.commute add_frac_num assms(1) assms(2) divide_less_eq order_less_le)\nqed", "origin": "cancel_div_for_inequalities_general", "update_count": 0}, "division_property_add": {"skill_name": "division_property_add", "marker": "lemma division_property_add:\n  fixes a b c d :: real\n  assumes \"b > 0\" \"d > 0\"\n  shows \"(a / b) + (c / d) = (a * d + c * b) / (b * d)\"\nproof -\n  have \"a / b + c / d = (a * d) / (b * d) + (c * b) / (b * d)\"\n    by (smt (verit) assms(1) assms(2) linorder_neq_iff nonzero_mult_divide_mult_cancel_right nonzero_mult_divide_mult_cancel_right2)\n  then show ?thesis by (smt (verit) add_divide_distrib)\nqed", "description": "-", "full_code": "lemma division_property_add:\n  fixes a b c d :: real\n  assumes \"b > 0\" \"d > 0\"\n  shows \"(a / b) + (c / d) = (a * d + c * b) / (b * d)\"\nproof -\n  have \"a / b + c / d = (a * d) / (b * d) + (c * b) / (b * d)\"\n    by (smt (verit) assms(1) assms(2) linorder_neq_iff nonzero_mult_divide_mult_cancel_right nonzero_mult_divide_mult_cancel_right2)\n  then show ?thesis by (smt (verit) add_divide_distrib)\nqed", "origin": "division_propertyV2", "update_count": 0}, "product_prime_case": {"skill_name": "product_prime_case", "marker": "lemma product_prime_case:\n  fixes p a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"a * b = p\" \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p = a * b\" using assms(3) by simp\n  then have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_nat_iff)\n  moreover have \"p > 1\" using assms(4) by (metis prime_gt_1_nat)\n  ultimately show ?thesis by (metis assms(1) assms(2) assms(3) assms(4) product_prime_general)\nqed", "description": "-", "full_code": "lemma product_prime_general:\n  fixes p a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"a * b = p\" \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p = a * b\" using assms(3) by simp\n  then have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_nat_iff)\n  moreover have \"p > 1\" using assms(4) by (metis prime_gt_1_nat)\n  ultimately have \"a = 1 \\<or> b = 1\" using prime_def by (metis assms(3) assms(4) prime_product)\n  thus ?thesis by auto\nqed\n\nlemma product_prime_case:\n  fixes p a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"a * b = p\" \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p = a * b\" using assms(3) by simp\n  then have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_nat_iff)\n  moreover have \"p > 1\" using assms(4) by (metis prime_gt_1_nat)\n  ultimately show ?thesis by (metis assms(1) assms(2) assms(3) assms(4) product_prime_general)\nqed", "origin": "product_prime_simple", "update_count": 0}, "product_prime_general_3d": {"skill_name": "product_prime_general_3d", "marker": "lemma product_prime_general_3d:\n  fixes p a b c :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"a * b * c = p\" \"prime p\"\n  shows \"a = 1 \\<or> b = 1 \\<or> c = 1\"\nproof -\n  have \"p = a * b * c\" using assms(4) by simp\n  then have \"1 < a * b * c\" using assms(1) assms(2) assms(3) by (metis Totient.of_nat_eq_1_iff assms(4) assms(5) less_one linorder_neqE_nat mult.commute mult.left_commute mult_1 mult_eq_0_iff mult_pos_pos nat_mult_eq_1_iff prime_prime_factor zero_less_iff_neq_zero)\n  moreover have \"p > 1\" using assms(5) by (metis prime_gt_1_nat)\n  ultimately show ?thesis\n  proof (cases \"a > 1\")\n    case True\n    then have \"b * c = p div a\" using assms(4) by auto\n    then show ?thesis by (metis assms(4) assms(5) mult.commute mult_delta_right nat_1_eq_mult_iff prime_product)\n  next\n    case False\n    then show ?thesis by (metis assms(1) linorder_neqE_nat nat_dvd_not_less one_dvd)\n  qed\nqed", "description": "-", "full_code": "lemma product_prime_general:\n  fixes p a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"a * b = p\" \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p = a * b\" using assms(3) by simp\n  then have \"1 < a * b\" using assms(1) assms(2) by (metis assms(3) assms(4) prime_nat_iff)\n  moreover have \"p > 1\" using assms(4) by (metis prime_gt_1_nat)\n  ultimately show ?thesis by (metis assms(3) assms(4) prime_product)\nqed\n\nlemma product_prime_general_3d:\n  fixes p a b c :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"a * b * c = p\" \"prime p\"\n  shows \"a = 1 \\<or> b = 1 \\<or> c = 1\"\nproof -\n  have \"p = a * b * c\" using assms(4) by simp\n  then have \"1 < a * b * c\" using assms(1) assms(2) assms(3) by (metis Totient.of_nat_eq_1_iff assms(4) assms(5) less_one linorder_neqE_nat mult.commute mult.left_commute mult_1 mult_eq_0_iff mult_pos_pos nat_mult_eq_1_iff prime_prime_factor zero_less_iff_neq_zero)\n  moreover have \"p > 1\" using assms(5) by (metis prime_gt_1_nat)\n  ultimately show ?thesis\n  proof (cases \"a > 1\")\n    case True\n    then have \"b * c = p div a\" using assms(4) by auto\n    then show ?thesis by (metis assms(4) assms(5) mult.commute mult_delta_right nat_1_eq_mult_iff prime_product)\n  next\n    case False\n    then show ?thesis by (metis assms(1) linorder_neqE_nat nat_dvd_not_less one_dvd)\n  qed\nqed", "origin": "product_prime_case", "update_count": 0}, "prime_properties_for_any_prime": {"skill_name": "prime_properties_for_any_prime", "marker": "lemma prime_properties_for_any_prime:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\n  using prime_properties_generalized[of p] assms by simp", "description": "-", "full_code": "lemma prime_properties_generalized:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\nproof -\n  obtain k where \"p = 1 + k\" using assms by (metis not0_implies_Suc not_prime_0 plus_1_eq_Suc)\n  have \"k > 0\" using assms by (metis \\<open>p = 1 + k\\<close> add_cancel_right_right not_prime_1 zero_less_iff_neq_zero)\n  thus \"p > 1\" by (metis assms prime_gt_1_nat)\nqed\n\nlemma prime_properties_for_any_prime:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows \"p > 1\"\n  using prime_properties_generalized[of p] assms by simp", "origin": "prime_propertiesV2", "update_count": 0}, "a_times_vera_extended_n_dimensions": {"skill_name": "a_times_vera_extended_n_dimensions", "marker": "lemma a_times_vera_extended_n_dimensions:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" \n     and \"b * (1 / b) = 1\"\n     and \"(\\<forall>x. x > 0 \\<longrightarrow> a * (1 / a) = 1) \\<and> (\\<forall>y. y > 0 \\<longrightarrow> b * (1 / b) = 1)\"\nproof -\n  have \"a * (1 / a) = 1\" by (metis assms(1) field_simps)\n  moreover have \"b * (1 / b) = 1\" by (metis assms(2) field_simps)\n  ultimately show \"a * (1 / a) = 1\" \n    and \"b * (1 / b) = 1\"\n    and \"(\\<forall>x. x > 0 \\<longrightarrow> a * (1 / a) = 1) \\<and> (\\<forall>y. y > 0 \\<longrightarrow> b * (1 / b) = 1)\"\n    by auto\nqed", "description": "-", "full_code": "lemma a_times_vera_extended_n_dimensions:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" \n     and \"b * (1 / b) = 1\"\n     and \"(\\<forall>x. x > 0 \\<longrightarrow> a * (1 / a) = 1) \\<and> (\\<forall>y. y > 0 \\<longrightarrow> b * (1 / b) = 1)\"\nproof -\n  have \"a * (1 / a) = 1\" by (metis assms(1) field_simps)\n  moreover have \"b * (1 / b) = 1\" by (metis assms(2) field_simps)\n  ultimately show \"a * (1 / a) = 1\" \n    and \"b * (1 / b) = 1\"\n    and \"(\\<forall>x. x > 0 \\<longrightarrow> a * (1 / a) = 1) \\<and> (\\<forall>y. y > 0 \\<longrightarrow> b * (1 / b) = 1)\"\n    by auto\nqed", "origin": "a_times_vera_extended", "update_count": 0}, "product_prime_condition": {"skill_name": "product_prime_condition", "marker": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof (cases \"a = 1\")\n  case True\n  then show ?thesis by auto\nnext\n  case False\n  then have \"a > 1\" by (metis Primes.prime_nat_def assms mult.right_neutral prime_gt_1_nat prime_product)\n  have \"a * b > 1\" using False by (metis assms prime_gt_1_nat)\n  then have \"1 < a * b\" using `prime (a * b)` by (metis prime_gt_1_nat)\n  have \"a > 1 \\<Longrightarrow> b = 1\" using `prime (a * b)` by (metis prime_def prime_product False)\n  thus ?thesis by (metis \\<open>1 < a\\<close>)\nqed", "description": "-", "full_code": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof (cases \"a = 1\")\n  case True\n  then show ?thesis by auto\nnext\n  case False\n  then have \"a > 1\" by (metis Primes.prime_nat_def assms mult.right_neutral prime_gt_1_nat prime_product)\n  have \"a * b > 1\" using False by (metis assms prime_gt_1_nat)\n  then have \"1 < a * b\" using `prime (a * b)` by (metis prime_gt_1_nat)\n  have \"a > 1 \\<Longrightarrow> b = 1\" using `prime (a * b)` by (metis prime_def prime_product False)\n  thus ?thesis by (metis \\<open>1 < a\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "product_prime_conditionV2": {"skill_name": "product_prime_conditionV2", "marker": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof (cases \"a = 1\")\n  case True\n  then show ?thesis by auto\nnext\n  case False\n  then have \"a > 1\" by (metis Primes.prime_nat_def assms mult.right_neutral prime_gt_1_nat prime_product)\n  have \"a * b > 1\" using False assms prime_gt_1_nat by auto\n  then have \"1 < a * b\" using assms by (simp add: prime_gt_1_nat)\n  have \"prime (a * b) \\<Longrightarrow> a > 1 \\<Longrightarrow> b = 1\" \n    using assms False prime_def prime_product by auto\n  thus ?thesis using `a > 1` by (metis assms)\nqed", "description": "-", "full_code": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof (cases \"a = 1\")\n  case True\n  then show ?thesis by auto\nnext\n  case False\n  then have \"a > 1\" by (metis Primes.prime_nat_def assms mult.right_neutral prime_gt_1_nat prime_product)\n  have \"a * b > 1\" using False assms prime_gt_1_nat by auto\n  then have \"1 < a * b\" using assms by (simp add: prime_gt_1_nat)\n  have \"prime (a * b) \\<Longrightarrow> a > 1 \\<Longrightarrow> b = 1\" \n    using assms False prime_def prime_product by auto\n  thus ?thesis using `a > 1` by (metis assms)\nqed", "origin": "do_request", "update_count": 0}, "product_prime_conditionV3": {"skill_name": "product_prime_conditionV3", "marker": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof (cases \"a = 1\")\n  case True\n  then show ?thesis by auto\nnext\n  case False\n  then have \"a > 1\" by (metis Primes.prime_nat_def assms mult.right_neutral prime_gt_1_nat prime_product)\n  have \"1 < a * b\" using assms prime_gt_1_nat by simp\n  then have \"1 < a\" by (metis \\<open>1 < a\\<close>)\n  have \"prime (a * b) \\<Longrightarrow> a > 1 \\<Longrightarrow> b = 1\" using assms\n    by (metis prime_def prime_product False)\n  thus ?thesis by (metis \\<open>1 < a\\<close> assms)\nqed", "description": "-", "full_code": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof (cases \"a = 1\")\n  case True\n  then show ?thesis by auto\nnext\n  case False\n  then have \"a > 1\" by (metis Primes.prime_nat_def assms mult.right_neutral prime_gt_1_nat prime_product)\n  have \"1 < a * b\" using assms prime_gt_1_nat by simp\n  then have \"1 < a\" by (metis \\<open>1 < a\\<close>)\n  have \"prime (a * b) \\<Longrightarrow> a > 1 \\<Longrightarrow> b = 1\" using assms\n    by (metis prime_def prime_product False)\n  thus ?thesis by (metis \\<open>1 < a\\<close> assms)\nqed", "origin": "do_request", "update_count": 0}, "cancle_div_extended": {"skill_name": "cancle_div_extended", "marker": "lemma cancle_div_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"d > 0\" \"a + b / x = c\" \"a + b / d = c\"\n  shows \"a * x + b = c * x\" and \"a * d + b = c * d\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(3) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show \"a * x + b = c * x\"\n    using assms(1) by (simp add: mult.commute)\n  have \"d * (a + b / d) = c * d\"\n    using assms(4) by auto\n  then have \"d * a + d * (b / d) = c * d\"\n    by (simp add: distrib_left)\n  then show \"a * d + b = c * d\"\n    using assms(2) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancle_div_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"d > 0\" \"a + b / x = c\" \"a + b / d = c\"\n  shows \"a * x + b = c * x\" and \"a * d + b = c * d\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(3) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show \"a * x + b = c * x\"\n    using assms(1) by (simp add: mult.commute)\n  have \"d * (a + b / d) = c * d\"\n    using assms(4) by auto\n  then have \"d * a + d * (b / d) = c * d\"\n    by (simp add: distrib_left)\n  then show \"a * d + b = c * d\"\n    using assms(2) by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "mod_mult_power": {"skill_name": "mod_mult_power", "marker": "lemma mod_mult_power:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"((x * b)^c) mod n = ((a * b)^c) mod n\"\nproof -\n  have \"((x * b)^c) mod n = ((x mod n * b) mod n)^c mod n\"\n    by (metis mod_mult_left_eq power_mod)\n  also have \"... = ((a * b) mod n)^c mod n\"\n    using assms(2) by auto\n  also have \"... = (a * b)^c mod n\"\n    by (metis power_mod)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_mult_power:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"((x * b)^c) mod n = ((a * b)^c) mod n\"\nproof -\n  have \"((x * b)^c) mod n = ((x mod n * b) mod n)^c mod n\"\n    by (metis mod_mult_left_eq power_mod)\n  also have \"... = ((a * b) mod n)^c mod n\"\n    using assms(2) by auto\n  also have \"... = (a * b)^c mod n\"\n    by (metis power_mod)\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power_with_var_generalized", "update_count": 0}, "mod_product_generalized": {"skill_name": "mod_product_generalized", "marker": "lemma mod_product_generalized:\n  fixes x y n :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\"\n  shows \"(x * y) mod n = (a * b) mod n\"\nproof -\n  have \"(x * y) mod n = ((x mod n) * (y mod n)) mod n\"\n    by (metis mod_mult_eq)\n  also have \"... = (a * b) mod n\"\n    using assms(2,3) by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_product_generalized:\n  fixes x y n :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\"\n  shows \"(x * y) mod n = (a * b) mod n\"\nproof -\n  have \"(x * y) mod n = ((x mod n) * (y mod n)) mod n\"\n    by (metis mod_mult_eq)\n  also have \"... = (a * b) mod n\"\n    using assms(2,3) by auto\n  finally show ?thesis by simp\nqed", "origin": "mod_add_power_with_var_generalized", "update_count": 0}, "even_odd_productV5": {"skill_name": "even_odd_productV5", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto  \n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)  \n  have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  have \"a * b = (2 * k * 2 * m) + (2 * k * 1)\" by (smt (verit) \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> ab_semigroup_mult_class.mult_ac(1) distrib_left)\n  have \"a * b = 2 * (k * (2 * m) + k)\" by (smt (verit) \\<open>a * b = 2 * k * 2 * m + 2 * k * 1\\<close> \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> ab_semigroup_mult_class.mult_ac(1) add.commute add_implies_diff add_mult_distrib2 add_self_div_2 assms(1) diff_mult_distrib2 div_mult_div_if_dvd div_mult_mult2 div_mult_self2 dvd_div_div_eq_mult dvd_div_mult gcd_nat.eq_iff mult.left_commute mult_of_nat_commute nonzero_mult_div_cancel_left numeral_Bit0_div_2 numerals(1) of_nat_1 zero_neq_numeral)\n  thus \"even (a * b)\" by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto  \n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)  \n  have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  have \"a * b = (2 * k * 2 * m) + (2 * k * 1)\" by (smt (verit) \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> ab_semigroup_mult_class.mult_ac(1) distrib_left)\n  have \"a * b = 2 * (k * (2 * m) + k)\" by (smt (verit) \\<open>a * b = 2 * k * 2 * m + 2 * k * 1\\<close> \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> ab_semigroup_mult_class.mult_ac(1) add.commute add_implies_diff add_mult_distrib2 add_self_div_2 assms(1) diff_mult_distrib2 div_mult_div_if_dvd div_mult_mult2 div_mult_self2 dvd_div_div_eq_mult dvd_div_mult gcd_nat.eq_iff mult.left_commute mult_of_nat_commute nonzero_mult_div_cancel_left numeral_Bit0_div_2 numerals(1) of_nat_1 zero_neq_numeral)\n  thus \"even (a * b)\" by auto\nqed", "origin": "do_request", "update_count": 0}, "even_odd_productV6": {"skill_name": "even_odd_productV6", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" \n    by (simp add: distrib_left)\n  hence \"a * b = 2 * (k * (2 * m) + k)\" \n    by (simp add: distrib_left)\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" \n    by (simp add: distrib_left)\n  hence \"a * b = 2 * (k * (2 * m) + k)\" \n    by (simp add: distrib_left)\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_add_power_generalized_multiple": {"skill_name": "mod_add_power_generalized_multiple", "marker": "lemma mod_add_power_generalized_multiple:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  and \"((x + b) * (x + b)) mod n = ((a + b) * (a + b)) mod n\"\nproof -\n  have \"((x + b)^c) mod n = ((x mod n + b) mod n)^c mod n\"\n    by (metis mod_add_left_eq power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\"\n    using assms(4) by auto\n  also have \"... = (a + b)^c mod n\"\n    by (metis power_mod)\n  finally show \"((x + b)^c) mod n = ((a + b)^c) mod n\" by auto\n  have \"((x + b) * (x + b)) mod n = ((x mod n + b) mod n * (x mod n + b) mod n) mod n\"\n    by (smt (verit) bits_mod_div_trivial mod_add_left_eq mod_eq_self_iff_div_eq_0 mod_mult_eq mod_mult_left_eq)\n  also have \"... = ((a + b) * (a + b)) mod n\"\n    using assms(4) by (metis add.commute mod_mod_trivial mod_mult_left_eq)\n  finally show \"((x + b) * (x + b)) mod n = ((a + b) * (a + b)) mod n\" by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_generalized_multiple:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  and \"((x + b) * (x + b)) mod n = ((a + b) * (a + b)) mod n\"\nproof -\n  have \"((x + b)^c) mod n = ((x mod n + b) mod n)^c mod n\"\n    by (metis mod_add_left_eq power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\"\n    using assms(4) by auto\n  also have \"... = (a + b)^c mod n\"\n    by (metis power_mod)\n  finally show \"((x + b)^c) mod n = ((a + b)^c) mod n\" by auto\n  have \"((x + b) * (x + b)) mod n = ((x mod n + b) mod n * (x mod n + b) mod n) mod n\"\n    by (smt (verit) bits_mod_div_trivial mod_add_left_eq mod_eq_self_iff_div_eq_0 mod_mult_eq mod_mult_left_eq)\n  also have \"... = ((a + b) * (a + b)) mod n\"\n    using assms(4) by (metis add.commute mod_mod_trivial mod_mult_left_eq)\n  finally show \"((x + b) * (x + b)) mod n = ((a + b) * (a + b)) mod n\" by auto\nqed", "origin": "mod_add_power_generalized", "update_count": 0}, "multi_distrib_gen": {"skill_name": "multi_distrib_gen", "marker": "lemma multi_distrib_gen:\n  fixes a b c d e f :: complex\n  shows \"((a + b) * (c + d)) + ((e + f) * (c + d)) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"((a + b) * (c + d)) + ((e + f) * (c + d)) = (a * (c + d) + b * (c + d)) + (e * (c + d) + f * (c + d))\"\n    by (auto simp: field_simps)\n  also have \"... = (a + e) * (c + d) + (b + f) * (c + d)\"\n    by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_gen:\n  fixes a b c d e f :: complex\n  shows \"((a + b) * (c + d)) + ((e + f) * (c + d)) = (a + e) * (c + d) + (b + f) * (c + d)\"\nproof -\n  have \"((a + b) * (c + d)) + ((e + f) * (c + d)) = (a * (c + d) + b * (c + d)) + (e * (c + d) + f * (c + d))\"\n    by (auto simp: field_simps)\n  also have \"... = (a + e) * (c + d) + (b + f) * (c + d)\"\n    by (simp add: field_simps)\n  finally show ?thesis by simp\nqed", "origin": "multi_distrib", "update_count": 0}, "multi_distrib_complexV2": {"skill_name": "multi_distrib_complexV2", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a * c + a * d) + (b * c + b * d)\"\n    using distrib_left by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a * c + a * d) + (b * c + b * d)\"\n    using distrib_left by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "origin": "multi_distrib", "update_count": 0}, "mod_add_power_generalized_2d": {"skill_name": "mod_add_power_generalized_2d", "marker": "lemma mod_add_power_generalized_2d:\n  fixes x y n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \"y mod n = b\"\n  shows \"((x + y)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + y)^c) mod n = ((x mod n + y mod n)^c) mod n\"\n    using assms(4) assms(5) by (smt (verit) mod_add_left_eq mod_add_right_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    by (metis add.commute assms(4) assms(5))\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_generalized_2d:\n  fixes x y n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \"y mod n = b\"\n  shows \"((x + y)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + y)^c) mod n = ((x mod n + y mod n)^c) mod n\"\n    using assms(4) assms(5) by (smt (verit) mod_add_left_eq mod_add_right_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    by (metis add.commute assms(4) assms(5))\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power_special_caseV2", "update_count": 0}, "cancel_div_for_inequalities_reverse_extended": {"skill_name": "cancel_div_for_inequalities_reverse_extended", "marker": "lemma cancel_div_for_inequalities_reverse_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a * x + b < c * x\" \"d > 0\"\n  shows \"a + b / x < c\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(1) assms(2) by sos\n  thus \"a + b / x < c\" by (metis assms(1) mult.commute mult_less_cancel_left_disj order_less_imp_not_less)\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_reverse_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a * x + b < c * x\" \"d > 0\"\n  shows \"a + b / x < c\"\nproof -\n  have \"x * (a + b / x) < c * x\" using assms(1) assms(2) by sos\n  thus \"a + b / x < c\" by (metis assms(1) mult.commute mult_less_cancel_left_disj order_less_imp_not_less)\nqed", "origin": "cancel_div_for_inequalities_reverse", "update_count": 0}, "cancel_div_for_inequalities_reverse_stronger": {"skill_name": "cancel_div_for_inequalities_reverse_stronger", "marker": "lemma cancel_div_for_inequalities_reverse_stronger:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"0 < d\" \"a * x + b < c * x + d\"\n  shows \"a + b / x < c + d / x\"\nproof -\n  have \"x * (a + b / x) < c * x + d\" using assms(1) assms(2) assms(3) by sos\n  thus \"a + b / x < c + d / x\" by (smt (z3) add_divide_eq_iff assms(1) assms(3) divide_strict_right_mono)\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_reverse_stronger:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"0 < d\" \"a * x + b < c * x + d\"\n  shows \"a + b / x < c + d / x\"\nproof -\n  have \"x * (a + b / x) < c * x + d\" using assms(1) assms(2) assms(3) by sos\n  thus \"a + b / x < c + d / x\" by (smt (z3) add_divide_eq_iff assms(1) assms(3) divide_strict_right_mono)\nqed", "origin": "cancel_div_for_inequalities_reverse", "update_count": 0}, "cancel_div_for_inequalities_reverse_strict": {"skill_name": "cancel_div_for_inequalities_reverse_strict", "marker": "lemma cancel_div_for_inequalities_reverse_strict:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a * x + b < c * x\"\n  shows \"a + (b / x) < c\"\nproof -\n  have \"x * (a + (b / x)) < c * x\" using assms by sos\n  thus ?thesis by (metis assms(1) assms(2) cancel_div_for_inequalities_reverse_gen)\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_reverse_gen:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a * x + b < c * x\"\n  shows \"a + (b / x) < c\"\nproof -\n  have \"x * (a + (b / x)) < c * x\" using assms(1) assms(2) by sos\n  thus ?thesis by (metis assms(1) mult.commute mult_less_cancel_left_disj order_less_imp_not_less)\nqed\n\nlemma cancel_div_for_inequalities_reverse_strict:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a * x + b < c * x\"\n  shows \"a + (b / x) < c\"\nproof -\n  have \"x * (a + (b / x)) < c * x\" using assms by sos\n  thus ?thesis by (metis assms(1) assms(2) cancel_div_for_inequalities_reverse_gen)\nqed", "origin": "cancel_div_for_inequalities_reverse", "update_count": 0}, "cancel_div_for_inequalities_combined": {"skill_name": "cancel_div_for_inequalities_combined", "marker": "lemma cancel_div_for_inequalities_combined:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a * x + b < c * x\" \"d > 0\"\n  shows \"d * (a + (b / x)) < d * c\"\nproof -\n  have \"x * (a + (b / x)) < c * x\" using assms(1) assms(2) by sos\n  hence \"d * x * (a + (b / x)) < d * c * x\" using assms(3) by auto\n  thus ?thesis by (metis assms(1) mult.assoc mult.commute mult_less_cancel_left_pos)\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_combined:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a * x + b < c * x\" \"d > 0\"\n  shows \"d * (a + (b / x)) < d * c\"\nproof -\n  have \"x * (a + (b / x)) < c * x\" using assms(1) assms(2) by sos\n  hence \"d * x * (a + (b / x)) < d * c * x\" using assms(3) by auto\n  thus ?thesis by (metis assms(1) mult.assoc mult.commute mult_less_cancel_left_pos)\nqed", "origin": "cancel_div_for_inequalities_reverse", "update_count": 0}, "multi_distribV2": {"skill_name": "multi_distribV2", "marker": "lemma multi_distrib:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "multi_distrib_gen", "update_count": 0}, "distributive_propertyV2": {"skill_name": "distributive_propertyV2", "marker": "lemma distributive_property:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma distributive_property:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "multi_distrib_gen", "update_count": 0}, "distribution_property": {"skill_name": "distribution_property", "marker": "lemma distribution_property:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\n    by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_property:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\"\n    by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "multi_distrib_gen", "update_count": 0}, "prime_product_general": {"skill_name": "prime_product_general", "marker": "lemma prime_product_general:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"prime (a * b) \\<longleftrightarrow> (a = 1 \\<and> b > 1) \\<or> (a > 1 \\<and> b = 1)\" using assms by (metis Primes.prime_nat_def mult.right_neutral mult_1 prime_nat_iff prime_product)\n  thus ?thesis by (metis assms(3))\nqed", "description": "-", "full_code": "lemma prime_product_general:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"prime (a * b) \\<longleftrightarrow> (a = 1 \\<and> b > 1) \\<or> (a > 1 \\<and> b = 1)\" using assms by (metis Primes.prime_nat_def mult.right_neutral mult_1 prime_nat_iff prime_product)\n  thus ?thesis by (metis assms(3))\nqed", "origin": "prime_propertiesV2", "update_count": 0}, "division_properties": {"skill_name": "division_properties", "marker": "lemma division_properties:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b / a) * a = b \\<and> (c / a) * a = c \\<and> (b / a) + (c / a) = (b + c) / a\"\nproof -\n  have first: \"(b / a) * a = b\" using assms by (metis field_simps)\n  have second: \"(c / a) * a = c\" using assms by (metis field_simps)\n  have third: \"(b / a) + (c / a) = (b + c) / a\"\n    using assms by (auto simp: field_simps)\n  then show ?thesis by (metis first second)\nqed", "description": "-", "full_code": "lemma division_properties:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b / a) * a = b \\<and> (c / a) * a = c \\<and> (b / a) + (c / a) = (b + c) / a\"\nproof -\n  have first: \"(b / a) * a = b\" using assms by (metis field_simps)\n  have second: \"(c / a) * a = c\" using assms by (metis field_simps)\n  have third: \"(b / a) + (c / a) = (b + c) / a\"\n    using assms by (auto simp: field_simps)\n  then show ?thesis by (metis first second)\nqed", "origin": "nonzero_division_extendedV2", "update_count": 0}, "division_propertiesV2": {"skill_name": "division_propertiesV2", "marker": "lemma division_properties:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using assms by (metis field_simps)\n  have \"c / a * a = c\" using assms by (metis field_simps)\n  then show ?thesis by (metis \\<open>b / a * a = b\\<close>)\nqed", "description": "-", "full_code": "lemma division_properties:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using assms by (metis field_simps)\n  have \"c / a * a = c\" using assms by (metis field_simps)\n  then show ?thesis by (metis \\<open>b / a * a = b\\<close>)\nqed", "origin": "nonzero_division_extendedV2", "update_count": 0}, "division_propertiesV3": {"skill_name": "division_propertiesV3", "marker": "lemma division_properties:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b c. (b / a) * a = b \\<and> (c / a) * a = c \\<and> (b + c) / a * a = b + c\"\nproof -\n  have \"b / a * a = b\" using nonzero_division[OF assms] by auto\n  have \"c / a * a = c\" using nonzero_division[OF assms] by auto\n  have \"(b + c) / a * a = (b + c)\" \n    using assms by (metis (no_types, lifting) field_simps)\n  then show ?thesis by (smt (verit) assms nonzero_division)\nqed", "description": "-", "full_code": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b. (b / a) * a = b\"\n  using assms by (metis field_simps)\n\nlemma division_properties:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b c. (b / a) * a = b \\<and> (c / a) * a = c \\<and> (b + c) / a * a = b + c\"\nproof -\n  have \"b / a * a = b\" using nonzero_division[OF assms] by auto\n  have \"c / a * a = c\" using nonzero_division[OF assms] by auto\n  have \"(b + c) / a * a = (b + c)\" \n    using assms by (metis (no_types, lifting) field_simps)\n  then show ?thesis by (smt (verit) assms nonzero_division)\nqed", "origin": "nonzero_division_extendedV2", "update_count": 0}, "odd_even_product": {"skill_name": "odd_even_product", "marker": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  have \"a mod 2 = 0\" using assms(1) by simp\n  have \"b mod 2 = 1\" using assms(2) by simp\n  from `a mod 2 = 0` obtain k where \"a = 2 * k\"\n    by auto\n  from `b mod 2 = 1` obtain m where \"b = 2 * m + 1\"\n    by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by auto\n  then have \"a * b = 2 * k * (2 * m + 1)\" \n    by (simp add: distrib_left)\n  thus ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  have \"a mod 2 = 0\" using assms(1) by simp\n  have \"b mod 2 = 1\" using assms(2) by simp\n  from `a mod 2 = 0` obtain k where \"a = 2 * k\"\n    by auto\n  from `b mod 2 = 1` obtain m where \"b = 2 * m + 1\"\n    by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by auto\n  then have \"a * b = 2 * k * (2 * m + 1)\" \n    by (simp add: distrib_left)\n  thus ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "even_product_of_two_evens": {"skill_name": "even_product_of_two_evens", "marker": "lemma even_product_of_two_evens:\n  fixes a b :: nat\n  assumes \"even a\" \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m\" using assms(2) by auto\n  have \"a * b = (2 * k) * (2 * m)\" \n    using `a = 2 * k` `b = 2 * m` by simp\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma even_product_of_two_evens:\n  fixes a b :: nat\n  assumes \"even a\" \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m\" using assms(2) by auto\n  have \"a * b = (2 * k) * (2 * m)\" \n    using `a = 2 * k` `b = 2 * m` by simp\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "even_odd_productV6", "update_count": 0}, "odd_product_of_two_odds": {"skill_name": "odd_product_of_two_odds", "marker": "lemma odd_product_of_two_odds:\n  fixes a b :: nat\n  assumes \"odd a\" \"odd b\"\n  shows \"odd (a * b)\"\nproof -\n  obtain k where \"a = 2 * k + 1\" using assms(1) by (metis odd_two_times_div_two_succ)\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * k + 1) * (2 * m + 1)\" \n    using `a = 2 * k + 1` `b = 2 * m + 1` by simp\n  then have \"a * b = 2 * k * 2 * m + 2 * k + 2 * m + 1\" \n    by (simp add: distrib_left)\n  thus \"odd (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma odd_product_of_two_odds:\n  fixes a b :: nat\n  assumes \"odd a\" \"odd b\"\n  shows \"odd (a * b)\"\nproof -\n  obtain k where \"a = 2 * k + 1\" using assms(1) by (metis odd_two_times_div_two_succ)\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * k + 1) * (2 * m + 1)\" \n    using `a = 2 * k + 1` `b = 2 * m + 1` by simp\n  then have \"a * b = 2 * k * 2 * m + 2 * k + 2 * m + 1\" \n    by (simp add: distrib_left)\n  thus \"odd (a * b)\" \n    by auto\nqed", "origin": "even_odd_productV6", "update_count": 0}, "even_odd_product_extended": {"skill_name": "even_odd_product_extended", "marker": "lemma even_odd_product_extended:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\" \"c > 0\"\n  shows \"even (a * b * c)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b * c = (2 * k) * (2 * m + 1) * c\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  then have \"a * b * c = 2 * k * (2 * m) * c + 2 * k * c\" \n    by (auto simp: field_simps)\n  hence \"a * b * c = 2 * (k * (2 * m * c) + k * c)\" \n    by (simp add: distrib_left)\n  thus \"even (a * b * c)\" \n    by auto\nqed", "description": "-", "full_code": "lemma even_odd_product_extended:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\" \"c > 0\"\n  shows \"even (a * b * c)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b * c = (2 * k) * (2 * m + 1) * c\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  then have \"a * b * c = 2 * k * (2 * m) * c + 2 * k * c\" \n    by (auto simp: field_simps)\n  hence \"a * b * c = 2 * (k * (2 * m * c) + k * c)\" \n    by (simp add: distrib_left)\n  thus \"even (a * b * c)\" \n    by auto\nqed", "origin": "even_odd_productV6", "update_count": 0}, "odd_even_product_general": {"skill_name": "odd_even_product_general", "marker": "lemma odd_even_product_general:\n  fixes a b :: nat\n  assumes \"odd a\" \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"b = 2 * k\" using assms(2) by auto\n  obtain m where \"a = 2 * m + 1\" using assms(1) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * m + 1) * (2 * k)\" \n    using `a = 2 * m + 1` `b = 2 * k` by simp\n  then have \"a * b = 2 * m * (2 * k) + 2 * k\" \n    by (simp add: distrib_left)\n  hence \"a * b = 2 * (m * (2 * k) + k)\" \n    by (simp add: distrib_left)\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma odd_even_product_general:\n  fixes a b :: nat\n  assumes \"odd a\" \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"b = 2 * k\" using assms(2) by auto\n  obtain m where \"a = 2 * m + 1\" using assms(1) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * m + 1) * (2 * k)\" \n    using `a = 2 * m + 1` `b = 2 * k` by simp\n  then have \"a * b = 2 * m * (2 * k) + 2 * k\" \n    by (simp add: distrib_left)\n  hence \"a * b = 2 * (m * (2 * k) + k)\" \n    by (simp add: distrib_left)\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "even_odd_productV6", "update_count": 0}, "division_property_extended": {"skill_name": "division_property_extended", "marker": "lemma division_property_extended:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using division_property[OF assms] by auto\n  have \"c / a * a = c\" using division_property[OF assms] by auto\n  then show ?thesis by (auto simp add: assms)\nqed", "description": "-", "full_code": "lemma division_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b / a) * a = b\"\n  using assms by (metis field_simps)\n\nlemma division_property_extended:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using division_property[OF assms] by auto\n  have \"c / a * a = c\" using division_property[OF assms] by auto\n  then show ?thesis by (auto simp add: assms)\nqed", "origin": "nonzero_division_extendedV2", "update_count": 0}, "nonzero_division_extendedV3": {"skill_name": "nonzero_division_extendedV3", "marker": "lemma nonzero_division_extended:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b c. (b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using assms by (metis field_simps)\n  have \"c / a * a = c\" using assms by (metis field_simps)\n  then show ?thesis by (smt (verit) assms divide_eq_eq)\nqed", "description": "-", "full_code": "lemma nonzero_division_extended:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b c. (b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using assms by (metis field_simps)\n  have \"c / a * a = c\" using assms by (metis field_simps)\n  then show ?thesis by (smt (verit) assms divide_eq_eq)\nqed", "origin": "nonzero_division_extendedV2", "update_count": 0}, "nonzero_division_multiple": {"skill_name": "nonzero_division_multiple", "marker": "lemma nonzero_division_multiple:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b. (b / a) * a = b \\<and> (2 * b / a) * a = 2 * b\"\nproof -\n  have \"b / a * a = b\" using nonzero_division_extended[OF assms] by auto\n  have \"2 * b / a * a = 2 * b\" using assms by (metis field_simps)\n  then show ?thesis by (metis \\<open>b / a * a = b\\<close> assms div_by_1 divide_cancel_right divide_divide_eq_left' divide_divide_eq_right divide_divide_times_eq divide_eq_eq divide_self_if eq_divide_eq_1 frac_eq_eq mult.commute mult_cancel_right mult_cancel_right1 mult_delta_left mult_delta_right mult_divide_mult_cancel_left_if nonzero_divide_mult_cancel_right nonzero_mult_div_cancel_left right_inverse_eq times_divide_eq_left times_divide_eq_right times_divide_times_eq zero_neq_numeral)\nqed", "description": "-", "full_code": "lemma nonzero_division_extended:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b c. (b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using assms by (metis field_simps)\n  have \"c / a * a = c\" using assms by (metis field_simps)\n  then show ?thesis by (smt (verit) assms divide_eq_eq)\nqed\n\nlemma nonzero_division_multiple:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b. (b / a) * a = b \\<and> (2 * b / a) * a = 2 * b\"\nproof -\n  have \"b / a * a = b\" using nonzero_division_extended[OF assms] by auto\n  have \"2 * b / a * a = 2 * b\" using assms by (metis field_simps)\n  then show ?thesis by (metis \\<open>b / a * a = b\\<close> assms div_by_1 divide_cancel_right divide_divide_eq_left' divide_divide_eq_right divide_divide_times_eq divide_eq_eq divide_self_if eq_divide_eq_1 frac_eq_eq mult.commute mult_cancel_right mult_cancel_right1 mult_delta_left mult_delta_right mult_divide_mult_cancel_left_if nonzero_divide_mult_cancel_right nonzero_mult_div_cancel_left right_inverse_eq times_divide_eq_left times_divide_eq_right times_divide_times_eq zero_neq_numeral)\nqed", "origin": "nonzero_division_extendedV2", "update_count": 0}, "cancel_div_for_inequalities_combined_extended": {"skill_name": "cancel_div_for_inequalities_combined_extended", "marker": "lemma cancel_div_for_inequalities_combined_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"d > 0\" \"a * x + b < c * x\"\n  shows \"d * (a + (b / x)) < d * c\"\nproof -\n  have \"a * x + b < c * x\" using assms(3) by simp\n  hence \"x * (a + (b / x)) < c * x\" by (smt (z3) add_divide_eq_iff assms(1) mult_imp_div_pos_less mult_imp_le_div_pos nonzero_mult_div_cancel_left)\n  thus ?thesis using assms(2) by (metis assms(1) mult.assoc mult.commute mult_less_cancel_left_pos)\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_combined_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"d > 0\" \"a * x + b < c * x\"\n  shows \"d * (a + (b / x)) < d * c\"\nproof -\n  have \"a * x + b < c * x\" using assms(3) by simp\n  hence \"x * (a + (b / x)) < c * x\" by (smt (z3) add_divide_eq_iff assms(1) mult_imp_div_pos_less mult_imp_le_div_pos nonzero_mult_div_cancel_left)\n  thus ?thesis using assms(2) by (metis assms(1) mult.assoc mult.commute mult_less_cancel_left_pos)\nqed", "origin": "cancel_div_for_inequalities_combined", "update_count": 0}, "cancel_div_for_inequalities_combined_generalized": {"skill_name": "cancel_div_for_inequalities_combined_generalized", "marker": "lemma cancel_div_for_inequalities_combined_generalized:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"a * x + b < c * x\" \"d > 0\" \"e > 0\"\n  shows \"d * (a + (b / x)) < d * c\"\nproof -\n  have \"x * (a + (b / x)) < c * x\" using assms(1) assms(2) by sos\n  hence \"d * x * (a + (b / x)) < d * c * x\" using assms(3) by (simp add: mult_less_cancel_left_pos)\n  thus ?thesis by (smt (verit) assms(1) assms(2) assms(3) cancel_div_for_inequalities_combined_evolved)\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_combined_evolved:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a * x + b < c * x\" \"d > 0\"\n  shows \"d * (a + (b / x)) < d * c\"\nproof -\n  have \"x * (a + (b / x)) < c * x\" using assms(1) assms(2) by sos\n  hence \"d * x * (a + (b / x)) < d * c * x\" using assms(3) by (simp add: mult_less_cancel_left_pos)\n  thus ?thesis using assms(1) by sos\nqed\n\nlemma cancel_div_for_inequalities_combined_generalized:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"a * x + b < c * x\" \"d > 0\" \"e > 0\"\n  shows \"d * (a + (b / x)) < d * c\"\nproof -\n  have \"x * (a + (b / x)) < c * x\" using assms(1) assms(2) by sos\n  hence \"d * x * (a + (b / x)) < d * c * x\" using assms(3) by (simp add: mult_less_cancel_left_pos)\n  thus ?thesis by (smt (verit) assms(1) assms(2) assms(3) cancel_div_for_inequalities_combined_evolved)\nqed", "origin": "cancel_div_for_inequalities_combined", "update_count": 0}, "cancel_div_for_inequalities_combined_evolved": {"skill_name": "cancel_div_for_inequalities_combined_evolved", "marker": "lemma cancel_div_for_inequalities_combined_evolved:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a * x + b < c * x\" \"d > 0\"\n  shows \"d * (a + (b / x)) < d * c\"\nproof -\n  have \"x * (a + (b / x)) < c * x\" using assms(1) assms(2) by sos\n  hence \"d * x * (a + (b / x)) < d * c * x\" using assms(3) by (simp add: mult_less_cancel_left_pos)\n  thus ?thesis using assms(1) by sos\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_combined_evolved:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a * x + b < c * x\" \"d > 0\"\n  shows \"d * (a + (b / x)) < d * c\"\nproof -\n  have \"x * (a + (b / x)) < c * x\" using assms(1) assms(2) by sos\n  hence \"d * x * (a + (b / x)) < d * c * x\" using assms(3) by (simp add: mult_less_cancel_left_pos)\n  thus ?thesis using assms(1) by sos\nqed", "origin": "cancel_div_for_inequalities_combined", "update_count": 0}, "multiplication_by_zero": {"skill_name": "multiplication_by_zero", "marker": "lemma multiplication_by_zero:\n  fixes a :: real\n  shows \"a * 0 = 0\"\nproof -\n  have \"a * 0 = 0\" by (simp add: algebra_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multiplication_by_zero:\n  fixes a :: real\n  shows \"a * 0 = 0\"\nproof -\n  have \"a * 0 = 0\" by (simp add: algebra_simps)\n  then show ?thesis by simp\nqed", "origin": "division_and_multiplication", "update_count": 0}, "rearranging_equation": {"skill_name": "rearranging_equation", "marker": "lemma rearranging_equation:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"c = a + b / x\"\n  shows \"a = c - b / x\"\nproof -\n  have \"c - b / x = a\" using assms by (simp add: assms(2) algebra_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearranging_equation:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"c = a + b / x\"\n  shows \"a = c - b / x\"\nproof -\n  have \"c - b / x = a\" using assms by (simp add: assms(2) algebra_simps)\n  then show ?thesis by simp\nqed", "origin": "division_and_multiplication", "update_count": 0}, "division_and_rearrangement": {"skill_name": "division_and_rearrangement", "marker": "lemma division_and_rearrangement:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"c = a + b / x\"\n  shows \"b = x * (c - a)\"\nproof -\n  have \"c - a = b / x\" using assms by (simp add: assms(2) algebra_simps)\n  then show ?thesis by (metis assms(1) divide_eq_0_iff eq_iff_diff_eq_0 frac_eq_eq less_numeral_extra(3) mult.commute mult_eq_0_iff nonzero_eq_divide_eq)\nqed", "description": "-", "full_code": "lemma division_and_rearrangement:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"c = a + b / x\"\n  shows \"b = x * (c - a)\"\nproof -\n  have \"c - a = b / x\" using assms by (simp add: assms(2) algebra_simps)\n  then show ?thesis by (metis assms(1) divide_eq_0_iff eq_iff_diff_eq_0 frac_eq_eq less_numeral_extra(3) mult.commute mult_eq_0_iff nonzero_eq_divide_eq)\nqed", "origin": "division_and_multiplication", "update_count": 0}, "linear_combination_solve_for_b": {"skill_name": "linear_combination_solve_for_b", "marker": "lemma linear_combination_solve_for_b:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"c = a + b / x\"\n  shows \"b = x * (c - a)\"\nproof -\n  have \"b / x = c - a\" using assms by (simp add: assms(2) algebra_simps)\n  then have \"b = x * (c - a)\" using assms(1) by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma linear_combination_solve_for_b:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"c = a + b / x\"\n  shows \"b = x * (c - a)\"\nproof -\n  have \"b / x = c - a\" using assms by (simp add: assms(2) algebra_simps)\n  then have \"b = x * (c - a)\" using assms(1) by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "origin": "division_and_multiplication", "update_count": 0}, "rearranging_linear_combination": {"skill_name": "rearranging_linear_combination", "marker": "lemma rearranging_linear_combination:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"c = a + b / x\"\n  shows \"a = c - b / x\"\n  using rearranging_equation[of x a b c] by (metis add.commute add_scale_eq_noteq assms(2) cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0)", "description": "-", "full_code": "lemma rearranging_equation:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"c = a + b / x\"\n  shows \"a = c - b / x\"\nproof -\n  have \"a = c - b / x\" using assms by (simp add: assms(2) algebra_simps)\n  then show ?thesis by simp\nqed\n\nlemma rearranging_linear_combination:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"c = a + b / x\"\n  shows \"a = c - b / x\"\n  using rearranging_equation[of x a b c] by (metis add.commute add_scale_eq_noteq assms(2) cancel_ab_semigroup_add_class.diff_right_commute diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0)", "origin": "division_and_multiplication", "update_count": 0}, "cancel_div_for_inequalitiesV3": {"skill_name": "cancel_div_for_inequalitiesV3", "marker": "lemma cancel_div_for_inequalities:\n  fixes a b c :: real\n  assumes \"a > 0\" \"b < c\"\n  shows \"a + b < a + c\"\n  using assms by simp", "description": "-", "full_code": "lemma cancel_div_for_inequalities:\n  fixes a b c :: real\n  assumes \"a > 0\" \"b < c\"\n  shows \"a + b < a + c\"\n  using assms by simp", "origin": "cancel_div_for_inequalities_general", "update_count": 0}, "odd_even_productV2": {"skill_name": "odd_even_productV2", "marker": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  from assms(1) obtain k where \"a = 2 * k\" \n    by auto\n  from assms(2) obtain m where \"b = 2 * m + 1\"\n    by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by auto\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" \n    by (simp add: distrib_left)\n  hence \"a * b = 2 * (k * (2 * m) + k)\" \n    by (simp add: distrib_left)\n  thus \"(a * b) mod 2 = 0\" \n    by auto\nqed", "description": "-", "full_code": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  from assms(1) obtain k where \"a = 2 * k\" \n    by auto\n  from assms(2) obtain m where \"b = 2 * m + 1\"\n    by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by auto\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" \n    by (simp add: distrib_left)\n  hence \"a * b = 2 * (k * (2 * m) + k)\" \n    by (simp add: distrib_left)\n  thus \"(a * b) mod 2 = 0\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "general_even_odd_product": {"skill_name": "general_even_odd_product", "marker": "lemma general_even_odd_product:\n  fixes a b c :: nat\n  assumes \"even a\" \"odd b\" \"c > 0\"\n  shows \"even (a * b * c)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b * c = (2 * k) * (2 * m + 1) * c\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  then have \"a * b * c = 2 * (k * (2 * m * c) + k * c)\" \n    by (auto simp: field_simps)\n  thus \"even (a * b * c)\" \n    by auto\nqed", "description": "-", "full_code": "lemma general_even_odd_product:\n  fixes a b c :: nat\n  assumes \"even a\" \"odd b\" \"c > 0\"\n  shows \"even (a * b * c)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b * c = (2 * k) * (2 * m + 1) * c\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  then have \"a * b * c = 2 * (k * (2 * m * c) + k * c)\" \n    by (auto simp: field_simps)\n  thus \"even (a * b * c)\" \n    by auto\nqed", "origin": "even_odd_product_extended", "update_count": 0}, "division_and_sum": {"skill_name": "division_and_sum", "marker": "lemma division_and_sum:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(a + b) / a = 1 + (b / a)\"\nproof -\n  have \"(a + b) / a = a / a + b / a\" using assms by (simp add: field_simps)\n  then show ?thesis by (metis add_divide_distrib assms comm_monoid_mult_class.mult_1 frac_eq_eq mult.assoc mult_cancel_left2 mult_cancel_right1 nonzero_division nonzero_mult_div_cancel_right zero_neq_one)\nqed", "description": "-", "full_code": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b. (b / a) * a = b\"\n  using assms by (metis field_simps)\n\nlemma division_and_sum:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(a + b) / a = 1 + (b / a)\"\nproof -\n  have \"(a + b) / a = a / a + b / a\" using assms by (simp add: field_simps)\n  then show ?thesis by (metis add_divide_distrib assms comm_monoid_mult_class.mult_1 frac_eq_eq mult.assoc mult_cancel_left2 mult_cancel_right1 nonzero_division nonzero_mult_div_cancel_right zero_neq_one)\nqed", "origin": "division_propertiesV3", "update_count": 0}, "division_by_one": {"skill_name": "division_by_one", "marker": "lemma division_by_one:\n  fixes b :: real\n  shows \"b / 1 = b\"\n  by simp", "description": "-", "full_code": "lemma division_by_one:\n  fixes b :: real\n  shows \"b / 1 = b\"\n  by simp", "origin": "division_propertiesV3", "update_count": 0}, "division_multiplication_properties": {"skill_name": "division_multiplication_properties", "marker": "lemma division_multiplication_properties:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(\\<forall>b. (b / a) * a = b) \\<and> (\\<forall>c. (c / a) * a = c) \\<and> (\\<forall>b c. ((b + c) / a) * a = b + c)\"\nproof -\n  have division_eq: \"\\<forall>x. (x / a) * a = x\" using assms by (metis field_simps)\n  then show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma division_multiplication_properties:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(\\<forall>b. (b / a) * a = b) \\<and> (\\<forall>c. (c / a) * a = c) \\<and> (\\<forall>b c. ((b + c) / a) * a = b + c)\"\nproof -\n  have division_eq: \"\\<forall>x. (x / a) * a = x\" using assms by (metis field_simps)\n  then show ?thesis \n    by auto\nqed", "origin": "division_propertiesV3", "update_count": 0}, "mod_add_power_generalized_with_variables_high_dim": {"skill_name": "mod_add_power_generalized_with_variables_high_dim", "marker": "lemma mod_add_power_generalized_with_variables_high_dim:\n  fixes x y n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \n  shows \"((x + b + y)^c) mod n = ((a + b + y)^c) mod n\"\nproof -\n  have \"((x + b + y)^c) mod n = (((x + y) mod n + b) mod n)^c mod n\"\n    by (metis add.commute group_cancel.add1 group_cancel.add2 mod_add_left_eq power_mod)\n  also have \"... = ((a + b + y) mod n)^c mod n\"\n    using assms(4) by (smt (verit) calculation mod_add_cong mod_add_left_eq power_mod)\n  also have \"... = (a + b + y)^c mod n\"\n    by (metis power_mod)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_generalized_with_variables_high_dim:\n  fixes x y n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \n  shows \"((x + b + y)^c) mod n = ((a + b + y)^c) mod n\"\nproof -\n  have \"((x + b + y)^c) mod n = (((x + y) mod n + b) mod n)^c mod n\"\n    by (metis add.commute group_cancel.add1 group_cancel.add2 mod_add_left_eq power_mod)\n  also have \"... = ((a + b + y) mod n)^c mod n\"\n    using assms(4) by (smt (verit) calculation mod_add_cong mod_add_left_eq power_mod)\n  also have \"... = (a + b + y)^c mod n\"\n    by (metis power_mod)\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power_generalized_with_variables", "update_count": 0}, "cancel_div_with_multiple_variables": {"skill_name": "cancel_div_with_multiple_variables", "marker": "lemma cancel_div_with_multiple_variables:\n  fixes x a b c d e f :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c\" \"d + e / y = f\"\n  shows \"b = x * (c - a) \\<and> e = y * (f - d)\"\nproof -\n  have \"a + b / x = c\" using assms(3) by simp\n  then have \"b / x = c - a\" by simp\n  then have \"b = x * (c - a)\" using assms(1) by (auto simp: field_simps)\n  have \"d + e / y = f\" using assms(4) by simp\n  then have \"e / y = f - d\" by simp\n  then have \"e = y * (f - d)\" using assms(2) by (auto simp: field_simps)\n  thus ?thesis by (metis \\<open>b = x * (c - a)\\<close>)\nqed", "description": "-", "full_code": "lemma cancel_div_with_multiple_variables:\n  fixes x a b c d e f :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c\" \"d + e / y = f\"\n  shows \"b = x * (c - a) \\<and> e = y * (f - d)\"\nproof -\n  have \"a + b / x = c\" using assms(3) by simp\n  then have \"b / x = c - a\" by simp\n  then have \"b = x * (c - a)\" using assms(1) by (auto simp: field_simps)\n  have \"d + e / y = f\" using assms(4) by simp\n  then have \"e / y = f - d\" by simp\n  then have \"e = y * (f - d)\" using assms(2) by (auto simp: field_simps)\n  thus ?thesis by (metis \\<open>b = x * (c - a)\\<close>)\nqed", "origin": "cancel_div_with_variables", "update_count": 0}, "cancel_div_with_multiple_variablesV2": {"skill_name": "cancel_div_with_multiple_variablesV2", "marker": "lemma cancel_div_with_multiple_variables:\n  fixes x a b c d e f :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d = c - a\" \"e + f = b\"\n  shows \"f = d * x - e\"\nproof -\n  have \"a + b / x = c\" using assms(2) by simp\n  then have \"b / x = c - a\" by simp\n  then have \"b = x * (c - a)\" using assms(1) by (auto simp: field_simps)\n  also have \"... = x * d\" using assms(3) by simp\n  also have \"... = e + (d * x - e)\" using assms(4) by simp\n  thus ?thesis by (metis \\<open>b / x = c - a\\<close> add_diff_cancel_left' assms(1) assms(3) assms(4) frac_eq_eq nonzero_divide_eq_eq)\nqed", "description": "-", "full_code": "lemma cancel_div_with_multiple_variables:\n  fixes x a b c d e f :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"d = c - a\" \"e + f = b\"\n  shows \"f = d * x - e\"\nproof -\n  have \"a + b / x = c\" using assms(2) by simp\n  then have \"b / x = c - a\" by simp\n  then have \"b = x * (c - a)\" using assms(1) by (auto simp: field_simps)\n  also have \"... = x * d\" using assms(3) by simp\n  also have \"... = e + (d * x - e)\" using assms(4) by simp\n  thus ?thesis by (metis \\<open>b / x = c - a\\<close> add_diff_cancel_left' assms(1) assms(3) assms(4) frac_eq_eq nonzero_divide_eq_eq)\nqed", "origin": "cancel_div_with_variables", "update_count": 0}, "cancel_div_for_inequalities_combined_extended_v2": {"skill_name": "cancel_div_for_inequalities_combined_extended_v2", "marker": "lemma cancel_div_for_inequalities_combined_extended_v2:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"d > 0\" \"e > 0\" \"a * x + b < c * x\"\n  shows \"d * (a + (b / x)) < d * c + e\"\nproof -\n  have \"a * x + b < c * x\" using assms(4) by simp\n  hence \"x * (a + (b / x)) < c * x\" by (smt (z3) add_divide_eq_iff assms(1) mult_imp_div_pos_less mult_imp_le_div_pos nonzero_mult_div_cancel_left)\n  hence \"d * (a + (b / x)) < d * c\" using assms(2) by (metis assms(1) mult.assoc mult.commute mult_less_cancel_left_pos)\n  thus \"d * (a + (b / x)) < d * c + e\" using assms(3) by auto\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_combined_extended_v2:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"d > 0\" \"e > 0\" \"a * x + b < c * x\"\n  shows \"d * (a + (b / x)) < d * c + e\"\nproof -\n  have \"a * x + b < c * x\" using assms(4) by simp\n  hence \"x * (a + (b / x)) < c * x\" by (smt (z3) add_divide_eq_iff assms(1) mult_imp_div_pos_less mult_imp_le_div_pos nonzero_mult_div_cancel_left)\n  hence \"d * (a + (b / x)) < d * c\" using assms(2) by (metis assms(1) mult.assoc mult.commute mult_less_cancel_left_pos)\n  thus \"d * (a + (b / x)) < d * c + e\" using assms(3) by auto\nqed", "origin": "cancel_div_for_inequalities_combined_extended", "update_count": 0}, "cancel_div_for_inequalities_combined_extended_stronger": {"skill_name": "cancel_div_for_inequalities_combined_extended_stronger", "marker": "lemma cancel_div_for_inequalities_combined_extended_stronger:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"d > 0\" \"e > 0\" \"a * x + b < c * x\"\n  shows \"d * (a + (b / x)) < d * c + e\"\nproof -\n  have \"a * x + b < c * x\" using assms(4) by simp\n  hence \"x * (a + (b / x)) < c * x\" by (smt (verit) assms(1) cancel_div_for_inequalities_combined_extended_generalized mult.commute)\n  thus ?thesis using assms(2) assms(3) by (smt (verit) assms(1) assms(4) cancel_div_for_inequalities_combined_extended_generalized)\nqed", "description": "-", "full_code": "lemma cancel_div_for_inequalities_combined_extended_generalized:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"d > 0\" \"a * x + b < c * x\"\n  shows \"d * (a + (b / x)) < d * c\"\nproof -\n  have \"a * x + b < c * x\" using assms(3) by simp\n  hence \"x * (a + (b / x)) < c * x\" by (smt (z3) add_divide_eq_iff assms(1) mult_imp_div_pos_less mult_imp_le_div_pos nonzero_mult_div_cancel_left)\n  thus ?thesis using assms(2) by (metis assms(1) mult.assoc mult.commute mult_less_cancel_left_pos)\nqed\n\nlemma cancel_div_for_inequalities_combined_extended_stronger:\n  fixes x a b c d e :: real\n  assumes \"x > 0\" \"d > 0\" \"e > 0\" \"a * x + b < c * x\"\n  shows \"d * (a + (b / x)) < d * c + e\"\nproof -\n  have \"a * x + b < c * x\" using assms(4) by simp\n  hence \"x * (a + (b / x)) < c * x\" by (smt (verit) assms(1) cancel_div_for_inequalities_combined_extended_generalized mult.commute)\n  thus ?thesis using assms(2) assms(3) by (smt (verit) assms(1) assms(4) cancel_div_for_inequalities_combined_extended_generalized)\nqed", "origin": "cancel_div_for_inequalities_combined_extended", "update_count": 0}, "odd_even_productV3": {"skill_name": "odd_even_productV3", "marker": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  from assms(1) obtain k where \"a = 2 * k\" \n    by auto\n  from assms(2) obtain m where \"b = 2 * m + 1\" \n    by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\"\n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  have \"a * b = (2 * k) * (2 * m) + (2 * k) * 1\" \n    by (smt (verit) \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> distrib_left)\n  have \"a * b = 2 * (k * (2 * m) + k)\"\n    by (smt (verit) One_nat_def \\<open>a * b = 2 * k * (2 * m) + 2 * k * 1\\<close> \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> assms(1) diff_add_0 diff_mult_distrib2 distrib_left div_mod_decomp div_mult_self1_is_m mult.assoc mult.commute mult.left_commute mult_Suc_right pos2)\n  have \"(a * b) mod 2 = (2 * (k * (2 * m) + k)) mod 2\"\n    by (metis assms(1) assms(2) bits_one_mod_two_eq_one mod_mult_cong mod_mult_self1_is_0 mult.comm_neutral)\n  also have \"... = 0\"\n    by auto\n  finally show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  from assms(1) obtain k where \"a = 2 * k\" \n    by auto\n  from assms(2) obtain m where \"b = 2 * m + 1\" \n    by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\"\n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  have \"a * b = (2 * k) * (2 * m) + (2 * k) * 1\" \n    by (smt (verit) \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> distrib_left)\n  have \"a * b = 2 * (k * (2 * m) + k)\"\n    by (smt (verit) One_nat_def \\<open>a * b = 2 * k * (2 * m) + 2 * k * 1\\<close> \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> assms(1) diff_add_0 diff_mult_distrib2 distrib_left div_mod_decomp div_mult_self1_is_m mult.assoc mult.commute mult.left_commute mult_Suc_right pos2)\n  have \"(a * b) mod 2 = (2 * (k * (2 * m) + k)) mod 2\"\n    by (metis assms(1) assms(2) bits_one_mod_two_eq_one mod_mult_cong mod_mult_self1_is_0 mult.comm_neutral)\n  also have \"... = 0\"\n    by auto\n  finally show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "odd_even_productV4": {"skill_name": "odd_even_productV4", "marker": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  obtain k where \"a = 2 * k\" \n    using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" \n    using assms(2) by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  have \"a * b = 2 * k * (2 * m) + 2 * k\" \n    by (smt (verit) \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> distrib_left mult.comm_neutral)\n  have \"a * b = 2 * (k * (2 * m) + k)\" \n    by (smt (verit) \\<open>a * b = 2 * k * (2 * m) + 2 * k\\<close> \\<open>a = 2 * k\\<close> distrib_left mult.assoc mult.commute mult.left_commute)\n  thus \"(a * b) mod 2 = 0\"\n    by auto\nqed", "description": "-", "full_code": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  obtain k where \"a = 2 * k\" \n    using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" \n    using assms(2) by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  have \"a * b = 2 * k * (2 * m) + 2 * k\" \n    by (smt (verit) \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> distrib_left mult.comm_neutral)\n  have \"a * b = 2 * (k * (2 * m) + k)\" \n    by (smt (verit) \\<open>a * b = 2 * k * (2 * m) + 2 * k\\<close> \\<open>a = 2 * k\\<close> distrib_left mult.assoc mult.commute mult.left_commute)\n  thus \"(a * b) mod 2 = 0\"\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "prime_product_strong": {"skill_name": "prime_product_strong", "marker": "lemma prime_product_strong:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b) \\<and> a \\<noteq> b\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"prime (a * b) \\<longleftrightarrow> (a = 1 \\<and> b > 1) \\<or> (a > 1 \\<and> b = 1)\"\n    using assms by (metis Primes.prime_nat_def mult.right_neutral mult_1 prime_nat_iff prime_product)\n  have \"a \\<noteq> b\" using assms(3) by simp\n  then show ?thesis \n  proof (cases \"a = 1\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b = 1\" using assms(1) assms(3) by (metis \\<open>prime (a * b) = (a = 1 \\<and> 1 < b \\<or> 1 < a \\<and> b = 1)\\<close>)\n    thus ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma prime_product_strong:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b) \\<and> a \\<noteq> b\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"prime (a * b) \\<longleftrightarrow> (a = 1 \\<and> b > 1) \\<or> (a > 1 \\<and> b = 1)\"\n    using assms by (metis Primes.prime_nat_def mult.right_neutral mult_1 prime_nat_iff prime_product)\n  have \"a \\<noteq> b\" using assms(3) by simp\n  then show ?thesis \n  proof (cases \"a = 1\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b = 1\" using assms(1) assms(3) by (metis \\<open>prime (a * b) = (a = 1 \\<and> 1 < b \\<or> 1 < a \\<and> b = 1)\\<close>)\n    thus ?thesis by simp\n  qed\nqed", "origin": "prime_product_general", "update_count": 0}, "prime_product_extended": {"skill_name": "prime_product_extended", "marker": "lemma prime_product_extended:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"prime (a * b * c)\"\n  shows \"a = 1 \\<or> b = 1 \\<or> c = 1\"\nproof -\n  have \"prime (a * b * c) \\<longleftrightarrow> (a = 1 \\<and> b * c > 1) \\<or> (b = 1 \\<and> a * c > 1) \\<or> (c = 1 \\<and> a * b > 1)\"\n    using assms by (metis Primes.prime_nat_def dvd_imp_le dvd_mult_cancel1 dvd_mult_cancel2 mult.commute mult.left_commute mult_1 nat_less_le nat_mult_1_right one_dvd prime_nat_iff prime_product)\n  thus ?thesis \n    by (metis assms(4))\nqed", "description": "-", "full_code": "lemma prime_product_extended:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"prime (a * b * c)\"\n  shows \"a = 1 \\<or> b = 1 \\<or> c = 1\"\nproof -\n  have \"prime (a * b * c) \\<longleftrightarrow> (a = 1 \\<and> b * c > 1) \\<or> (b = 1 \\<and> a * c > 1) \\<or> (c = 1 \\<and> a * b > 1)\"\n    using assms by (metis Primes.prime_nat_def dvd_imp_le dvd_mult_cancel1 dvd_mult_cancel2 mult.commute mult.left_commute mult_1 nat_less_le nat_mult_1_right one_dvd prime_nat_iff prime_product)\n  thus ?thesis \n    by (metis assms(4))\nqed", "origin": "prime_product_general", "update_count": 0}, "cancel_div_general_with_params": {"skill_name": "cancel_div_general_with_params", "marker": "lemma cancel_div_general_with_params:\n  fixes x y a b c :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"p + q / x = r / y\"\n  shows \"p * (x * y) + q * y = r * x\"\nproof -\n  have \"(x * y) * (p + q / x) = r * x\" using assms(3)\n    by (metis assms(2) diff_minus_eq_add divide_cancel_left mult.assoc mult.commute nonzero_divide_eq_eq)\n  then have \"(x * y) * p + (x * y) * (q / x) = r * x\" by (simp add: distrib_left)\n  hence \"y * (x * p) + q * y = r * x\" using assms(1) by (auto simp: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma cancel_div_general:\n  fixes x y a b c :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c / y\"\n  shows \"a * (x * y) + b * y = c * x\"\nproof -\n  have \"(x * y) * (a + b / x) = c * x\" using assms(3)\n    by (metis assms(2) diff_minus_eq_add divide_cancel_left mult.assoc mult.commute nonzero_divide_eq_eq)\n  then have \"(x * y) * a + (x * y) * (b / x) = c * x\" by (simp add: distrib_left)\n  hence \"y * (x * a) + b * y = c * x\" using assms(1) by (auto simp: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed\n\nlemma cancel_div_general_with_params:\n  fixes x y a b c :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"p + q / x = r / y\"\n  shows \"p * (x * y) + q * y = r * x\"\nproof -\n  have \"(x * y) * (p + q / x) = r * x\" using assms(3)\n    by (metis assms(2) diff_minus_eq_add divide_cancel_left mult.assoc mult.commute nonzero_divide_eq_eq)\n  then have \"(x * y) * p + (x * y) * (q / x) = r * x\" by (simp add: distrib_left)\n  hence \"y * (x * p) + q * y = r * x\" using assms(1) by (auto simp: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "cancel_div_general_with_nonzeroV2", "update_count": 0}, "cancel_div_general_with_zero_for_complex_extended": {"skill_name": "cancel_div_general_with_zero_for_complex_extended", "marker": "lemma cancel_div_general_with_zero_for_complex_extended:\n  fixes x a b c :: complex\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c\" \"a + b / y = d\"\n  shows \"a * x + b = c * x \\<and> a * y + b = d * y\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by (metis assms(3) mult.commute)\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  have \"y * (a + b / y) = d * y\" using assms(4) by auto\n  then have \"y * a + y * (b / y) = d * y\" by (simp add: distrib_left)\n  thus ?thesis using assms(1) by (smt (verit) \\<open>x * (a + b / x) = c * x\\<close> \\<open>x * a + x * (b / x) = c * x\\<close> add_cancel_left_right add_divide_eq_iff assms(2) assms(4) divide_cancel_right divide_eq_0_iff eq_divide_imp mult.commute no_zero_divisors nonzero_eq_divide_eq nonzero_mult_divide_mult_cancel_left nonzero_mult_divide_mult_cancel_right2 times_divide_eq_right)\nqed", "description": "-", "full_code": "lemma cancel_div_general_with_zero_for_complex_extended:\n  fixes x a b c :: complex\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c\" \"a + b / y = d\"\n  shows \"a * x + b = c * x \\<and> a * y + b = d * y\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by (metis assms(3) mult.commute)\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  have \"y * (a + b / y) = d * y\" using assms(4) by auto\n  then have \"y * a + y * (b / y) = d * y\" by (simp add: distrib_left)\n  thus ?thesis using assms(1) by (smt (verit) \\<open>x * (a + b / x) = c * x\\<close> \\<open>x * a + x * (b / x) = c * x\\<close> add_cancel_left_right add_divide_eq_iff assms(2) assms(4) divide_cancel_right divide_eq_0_iff eq_divide_imp mult.commute no_zero_divisors nonzero_eq_divide_eq nonzero_mult_divide_mult_cancel_left nonzero_mult_divide_mult_cancel_right2 times_divide_eq_right)\nqed", "origin": "cancel_div_general_with_zero_for_complex", "update_count": 0}, "nonzero_division_generalized": {"skill_name": "nonzero_division_generalized", "marker": "lemma nonzero_division_generalized:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>c. (b / a) * a = b\"\nproof -\n  have \"(b / a) * a = b\" using nonzero_division[OF assms] by auto\n  then show ?thesis by (metis)\nqed", "description": "-", "full_code": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b. (b / a) * a = b\"\n  using assms by (metis field_simps)\n\nlemma nonzero_division_generalized:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>c. (b / a) * a = b\"\nproof -\n  have \"(b / a) * a = b\" using nonzero_division[OF assms] by auto\n  then show ?thesis by (metis)\nqed", "origin": "nonzero_division_extendedV2", "update_count": 0}, "nonzero_division_multipleV2": {"skill_name": "nonzero_division_multipleV2", "marker": "lemma nonzero_division_multiple:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b c. (b / a) * a = b \\<and> (c / a) * a = c\"\n  using nonzero_division_general[OF assms] by auto", "description": "-", "full_code": "lemma nonzero_division_general:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using assms by (metis field_simps)\n  have \"c / a * a = c\" using assms by (metis field_simps)\n  then show ?thesis by (metis \\<open>b / a * a = b\\<close>)\nqed\n\nlemma nonzero_division_multiple:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<forall>b c. (b / a) * a = b \\<and> (c / a) * a = c\"\n  using nonzero_division_general[OF assms] by auto", "origin": "nonzero_division_extendedV2", "update_count": 0}, "nonzero_division_general": {"skill_name": "nonzero_division_general", "marker": "lemma nonzero_division_general:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using assms by (metis field_simps)\n  have \"c / a * a = c\" using assms by (metis field_simps)\n  then show ?thesis by (metis \\<open>b / a * a = b\\<close>)\nqed", "description": "-", "full_code": "lemma nonzero_division_general:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b / a) * a = b \\<and> (c / a) * a = c\"\nproof -\n  have \"b / a * a = b\" using assms by (metis field_simps)\n  have \"c / a * a = c\" using assms by (metis field_simps)\n  then show ?thesis by (metis \\<open>b / a * a = b\\<close>)\nqed", "origin": "nonzero_division_extendedV2", "update_count": 0}, "case_analysis_on_n": {"skill_name": "case_analysis_on_n", "marker": "lemma case_analysis_on_n:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"n = 1 \\<or> n = 2 \\<or> n = 3 \\<or> n > 3\"\nproof -\n  have \"n = 1 \\<or> n = 2 \\<or> n = 3 \\<or> n > 3\" \n  proof (cases \"n\")\n    case 0\n    then show ?thesis using assms by simp\n  next\n    case (Suc m)\n    then show ?thesis \n    proof (cases \"m\")\n      case 0\n      then show ?thesis by (metis Ex_less_Suc Suc_1 Suc_lessD assms eval_nat_numeral(3) less_Suc_eq less_trans_Suc nat_less_induct nat_neq_iff not_less_zero numeral_1_eq_Suc_0 numeral_eq_one_iff zero_induct zero_less_iff_neq_zero)\n    next\n      case (Suc k)\n      then show ?thesis by (metis Ex_less_Suc Suc_1 Suc_lessD assms eval_nat_numeral(3) less_Suc_eq less_trans_Suc less_zeroE nat_less_induct nat_neq_iff numeral_1_eq_Suc_0 one_eq_numeral_iff zero_induct zero_less_iff_neq_zero)\n    qed\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma case_analysis_on_n:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"n = 1 \\<or> n = 2 \\<or> n = 3 \\<or> n > 3\"\nproof -\n  have \"n = 1 \\<or> n = 2 \\<or> n = 3 \\<or> n > 3\" \n  proof (cases \"n\")\n    case 0\n    then show ?thesis using assms by simp\n  next\n    case (Suc m)\n    then show ?thesis \n    proof (cases \"m\")\n      case 0\n      then show ?thesis by (metis Ex_less_Suc Suc_1 Suc_lessD assms eval_nat_numeral(3) less_Suc_eq less_trans_Suc nat_less_induct nat_neq_iff not_less_zero numeral_1_eq_Suc_0 numeral_eq_one_iff zero_induct zero_less_iff_neq_zero)\n    next\n      case (Suc k)\n      then show ?thesis by (metis Ex_less_Suc Suc_1 Suc_lessD assms eval_nat_numeral(3) less_Suc_eq less_trans_Suc less_zeroE nat_less_induct nat_neq_iff numeral_1_eq_Suc_0 one_eq_numeral_iff zero_induct zero_less_iff_neq_zero)\n    qed\n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "nonzero_division_generalizedV2": {"skill_name": "nonzero_division_generalizedV2", "marker": "lemma nonzero_division_generalized:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\" and \"c \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(b / a) * a = b \\<and> (c / a) * a = c \\<and> (d / a) * a = d\"\nproof -\n  have \"b / a * a = b\" using assms by (metis field_simps)\n  have \"c / a * a = c\" using assms by (metis field_simps)\n  have \"d / a * a = d\" using assms by (metis field_simps)\n  then show ?thesis by (metis \\<open>b / a * a = b\\<close> \\<open>c / a * a = c\\<close>)\nqed", "description": "-", "full_code": "lemma nonzero_division_generalized:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\" and \"c \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(b / a) * a = b \\<and> (c / a) * a = c \\<and> (d / a) * a = d\"\nproof -\n  have \"b / a * a = b\" using assms by (metis field_simps)\n  have \"c / a * a = c\" using assms by (metis field_simps)\n  have \"d / a * a = d\" using assms by (metis field_simps)\n  then show ?thesis by (metis \\<open>b / a * a = b\\<close> \\<open>c / a * a = c\\<close>)\nqed", "origin": "nonzero_division_general", "update_count": 0}, "multiplication_lemma": {"skill_name": "multiplication_lemma", "marker": "lemma multiplication_lemma:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (b / a) = b\"\n  using nonzero_division_generalized assms by simp", "description": "-", "full_code": "lemma nonzero_division_generalized:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b / a) * a = b\"\n  using assms by (metis field_simps)\n\nlemma multiplication_lemma:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (b / a) = b\"\n  using nonzero_division_generalized assms by simp", "origin": "a_times_vera_extendedV2", "update_count": 0}, "division_propertiesV4": {"skill_name": "division_propertiesV4", "marker": "lemma division_properties:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = (1 / a) * b\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma division_properties:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = (1 / a) * b\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "a_times_vera_extendedV2", "update_count": 0}, "multiplication_property": {"skill_name": "multiplication_property", "marker": "lemma multiplication_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (b / a) = b\"\n  using assms division_property by simp", "description": "-", "full_code": "lemma division_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b = (b / a) * a\"\n  using assms by (metis field_simps)\n\nlemma multiplication_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (b / a) = b\"\n  using assms division_property by simp", "origin": "a_times_vera_extendedV2", "update_count": 0}, "integer_solution": {"skill_name": "integer_solution", "marker": "lemma integer_solution:\n  fixes a b :: nat\n  assumes \"a * b = 2\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms by simp\n  show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then have \"2 = 0\" using `a * b = 2` by auto\n    thus ?thesis by (metis zero_neq_numeral)\n  next\n    case False\n    then have \"a > 0\" by simp\n    have \"b > 0\" using `a * b = 2` by (metis mult_is_0 zero_less_iff_neq_zero zero_neq_numeral)\n    show ?thesis\n    proof (cases \"a = 1\")\n      case True\n      then have \"b = 2\" using `a * b = 2` by simp\n      thus ?thesis by (simp add: True)\n    next\n      case False\n      then have \"a > 1\" by (metis `a > 0` less_numeral_extra(3) less_one linorder_neq_iff)\n      have \"b < 2\" using `a * b = 2` by (metis One_nat_def \\<open>0 < b\\<close> \\<open>1 < a\\<close> n_less_m_mult_n)\n      have \"b = 1\" using `b > 0` `b < 2` by auto\n      then show ?thesis by (metis Suc_1 assms nat_mult_1_right)\n    qed\n  qed\nqed", "description": "-", "full_code": "lemma integer_solution:\n  fixes a b :: nat\n  assumes \"a * b = 2\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms by simp\n  show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then have \"2 = 0\" using `a * b = 2` by auto\n    thus ?thesis by (metis zero_neq_numeral)\n  next\n    case False\n    then have \"a > 0\" by simp\n    have \"b > 0\" using `a * b = 2` by (metis mult_is_0 zero_less_iff_neq_zero zero_neq_numeral)\n    show ?thesis\n    proof (cases \"a = 1\")\n      case True\n      then have \"b = 2\" using `a * b = 2` by simp\n      thus ?thesis by (simp add: True)\n    next\n      case False\n      then have \"a > 1\" by (metis `a > 0` less_numeral_extra(3) less_one linorder_neq_iff)\n      have \"b < 2\" using `a * b = 2` by (metis One_nat_def \\<open>0 < b\\<close> \\<open>1 < a\\<close> n_less_m_mult_n)\n      have \"b = 1\" using `b > 0` `b < 2` by auto\n      then show ?thesis by (metis Suc_1 assms nat_mult_1_right)\n    qed\n  qed\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_general_with_zero_for_complex_extendedV2": {"skill_name": "cancel_div_general_with_zero_for_complex_extendedV2", "marker": "lemma cancel_div_general_with_zero_for_complex_extended:\n  fixes x y a b c d :: complex\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c\" \"a + b / y = d\"\n  shows \"a * x + b = c * x \\<and> a * y + b = d * y\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(3) by (metis assms(2) mult.commute)\n  then have \"x * a + b = c * x\" by (metis add.commute add_0_iff add_cancel_left_right add_cancel_right_left add_divide_eq_if_simps(2) add_right_imp_eq add_scale_eq_noteq assms(1) assms(3) comm_monoid_add_class.add_0 crossproduct_eq divide_cancel_left divide_cancel_right divide_divide_eq_left divide_divide_eq_right divide_divide_times_eq divide_eq_0_iff eq_divide_eq frac_eq_eq mult.commute mult.left_commute mult_cancel_left mult_delta_left mult_delta_right mult_left_cancel mult_right_cancel times_divide_eq_left)\n  have \"y * (a + b / y) = d * y\" using assms(4) by auto\n  then have \"y * a + b = d * y\" by (smt (verit) add_divide_eq_iff assms(2) assms(4) mult.commute nonzero_eq_divide_eq)\n  thus ?thesis using assms(1) by (smt (verit) \\<open>x * (a + b / x) = c * x\\<close> \\<open>x * a + b = c * x\\<close> add_cancel_left_right add_divide_eq_iff assms(2) assms(4) divide_cancel_right divide_eq_0_iff eq_divide_imp mult.commute no_zero_divisors nonzero_eq_divide_eq nonzero_mult_divide_mult_cancel_left nonzero_mult_divide_mult_cancel_right2 times_divide_eq_right)\nqed", "description": "-", "full_code": "lemma cancel_div_general_with_zero_for_complex_extended:\n  fixes x y a b c d :: complex\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c\" \"a + b / y = d\"\n  shows \"a * x + b = c * x \\<and> a * y + b = d * y\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(3) by (metis assms(2) mult.commute)\n  then have \"x * a + b = c * x\" by (metis add.commute add_0_iff add_cancel_left_right add_cancel_right_left add_divide_eq_if_simps(2) add_right_imp_eq add_scale_eq_noteq assms(1) assms(3) comm_monoid_add_class.add_0 crossproduct_eq divide_cancel_left divide_cancel_right divide_divide_eq_left divide_divide_eq_right divide_divide_times_eq divide_eq_0_iff eq_divide_eq frac_eq_eq mult.commute mult.left_commute mult_cancel_left mult_delta_left mult_delta_right mult_left_cancel mult_right_cancel times_divide_eq_left)\n  have \"y * (a + b / y) = d * y\" using assms(4) by auto\n  then have \"y * a + b = d * y\" by (smt (verit) add_divide_eq_iff assms(2) assms(4) mult.commute nonzero_eq_divide_eq)\n  thus ?thesis using assms(1) by (smt (verit) \\<open>x * (a + b / x) = c * x\\<close> \\<open>x * a + b = c * x\\<close> add_cancel_left_right add_divide_eq_iff assms(2) assms(4) divide_cancel_right divide_eq_0_iff eq_divide_imp mult.commute no_zero_divisors nonzero_eq_divide_eq nonzero_mult_divide_mult_cancel_left nonzero_mult_divide_mult_cancel_right2 times_divide_eq_right)\nqed", "origin": "cancel_div_general_with_zero_for_complex_extended", "update_count": 0}, "cancel_div_general_with_nonzeroV3": {"skill_name": "cancel_div_general_with_nonzeroV3", "marker": "lemma cancel_div_general_with_nonzero:\n  fixes x y a b c d :: complex\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c\" \"a + b / y = d\"\n  shows \"a * x + b = c * x \\<and> a * y + b = d * y\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(3) by (metis assms(1) mult.commute)\n  then have \"x * a + b = c * x\" by (metis add.commute add_0_iff add_cancel_left_right add_cancel_right_left add_divide_eq_if_simps(2) add_right_imp_eq add_scale_eq_noteq assms(1) assms(3) comm_monoid_add_class.add_0 crossproduct_eq divide_cancel_left divide_cancel_right divide_divide_eq_left divide_divide_eq_right divide_divide_times_eq divide_eq_0_iff eq_divide_eq frac_eq_eq mult.commute mult.left_commute mult_cancel_left mult_delta_left mult_delta_right mult_left_cancel mult_right_cancel times_divide_eq_left)\n  have \"y * (a + b / y) = d * y\" using assms(4) by (metis assms(2) mult.commute)\n  then have \"y * a + b = d * y\" by (smt (verit) add_divide_eq_iff assms(2) assms(4) mult.commute nonzero_eq_divide_eq)\n  thus ?thesis using assms(1) by (metis \\<open>x * a + b = c * x\\<close> add.comm_neutral add.commute add.left_commute add_cancel_left_left add_divide_distrib add_num_frac assms(2) frac_eq_eq mult.commute nonzero_divide_eq_eq nonzero_mult_div_cancel_left)\nqed", "description": "-", "full_code": "lemma cancel_div_general_with_nonzero:\n  fixes x y a b c d :: complex\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"a + b / x = c\" \"a + b / y = d\"\n  shows \"a * x + b = c * x \\<and> a * y + b = d * y\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(3) by (metis assms(1) mult.commute)\n  then have \"x * a + b = c * x\" by (metis add.commute add_0_iff add_cancel_left_right add_cancel_right_left add_divide_eq_if_simps(2) add_right_imp_eq add_scale_eq_noteq assms(1) assms(3) comm_monoid_add_class.add_0 crossproduct_eq divide_cancel_left divide_cancel_right divide_divide_eq_left divide_divide_eq_right divide_divide_times_eq divide_eq_0_iff eq_divide_eq frac_eq_eq mult.commute mult.left_commute mult_cancel_left mult_delta_left mult_delta_right mult_left_cancel mult_right_cancel times_divide_eq_left)\n  have \"y * (a + b / y) = d * y\" using assms(4) by (metis assms(2) mult.commute)\n  then have \"y * a + b = d * y\" by (smt (verit) add_divide_eq_iff assms(2) assms(4) mult.commute nonzero_eq_divide_eq)\n  thus ?thesis using assms(1) by (metis \\<open>x * a + b = c * x\\<close> add.comm_neutral add.commute add.left_commute add_cancel_left_left add_divide_distrib add_num_frac assms(2) frac_eq_eq mult.commute nonzero_divide_eq_eq nonzero_mult_div_cancel_left)\nqed", "origin": "cancel_div_general_with_zero_for_complex_extended", "update_count": 0}}
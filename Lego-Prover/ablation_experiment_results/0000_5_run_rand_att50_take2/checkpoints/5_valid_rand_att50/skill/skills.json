{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "multi_distrib_cubic": {"skill_name": "multi_distrib_cubic", "marker": "lemma multi_distrib_cubic:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d + e + f) = a * c + a * d + a * e + a * f + b * c + b * d + b * e + b * f\"\nproof -\n  have \"(a + b) * (c + d + e + f) = (a + b) * ((c + d) + (e + f))\" by simp\n  also have \"... = (a + b) * (c + d) + (a + b) * (e + f)\" by (simp add: distrib_left)\n  also have \"... = (a * c + a * d + b * c + b * d) + (a * e + a * f + b * e + b * f)\" by (auto simp: field_simps)\n  thus ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_cubic:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d + e + f) = a * c + a * d + a * e + a * f + b * c + b * d + b * e + b * f\"\nproof -\n  have \"(a + b) * (c + d + e + f) = (a + b) * ((c + d) + (e + f))\" by simp\n  also have \"... = (a + b) * (c + d) + (a + b) * (e + f)\" by (simp add: distrib_left)\n  also have \"... = (a * c + a * d + b * c + b * d) + (a * e + a * f + b * e + b * f)\" by (auto simp: field_simps)\n  thus ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib_complex_general": {"skill_name": "multi_distrib_complex_general", "marker": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + b + e + f) * (c + d)\"\nproof -\n  have \"((a + b) + (e + f)) * (c + d) = (a + b) * (c + d) + (e + f) * (c + d)\"\n    by (auto simp: field_simps)\n  thus ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) + (e + f) * (c + d) = (a + b + e + f) * (c + d)\"\nproof -\n  have \"((a + b) + (e + f)) * (c + d) = (a + b) * (c + d) + (e + f) * (c + d)\"\n    by (auto simp: field_simps)\n  thus ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib_complex_extended": {"skill_name": "multi_distrib_complex_extended", "marker": "lemma multi_distrib_complex_extended:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d + e + f) = a * c + a * d + a * e + a * f + b * c + b * d + b * e + b * f\"\nproof -\n  have \"(a + b) * (c + (d + (e + f))) = (a + b) * (c + d + e + f)\"\n    by simp\n  also have \"... = (a + b) * c + (a + b) * (d + e + f)\" by (simp add: distrib_left)\n  also have \"... = (a * c + b * c) + (a * (d + e + f) + b * (d + e + f))\" by (auto simp: field_simps)\n  also have \"... = a * c + b * c + (a * d + a * e + a * f + b * d + b * e + b * f)\"\n    by (metis (no_types, lifting) add.assoc add.left_neutral distrib_left)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_extended:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d + e + f) = a * c + a * d + a * e + a * f + b * c + b * d + b * e + b * f\"\nproof -\n  have \"(a + b) * (c + (d + (e + f))) = (a + b) * (c + d + e + f)\"\n    by simp\n  also have \"... = (a + b) * c + (a + b) * (d + e + f)\" by (simp add: distrib_left)\n  also have \"... = (a * c + b * c) + (a * (d + e + f) + b * (d + e + f))\" by (auto simp: field_simps)\n  also have \"... = a * c + b * c + (a * d + a * e + a * f + b * d + b * e + b * f)\"\n    by (metis (no_types, lifting) add.assoc add.left_neutral distrib_left)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "nonzero_division": {"skill_name": "nonzero_division", "marker": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<exists>x. a * x = 1\"\nproof -\n  let ?x = \"1 / a\"\n  have \"a * ?x = 1\" by (simp add: assms)\n  thus ?thesis by blast\nqed", "description": "-", "full_code": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<exists>x. a * x = 1\"\nproof -\n  let ?x = \"1 / a\"\n  have \"a * ?x = 1\" by (simp add: assms)\n  thus ?thesis by blast\nqed", "origin": "a_times_vera", "update_count": 0}, "substitution_in_equation": {"skill_name": "substitution_in_equation", "marker": "lemma substitution_in_equation:\n  fixes x e a b :: complex\n  assumes \"x + e = a\" and \"e = a - x\"\n  shows \"2 * x + e = 2 * x + (a - x)\"\nproof -\n  have \"e = a - x\" using assms(2) by auto\n  then have \"2 * x + e = 2 * x + (a - x)\" by simp\n  thus ?thesis by (simp add: assms(1))\nqed", "description": "-", "full_code": "lemma substitution_in_equation:\n  fixes x e a b :: complex\n  assumes \"x + e = a\" and \"e = a - x\"\n  shows \"2 * x + e = 2 * x + (a - x)\"\nproof -\n  have \"e = a - x\" using assms(2) by auto\n  then have \"2 * x + e = 2 * x + (a - x)\" by simp\n  thus ?thesis by (simp add: assms(1))\nqed", "origin": "do_request", "update_count": 0}, "substitution_in_equationV2": {"skill_name": "substitution_in_equationV2", "marker": "lemma substitution_in_equation:\n  fixes x e a b :: complex\n  assumes \"x + e = a\" and \"e = a - x\"\n  shows \"2 * x + e = 2 * x + (a - x)\"\nproof -\n  have \"e = a - x\" using assms(2) by auto\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma substitution_in_equation:\n  fixes x e a b :: complex\n  assumes \"x + e = a\" and \"e = a - x\"\n  shows \"2 * x + e = 2 * x + (a - x)\"\nproof -\n  have \"e = a - x\" using assms(2) by auto\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "square_root_equivalence": {"skill_name": "square_root_equivalence", "marker": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = sqrt b * sqrt b\"\n    using assms(3) by (simp add: power2_eq_square)\n  then show ?thesis\n    using assms(1) assms(2) by auto\nqed", "description": "-", "full_code": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = sqrt b * sqrt b\"\n    using assms(3) by (simp add: power2_eq_square)\n  then show ?thesis\n    using assms(1) assms(2) by auto\nqed", "origin": "do_request", "update_count": 0}, "square_root_equivalenceV2": {"skill_name": "square_root_equivalenceV2", "marker": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms(1) by auto\n  have \"sqrt b ^ 2 = b\" using assms(2) by auto\n  from assms(3) have \"sqrt a ^ 2 = sqrt b ^ 2\" by simp\n  then show ?thesis using `sqrt a ^ 2 = a` and `sqrt b ^ 2 = b` by auto\nqed", "description": "-", "full_code": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms(1) by auto\n  have \"sqrt b ^ 2 = b\" using assms(2) by auto\n  from assms(3) have \"sqrt a ^ 2 = sqrt b ^ 2\" by simp\n  then show ?thesis using `sqrt a ^ 2 = a` and `sqrt b ^ 2 = b` by auto\nqed", "origin": "do_request", "update_count": 0}, "square_root_equivalenceV3": {"skill_name": "square_root_equivalenceV3", "marker": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = sqrt b * sqrt b\"\n    using assms(3) by (simp add: power2_eq_square)\n  then have \"a = b\"\n    using assms(1) assms(2) by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = sqrt b * sqrt b\"\n    using assms(3) by (simp add: power2_eq_square)\n  then have \"a = b\"\n    using assms(1) assms(2) by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_root_equivalenceV4": {"skill_name": "square_root_equivalenceV4", "marker": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms(1) by (simp add: sqrt_def)\n  then have \"sqrt b ^ 2 = b\" using assms(2) by (simp add: sqrt_def)\n  then have \"sqrt a ^ 2 = sqrt b ^ 2\" using assms(3) by (simp add: power2_eq_square)\n  thus ?thesis using assms(1) assms(2) by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms(1) by (simp add: sqrt_def)\n  then have \"sqrt b ^ 2 = b\" using assms(2) by (simp add: sqrt_def)\n  then have \"sqrt a ^ 2 = sqrt b ^ 2\" using assms(3) by (simp add: power2_eq_square)\n  thus ?thesis using assms(1) assms(2) by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "square_root_equivalenceV5": {"skill_name": "square_root_equivalenceV5", "marker": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a = sqrt b\" using assms(3) by auto\n  then have \"sqrt a ^ 2 = sqrt b ^ 2\" by (simp add: power2_eq_square)\n  then show ?thesis using assms(1) assms(2) by auto\nqed", "description": "-", "full_code": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a = sqrt b\" using assms(3) by auto\n  then have \"sqrt a ^ 2 = sqrt b ^ 2\" by (simp add: power2_eq_square)\n  then show ?thesis using assms(1) assms(2) by auto\nqed", "origin": "do_request", "update_count": 0}, "square_root_equivalenceV6": {"skill_name": "square_root_equivalenceV6", "marker": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = sqrt b * sqrt b\" \n    using assms(3) by auto\n  then have \"a = b\" \n    by (metis assms(3) real_sqrt_eq_iff)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = sqrt b * sqrt b\" \n    using assms(3) by auto\n  then have \"a = b\" \n    by (metis assms(3) real_sqrt_eq_iff)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e=11 \\<and> x= (-4)\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e=11 \\<and> x= (-4)\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "data/full_data/debug/valid_rand/algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4.json_v0", "update_count": -1}, "square_root_product_equivalence": {"skill_name": "square_root_product_equivalence", "marker": "lemma square_root_product_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a * b) = sqrt a * sqrt b\"\nproof -\n  have \"sqrt (a * b) ^ 2 = a * b\" using assms(1) assms(2) by auto\n  also have \"... = (sqrt a * sqrt b) ^ 2\" using assms(1) assms(2) by (auto simp: field_simps)\n  finally show ?thesis by (metis real_sqrt_mult)\nqed", "description": "-", "full_code": "lemma square_root_product_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a * b) = sqrt a * sqrt b\"\nproof -\n  have \"sqrt (a * b) ^ 2 = a * b\" using assms(1) assms(2) by auto\n  also have \"... = (sqrt a * sqrt b) ^ 2\" using assms(1) assms(2) by (auto simp: field_simps)\n  finally show ?thesis by (metis real_sqrt_mult)\nqed", "origin": "square_root_equivalenceV2", "update_count": 0}, "amc12b_2003_p9": {"skill_name": "amc12b_2003_p9", "marker": "theorem amc12b_2003_p9:\n  fixes a b ::real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \" f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  have \"a = 3\" by (smt (verit) \\<open>4 * a = 12\\<close>)\n  have \"f 12 - f 2 = (a * 12 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 12 - f 2 = 12 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"f 12 - f 2 = 10 * a\" by (smt (verit) \\<open>f 12 - f 2 = 12 * a - 2 * a\\<close>)\n  then have \"f 12 - f 2 = 10 * 3\" using `a = 3` by simp\n  show ?thesis by (smt (verit) \\<open>f 12 - f 2 = 10 * 3\\<close>)\nqed", "description": "", "full_code": "theorem amc12b_2003_p9:\n  fixes a b ::real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \" f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  have \"a = 3\" by (smt (verit) \\<open>4 * a = 12\\<close>)\n  have \"f 12 - f 2 = (a * 12 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 12 - f 2 = 12 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"f 12 - f 2 = 10 * a\" by (smt (verit) \\<open>f 12 - f 2 = 12 * a - 2 * a\\<close>)\n  then have \"f 12 - f 2 = 10 * 3\" using `a = 3` by simp\n  show ?thesis by (smt (verit) \\<open>f 12 - f 2 = 10 * 3\\<close>)\nqed", "origin": "data/full_data/debug/valid_rand/amc12b_2003_p9.json_v0", "update_count": -1}, "linear_equations": {"skill_name": "linear_equations", "marker": "lemma linear_equations:\n  fixes x e :: complex\n  assumes h0: \"x + e = a\"\n    and h1: \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  then show ?thesis using e_eq by auto\nqed", "description": "-", "full_code": "lemma linear_equations:\n  fixes x e :: complex\n  assumes h0: \"x + e = a\"\n    and h1: \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  then show ?thesis using e_eq by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "amc12b_2003_p9_algebraic": {"skill_name": "amc12b_2003_p9_algebraic", "marker": "theorem amc12b_2003_p9_algebraic:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = (6 * a - 2 * a)\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  hence \"4 * a = 12\" using `f 6 - f 2 = 12` by auto\n  hence \"a = 3\" by auto\n  have \"f 12 - f 2 = (a * 12 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 12 - f 2 = (12 * a - 2 * a)\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  hence \"f 12 - f 2 = 10 * a\" by (simp add: algebra_simps)\n  thus ?thesis using `a = 3` by simp\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9_algebraic:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = (6 * a - 2 * a)\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  hence \"4 * a = 12\" using `f 6 - f 2 = 12` by auto\n  hence \"a = 3\" by auto\n  have \"f 12 - f 2 = (a * 12 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 12 - f 2 = (12 * a - 2 * a)\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  hence \"f 12 - f 2 = 10 * a\" by (simp add: algebra_simps)\n  thus ?thesis using `a = 3` by simp\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "substitution_in_equationV3": {"skill_name": "substitution_in_equationV3", "marker": "lemma substitution_in_equation:\n  fixes x e a b :: complex\n  assumes \"x + e = a\" and \"e = a - x\"\n  shows \"2 * x + e = 2 * x + (a - x)\"\nproof -\n  have \"e = a - x\" using assms(2) by simp\n  then show \"2 * x + e = 2 * x + (a - x)\"\n    by simp\nqed", "description": "-", "full_code": "lemma substitution_in_equation:\n  fixes x e a b :: complex\n  assumes \"x + e = a\" and \"e = a - x\"\n  shows \"2 * x + e = 2 * x + (a - x)\"\nproof -\n  have \"e = a - x\" using assms(2) by simp\n  then show \"2 * x + e = 2 * x + (a - x)\"\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109": {"skill_name": "mathd_algebra_109", "marker": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a+2*b=12\"\n    and h1 : \"a=4\"\n  shows \"b=0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "", "full_code": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a+2*b=12\"\n    and h1 : \"a=4\"\n  shows \"b=0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "data/full_data/debug/valid_rand/mathd_algebra_109.json_v0", "update_count": -1}, "multi_distrib_complex_general_n": {"skill_name": "multi_distrib_complex_general_n", "marker": "lemma multi_distrib_complex_general_n:\n  fixes a b c d e f :: \"complex\"\n  shows \"(\\<Sum>i\\<in>A. (a + b) * (c + d)) + (\\<Sum>i\\<in>B. (e + f) * (c + d)) = ((\\<Sum>i\\<in>A. a + b) + (\\<Sum>i\\<in>B. e + f)) * (c + d)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. (a + b) * (c + d)) = (\\<Sum>i\\<in>A. a + b) * (c + d)\" by (simp add: sum_distrib_left)\n  also have \"(\\<Sum>i\\<in>B. (e + f) * (c + d)) = (\\<Sum>i\\<in>B. e + f) * (c + d)\" by (simp add: sum_distrib_left)\n  then have \"(\\<Sum>i\\<in>A. (a + b) * (c + d)) + (\\<Sum>i\\<in>B. (e + f) * (c + d)) = ((\\<Sum>i\\<in>A. a + b) + (\\<Sum>i\\<in>B. e + f)) * (c + d)\"\n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_general_n:\n  fixes a b c d e f :: \"complex\"\n  shows \"(\\<Sum>i\\<in>A. (a + b) * (c + d)) + (\\<Sum>i\\<in>B. (e + f) * (c + d)) = ((\\<Sum>i\\<in>A. a + b) + (\\<Sum>i\\<in>B. e + f)) * (c + d)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. (a + b) * (c + d)) = (\\<Sum>i\\<in>A. a + b) * (c + d)\" by (simp add: sum_distrib_left)\n  also have \"(\\<Sum>i\\<in>B. (e + f) * (c + d)) = (\\<Sum>i\\<in>B. e + f) * (c + d)\" by (simp add: sum_distrib_left)\n  then have \"(\\<Sum>i\\<in>A. (a + b) * (c + d)) + (\\<Sum>i\\<in>B. (e + f) * (c + d)) = ((\\<Sum>i\\<in>A. a + b) + (\\<Sum>i\\<in>B. e + f)) * (c + d)\"\n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "multi_distrib_complex_general", "update_count": 0}, "common_denominator": {"skill_name": "common_denominator", "marker": "lemma common_denominator:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - c * b) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / b - c / d = (a * d - c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma common_denominator:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - c * b) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / b - c / d = (a * d - c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "expand_expression": {"skill_name": "expand_expression", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  then have \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 - 2 * (x * y) + 1 + x^2 + 2 * (x * y) + y^2\"\n    by (simp add: algebra_simps)\n  also have \"... = x^2 * y^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have lhs: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  then have \"((x * y) - 1)^2 + (x + y)^2 = x^2 * y^2 - 2 * (x * y) + 1 + x^2 + 2 * (x * y) + y^2\"\n    by (simp add: algebra_simps)\n  also have \"... = x^2 * y^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "expand_expressionV2": {"skill_name": "expand_expressionV2", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  moreover have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  ultimately have \n    \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  then show ?thesis\n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  moreover have \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\n    by sos\n  ultimately have \n    \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  then show ?thesis\n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "linear_function_difference": {"skill_name": "linear_function_difference", "marker": "theorem linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  have \"f x - f y = (a * x + b) - (a * y + b)\" using assms by simp\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "theorem linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  have \"f x - f y = (a * x + b) - (a * y + b)\" using assms by simp\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "non_negative_squares": {"skill_name": "non_negative_squares", "marker": "lemma non_negative_squares:\n  fixes a b c :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\" and \"0 \\<le> c^2\" \nproof -\n  show \"0 \\<le> a^2\" by (simp add: power2_eq_square)\n  show \"0 \\<le> b^2\" by (simp add: power2_eq_square)\n  show \"0 \\<le> c^2\" by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b c :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\" and \"0 \\<le> c^2\" \nproof -\n  show \"0 \\<le> a^2\" by (simp add: power2_eq_square)\n  show \"0 \\<le> b^2\" by (simp add: power2_eq_square)\n  show \"0 \\<le> c^2\" by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "non_negative_squaresV2": {"skill_name": "non_negative_squaresV2", "marker": "lemma non_negative_squares:\n  fixes a b c :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\" and \"0 \\<le> c^2\" \nproof -\n  have \"0 \\<le> a^2\" by (simp add: power2_eq_square)\n  have \"0 \\<le> b^2\" by (simp add: power2_eq_square)\n  have \"0 \\<le> c^2\" by (simp add: power2_eq_square)\n  thus \"0 \\<le> a^2\" and \"0 \\<le> b^2\" and \"0 \\<le> c^2\" by auto\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b c :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\" and \"0 \\<le> c^2\" \nproof -\n  have \"0 \\<le> a^2\" by (simp add: power2_eq_square)\n  have \"0 \\<le> b^2\" by (simp add: power2_eq_square)\n  have \"0 \\<le> c^2\" by (simp add: power2_eq_square)\n  thus \"0 \\<le> a^2\" and \"0 \\<le> b^2\" and \"0 \\<le> c^2\" by auto\nqed", "origin": "do_request", "update_count": 0}, "common_denominatorV2": {"skill_name": "common_denominatorV2", "marker": "lemma common_denominator:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / b - c / d = (a * d - c * b) / (b * d)\"\n    by (smt (verit) assms(1) assms(2) diff_frac_eq)\n  thus ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma common_denominator:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / b - c / d = (a * d - c * b) / (b * d)\"\n    by (smt (verit) assms(1) assms(2) diff_frac_eq)\n  thus ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "expand_expressionV3": {"skill_name": "expand_expressionV3", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have \"((x * y) - 1)^2 = (x^2 * y^2) - 2 * (x * y) + 1\" \n    by sos\n  moreover have \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\" \n    by sos\n  ultimately show ?thesis \n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have \"((x * y) - 1)^2 = (x^2 * y^2) - 2 * (x * y) + 1\" \n    by sos\n  moreover have \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\" \n    by sos\n  ultimately show ?thesis \n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "expand_expressionV4": {"skill_name": "expand_expressionV4", "marker": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have left_side: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1 + x^2 + 2 * (x * y) + y^2)\"\n    using left_side by sos\n  then show ?thesis\n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2) + (y^2) + 1\"\nproof -\n  have left_side: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1 + x^2 + 2 * (x * y) + y^2)\"\n    using left_side by sos\n  then show ?thesis\n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "square_root_equivalenceV7": {"skill_name": "square_root_equivalenceV7", "marker": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  from assms(3) have \"sqrt a ^ 2 = sqrt b ^ 2\" \n    by (simp add: power2_eq_square)\n  then have \"a = b\" \n    using assms(1) assms(2) by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_root_equivalence:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  from assms(3) have \"sqrt a ^ 2 = sqrt b ^ 2\" \n    by (simp add: power2_eq_square)\n  then have \"a = b\" \n    using assms(1) assms(2) by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negative_squaresV3": {"skill_name": "non_negative_squaresV3", "marker": "lemma non_negative_squares:\n  fixes a b c :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\" and \"0 \\<le> c^2\"\n  by auto", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b c :: real\n  shows \"0 \\<le> a^2\" and \"0 \\<le> b^2\" and \"0 \\<le> c^2\"\n  by auto", "origin": "do_request", "update_count": 0}, "amc12b_2003_p9_generalized": {"skill_name": "amc12b_2003_p9_generalized", "marker": "theorem amc12b_2003_p9_generalized:\n  fixes a b c :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f c - f 2 = (c - 2) * a\"\n  shows \"f 12 - f 2 = 10 * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f c - f 2 = (a * c + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f c - f 2 = a * c - a * 2\" by (metis add_diff_cancel_right assms(1))\n  have \"a * (c - 2) = (c - 2) * a\" using `f c - f 2 = (c - 2) * a` by simp\n  have \"f 12 - f 2 = (a * 12 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 12 - f 2 = a * 12 - a * 2\" by (metis add.commute add_diff_cancel_left assms(1) dbl_def dbl_simps(3) diff_add_eq_diff_diff_swap diff_minus_eq_add numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib right_diff_distrib' semiring_norm(2))\n  have \"f 12 - f 2 = 10 * a\" by (smt (verit) \\<open>f 12 - f 2 = a * 12 - a * 2\\<close>)\n  show ?thesis by (simp add: `f 12 - f 2 = 10 * a`)\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9_generalized:\n  fixes a b c :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f c - f 2 = (c - 2) * a\"\n  shows \"f 12 - f 2 = 10 * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f c - f 2 = (a * c + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f c - f 2 = a * c - a * 2\" by (metis add_diff_cancel_right assms(1))\n  have \"a * (c - 2) = (c - 2) * a\" using `f c - f 2 = (c - 2) * a` by simp\n  have \"f 12 - f 2 = (a * 12 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 12 - f 2 = a * 12 - a * 2\" by (metis add.commute add_diff_cancel_left assms(1) dbl_def dbl_simps(3) diff_add_eq_diff_diff_swap diff_minus_eq_add numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib right_diff_distrib' semiring_norm(2))\n  have \"f 12 - f 2 = 10 * a\" by (smt (verit) \\<open>f 12 - f 2 = a * 12 - a * 2\\<close>)\n  show ?thesis by (simp add: `f 12 - f 2 = 10 * a`)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "algebra_2varlineareq_xpeeq_a_2xpeeq_b_eq_c": {"skill_name": "algebra_2varlineareq_xpeeq_a_2xpeeq_b_eq_c", "marker": "theorem algebra_2varlineareq_xpeeq_a_2xpeeq_b_eq_c:\n  fixes x e a b c :: real\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - 2 * (b - a) / 2 \\<and> x = (a - e)\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a)\" using simplified_eq by (metis add.commute add_diff_cancel_right' diff_add_cancel)\n  have e_value: \"e = a - (b - a)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by sos\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq_a_2xpeeq_b_eq_c:\n  fixes x e a b c :: real\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - 2 * (b - a) / 2 \\<and> x = (a - e)\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a)\" using simplified_eq by (metis add.commute add_diff_cancel_right' diff_add_cancel)\n  have e_value: \"e = a - (b - a)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by sos\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq_a_2xpeeq_b_eeq_c_xeqn_d": {"skill_name": "algebra_2varlineareq_xpeeq_a_2xpeeq_b_eeq_c_xeqn_d", "marker": "theorem algebra_2varlineareq_xpeeq_a_2xpeeq_b_eeq_c_xeqn_d:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a) / 1\" using simplified_eq by auto\n  show ?thesis using x_value e_eq by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq_a_2xpeeq_b_eeq_c_xeqn_d:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a) / 1\" using simplified_eq by auto\n  show ?thesis using x_value e_eq by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "lcm_definition": {"skill_name": "lcm_definition", "marker": "lemma lcm_definition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\"\n    by auto\n  then show ?thesis\n    by (simp add: lcm_gcd)\nqed", "description": "-", "full_code": "lemma lcm_definition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\"\n    by auto\n  then show ?thesis\n    by (simp add: lcm_gcd)\nqed", "origin": "do_request", "update_count": 0}, "lcm_definitionV2": {"skill_name": "lcm_definitionV2", "marker": "lemma lcm_definition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  have \"lcm a b * gcd a b = a * b\"\n    by auto\n  then have \"lcm a b = (a * b) div gcd a b\"\n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma lcm_definition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  have \"lcm a b * gcd a b = a * b\"\n    by auto\n  then have \"lcm a b = (a * b) div gcd a b\"\n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "lcm_definitionV3": {"skill_name": "lcm_definitionV3", "marker": "lemma lcm_definition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\" \n    using assms by auto\n  then have \"lcm a b = (a * b) div gcd a b\"\n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma lcm_definition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\" \n    using assms by auto\n  then have \"lcm a b = (a * b) div gcd a b\"\n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "lcm_definitionV4": {"skill_name": "lcm_definitionV4", "marker": "lemma lcm_definition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  have \"a * b = lcm a b * gcd a b\" \n    using lcm_gcd[of a b] assms by auto\n  hence \"lcm a b = (a * b) div gcd a b\" \n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma lcm_definition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  have \"a * b = lcm a b * gcd a b\" \n    using lcm_gcd[of a b] assms by auto\n  hence \"lcm a b = (a * b) div gcd a b\" \n    by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positive": {"skill_name": "sqrt_positive", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" \n    by (metis assms max.absorb_iff2 max.commute)\n  then have \"sqrt x >= 0\" \n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" \n    by (metis assms max.absorb_iff2 max.commute)\n  then have \"sqrt x >= 0\" \n    by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positiveV2": {"skill_name": "sqrt_positiveV2", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x ^ 2 = x\" using assms by (simp add: sqrt_def)\n  then have \"sqrt x = sqrt x\" by (simp add: power2_eq_square)\n  moreover have \"sqrt x >= 0\" by (metis assms real_sqrt_ge_zero)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x ^ 2 = x\" using assms by (simp add: sqrt_def)\n  then have \"sqrt x = sqrt x\" by (simp add: power2_eq_square)\n  moreover have \"sqrt x >= 0\" by (metis assms real_sqrt_ge_zero)\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positiveV3": {"skill_name": "sqrt_positiveV3", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x ^ 2 = x\" using assms by (simp add: sqrt_def)\n  then have \"sqrt x ^ 2 >= 0\" using assms by auto\n  moreover have \"sqrt x >= 0\" using assms by (simp add: sqrt_def)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x ^ 2 = x\" using assms by (simp add: sqrt_def)\n  then have \"sqrt x ^ 2 >= 0\" using assms by auto\n  moreover have \"sqrt x >= 0\" using assms by (simp add: sqrt_def)\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positiveV4": {"skill_name": "sqrt_positiveV4", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt x\" by simp\n  moreover have \"0 <= sqrt x\" \n    by (metis assms real_sqrt_ge_zero)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt x\" by simp\n  moreover have \"0 <= sqrt x\" \n    by (metis assms real_sqrt_ge_zero)\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positiveV5": {"skill_name": "sqrt_positiveV5", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" \n    using assms by simp\n  then show ?thesis \n    using assms(1) \n    by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" \n    using assms by simp\n  then show ?thesis \n    using assms(1) \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positiveV6": {"skill_name": "sqrt_positiveV6", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt x\" by simp  \n  then show ?thesis\n    using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt x\" by simp  \n  then show ?thesis\n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positiveV7": {"skill_name": "sqrt_positiveV7", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x * sqrt x = x\" using assms by auto\n  then show \"sqrt x >= 0\" using assms by (simp add: sqrt_def)\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x * sqrt x = x\" using assms by auto\n  then show \"sqrt x >= 0\" using assms by (simp add: sqrt_def)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positiveV8": {"skill_name": "sqrt_positiveV8", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x ^ 2 = x\" using assms by (simp add: real_sqrt_eq_iff)\n  then show \"sqrt x >= 0\" \n    using `x >= 0` by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x ^ 2 = x\" using assms by (simp add: real_sqrt_eq_iff)\n  then show \"sqrt x >= 0\" \n    using `x >= 0` by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positiveV9": {"skill_name": "sqrt_positiveV9", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x * sqrt x = x\" using assms by (simp add: power2_eq_square)\n  then show ?thesis\n  proof (cases \"x = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x > 0\" by (metis assms order_less_le)\n    from `sqrt x * sqrt x = x` and `x > 0` show ?thesis\n      using real_sqrt_eq_iff by auto\n  qed\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x * sqrt x = x\" using assms by (simp add: power2_eq_square)\n  then show ?thesis\n  proof (cases \"x = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x > 0\" by (metis assms order_less_le)\n    from `sqrt x * sqrt x = x` and `x > 0` show ?thesis\n      using real_sqrt_eq_iff by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positiveV10": {"skill_name": "sqrt_positiveV10", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" \n    using assms by auto\n  hence \"sqrt x = sqrt x\" \n    by auto\n  thus ?thesis \n    using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = sqrt (max x 0)\" \n    using assms by auto\n  hence \"sqrt x = sqrt x\" \n    by auto\n  thus ?thesis \n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "cross_multiply": {"skill_name": "cross_multiply", "marker": "lemma cross_multiply:\n  fixes x y :: real\n  assumes \"x - y = (2/y - 2/x)\"\n  shows \"(x - y) * (x * y) = 2 * (x - y)\"\nproof -\n  have \"x - y = (2/y - 2/x)\" using assms by simp\n  then have \"x - y = (2 * x - 2 * y) / (x * y)\" \n    by sos\n  then have \"(x - y) * (x * y) = (2 * x - 2 * y)\" \n    using field_simps by auto\n  thus ?thesis \n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma cross_multiply:\n  fixes x y :: real\n  assumes \"x - y = (2/y - 2/x)\"\n  shows \"(x - y) * (x * y) = 2 * (x - y)\"\nproof -\n  have \"x - y = (2/y - 2/x)\" using assms by simp\n  then have \"x - y = (2 * x - 2 * y) / (x * y)\" \n    by sos\n  then have \"(x - y) * (x * y) = (2 * x - 2 * y)\" \n    using field_simps by auto\n  thus ?thesis \n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "floor_inequality": {"skill_name": "floor_inequality", "marker": "lemma floor_inequality:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n <= r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms by auto\n  moreover have \"r < n + 1\" using assms by auto\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_inequality:\n  fixes r :: real\n  assumes \"n = floor r\"\n  shows \"n <= r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms by auto\n  moreover have \"r < n + 1\" using assms by auto\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "floor_inequalityV2": {"skill_name": "floor_inequalityV2", "marker": "lemma floor_inequality:\n  fixes r :: real and n :: int\n  assumes \"n = floor r\"\n  shows \"n <= r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  have \"r < n + 1\" using assms\n    by auto\n  thus ?thesis by (metis \\<open>real_of_int n \\<le> r\\<close>)\nqed", "description": "-", "full_code": "lemma floor_inequality:\n  fixes r :: real and n :: int\n  assumes \"n = floor r\"\n  shows \"n <= r \\<and> r < n + 1\"\nproof -\n  have \"n \\<le> r\" using assms\n    by auto\n  have \"r < n + 1\" using assms\n    by auto\n  thus ?thesis by (metis \\<open>real_of_int n \\<le> r\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "distinct_nonzero": {"skill_name": "distinct_nonzero", "marker": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  have \"x * y = 0 \\<longleftrightarrow> (x = 0 \\<or> y = 0)\" \n    by (simp add: mult_eq_0_iff)\n  then show \"x * y \\<noteq> 0\" \n    using assms by auto\nqed", "description": "-", "full_code": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  have \"x * y = 0 \\<longleftrightarrow> (x = 0 \\<or> y = 0)\" \n    by (simp add: mult_eq_0_iff)\n  then show \"x * y \\<noteq> 0\" \n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "non_negative_squaresV4": {"skill_name": "non_negative_squaresV4", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\" and \"(a * b)^2 >= 0\"\nproof -\n  show \"a^2 >= 0\" \n    by (simp add: power2_eq_square)  \n  show \"b^2 >= 0\" \n    by (simp add: power2_eq_square)  \n  show \"(a * b)^2 >= 0\" \n    by (simp add: power2_eq_square)  \nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\" and \"(a * b)^2 >= 0\"\nproof -\n  show \"a^2 >= 0\" \n    by (simp add: power2_eq_square)  \n  show \"b^2 >= 0\" \n    by (simp add: power2_eq_square)  \n  show \"(a * b)^2 >= 0\" \n    by (simp add: power2_eq_square)  \nqed", "origin": "do_request", "update_count": 0}, "expand_polynomial": {"skill_name": "expand_polynomial", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  have \"((x * y) - 1)^2 = (x^2 * y^2) - 2 * (x * y) + 1\" \n    by sos  \n  moreover have \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\" \n    by sos  \n  ultimately have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\" \n    by simp\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1 + (-2 * (x * y) + 2 * (x * y)))\" \n    by sos\n  have \"... = (x^2 * y^2) + (x^2 + y^2) + 1\" \n    by (simp add: algebra_simps)\n  thus ?thesis \n    by sos\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  have \"((x * y) - 1)^2 = (x^2 * y^2) - 2 * (x * y) + 1\" \n    by sos  \n  moreover have \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\" \n    by sos  \n  ultimately have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\" \n    by simp\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1 + (-2 * (x * y) + 2 * (x * y)))\" \n    by sos\n  have \"... = (x^2 * y^2) + (x^2 + y^2) + 1\" \n    by (simp add: algebra_simps)\n  thus ?thesis \n    by sos\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV2": {"skill_name": "expand_polynomialV2", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2) - 2 * (x * y) + 1\" \n    by sos\n  moreover have \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\" \n    by sos\n  ultimately have \"?lhs = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by (simp add: algebra_simps)\n  then have \"?lhs = x^2 * y^2 + (x^2 + y^2) + (1 - 2 * (x * y) + 2 * (x * y))\"\n    by (simp add: algebra_simps)\n  thus ?thesis \n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  let ?lhs = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2) - 2 * (x * y) + 1\" \n    by sos\n  moreover have \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\" \n    by sos\n  ultimately have \"?lhs = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by (simp add: algebra_simps)\n  then have \"?lhs = x^2 * y^2 + (x^2 + y^2) + (1 - 2 * (x * y) + 2 * (x * y))\"\n    by (simp add: algebra_simps)\n  thus ?thesis \n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV3": {"skill_name": "expand_polynomialV3", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  have left_side: \"((x * y) - 1)^2 = (x^2 * y^2) - 2 * (x * y) + 1\" \n    by sos\n  moreover have \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\" \n    by sos\n  ultimately have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by auto\n  then show ?thesis \n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  have left_side: \"((x * y) - 1)^2 = (x^2 * y^2) - 2 * (x * y) + 1\" \n    by sos\n  moreover have \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\" \n    by sos\n  ultimately have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by auto\n  then show ?thesis \n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV4": {"skill_name": "expand_polynomialV4", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  have left_side: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1 + x^2 + 2 * (x * y) + y^2)\"\n    using left_side by sos\n  have \"x^2 * y^2 - 2 * (x * y) + 1 + x^2 + 2 * (x * y) + y^2 = x^2 * y^2 + x^2 + y^2 + 1\"\n    by (simp add: algebra_simps)\n  thus ?thesis\n    by sos\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  have left_side: \"((x * y) - 1)^2 + (x + y)^2 = (x * y)^2 - 2 * (x * y) + 1 + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1 + x^2 + 2 * (x * y) + y^2)\"\n    using left_side by sos\n  have \"x^2 * y^2 - 2 * (x * y) + 1 + x^2 + 2 * (x * y) + y^2 = x^2 * y^2 + x^2 + y^2 + 1\"\n    by (simp add: algebra_simps)\n  thus ?thesis\n    by sos\nqed", "origin": "do_request", "update_count": 0}, "distinct_nonzeroV2": {"skill_name": "distinct_nonzeroV2", "marker": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  have \"x * y = 0 \\<longleftrightarrow> (x = 0 \\<or> y = 0)\" \n    by (simp add: algebra_simps)\n  then show \"x * y \\<noteq> 0\" \n    using assms by auto\nqed", "description": "-", "full_code": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  have \"x * y = 0 \\<longleftrightarrow> (x = 0 \\<or> y = 0)\" \n    by (simp add: algebra_simps)\n  then show \"x * y \\<noteq> 0\" \n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "distinct_nonzeroV3": {"skill_name": "distinct_nonzeroV3", "marker": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  have \"x * y = 0 \\<Longrightarrow> (x = 0 \\<or> y = 0)\" by (simp add: mult_eq_0_iff)\n  then show \"x * y \\<noteq> 0\" using assms by auto\nqed", "description": "-", "full_code": "lemma distinct_nonzero:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  have \"x * y = 0 \\<Longrightarrow> (x = 0 \\<or> y = 0)\" by (simp add: mult_eq_0_iff)\n  then show \"x * y \\<noteq> 0\" using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "linear_equations_solver": {"skill_name": "linear_equations_solver", "marker": "theorem linear_equations_solver:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  then have simplified_eq: \"x + a = b\" by simp\n  have x_value: \"x = b - a\" using simplified_eq by auto\n  then show ?thesis using e_eq by simp\nqed", "description": "-", "full_code": "theorem linear_equations_solver:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  then have simplified_eq: \"x + a = b\" by simp\n  have x_value: \"x = b - a\" using simplified_eq by auto\n  then show ?thesis using e_eq by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "linear_combination": {"skill_name": "linear_combination", "marker": "lemma linear_combination:\n  fixes a b c :: complex\n  assumes h0: \"a + b = c\"\n  shows \"b = c - a\"\nproof -\n  have \"b = c - a\" using h0 by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma linear_combination:\n  fixes a b c :: complex\n  assumes h0: \"a + b = c\"\n  shows \"b = c - a\"\nproof -\n  have \"b = c - a\" using h0 by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "expand_polynomialV5": {"skill_name": "expand_polynomialV5", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  have lhs1: \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  moreover have lhs2: \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\"\n    by sos\n  ultimately have \n    \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by simp\n  then have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by (simp add: algebra_simps)\n  also have \"... = x^2 * y^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  have lhs1: \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  moreover have lhs2: \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\"\n    by sos\n  ultimately have \n    \"((x * y) - 1)^2 + (x + y)^2 = ((x * y)^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by simp\n  then have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by (simp add: algebra_simps)\n  also have \"... = x^2 * y^2 + (x^2 + y^2) + 1\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "expand_polynomialV6": {"skill_name": "expand_polynomialV6", "marker": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  have \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  moreover have \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\"\n    by sos\n  ultimately have \n    \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1 + (-2 * (x * y) + 2 * (x * y))\"\n    by sos\n  then show ?thesis \n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma expand_polynomial:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1\"\nproof -\n  have \"((x * y) - 1)^2 = (x * y)^2 - 2 * (x * y) + 1\"\n    by sos\n  moreover have \"(x + y)^2 = x^2 + 2 * (x * y) + y^2\"\n    by sos\n  ultimately have \n    \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2 - 2 * (x * y) + 1) + (x^2 + 2 * (x * y) + y^2)\"\n    by sos\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) + (x^2 + y^2) + 1 + (-2 * (x * y) + 2 * (x * y))\"\n    by sos\n  then show ?thesis \n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "linear_function_differenceV2": {"skill_name": "linear_function_differenceV2", "marker": "theorem linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x - f y = (x - y) * a\"\n  shows \"f z - f y = (z - y) * a\"\nproof -\n  have \"f z - f y = (a * z + b) - (a * y + b)\" by (simp add: assms(1))\n  thus ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x - f y = (x - y) * a\"\n  shows \"f z - f y = (z - y) * a\"\nproof -\n  have \"f z - f y = (a * z + b) - (a * y + b)\" by (simp add: assms(1))\n  thus ?thesis by (auto simp: field_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "non_negative_squaresV5": {"skill_name": "non_negative_squaresV5", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\" and \"(a * b)^2 >= 0\"\nproof -\n  have \"a^2 >= 0\" by auto\n  moreover have \"b^2 >= 0\" by auto\n  moreover have \"(a * b)^2 >= 0\" by auto\n  ultimately show \"a^2 >= 0\" and \"b^2 >= 0\" and \"(a * b)^2 >= 0\" by auto\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\" and \"(a * b)^2 >= 0\"\nproof -\n  have \"a^2 >= 0\" by auto\n  moreover have \"b^2 >= 0\" by auto\n  moreover have \"(a * b)^2 >= 0\" by auto\n  ultimately show \"a^2 >= 0\" and \"b^2 >= 0\" and \"(a * b)^2 >= 0\" by auto\nqed", "origin": "do_request", "update_count": 0}, "non_negative_squaresV6": {"skill_name": "non_negative_squaresV6", "marker": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\" and \"(a * b)^2 >= 0\"\nproof -\n  have \"a^2 >= 0\" \n    by auto\n  moreover have \"b^2 >= 0\" \n    by auto\n  moreover have \"(a * b)^2 = a^2 * b^2\" \n    by sos\n  ultimately show \"a^2 >= 0\" and \"b^2 >= 0\" and \"(a * b)^2 >= 0\"\n    using `a^2 >= 0` `b^2 >= 0` by auto\nqed", "description": "-", "full_code": "lemma non_negative_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\" and \"(a * b)^2 >= 0\"\nproof -\n  have \"a^2 >= 0\" \n    by auto\n  moreover have \"b^2 >= 0\" \n    by auto\n  moreover have \"(a * b)^2 = a^2 * b^2\" \n    by sos\n  ultimately show \"a^2 >= 0\" and \"b^2 >= 0\" and \"(a * b)^2 >= 0\"\n    using `a^2 >= 0` `b^2 >= 0` by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_addition": {"skill_name": "mod_addition", "marker": "lemma mod_addition:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by simp\nnext\n  case False\n  then have \"m > 0\" by simp\n  hence \"a mod m < m\" and \"b mod m < m\" by auto\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = ?x + (a div m) * m\" and \"b = ?y + (b div m) * m\"\n    by auto\n  have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((?x + ?y) + ((a div m) + (b div m)) * m) mod m\"\n    by simp\n  also have \"... = (?x + ?y) mod m\"\n    by auto\n  finally show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by simp\nnext\n  case False\n  then have \"m > 0\" by simp\n  hence \"a mod m < m\" and \"b mod m < m\" by auto\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = ?x + (a div m) * m\" and \"b = ?y + (b div m) * m\"\n    by auto\n  have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((?x + ?y) + ((a div m) + (b div m)) * m) mod m\"\n    by simp\n  also have \"... = (?x + ?y) mod m\"\n    by auto\n  finally show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_additionV2": {"skill_name": "mod_additionV2", "marker": "lemma mod_addition:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof (induction a)\n  case 0\n  then show ?case\n  proof (cases b)\n    case 0\n    then show ?thesis by simp\n  next\n    case (Suc n)\n    then show ?thesis by simp\n  qed\nnext\n  case (Suc a)\n  then show ?case\n  proof (cases \"b mod m\")\n    case 0\n    then have \"b = (b div m) * m\" by auto\n    then have \"(a + b) mod m = (a + (b div m) * m) mod m\"\n      by simp\n    also have \"... = (a mod m + 0) mod m\" \n      using Suc.IH by simp\n    finally show ?thesis by (metis mod_add_eq)\n  next\n    case (Suc n)\n    then show ?thesis\n      using Suc.IH by (metis mod_add_eq)\n  qed\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof (induction a)\n  case 0\n  then show ?case\n  proof (cases b)\n    case 0\n    then show ?thesis by simp\n  next\n    case (Suc n)\n    then show ?thesis by simp\n  qed\nnext\n  case (Suc a)\n  then show ?case\n  proof (cases \"b mod m\")\n    case 0\n    then have \"b = (b div m) * m\" by auto\n    then have \"(a + b) mod m = (a + (b div m) * m) mod m\"\n      by simp\n    also have \"... = (a mod m + 0) mod m\" \n      using Suc.IH by simp\n    finally show ?thesis by (metis mod_add_eq)\n  next\n    case (Suc n)\n    then show ?thesis\n      using Suc.IH by (metis mod_add_eq)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "combine_fractions": {"skill_name": "combine_fractions", "marker": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have \"a / c + b / d = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / c + b / d = (a * d + b * c) / (c * d)\"\n    by (metis add_frac_eq assms(1) assms(2))\n  thus ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have \"a / c + b / d = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / c + b / d = (a * d + b * c) / (c * d)\"\n    by (metis add_frac_eq assms(1) assms(2))\n  thus ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_fractionsV2": {"skill_name": "combine_fractionsV2", "marker": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have \"a / c + b / d = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / c + b / d = (a * d + b * c) / (c * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / c) + (b / d) = (a * d + b * c) / (c * d)\"\nproof -\n  have \"a / c + b / d = (a * d) / (c * d) + (b * c) / (c * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / c + b / d = (a * d + b * c) / (c * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109V2": {"skill_name": "mathd_algebra_109V2", "marker": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"3 * 4 + 2 * b = 12\" using h1 by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  then have \"2 * b = 12 - 12\" by simp\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right diff_minus_eq_add semiring_norm(5) verit_minus_simplify(3))\n  then show \"b = 0\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"3 * 4 + 2 * b = 12\" using h1 by simp\n  have \"12 + 2 * b = 12\" by (smt (verit) \\<open>3 * 4 + 2 * b = 12\\<close>)\n  then have \"2 * b = 12 - 12\" by simp\n  have \"2 * b = 0\" by (metis \\<open>12 + 2 * b = 12\\<close> add_cancel_right_right diff_minus_eq_add semiring_norm(5) verit_minus_simplify(3))\n  then show \"b = 0\" by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "algebra_linear_system": {"skill_name": "algebra_linear_system", "marker": "theorem algebra_linear_system:\n  fixes a b :: real\n  assumes h0: \"3*a + 2*b = 12\"\n      and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 h0 by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem algebra_linear_system:\n  fixes a b :: real\n  assumes h0: \"3*a + 2*b = 12\"\n      and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 h0 by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "floor_properties": {"skill_name": "floor_properties", "marker": "lemma floor_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor (x + 1) = max (floor x + 1) (floor x + 1)\"\n    by auto\n  then have \"floor (x + 1) \\<le> floor x + 1\"\n    using floor_mono by auto\n  moreover have \"floor x \\<le> x\" by auto\n  hence \"floor x + 1 \\<le> x + 1\" by (simp add: add_le_mono)\n  then have \"floor x + 1 \\<le> floor (x + 1)\" using floor_mono by auto\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor (x + 1) = max (floor x + 1) (floor x + 1)\"\n    by auto\n  then have \"floor (x + 1) \\<le> floor x + 1\"\n    using floor_mono by auto\n  moreover have \"floor x \\<le> x\" by auto\n  hence \"floor x + 1 \\<le> x + 1\" by (simp add: add_le_mono)\n  then have \"floor x + 1 \\<le> floor (x + 1)\" using floor_mono by auto\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "floor_propertiesV2": {"skill_name": "floor_propertiesV2", "marker": "lemma floor_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor (x + 1) = floor (x + 1 + 0)\" by simp\n  then have \"floor (x + 1) = floor (x + 1)\" by simp\n  then have \"floor (x + 1) = floor x + 1\" \n    by auto\n  show ?thesis\n    using `floor (x + 1) = floor x + 1` by auto\nqed", "description": "-", "full_code": "lemma floor_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor (x + 1) = floor (x + 1 + 0)\" by simp\n  then have \"floor (x + 1) = floor (x + 1)\" by simp\n  then have \"floor (x + 1) = floor x + 1\" \n    by auto\n  show ?thesis\n    using `floor (x + 1) = floor x + 1` by auto\nqed", "origin": "do_request", "update_count": 0}, "floor_propertiesV3": {"skill_name": "floor_propertiesV3", "marker": "lemma floor_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor (x + 1) = floor x + 1\" if \"floor x = n\" for n :: int\n  proof -\n    have \"n <= x\" using that by auto\n    have \"x < n + 1\" using that by auto\n    hence \"n + 1 <= x + 1\" by (smt (verit) \\<open>real_of_int n \\<le> x\\<close> add_mono_thms_linordered_semiring(2) of_int_1 of_int_add)\n    also have \"x + 1 < n + 2\" using that by arith\n    finally show ?thesis by auto\n  qed\n  then show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma floor_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor (x + 1) = floor x + 1\" if \"floor x = n\" for n :: int\n  proof -\n    have \"n <= x\" using that by auto\n    have \"x < n + 1\" using that by auto\n    hence \"n + 1 <= x + 1\" by (smt (verit) \\<open>real_of_int n \\<le> x\\<close> add_mono_thms_linordered_semiring(2) of_int_1 of_int_add)\n    also have \"x + 1 < n + 2\" using that by arith\n    finally show ?thesis by auto\n  qed\n  then show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "linear_equation_solution": {"skill_name": "linear_equation_solution", "marker": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0: \"a \\<noteq> 0\" \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using h0 by simp\n  hence \"a * x = c - b\" by (simp add: algebra_simps)\n  then show ?thesis by (metis div_by_1 frac_eq_eq h0(1) mult.commute mult_cancel_left1 zero_neq_one)\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0: \"a \\<noteq> 0\" \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using h0 by simp\n  hence \"a * x = c - b\" by (simp add: algebra_simps)\n  then show ?thesis by (metis div_by_1 frac_eq_eq h0(1) mult.commute mult_cancel_left1 zero_neq_one)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_solutionV2": {"skill_name": "linear_equation_solutionV2", "marker": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0: \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"a * x + b * y = c\"\n  shows \"y = (c - a * x) / b\"\nproof -\n  have \"b * y = c - a * x\" using h0 by auto\n  then show ?thesis by (metis h0(2) nonzero_mult_div_cancel_left)\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0: \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"a * x + b * y = c\"\n  shows \"y = (c - a * x) / b\"\nproof -\n  have \"b * y = c - a * x\" using h0 by auto\n  then show ?thesis by (metis h0(2) nonzero_mult_div_cancel_left)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_generalized": {"skill_name": "mathd_algebra_109_generalized", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have simplified: \"12 + 2 * b = c\" by (smt (verit) sub)\n  hence \"2 * b = c - 12\" by simp\n  thus \"b = (c - 12) / 2\" using field_simps by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0: \"3 * a + 2 * b = c\"\n    and h1: \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have simplified: \"12 + 2 * b = c\" by (smt (verit) sub)\n  hence \"2 * b = c - 12\" by simp\n  thus \"b = (c - 12) / 2\" using field_simps by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "square_eq": {"skill_name": "square_eq", "marker": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp", "description": "", "full_code": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp", "origin": "data/full_data/debug/valid_rand/mathd_algebra_31.json_v2", "update_count": -1}, "amc12b_2003_p9_extended": {"skill_name": "amc12b_2003_p9_extended", "marker": "theorem amc12b_2003_p9_extended:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f x - f 2 = (x - 2) * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  have \"a = 3\" by (smt (verit) \\<open>4 * a = 12\\<close>)\n  have \"f x - f 2 = (a * x + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f x - f 2 = (a * x - a * 2)\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"f x - f 2 = (x - 2) * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add mult.commute one_plus_BitM right_diff_distrib)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9_extended:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f x - f 2 = (x - 2) * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  have \"a = 3\" by (smt (verit) \\<open>4 * a = 12\\<close>)\n  have \"f x - f 2 = (a * x + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f x - f 2 = (a * x - a * 2)\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"f x - f 2 = (x - 2) * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add mult.commute one_plus_BitM right_diff_distrib)\n  then show ?thesis by simp\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "isolate_variable": {"skill_name": "isolate_variable", "marker": "lemma isolate_variable:\n  fixes a b c :: real\n  assumes \"a * x + b = c\" and \"a \\<noteq> 0\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x = c - b\" using assms by simp\n  then show ?thesis by (metis assms(2) div_by_1 frac_eq_eq mult.commute mult_cancel_left1 zero_neq_one)\nqed", "description": "-", "full_code": "lemma isolate_variable:\n  fixes a b c :: real\n  assumes \"a * x + b = c\" and \"a \\<noteq> 0\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x = c - b\" using assms by simp\n  then show ?thesis by (metis assms(2) div_by_1 frac_eq_eq mult.commute mult_cancel_left1 zero_neq_one)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "isolate_variableV2": {"skill_name": "isolate_variableV2", "marker": "lemma isolate_variable:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b + b = c\" by (simp add: assms)\n  then show \"a = c - b\" using assms by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma isolate_variable:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b + b = c\" by (simp add: assms)\n  then show \"a = c - b\" using assms by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "isolate_variableV3": {"skill_name": "isolate_variableV3", "marker": "lemma isolate_variable:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"a = c - b\" using assms by (simp add: diff_add_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma isolate_variable:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"a = c - b\" using assms by (simp add: diff_add_eq)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "isolate_variableV4": {"skill_name": "isolate_variableV4", "marker": "lemma isolate_variable:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b + b = c\" by (simp add: assms)\n  then show ?thesis by (metis add.commute add_cancel_left_right assms cancel_ab_semigroup_add_class.diff_right_commute crossproduct_eq diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0 minus_diff_eq mult.commute mult_cancel_right2 mult_eq_0_iff mult_minus_right neg_0_equal_iff_equal zero_neq_neg_one)\nqed", "description": "-", "full_code": "lemma isolate_variable:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b + b = c\" by (simp add: assms)\n  then show ?thesis by (metis add.commute add_cancel_left_right assms cancel_ab_semigroup_add_class.diff_right_commute crossproduct_eq diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0 minus_diff_eq mult.commute mult_cancel_right2 mult_eq_0_iff mult_minus_right neg_0_equal_iff_equal zero_neq_neg_one)\nqed", "origin": "do_request", "update_count": 0}, "amc12b_2003_p9_extendedV2": {"skill_name": "amc12b_2003_p9_extendedV2", "marker": "theorem amc12b_2003_p9_extended:\n  fixes a b c :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n    and \"f c - f 2 = (c - 2) * a\"  \n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_add_eq_diff_diff_swap diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib semiring_norm(2))\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  have \"a = 3\" by (smt (verit) \\<open>4 * a = 12\\<close>)\n  have \"f 12 - f 2 = (a * 12 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 12 - f 2 = 12 * a - 2 * a\" by (metis add.commute add_diff_cancel_left assms(1) dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib semiring_norm(2))\n  have \"f 12 - f 2 = 10 * a\" by (smt (verit) \\<open>f 12 - f 2 = 12 * a - 2 * a\\<close>)\n  then have \"f 12 - f 2 = 10 * 3\" using `a = 3` by simp\n  show ?thesis by (simp add: `f 12 - f 2 = 10 * 3`)\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9_extended:\n  fixes a b c :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n    and \"f c - f 2 = (c - 2) * a\"  \n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_add_eq_diff_diff_swap diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib semiring_norm(2))\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  have \"a = 3\" by (smt (verit) \\<open>4 * a = 12\\<close>)\n  have \"f 12 - f 2 = (a * 12 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 12 - f 2 = 12 * a - 2 * a\" by (metis add.commute add_diff_cancel_left assms(1) dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib semiring_norm(2))\n  have \"f 12 - f 2 = 10 * a\" by (smt (verit) \\<open>f 12 - f 2 = 12 * a - 2 * a\\<close>)\n  then have \"f 12 - f 2 = 10 * 3\" using `a = 3` by simp\n  show ?thesis by (simp add: `f 12 - f 2 = 10 * 3`)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "amc12b_2003_p9_v2": {"skill_name": "amc12b_2003_p9_v2", "marker": "theorem amc12b_2003_p9_v2:\n  fixes a b x1 x2 x3 :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x1 - f x2 = x1 - x2\"\n  shows \"f x3 - f x2 = (x3 - x2) * a\"\nproof -\n  have \"f x1 - f x2 = (a * x1 + b) - (a * x2 + b)\" using assms(1) by simp\n  hence \"f x1 - f x2 = a * (x1 - x2)\" by (auto simp: field_simps)\n  then have \"x1 - x2 = a * (x1 - x2)\" using assms(2) by simp\n  have \"f x3 - f x2 = (a * x3 + b) - (a * x2 + b)\" using assms(1) by simp\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9_v2:\n  fixes a b x1 x2 x3 :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x1 - f x2 = x1 - x2\"\n  shows \"f x3 - f x2 = (x3 - x2) * a\"\nproof -\n  have \"f x1 - f x2 = (a * x1 + b) - (a * x2 + b)\" using assms(1) by simp\n  hence \"f x1 - f x2 = a * (x1 - x2)\" by (auto simp: field_simps)\n  then have \"x1 - x2 = a * (x1 - x2)\" using assms(2) by simp\n  have \"f x3 - f x2 = (a * x3 + b) - (a * x2 + b)\" using assms(1) by simp\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "fraction_combination": {"skill_name": "fraction_combination", "marker": "lemma fraction_combination:\n  fixes a b c d :: real\n  assumes \"d \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (smt (verit) assms(1) assms(2) frac_eq_eq mult.assoc mult.commute no_zero_divisors nonzero_mult_divide_mult_cancel_left2)\n  then have \"a / b - c / d = (a * d - c * b) / (b * d)\"\n    by (smt (verit) assms(1) assms(2) diff_frac_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma fraction_combination:\n  fixes a b c d :: real\n  assumes \"d \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (smt (verit) assms(1) assms(2) frac_eq_eq mult.assoc mult.commute no_zero_divisors nonzero_mult_divide_mult_cancel_left2)\n  then have \"a / b - c / d = (a * d - c * b) / (b * d)\"\n    by (smt (verit) assms(1) assms(2) diff_frac_eq)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "linear_equations_solution": {"skill_name": "linear_equations_solution", "marker": "theorem linear_equations_solution:\n  fixes a b c d e f :: real\n  assumes h0: \"a*x + b*y = c\"\n      and h1: \"d*x + e*y = f\"\n      and h2: \"b \\<noteq> 0\"\n      and h3: \"e \\<noteq> 0\"\n  shows \"y = (f - d*x) / e\"\nproof -\n  have \"e*y = f - d*x\" using h1 by simp\n  then show ?thesis by (metis h3 nonzero_mult_div_cancel_left)\nqed", "description": "-", "full_code": "theorem linear_equations_solution:\n  fixes a b c d e f :: real\n  assumes h0: \"a*x + b*y = c\"\n      and h1: \"d*x + e*y = f\"\n      and h2: \"b \\<noteq> 0\"\n      and h3: \"e \\<noteq> 0\"\n  shows \"y = (f - d*x) / e\"\nproof -\n  have \"e*y = f - d*x\" using h1 by simp\n  then show ?thesis by (metis h3 nonzero_mult_div_cancel_left)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_multi": {"skill_name": "mathd_algebra_109_multi", "marker": "theorem mathd_algebra_109_multi:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\" and \"b = 0 + 0\" and \"b = 0 + 1 + (-1)\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  then show \"b = 0\" by simp\n  then show \"b = 0 + 0\" by simp\n  then show \"b = 0 + 1 + (-1)\" by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed\n\ntheorem mathd_algebra_109_multi:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\" and \"b = 0 + 0\" and \"b = 0 + 1 + (-1)\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  then show \"b = 0\" by simp\n  then show \"b = 0 + 0\" by simp\n  then show \"b = 0 + 1 + (-1)\" by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "factor_difference": {"skill_name": "factor_difference", "marker": "lemma factor_difference:\n  fixes a b c :: real\n  assumes \"a \\<noteq> b\"\n  shows \"a * c - b * c = (a - b) * c\"\nproof -\n  have \"a * c - b * c = (a - b) * c + b * c - b * c\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma factor_difference:\n  fixes a b c :: real\n  assumes \"a \\<noteq> b\"\n  shows \"a * c - b * c = (a - b) * c\"\nproof -\n  have \"a * c - b * c = (a - b) * c + b * c - b * c\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "square_eq_generalized": {"skill_name": "square_eq_generalized", "marker": "lemma square_eq_generalized:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\" \n  and \"a^2 + c = b^2 + c\" \n  and \"a^2 - c = b^2 - c\"\n  using assms by (simp_all add: algebra_simps)", "description": "-", "full_code": "lemma square_eq_generalized:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\" \n  and \"a^2 + c = b^2 + c\" \n  and \"a^2 - c = b^2 - c\"\n  using assms by (simp_all add: algebra_simps)", "origin": "square_eq", "update_count": 0}, "factor_differenceV2": {"skill_name": "factor_differenceV2", "marker": "lemma factor_difference:\n  fixes a b c :: real\n  assumes \"a \\<noteq> b\"\n  shows \"a * c - b * c = (a - b) * c\"\nproof -\n  have \"a * c - b * c = (a - b) * c + b * c - b * c\" by sos\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma factor_difference:\n  fixes a b c :: real\n  assumes \"a \\<noteq> b\"\n  shows \"a * c - b * c = (a - b) * c\"\nproof -\n  have \"a * c - b * c = (a - b) * c + b * c - b * c\" by sos\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "square_eq_with_difference": {"skill_name": "square_eq_with_difference", "marker": "lemma square_eq_with_difference:\n  fixes a b :: real\n  shows \"a = b \\<Longrightarrow> (a - b) * (a + b) = 0\"\nproof -\n  assume \"a = b\"\n  then show \"(a - b) * (a + b) = 0\" \n    by simp\nqed", "description": "-", "full_code": "lemma square_eq_with_difference:\n  fixes a b :: real\n  shows \"a = b \\<Longrightarrow> (a - b) * (a + b) = 0\"\nproof -\n  assume \"a = b\"\n  then show \"(a - b) * (a + b) = 0\" \n    by simp\nqed", "origin": "square_eq", "update_count": 0}, "factor_differenceV3": {"skill_name": "factor_differenceV3", "marker": "lemma factor_difference:\n  fixes a b c :: real\n  assumes \"a \\<noteq> b\"\n  shows \"a * c - b * c = (a - b) * c\"\nproof -\n  have \"a * c - b * c = (a - b) * c + b * c - b * c\" \n    by (simp only: algebra_simps)\n  also have \"... = (a - b) * c + (b * c - b * c)\" \n    by (simp)\n  also have \"... = (a - b) * c + 0\" \n    by (simp)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma factor_difference:\n  fixes a b c :: real\n  assumes \"a \\<noteq> b\"\n  shows \"a * c - b * c = (a - b) * c\"\nproof -\n  have \"a * c - b * c = (a - b) * c + b * c - b * c\" \n    by (simp only: algebra_simps)\n  also have \"... = (a - b) * c + (b * c - b * c)\" \n    by (simp)\n  also have \"... = (a - b) * c + 0\" \n    by (simp)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_eq_expanded": {"skill_name": "square_eq_expanded", "marker": "lemma square_eq_expanded:\n  fixes a b :: real\n  shows \"a = b \\<Longrightarrow> (a + c)^2 = (b + c)^2\"\nproof -\n  assume \"a = b\"\n  then show \"(a + c)^2 = (b + c)^2\" \n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma square_eq_expanded:\n  fixes a b :: real\n  shows \"a = b \\<Longrightarrow> (a + c)^2 = (b + c)^2\"\nproof -\n  assume \"a = b\"\n  then show \"(a + c)^2 = (b + c)^2\" \n    by (simp add: algebra_simps)\nqed", "origin": "square_eq", "update_count": 0}, "square_eq_general": {"skill_name": "square_eq_general", "marker": "lemma square_eq_general:\n  fixes a b :: real\n  shows \"a = b \\<Longrightarrow> a^2 = b^2\"\nproof -\n  assume \"a = b\"\n  then show \"a^2 = b^2\" by simp\nqed", "description": "-", "full_code": "lemma square_eq_general:\n  fixes a b :: real\n  shows \"a = b \\<Longrightarrow> a^2 = b^2\"\nproof -\n  assume \"a = b\"\n  then show \"a^2 = b^2\" by simp\nqed", "origin": "square_eq", "update_count": 0}, "mod4_cases": {"skill_name": "mod4_cases", "marker": "lemma mod4_cases:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n  by auto", "description": "", "full_code": "lemma mod4_cases:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n  by auto", "origin": "data/full_data/debug/valid_rand/numbertheory_sqmod4in01d.json_v3", "update_count": -1}, "mathd_algebra_109_extended_2d": {"skill_name": "mathd_algebra_109_extended_2d", "marker": "theorem mathd_algebra_109_extended_2d:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\" \"c = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b + c = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b + 0 = 12\" using h1(1) eq by (metis dbl_inc_simps(3) dbl_simps(3) h1(2))\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0 \\<and> (3*a + 2*b) = 12\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  thus ?thesis by (metis h0)\nqed\n\ntheorem mathd_algebra_109_extended_2d:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\" \"c = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b + c = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b + 0 = 12\" using h1(1) eq by (metis dbl_inc_simps(3) dbl_simps(3) h1(2))\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_extended": {"skill_name": "mathd_algebra_109_extended", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0 \\<and> (3*a + 2*b) = 12\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  thus ?thesis by (metis h0)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0 \\<and> (3*a + 2*b) = 12\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  thus ?thesis by (metis h0)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_extendedV2": {"skill_name": "mathd_algebra_109_extendedV2", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"k * a + m * b = c\"\n    and h1 : \"a = d\"\n    and h2: \"k > 0\" and \"m > 0\"\n  shows \"b = (c - k * d) / m\"\nproof -\n  have eq: \"k * a + m * b = c\" using h0 by simp\n  have sub: \"k * d + m * b = c\" using h1 eq by simp\n  have isolate: \"m * b = c - k * d\" using sub by simp\n  have solution: \"b = (c - k * d) / m\" using isolate by (metis assms(4) less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b :: real\n  assumes h0 : \"k * a + m * b = c\"\n    and h1 : \"a = d\"\n    and h2: \"k > 0\" and \"m > 0\"\n  shows \"b = (c - k * d) / m\"\nproof -\n  have eq: \"k * a + m * b = c\" using h0 by simp\n  have sub: \"k * d + m * b = c\" using h1 eq by simp\n  have isolate: \"m * b = c - k * d\" using sub by simp\n  have solution: \"b = (c - k * d) / m\" using isolate by (metis assms(4) less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "cross_multiplyV2": {"skill_name": "cross_multiplyV2", "marker": "lemma cross_multiply:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b = c / d) \\<longleftrightarrow> (a * d = b * c)\"\nproof\n  assume \"a / b = c / d\"\n  then have \"a * d = c * b\"\n    by (simp add: assms(1) assms(2) field_simps)\n  thus \"a * d = b * c\" by simp\nnext\n  assume \"a * d = b * c\"\n  then have \"a / b = c / d\"\n    using assms(1) assms(2) by (simp add: field_simps)\n  thus \"a / b = c / d\" by simp\nqed", "description": "-", "full_code": "lemma cross_multiply:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b = c / d) \\<longleftrightarrow> (a * d = b * c)\"\nproof\n  assume \"a / b = c / d\"\n  then have \"a * d = c * b\"\n    by (simp add: assms(1) assms(2) field_simps)\n  thus \"a * d = b * c\" by simp\nnext\n  assume \"a * d = b * c\"\n  then have \"a / b = c / d\"\n    using assms(1) assms(2) by (simp add: field_simps)\n  thus \"a / b = c / d\" by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_n_cases": {"skill_name": "mod_n_cases", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n = 0 \\<or> a mod n = 1 \\<or> (\\<exists>k. a mod n = k \\<and> k < n)\"\nproof -\n  have \"a mod n < n\" using assms by auto\n  then show ?thesis\n  proof (cases \"a mod n = 0\")\n    case True\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a mod n \\<noteq> 0\" by simp\n    then show ?thesis\n    proof (cases \"a mod n = 1\")\n      case True\n      then show ?thesis by auto\n    next\n      case False\n      then have \"a mod n > 1\" using `a mod n < n` by (metis Euclidean_Division.pos_mod_sign \\<open>a mod int n \\<noteq> 0\\<close> assms linorder_neqE_linordered_idom mod_by_1 of_nat_0_less_iff zmod_trivial_iff)\n      hence \"a mod n > 1\" by simp\n      moreover have \"a mod n < n\" by (metis \\<open>a mod int n < int n\\<close>)\n      ultimately show ?thesis by auto\n    qed\n  qed\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n = 0 \\<or> a mod n = 1 \\<or> (\\<exists>k. a mod n = k \\<and> k < n)\"\nproof -\n  have \"a mod n < n\" using assms by auto\n  then show ?thesis\n  proof (cases \"a mod n = 0\")\n    case True\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a mod n \\<noteq> 0\" by simp\n    then show ?thesis\n    proof (cases \"a mod n = 1\")\n      case True\n      then show ?thesis by auto\n    next\n      case False\n      then have \"a mod n > 1\" using `a mod n < n` by (metis Euclidean_Division.pos_mod_sign \\<open>a mod int n \\<noteq> 0\\<close> assms linorder_neqE_linordered_idom mod_by_1 of_nat_0_less_iff zmod_trivial_iff)\n      hence \"a mod n > 1\" by simp\n      moreover have \"a mod n < n\" by (metis \\<open>a mod int n < int n\\<close>)\n      ultimately show ?thesis by auto\n    qed\n  qed\nqed", "origin": "mod4_cases", "update_count": 0}, "linear_equation_substitution": {"skill_name": "linear_equation_substitution", "marker": "lemma linear_equation_substitution:\n  fixes a b :: real\n  assumes h0: \"3*a + 2*b = k\" \n    and h1: \"a = c\"\n  shows \"b = (k - 3*c) / 2\"\nproof -\n  have eq: \"3*a + 2*b = k\" using h0 by simp\n  then have sub: \"3 * c + 2 * b = k\" using h1 by simp\n  then have simplified: \"2*b = k - 3*c\" by (simp add: algebra_simps)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma linear_equation_substitution:\n  fixes a b :: real\n  assumes h0: \"3*a + 2*b = k\" \n    and h1: \"a = c\"\n  shows \"b = (k - 3*c) / 2\"\nproof -\n  have eq: \"3*a + 2*b = k\" using h0 by simp\n  then have sub: \"3 * c + 2 * b = k\" using h1 by simp\n  then have simplified: \"2*b = k - 3*c\" by (simp add: algebra_simps)\n  then show ?thesis by auto\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_substitutionV2": {"skill_name": "linear_equation_substitutionV2", "marker": "lemma linear_equation_substitution:\n  fixes a b c d :: real\n  assumes \"3*a + 2*b = c\" \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have \"3*a + 2*b = c\" using assms(1) by simp\n  then have \"3*d + 2*b = c\" using assms(2) by simp\n  then have \"2*b = c - 3*d\" by simp\n  then show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma linear_equation_substitution:\n  fixes a b c d :: real\n  assumes \"3*a + 2*b = c\" \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have \"3*a + 2*b = c\" using assms(1) by simp\n  then have \"3*d + 2*b = c\" using assms(2) by simp\n  then have \"2*b = c - 3*d\" by simp\n  then show ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "combine_fractionsV3": {"skill_name": "combine_fractionsV3", "marker": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) + (c / d) = (a * d + c * b) / (b * d)\"\nproof -\n  have \"a / b + c / d = (a * d) / (b * d) + (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / b + c / d = ((a * d) + (c * b)) / (b * d)\"\n    by (metis add_frac_eq assms(1) assms(2))\n  thus ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) + (c / d) = (a * d + c * b) / (b * d)\"\nproof -\n  have \"a / b + c / d = (a * d) / (b * d) + (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / b + c / d = ((a * d) + (c * b)) / (b * d)\"\n    by (metis add_frac_eq assms(1) assms(2))\n  thus ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_fractionsV4": {"skill_name": "combine_fractionsV4", "marker": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) + (c / d) = (a * d + c * b) / (b * d)\"\nproof -\n  have \"a / b + c / d = (a * d) / (b * d) + (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / b + c / d = (a * d + c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_fractions:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) + (c / d) = (a * d + c * b) / (b * d)\"\nproof -\n  have \"a / b + c / d = (a * d) / (b * d) + (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then have \"a / b + c / d = (a * d + c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "divide_non_zero": {"skill_name": "divide_non_zero", "marker": "lemma divide_non_zero:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a / c = b / c\"\nproof -\n  have \"a / c = (b / c)\" using assms(1) by (simp add: assms(2) field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma divide_non_zero:\n  fixes a b c :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a / c = b / c\"\nproof -\n  have \"a / c = (b / c)\" using assms(1) by (simp add: assms(2) field_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "divide_non_zeroV2": {"skill_name": "divide_non_zeroV2", "marker": "lemma divide_non_zero:\n  fixes a b :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a / c = b / c\"\nproof -\n  from assms(1) have \"b = a\" by auto\n  then show ?thesis by (simp add: assms(2) field_simps)\nqed", "description": "-", "full_code": "lemma divide_non_zero:\n  fixes a b :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a / c = b / c\"\nproof -\n  from assms(1) have \"b = a\" by auto\n  then show ?thesis by (simp add: assms(2) field_simps)\nqed", "origin": "do_request", "update_count": 0}, "sum_partition": {"skill_name": "sum_partition", "marker": "lemma sum_partition:\n  fixes n :: nat\n  fixes x y a b c :: real\n  assumes \"x + y = n\"\n  shows \"x * a + y * b = c \\<Longrightarrow> (x + y) * a + y * (b - a) = c\"\nproof -\n  assume \"x * a + y * b = c\"\n  then have \"y * b = c - x * a\" by (simp add: algebra_simps)\n  then have \"(x + y) * a + y * (b - a) = (x + y) * a + y * b - y * a\" \n    by (simp add: algebra_simps)\n  also have \"... = (x + y) * a + (c - x * a) - y * a\"\n    by (metis \\<open>y * b = c - x * a\\<close> add.commute add_cancel_right_left add_diff_eq cancel_comm_monoid_add_class.diff_cancel group_cancel.sub1 mult.commute right_diff_distrib)\n  finally show ?thesis\n    by sos\nqed", "description": "-", "full_code": "lemma sum_partition:\n  fixes n :: nat\n  fixes x y a b c :: real\n  assumes \"x + y = n\"\n  shows \"x * a + y * b = c \\<Longrightarrow> (x + y) * a + y * (b - a) = c\"\nproof -\n  assume \"x * a + y * b = c\"\n  then have \"y * b = c - x * a\" by (simp add: algebra_simps)\n  then have \"(x + y) * a + y * (b - a) = (x + y) * a + y * b - y * a\" \n    by (simp add: algebra_simps)\n  also have \"... = (x + y) * a + (c - x * a) - y * a\"\n    by (metis \\<open>y * b = c - x * a\\<close> add.commute add_cancel_right_left add_diff_eq cancel_comm_monoid_add_class.diff_cancel group_cancel.sub1 mult.commute right_diff_distrib)\n  finally show ?thesis\n    by sos\nqed", "origin": "do_request", "update_count": 0}, "divide_non_zeroV3": {"skill_name": "divide_non_zeroV3", "marker": "lemma divide_non_zero:\n  fixes a b :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a / c = b / c\"\nproof -\n  have \"a / c = b / c\" \n    by (simp add: assms(1) field_simps(1))\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma divide_non_zero:\n  fixes a b :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a / c = b / c\"\nproof -\n  have \"a / c = b / c\" \n    by (simp add: assms(1) field_simps(1))\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "divide_non_zeroV4": {"skill_name": "divide_non_zeroV4", "marker": "lemma divide_non_zero:\n  fixes a b :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a / c = b / c\"\nproof -\n  have \"a / c = (a * 1) / c\" by (simp)\n  also have \"... = (a * (1 / c))\" by (simp add: field_simps)\n  finally have \"a / c = a * (1 / c)\" .\n  have \"b / c = (b * 1) / c\" by (simp)\n  also have \"... = (b * (1 / c))\" by (simp add: field_simps)\n  finally have \"b / c = b * (1 / c)\" .\n  have \"b * (1 / c) = a * (1 / c)\" using assms(1) by simp\n  thus ?thesis using `a / c = a * (1 / c)` by (metis assms(1))\nqed", "description": "-", "full_code": "lemma divide_non_zero:\n  fixes a b :: real\n  assumes \"a = b\" \"c \\<noteq> 0\"\n  shows \"a / c = b / c\"\nproof -\n  have \"a / c = (a * 1) / c\" by (simp)\n  also have \"... = (a * (1 / c))\" by (simp add: field_simps)\n  finally have \"a / c = a * (1 / c)\" .\n  have \"b / c = (b * 1) / c\" by (simp)\n  also have \"... = (b * (1 / c))\" by (simp add: field_simps)\n  finally have \"b / c = b * (1 / c)\" .\n  have \"b * (1 / c) = a * (1 / c)\" using assms(1) by simp\n  thus ?thesis using `a / c = a * (1 / c)` by (metis assms(1))\nqed", "origin": "do_request", "update_count": 0}, "sqrt_equation": {"skill_name": "sqrt_equation", "marker": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9\" using assms by simp\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show \"x = 72\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9\" using assms by simp\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show \"x = 72\" by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negativity_of_squares": {"skill_name": "non_negativity_of_squares", "marker": "lemma non_negativity_of_squares:\n  fixes z :: real\n  shows \"z^2 >= 0\"\nproof -\n  have \"z^2 = z * z\" \n    by (simp add: power2_eq_square)\n  moreover have \"z * z >= 0\" \n    by auto\n  ultimately show \"z^2 >= 0\" \n    by simp\nqed", "description": "-", "full_code": "lemma non_negativity_of_squares:\n  fixes z :: real\n  shows \"z^2 >= 0\"\nproof -\n  have \"z^2 = z * z\" \n    by (simp add: power2_eq_square)\n  moreover have \"z * z >= 0\" \n    by auto\n  ultimately show \"z^2 >= 0\" \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negativity_of_squaresV2": {"skill_name": "non_negativity_of_squaresV2", "marker": "lemma non_negativity_of_squares:\n  fixes z :: real\n  shows \"z^2 >= 0\"\nproof -\n  have \"z^2 = z * z\" \n    by (simp add: power2_eq_square)\n  then show \"z^2 >= 0\" \n    using mult_nonneg_nonneg by auto\nqed", "description": "-", "full_code": "lemma non_negativity_of_squares:\n  fixes z :: real\n  shows \"z^2 >= 0\"\nproof -\n  have \"z^2 = z * z\" \n    by (simp add: power2_eq_square)\n  then show \"z^2 >= 0\" \n    using mult_nonneg_nonneg by auto\nqed", "origin": "do_request", "update_count": 0}, "non_negativity_of_squaresV3": {"skill_name": "non_negativity_of_squaresV3", "marker": "lemma non_negativity_of_squares:\n  fixes z :: real\n  shows \"z^2 >= 0\"\nproof -\n  have \"z^2 = z * z\" by sos\n  then show \"z^2 >= 0\" \n    by auto\nqed", "description": "-", "full_code": "lemma non_negativity_of_squares:\n  fixes z :: real\n  shows \"z^2 >= 0\"\nproof -\n  have \"z^2 = z * z\" by sos\n  then show \"z^2 >= 0\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "min_of_non_negatives": {"skill_name": "min_of_non_negatives", "marker": "lemma min_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  from assms have \"a >= 0\" by simp\n  from assms have \"b >= 0\" by simp\n  thus \"a + b >= 0\" by (metis add_nonneg_nonneg assms(1))\nqed", "description": "-", "full_code": "lemma min_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  from assms have \"a >= 0\" by simp\n  from assms have \"b >= 0\" by simp\n  thus \"a + b >= 0\" by (metis add_nonneg_nonneg assms(1))\nqed", "origin": "do_request", "update_count": 0}, "min_of_non_negativesV2": {"skill_name": "min_of_non_negativesV2", "marker": "lemma min_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  from assms have \"0 <= a\" and \"0 <= b\" by auto\n  then show \"a + b >= 0\" by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma min_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  from assms have \"0 <= a\" and \"0 <= b\" by auto\n  then show \"a + b >= 0\" by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "min_of_non_negativesV3": {"skill_name": "min_of_non_negativesV3", "marker": "lemma min_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b = a + 0 + b\" by (simp add: algebra_simps)\n  also have \"... >= 0 + 0\" using assms by (simp add: field_simps)\n  finally show \"a + b >= 0\" by simp\nqed", "description": "-", "full_code": "lemma min_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a + b = a + 0 + b\" by (simp add: algebra_simps)\n  also have \"... >= 0 + 0\" using assms by (simp add: field_simps)\n  finally show \"a + b >= 0\" by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_square_cases": {"skill_name": "mod_square_cases", "marker": "lemma mod_square_cases:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<or> (a mod 4 = 1) \\<or> (a mod 4 = 2) \\<or> (a mod 4 = 3)\"\nproof -\n  have \"0 \\<le> a mod 4\" and \"a mod 4 < 4\" by auto\n  hence \"a mod 4 < 4\" by auto\n  then show ?thesis using \\<open>0 \\<le> a mod 4\\<close> by auto\nqed", "description": "-", "full_code": "lemma mod_square_cases:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<or> (a mod 4 = 1) \\<or> (a mod 4 = 2) \\<or> (a mod 4 = 3)\"\nproof -\n  have \"0 \\<le> a mod 4\" and \"a mod 4 < 4\" by auto\n  hence \"a mod 4 < 4\" by auto\n  then show ?thesis using \\<open>0 \\<le> a mod 4\\<close> by auto\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_extendedV3": {"skill_name": "mathd_algebra_109_extendedV3", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\" \n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have eq_c: \"c = 12\" using h2 by simp\n  have simplified: \"12 + 2*b = 12\" using sub eq_c by simp\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\" \n    and h2 : \"c = 12\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have eq_c: \"c = 12\" using h2 by simp\n  have simplified: \"12 + 2*b = 12\" using sub eq_c by simp\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109V3": {"skill_name": "mathd_algebra_109V3", "marker": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have substitute: \"3*4 + 2*b = 12\" using h1 eq by simp\n  have \"12 + 2*b = 12\" using substitute by simp\n  have \"2*b = 0\" using `12 + 2*b = 12` by simp\n  have \"b = 0\" using `2*b = 0` by (simp add: field_simps)\n  show ?thesis using `b = 0` by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have substitute: \"3*4 + 2*b = 12\" using h1 eq by simp\n  have \"12 + 2*b = 12\" using substitute by simp\n  have \"2*b = 0\" using `12 + 2*b = 12` by simp\n  have \"b = 0\" using `2*b = 0` by (simp add: field_simps)\n  show ?thesis using `b = 0` by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109V4": {"skill_name": "mathd_algebra_109V4", "marker": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  hence \"12 + 2*b = 12\" by simp\n  thus \"b = 0\" by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  hence \"12 + 2*b = 12\" by simp\n  thus \"b = 0\" by (simp add: algebra_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "inequality_manipulation": {"skill_name": "inequality_manipulation", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"a < b\" using assms(1) by assumption\n  have \"c > 0\" using assms(2) by assumption\n  from this and `a < b` have \"a * c < b * c\"\n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"a < b\" using assms(1) by assumption\n  have \"c > 0\" using assms(2) by assumption\n  from this and `a < b` have \"a * c < b * c\"\n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "inequality_manipulationV2": {"skill_name": "inequality_manipulationV2", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: field_simps)\n  then have \"b - a = (b - a) * 1\" by simp\n  moreover have \"1 * c > 0\" using assms(2) by simp\n  ultimately have \"(b - a) * c > 0\" by (metis \\<open>0 < b - a\\<close> assms(2) mult.commute mult_pos_pos)\n  thus ?thesis using `b - a > 0` by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: field_simps)\n  then have \"b - a = (b - a) * 1\" by simp\n  moreover have \"1 * c > 0\" using assms(2) by simp\n  ultimately have \"(b - a) * c > 0\" by (metis \\<open>0 < b - a\\<close> assms(2) mult.commute mult_pos_pos)\n  thus ?thesis using `b - a > 0` by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "inequality_manipulationV3": {"skill_name": "inequality_manipulationV3", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"c * (b - a) > 0\" using assms(2) by (simp add: mult_pos_pos)\n  then show ?thesis using `b - a > 0` by sos\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"c * (b - a) > 0\" using assms(2) by (simp add: mult_pos_pos)\n  then show ?thesis using `b - a > 0` by sos\nqed", "origin": "do_request", "update_count": 0}, "mod4_cases_expanded": {"skill_name": "mod4_cases_expanded", "marker": "lemma mod4_cases_expanded:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 \\<in> {0, 1, 2, 3}\" by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_cases_expanded:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 \\<in> {0, 1, 2, 3}\" by auto\n  thus ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "units_digit_square": {"skill_name": "units_digit_square", "marker": "lemma units_digit_square:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?d = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?d\" by auto\n  then show \"(?d)^2 mod 10 = (n^2 mod 10)\"\n  proof -\n    have \"n^2 = (10 * (n div 10) + ?d)^2\"\n      by (simp add: algebra_simps)\n    also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?d + ?d^2\"\n      by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n    also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\"\n      by (simp add: algebra_simps)\n    finally have \"n^2 = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" .\n    then have \"n^2 mod 10 = (?d^2 mod 10)\"\n      by (metis power_mod)\n    moreover have \"?d^2 mod 10 = (?d)^2 mod 10\" by simp\n    ultimately show \"(?d)^2 mod 10 = (n^2 mod 10)\" by simp\n  qed\nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?d = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?d\" by auto\n  then show \"(?d)^2 mod 10 = (n^2 mod 10)\"\n  proof -\n    have \"n^2 = (10 * (n div 10) + ?d)^2\"\n      by (simp add: algebra_simps)\n    also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?d + ?d^2\"\n      by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n    also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\"\n      by (simp add: algebra_simps)\n    finally have \"n^2 = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" .\n    then have \"n^2 mod 10 = (?d^2 mod 10)\"\n      by (metis power_mod)\n    moreover have \"?d^2 mod 10 = (?d)^2 mod 10\" by simp\n    ultimately show \"(?d)^2 mod 10 = (n^2 mod 10)\" by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "algebra_simplified_linear_eq": {"skill_name": "algebra_simplified_linear_eq", "marker": "theorem algebra_simplified_linear_eq:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n  shows \"e = 7 - x\"\nproof -\n  show ?thesis using h0 by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem algebra_simplified_linear_eq:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n  shows \"e = 7 - x\"\nproof -\n  show ?thesis using h0 by (auto simp: field_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "square_eq_extended": {"skill_name": "square_eq_extended", "marker": "lemma square_eq_extended:\n  fixes a b c :: real\n  assumes \"a = b\" \"c = 0\"\n  shows \"a^2 - c^2 = b^2 - c^2\"\nproof -\n  have \"a^2 = b^2\" using assms by (simp)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_eq_extended:\n  fixes a b c :: real\n  assumes \"a = b\" \"c = 0\"\n  shows \"a^2 - c^2 = b^2 - c^2\"\nproof -\n  have \"a^2 = b^2\" using assms by (simp)\n  thus ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "square_difference": {"skill_name": "square_difference", "marker": "lemma square_difference:\n  fixes a b :: real\n  shows \"a^2 - b^2 = (a - b) * (a + b)\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_difference:\n  fixes a b :: real\n  shows \"a^2 - b^2 = (a - b) * (a + b)\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  thus ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "units_digit_squareV2": {"skill_name": "units_digit_squareV2", "marker": "lemma units_digit_square:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?d = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?d\" by auto\n  then have \"n^2 = (10 * (n div 10) + ?d)^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?d + ?d^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" by (simp add: power2_eq_square)\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2) mod 10\" by simp\n  then have \"n^2 mod 10 = (?d^2 mod 10)\" by (metis power_mod)\n  then show \"(n mod 10)^2 mod 10 = (n^2 mod 10)\" by auto\nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?d = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?d\" by auto\n  then have \"n^2 = (10 * (n div 10) + ?d)^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?d + ?d^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" by (simp add: power2_eq_square)\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2) mod 10\" by simp\n  then have \"n^2 mod 10 = (?d^2 mod 10)\" by (metis power_mod)\n  then show \"(n mod 10)^2 mod 10 = (n^2 mod 10)\" by auto\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_3d": {"skill_name": "mathd_algebra_109_3d", "marker": "theorem mathd_algebra_109_3d:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b + c = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 0\"  \n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b + c = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b + 0 = 12\" using h1 h2 eq by simp\n  have simplified: \"12 + 2 * b = 12\" by (smt (verit) sub)\n  have isolate: \"2 * b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_3d:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b + c = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 0\"  \n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b + c = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b + 0 = 12\" using h1 h2 eq by simp\n  have simplified: \"12 + 2 * b = 12\" by (smt (verit) sub)\n  have isolate: \"2 * b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_solutionV3": {"skill_name": "linear_equation_solutionV3", "marker": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * d + 2 * b = c\" using h1 eq by simp\n  have isolate: \"2*b = c - 3*d\" using sub by simp\n  have solution: \"b = (c - 3*d) / 2\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * d + 2 * b = c\" using h1 eq by simp\n  have isolate: \"2*b = c - 3*d\" using sub by simp\n  have solution: \"b = (c - 3*d) / 2\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mod_n_casesV2": {"skill_name": "mod_n_casesV2", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n \\<in> {0..n-1}\"\nproof -\n  have \"a mod n < n\" by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)\n  moreover have \"a mod n \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n \\<in> {0..n-1}\"\nproof -\n  have \"a mod n < n\" by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)\n  moreover have \"a mod n \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff)\n  ultimately show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "congruence_properties": {"skill_name": "congruence_properties", "marker": "lemma congruence_properties:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis assms(1) assms(2) mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = (a div m) * m + b\" using assms(1) by auto\n  have \"c = (c div m) * m + d\" using assms(2) by auto\n  have \"a + c = ((a div m) + (c div m)) * m + (b + d)\"\n    by (smt (verit) \\<open>a = a div m * m + b\\<close> \\<open>c = c div m * m + d\\<close> ab_semigroup_add_class.add_ac(1) add.commute combine_common_factor group_cancel.add1)\n  then have \"(a + c) mod m = (((a div m) + (c div m)) * m + (b + d)) mod m\"\n    by simp\n  also have \"... = (b + d) mod m\"\n    by auto\n  finally show ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma congruence_properties:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis assms(1) assms(2) mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = (a div m) * m + b\" using assms(1) by auto\n  have \"c = (c div m) * m + d\" using assms(2) by auto\n  have \"a + c = ((a div m) + (c div m)) * m + (b + d)\"\n    by (smt (verit) \\<open>a = a div m * m + b\\<close> \\<open>c = c div m * m + d\\<close> ab_semigroup_add_class.add_ac(1) add.commute combine_common_factor group_cancel.add1)\n  then have \"(a + c) mod m = (((a div m) + (c div m)) * m + (b + d)) mod m\"\n    by simp\n  also have \"... = (b + d) mod m\"\n    by auto\n  finally show ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "congruence_propertiesV2": {"skill_name": "congruence_propertiesV2", "marker": "lemma congruence_properties:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis assms(1) assms(2) mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = b + (a div m) * m\" and \"c = d + (c div m) * m\"\n    using assms by auto\n  have \"a + c = (b + (a div m) * m) + (d + (c div m) * m)\"\n    by (metis \\<open>a = b + a div m * m\\<close> \\<open>c = d + c div m * m\\<close>)\n  then have \"a + c = (b + d) + ((a div m) + (c div m)) * m\"\n    by (simp add: algebra_simps)\n  then show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma congruence_properties:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis assms(1) assms(2) mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = b + (a div m) * m\" and \"c = d + (c div m) * m\"\n    using assms by auto\n  have \"a + c = (b + (a div m) * m) + (d + (c div m) * m)\"\n    by (metis \\<open>a = b + a div m * m\\<close> \\<open>c = d + c div m * m\\<close>)\n  then have \"a + c = (b + d) + ((a div m) + (c div m)) * m\"\n    by (simp add: algebra_simps)\n  then show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "sum_partitionV2": {"skill_name": "sum_partitionV2", "marker": "lemma sum_partition:\n  fixes n :: nat\n  fixes x y a b c :: real\n  assumes \"x + y = n\"\n  shows \"x * a + y * b = c \\<Longrightarrow> (x + y) * a + y * (b - a) = c\"\nproof -\n  assume hyp: \"x * a + y * b = c\"\n  have \"(x + y) * a + y * (b - a) = (x + y) * a + y * b - y * a\"\n    by (simp add: algebra_simps)\n  also have \"... = (x + y) * a + (c - x * a) - y * a\"\n    using hyp by (simp add: algebra_simps)\n  also have \"... = (x + y) * a - y * a + c - x * a\"\n    by (simp add: algebra_simps)\n  also have \"... = (x + y - y) * a + c - x * a\"\n    by (simp add: algebra_simps)\n  also have \"... = c\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma sum_partition:\n  fixes n :: nat\n  fixes x y a b c :: real\n  assumes \"x + y = n\"\n  shows \"x * a + y * b = c \\<Longrightarrow> (x + y) * a + y * (b - a) = c\"\nproof -\n  assume hyp: \"x * a + y * b = c\"\n  have \"(x + y) * a + y * (b - a) = (x + y) * a + y * b - y * a\"\n    by (simp add: algebra_simps)\n  also have \"... = (x + y) * a + (c - x * a) - y * a\"\n    using hyp by (simp add: algebra_simps)\n  also have \"... = (x + y) * a - y * a + c - x * a\"\n    by (simp add: algebra_simps)\n  also have \"... = (x + y - y) * a + c - x * a\"\n    by (simp add: algebra_simps)\n  also have \"... = c\"\n    by (simp add: algebra_simps)\n  finally show ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "congruence_propertiesV3": {"skill_name": "congruence_propertiesV3", "marker": "lemma congruence_properties:\n  fixes a b c d :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  let ?x = \"a mod m\"\n  let ?y = \"c mod m\"\n  have \"a = ?x + (a div m) * m\" and \"c = ?y + (c div m) * m\"\n    by auto\n  then have \"a + c = (?x + ?y) + ((a div m) + (c div m)) * m\"\n    by (simp add: algebra_simps)\n  then have \"(a + c) mod m = ((?x + ?y) + ((a div m) + (c div m)) * m) mod m\"\n    by simp\n  also have \"... = (?x + ?y) mod m\"\n    by auto\n  have \"?x = b\" and \"?y = d\" using assms by auto\n  then show ?thesis\n    by (metis mod_add_cong mod_add_eq)\nqed", "description": "-", "full_code": "lemma congruence_properties:\n  fixes a b c d :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  let ?x = \"a mod m\"\n  let ?y = \"c mod m\"\n  have \"a = ?x + (a div m) * m\" and \"c = ?y + (c div m) * m\"\n    by auto\n  then have \"a + c = (?x + ?y) + ((a div m) + (c div m)) * m\"\n    by (simp add: algebra_simps)\n  then have \"(a + c) mod m = ((?x + ?y) + ((a div m) + (c div m)) * m) mod m\"\n    by simp\n  also have \"... = (?x + ?y) mod m\"\n    by auto\n  have \"?x = b\" and \"?y = d\" using assms by auto\n  then show ?thesis\n    by (metis mod_add_cong mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_110": {"skill_name": "mathd_algebra_110", "marker": "theorem mathd_algebra_110:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have simplified: \"12 + 2*b = c\" by (smt (verit) sub)\n  have isolate: \"2*b = c - 12\" using simplified by simp\n  thus ?thesis using isolate by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_110:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have simplified: \"12 + 2*b = c\" by (smt (verit) sub)\n  have isolate: \"2*b = c - 12\" using simplified by simp\n  thus ?thesis using isolate by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_110V2": {"skill_name": "mathd_algebra_110V2", "marker": "theorem mathd_algebra_110:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have simplified: \"12 + 2*b = c\" by (smt (verit) sub)\n  have isolate: \"2*b = c - 12\" using simplified by simp\n  have solution: \"b = (c - 12) / 2\" using isolate by (simp add: field_simps)\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_110:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have simplified: \"12 + 2*b = c\" by (smt (verit) sub)\n  have isolate: \"2*b = c - 12\" using simplified by simp\n  have solution: \"b = (c - 12) / 2\" using isolate by (simp add: field_simps)\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "square_mod": {"skill_name": "square_mod", "marker": "lemma square_mod:\n  fixes a :: int and n :: int\n  shows \"(a mod n)^2 mod n = (a^2 mod n)\"\nproof -\n  let ?d = \"a mod n\"\n  have \"a = n * (a div n) + ?d\" by auto\n  then have \"a^2 = (n * (a div n) + ?d)^2\" by simp\n  also have \"... = (n * (a div n))^2 + 2 * (n * (a div n)) * ?d + ?d^2\" by (smt (verit) power2_sum)\n  also have \"... = n^2 * (a div n)^2 + 2 * n * (a div n) * ?d + ?d^2\" by (simp add: power2_eq_square)\n  finally have \"a^2 = n^2 * (a div n)^2 + 2 * n * (a div n) * ?d + ?d^2\" .\n  then have \"a^2 mod n = (n^2 * (a div n)^2 + 2 * n * (a div n) * ?d + ?d^2) mod n\" by simp\n  then have \"a^2 mod n = (?d^2 mod n)\" by (metis minus_div_mult_eq_mod power_mod)\n  moreover have \"(?d)^2 mod n = (?d^2 mod n)\" by simp\n  ultimately show \"(a mod n)^2 mod n = (a^2 mod n)\" by simp\nqed", "description": "-", "full_code": "lemma square_mod:\n  fixes a :: int and n :: int\n  shows \"(a mod n)^2 mod n = (a^2 mod n)\"\nproof -\n  let ?d = \"a mod n\"\n  have \"a = n * (a div n) + ?d\" by auto\n  then have \"a^2 = (n * (a div n) + ?d)^2\" by simp\n  also have \"... = (n * (a div n))^2 + 2 * (n * (a div n)) * ?d + ?d^2\" by (smt (verit) power2_sum)\n  also have \"... = n^2 * (a div n)^2 + 2 * n * (a div n) * ?d + ?d^2\" by (simp add: power2_eq_square)\n  finally have \"a^2 = n^2 * (a div n)^2 + 2 * n * (a div n) * ?d + ?d^2\" .\n  then have \"a^2 mod n = (n^2 * (a div n)^2 + 2 * n * (a div n) * ?d + ?d^2) mod n\" by simp\n  then have \"a^2 mod n = (?d^2 mod n)\" by (metis minus_div_mult_eq_mod power_mod)\n  moreover have \"(?d)^2 mod n = (?d^2 mod n)\" by simp\n  ultimately show \"(a mod n)^2 mod n = (a^2 mod n)\" by simp\nqed", "origin": "do_request", "update_count": 0}, "square_modV2": {"skill_name": "square_modV2", "marker": "lemma square_mod:\n  fixes a :: int and n :: int\n  shows \"(a mod n)^2 mod n = (a^2 mod n)\"\nproof -\n  let ?m = \"a mod n\"\n  have \"a = n * (a div n) + ?m\" by auto\n  then have \"a^2 = (n * (a div n) + ?m)^2\" by simp\n  also have \"... = (n * (a div n))^2 + 2 * (n * (a div n)) * ?m + ?m^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2\" by (simp add: power2_eq_square)\n  finally have \"a^2 = n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2\" .\n  then have \"a^2 mod n = (n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2) mod n\" by simp\n  also have \"... = (?m^2 mod n)\" by (metis calculation power_mod)\n  finally have \"a^2 mod n = (?m^2 mod n)\" .\n  have \"?m^2 mod n = (?m)^2 mod n\" by simp\n  thus \"(a mod n)^2 mod n = (a^2 mod n)\" by (metis power_mod)\nqed", "description": "-", "full_code": "lemma square_mod:\n  fixes a :: int and n :: int\n  shows \"(a mod n)^2 mod n = (a^2 mod n)\"\nproof -\n  let ?m = \"a mod n\"\n  have \"a = n * (a div n) + ?m\" by auto\n  then have \"a^2 = (n * (a div n) + ?m)^2\" by simp\n  also have \"... = (n * (a div n))^2 + 2 * (n * (a div n)) * ?m + ?m^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2\" by (simp add: power2_eq_square)\n  finally have \"a^2 = n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2\" .\n  then have \"a^2 mod n = (n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2) mod n\" by simp\n  also have \"... = (?m^2 mod n)\" by (metis calculation power_mod)\n  finally have \"a^2 mod n = (?m^2 mod n)\" .\n  have \"?m^2 mod n = (?m)^2 mod n\" by simp\n  thus \"(a mod n)^2 mod n = (a^2 mod n)\" by (metis power_mod)\nqed", "origin": "do_request", "update_count": 0}, "linear_function_differenceV3": {"skill_name": "linear_function_differenceV3", "marker": "theorem linear_function_difference:\n  fixes a b x1 x2 :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n    and \"f x2 - f x1 = c\"\n  shows \"f (x1 + d) - f x1 = (d * a)\"\nproof -\n  have \"f x2 - f x1 = (a * x2 + b) - (a * x1 + b)\" by (simp add: assms(1))\n  have \"f x2 - f x1 = (a * x2 - a * x1)\" by (simp add: assms(1))\n  then have \"f x2 - f x1 = a * (x2 - x1)\" by (simp add: algebra_simps)\n  have \"a * (x2 - x1) = c\" using assms(2) by (metis \\<open>f x2 - f x1 = a * (x2 - x1)\\<close> mult_delta_right)\n  have \"f (x1 + d) - f x1 = (a * (x1 + d) + b) - (a * x1 + b)\" by (simp add: assms(1))\n  have \"f (x1 + d) - f x1 = a * (x1 + d - x1)\" by (smt (verit) \\<open>f (x1 + d) - f x1 = a * (x1 + d) + b - (a * x1 + b)\\<close> add_diff_add right_diff_distrib)\n  have \"f (x1 + d) - f x1 = a * d\" by (metis \\<open>f (x1 + d) - f x1 = a * (x1 + d - x1)\\<close> add.commute add_diff_cancel mult_delta_right)\n  thus ?thesis by (simp)\nqed", "description": "-", "full_code": "theorem linear_function_difference:\n  fixes a b x1 x2 :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n    and \"f x2 - f x1 = c\"\n  shows \"f (x1 + d) - f x1 = (d * a)\"\nproof -\n  have \"f x2 - f x1 = (a * x2 + b) - (a * x1 + b)\" by (simp add: assms(1))\n  have \"f x2 - f x1 = (a * x2 - a * x1)\" by (simp add: assms(1))\n  then have \"f x2 - f x1 = a * (x2 - x1)\" by (simp add: algebra_simps)\n  have \"a * (x2 - x1) = c\" using assms(2) by (metis \\<open>f x2 - f x1 = a * (x2 - x1)\\<close> mult_delta_right)\n  have \"f (x1 + d) - f x1 = (a * (x1 + d) + b) - (a * x1 + b)\" by (simp add: assms(1))\n  have \"f (x1 + d) - f x1 = a * (x1 + d - x1)\" by (smt (verit) \\<open>f (x1 + d) - f x1 = a * (x1 + d) + b - (a * x1 + b)\\<close> add_diff_add right_diff_distrib)\n  have \"f (x1 + d) - f x1 = a * d\" by (metis \\<open>f (x1 + d) - f x1 = a * (x1 + d - x1)\\<close> add.commute add_diff_cancel mult_delta_right)\n  thus ?thesis by (simp)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "linear_difference": {"skill_name": "linear_difference", "marker": "theorem linear_difference:\n  fixes a b x y :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n    and \"f y - f x = d\"\n  shows \"f (y + (y - x)) - f x = 2 * d\"\nproof -\n  have \"f y - f x = (a * y + b) - (a * x + b)\" by (simp add: assms(1))\n  have \"f y - f x = a * (y - x)\" by (smt (verit) \\<open>f y - f x = a * y + b - (a * x + b)\\<close> add_diff_add right_diff_distrib')\n  then have \"d = a * (y - x)\" using assms(2) by simp\n  have \"f (y + (y - x)) - f x = (a * (y + (y - x)) + b) - (a * x + b)\" by (simp add: assms(1))\n  have \"f (y + (y - x)) - f x = a * (y + (y - x) - x)\" by (smt (verit) \\<open>f (y + (y - x)) - f x = a * (y + (y - x)) + b - (a * x + b)\\<close> add_implies_diff diff_add_eq_diff_diff_swap right_diff_distrib)\n  have \"f (y + (y - x)) - f x = a * (y - x + (y - x))\" by (metis \\<open>f (y + (y - x)) - f x = a * (y + (y - x) - x)\\<close> add_diff_add diff_diff_eq group_cancel.sub1)\n  have \"f (y + (y - x)) - f x = 2 * a * (y - x)\" by (metis \\<open>f (y + (y - x)) - f x = a * (y - x + (y - x))\\<close> assms(1) mult.assoc mult.left_commute mult_2)\n  then show ?thesis by (smt (verit) \\<open>f (y + (y - x)) - f x = a * (y - x + (y - x))\\<close> \\<open>f y - f x = a * (y - x)\\<close> assms(2) distrib_left mult_2)\nqed", "description": "-", "full_code": "theorem linear_difference:\n  fixes a b x y :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n    and \"f y - f x = d\"\n  shows \"f (y + (y - x)) - f x = 2 * d\"\nproof -\n  have \"f y - f x = (a * y + b) - (a * x + b)\" by (simp add: assms(1))\n  have \"f y - f x = a * (y - x)\" by (smt (verit) \\<open>f y - f x = a * y + b - (a * x + b)\\<close> add_diff_add right_diff_distrib')\n  then have \"d = a * (y - x)\" using assms(2) by simp\n  have \"f (y + (y - x)) - f x = (a * (y + (y - x)) + b) - (a * x + b)\" by (simp add: assms(1))\n  have \"f (y + (y - x)) - f x = a * (y + (y - x) - x)\" by (smt (verit) \\<open>f (y + (y - x)) - f x = a * (y + (y - x)) + b - (a * x + b)\\<close> add_implies_diff diff_add_eq_diff_diff_swap right_diff_distrib)\n  have \"f (y + (y - x)) - f x = a * (y - x + (y - x))\" by (metis \\<open>f (y + (y - x)) - f x = a * (y + (y - x) - x)\\<close> add_diff_add diff_diff_eq group_cancel.sub1)\n  have \"f (y + (y - x)) - f x = 2 * a * (y - x)\" by (metis \\<open>f (y + (y - x)) - f x = a * (y - x + (y - x))\\<close> assms(1) mult.assoc mult.left_commute mult_2)\n  then show ?thesis by (smt (verit) \\<open>f (y + (y - x)) - f x = a * (y - x + (y - x))\\<close> \\<open>f y - f x = a * (y - x)\\<close> assms(2) distrib_left mult_2)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "mathd_algebra_109_extendedV4": {"skill_name": "mathd_algebra_109_extendedV4", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n    and h2 : \"c = 12\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3*d + 2*b = c\" using h1 eq by simp\n  have simplified: \"3*d + 2*b = 12\" using h2 sub by simp\n  have isolate: \"2*b = 12 - 3*d\" using simplified by simp\n  have solution: \"b = (12 - 3*d) / 2\" using isolate by simp\n  show ?thesis using solution by (metis dbl_inc_simps(3) dbl_simps(3) h1 h2)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = d\"\n    and h2 : \"c = 12\"\n  shows \"b = (c - 3*d) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3*d + 2*b = c\" using h1 eq by simp\n  have simplified: \"3*d + 2*b = 12\" using h2 sub by simp\n  have isolate: \"2*b = 12 - 3*d\" using simplified by simp\n  have solution: \"b = (12 - 3*d) / 2\" using isolate by simp\n  show ?thesis using solution by (metis dbl_inc_simps(3) dbl_simps(3) h1 h2)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_system_solution": {"skill_name": "linear_system_solution", "marker": "theorem linear_system_solution:\n  fixes a b c :: real\n  assumes h0: \"3*a + 2*b = c\"\n    and h1: \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have simplified: \"12 + 2*b = c\" using sub by simp\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "theorem linear_system_solution:\n  fixes a b c :: real\n  assumes h0: \"3*a + 2*b = c\"\n    and h1: \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have simplified: \"12 + 2*b = c\" using sub by simp\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mod4_product": {"skill_name": "mod4_product", "marker": "lemma mod4_product:\n  fixes a b :: int\n  shows \"(a mod 4 * b mod 4) mod 4 = (a * b) mod 4\"\nproof -\n  have \"a mod 4 = (a + 0) mod 4\" and \"b mod 4 = (0 + b) mod 4\" by simp_all\n  then have \"(a mod 4 * b mod 4) mod 4 = ((a + 0) * (0 + b)) mod 4\" by (metis add_cancel_left_left add_cancel_right_right mod_mod_trivial mod_mult_left_eq mult.commute)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_product:\n  fixes a b :: int\n  shows \"(a mod 4 * b mod 4) mod 4 = (a * b) mod 4\"\nproof -\n  have \"a mod 4 = (a + 0) mod 4\" and \"b mod 4 = (0 + b) mod 4\" by simp_all\n  then have \"(a mod 4 * b mod 4) mod 4 = ((a + 0) * (0 + b)) mod 4\" by (metis add_cancel_left_left add_cancel_right_right mod_mod_trivial mod_mult_left_eq mult.commute)\n  thus ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "mod4_sum": {"skill_name": "mod4_sum", "marker": "lemma mod4_sum:\n  fixes a b :: int\n  shows \"(a mod 4 + b mod 4) mod 4 = (a + b) mod 4\"\nproof -\n  have \"a mod 4 = (a + 0) mod 4\" and \"b mod 4 = (0 + b) mod 4\" by simp_all\n  then have \"(a mod 4 + b mod 4) mod 4 = ((a + 0) + (0 + b)) mod 4\" by presburger\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_sum:\n  fixes a b :: int\n  shows \"(a mod 4 + b mod 4) mod 4 = (a + b) mod 4\"\nproof -\n  have \"a mod 4 = (a + 0) mod 4\" and \"b mod 4 = (0 + b) mod 4\" by simp_all\n  then have \"(a mod 4 + b mod 4) mod 4 = ((a + 0) + (0 + b)) mod 4\" by presburger\n  thus ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "mod4_remainder_properties": {"skill_name": "mod4_remainder_properties", "marker": "lemma mod4_remainder_properties:\n  fixes a b :: int\n  shows \"a mod 4 = b mod 4 \\<Longrightarrow> (a - b) mod 4 = 0\"\n  by presburger", "description": "-", "full_code": "lemma mod4_remainder_properties:\n  fixes a b :: int\n  shows \"a mod 4 = b mod 4 \\<Longrightarrow> (a - b) mod 4 = 0\"\n  by presburger", "origin": "mod4_cases", "update_count": 0}, "square_root_inequality": {"skill_name": "square_root_inequality", "marker": "lemma square_root_inequality:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt(a) * sqrt(b) <= (sqrt(a + b))^2\"\nproof -\n  have \"sqrt(a) * sqrt(b) = sqrt(a * b)\" by (metis real_sqrt_mult)\n  also have \"... <= sqrt((a + b) * (a + b))\" using \\<open>a >= 0\\<close> \\<open>b >= 0\\<close> by (auto simp: field_simps)\n  finally show ?thesis by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_root_inequality:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt(a) * sqrt(b) <= (sqrt(a + b))^2\"\nproof -\n  have \"sqrt(a) * sqrt(b) = sqrt(a * b)\" by (metis real_sqrt_mult)\n  also have \"... <= sqrt((a + b) * (a + b))\" using \\<open>a >= 0\\<close> \\<open>b >= 0\\<close> by (auto simp: field_simps)\n  finally show ?thesis by (simp add: power2_eq_square)\nqed", "origin": "square_eq", "update_count": 0}, "square_eqV2": {"skill_name": "square_eqV2", "marker": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = b * b\" using assms by sos\n  thus ?thesis by (simp add: assms)\nqed", "description": "-", "full_code": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = b * b\" using assms by sos\n  thus ?thesis by (simp add: assms)\nqed", "origin": "square_eq", "update_count": 0}, "square_abs_eq": {"skill_name": "square_abs_eq", "marker": "lemma square_abs_eq:\n  fixes a :: real\n  shows \"a^2 = abs(a)^2\"\nproof -\n  show ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_abs_eq:\n  fixes a :: real\n  shows \"a^2 = abs(a)^2\"\nproof -\n  show ?thesis by auto\nqed", "origin": "square_eq", "update_count": 0}, "mod_additionV3": {"skill_name": "mod_additionV3", "marker": "lemma mod_addition:\n  fixes a b n x y :: nat\n  assumes \"a mod n = x\" and \"b mod n = y\"\n  shows \"(a + b) mod n = (x + y) mod n\"\nproof -\n  let ?x = \"a mod n\"\n  let ?y = \"b mod n\"\n  have \"a = ?x + (a div n) * n\" and \"b = ?y + (b div n) * n\"\n    by auto\n  then have \"a + b = (?x + ?y) + ((a div n) + (b div n)) * n\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod n = ((?x + ?y) + ((a div n) + (b div n)) * n) mod n\"\n    by simp\n  also have \"... = (?x + ?y) mod n\"\n    by auto\n  also have \"... = (x + y) mod n\"\n    using assms by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b n x y :: nat\n  assumes \"a mod n = x\" and \"b mod n = y\"\n  shows \"(a + b) mod n = (x + y) mod n\"\nproof -\n  let ?x = \"a mod n\"\n  let ?y = \"b mod n\"\n  have \"a = ?x + (a div n) * n\" and \"b = ?y + (b div n) * n\"\n    by auto\n  then have \"a + b = (?x + ?y) + ((a div n) + (b div n)) * n\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod n = ((?x + ?y) + ((a div n) + (b div n)) * n) mod n\"\n    by simp\n  also have \"... = (?x + ?y) mod n\"\n    by auto\n  also have \"... = (x + y) mod n\"\n    using assms by auto\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "linear_system_solutionV2": {"skill_name": "linear_system_solutionV2", "marker": "theorem linear_system_solution:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "theorem linear_system_solution:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "linear_combinationV2": {"skill_name": "linear_combinationV2", "marker": "lemma linear_combination:\n  fixes a b x e :: real\n  assumes h0: \"x + e = a\"\n    and h1: \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - e) / 2\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a) / 1\" using simplified_eq by auto\n  then show ?thesis using e_eq x_value by simp\nqed", "description": "-", "full_code": "lemma linear_combination:\n  fixes a b x e :: real\n  assumes h0: \"x + e = a\"\n    and h1: \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - e) / 2\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a) / 1\" using simplified_eq by auto\n  then show ?thesis using e_eq x_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "square_eq_sym": {"skill_name": "square_eq_sym", "marker": "lemma square_eq_sym:\n  fixes a b :: real\n  assumes \"a^2 = b^2\"\n  shows \"a = b \\<or> a = -b\"\nproof -\n  have \"a^2 - b^2 = 0\" using assms by simp\n  then have \"0 = (a - b) * (a + b)\" by (simp add: squares_diff)\n  hence \"a - b = 0 \\<or> a + b = 0\" by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma squares_diff:\n  fixes a b :: real\n  shows \"a^2 - b^2 = (a - b) * (a + b)\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  thus ?thesis by simp\nqed\n\nlemma square_eq_sym:\n  fixes a b :: real\n  assumes \"a^2 = b^2\"\n  shows \"a = b \\<or> a = -b\"\nproof -\n  have \"a^2 - b^2 = 0\" using assms by simp\n  then have \"0 = (a - b) * (a + b)\" by (simp add: squares_diff)\n  hence \"a - b = 0 \\<or> a + b = 0\" by auto\n  thus ?thesis by auto\nqed", "origin": "square_eq", "update_count": 0}, "square_root_property": {"skill_name": "square_root_property", "marker": "lemma square_root_property:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt(x^2) = x\"\nproof -\n  have \"sqrt(x^2) = sqrt((abs x)^2)\" using assms by (simp add: abs_if)\n  also have \"... = abs x\" by auto\n  finally show ?thesis using assms by (simp add: abs_if)\nqed", "description": "-", "full_code": "lemma square_root_property:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt(x^2) = x\"\nproof -\n  have \"sqrt(x^2) = sqrt((abs x)^2)\" using assms by (simp add: abs_if)\n  also have \"... = abs x\" by auto\n  finally show ?thesis using assms by (simp add: abs_if)\nqed", "origin": "square_eq", "update_count": 0}, "square_nonneg": {"skill_name": "square_nonneg", "marker": "lemma square_nonneg:\n  fixes x :: real\n  shows \"x^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  thus ?thesis by (simp add: mult_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes x :: real\n  shows \"x^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  thus ?thesis by (simp add: mult_nonneg_nonneg)\nqed", "origin": "square_eq", "update_count": 0}, "square_eq_extendedV2": {"skill_name": "square_eq_extendedV2", "marker": "lemma square_eq_extended:\n  fixes a b c d :: real\n  assumes \"a = b\" \"c = d\"\n  shows \"a^2 + c^2 = b^2 + d^2\"\nproof -\n  have \"a^2 + c^2 = b^2 + c^2\" using assms(1) by simp\n  also have \"... = b^2 + d^2\" using assms(2) by simp\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_eq_extended:\n  fixes a b c d :: real\n  assumes \"a = b\" \"c = d\"\n  shows \"a^2 + c^2 = b^2 + d^2\"\nproof -\n  have \"a^2 + c^2 = b^2 + c^2\" using assms(1) by simp\n  also have \"... = b^2 + d^2\" using assms(2) by simp\n  finally show ?thesis .\nqed", "origin": "square_eq", "update_count": 0}, "amc12b_2003_p9_ext": {"skill_name": "amc12b_2003_p9_ext", "marker": "theorem amc12b_2003_p9_ext:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f (k + 6) - f (k + 2) = 4 * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  let ?k = \"k\"\n  have \"f (?k + 6) - f (?k + 2) = (a * (?k + 6) + b) - (a * (?k + 2) + b)\"\n    by (simp add: assms(1))\n  also have \"... = a * (?k + 6) - a * (?k + 2)\" by simp\n  also have \"... = a * ((?k + 6) - (?k + 2))\" by (simp add: algebra_simps)\n  also have \"... = a * 4\" by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9_ext:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f (k + 6) - f (k + 2) = 4 * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  let ?k = \"k\"\n  have \"f (?k + 6) - f (?k + 2) = (a * (?k + 6) + b) - (a * (?k + 2) + b)\"\n    by (simp add: assms(1))\n  also have \"... = a * (?k + 6) - a * (?k + 2)\" by simp\n  also have \"... = a * ((?k + 6) - (?k + 2))\" by (simp add: algebra_simps)\n  also have \"... = a * 4\" by simp\n  finally show ?thesis by simp\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "mathd_algebra_n_dimensions": {"skill_name": "mathd_algebra_n_dimensions", "marker": "theorem mathd_algebra_n_dimensions:\n  fixes a :: \"real list\" and b :: \"real list\"\n  assumes \"length a = n\" \"length b = n\" \"(\\<Sum>i=0..n-1. a ! i + b ! i) = c\" \n  shows \"(\\<Sum>i=0..n-1. b ! i) = c - (\\<Sum>i=0..n-1. a ! i)\"\nproof -\n  have sum_a: \"(\\<Sum>i=0..n-1. a ! i) + (\\<Sum>i=0..n-1. b ! i) = c\" using assms(3) by (metis sum.distrib)\n  hence \"(\\<Sum>i=0..n-1. b ! i) = c - (\\<Sum>i=0..n-1. a ! i)\" by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_n_dimensions:\n  fixes a :: \"real list\" and b :: \"real list\"\n  assumes \"length a = n\" \"length b = n\" \"(\\<Sum>i=0..n-1. a ! i + b ! i) = c\" \n  shows \"(\\<Sum>i=0..n-1. b ! i) = c - (\\<Sum>i=0..n-1. a ! i)\"\nproof -\n  have sum_a: \"(\\<Sum>i=0..n-1. a ! i) + (\\<Sum>i=0..n-1. b ! i) = c\" using assms(3) by (metis sum.distrib)\n  hence \"(\\<Sum>i=0..n-1. b ! i) = c - (\\<Sum>i=0..n-1. a ! i)\" by auto\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e a b :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = b - a\" using simplified_eq by (simp add: field_simps)\n  show ?thesis using x_value e_eq by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e a b :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = b - a\" using simplified_eq by (simp add: field_simps)\n  show ?thesis using x_value e_eq by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "mod_n_casesV3": {"skill_name": "mod_n_casesV3", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. r < n \\<and> (a mod n = r)\"\nproof -\n  obtain r where \"0 \\<le> r \\<and> r < n \\<and> a mod n = r\" \n    using assms by (metis Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign bot_nat_0.extremum dual_order.refl nat_less_iff nat_zero_as_int of_nat_less_iff zero_le_imp_eq_int)\n  thus ?thesis by blast\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. r < n \\<and> (a mod n = r)\"\nproof -\n  obtain r where \"0 \\<le> r \\<and> r < n \\<and> a mod n = r\" \n    using assms by (metis Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign bot_nat_0.extremum dual_order.refl nat_less_iff nat_zero_as_int of_nat_less_iff zero_le_imp_eq_int)\n  thus ?thesis by blast\nqed", "origin": "mod4_cases", "update_count": 0}, "linear_function_differenceV4": {"skill_name": "linear_function_differenceV4", "marker": "theorem linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x - f y = d\"\n  shows \"f u - f v = (u - v) * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f u - f v = (a * u + b) - (a * v + b)\" by (simp add: assms(1))\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "theorem linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x - f y = d\"\n  shows \"f u - f v = (u - v) * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f u - f v = (a * u + b) - (a * v + b)\" by (simp add: assms(1))\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "linear_function_differenceV5": {"skill_name": "linear_function_differenceV5", "marker": "theorem linear_function_difference:\n  fixes a b x y :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> z. f z = a * z + b\"\n    and \"f x - f y = c\"\n  shows \"f (x + d) - f y = (a * d + c)\"\nproof -\n  have \"f z = a * z + b\" for z by (simp add: assms(1))\n  have \"f x - f y = (a * x + b) - (a * y + b)\" by (simp add: assms(1))\n  have \"f x - f y = a * (x - y)\" by (smt (verit) \\<open>f x - f y = a * x + b - (a * y + b)\\<close> add_diff_add right_diff_distrib')\n  then have \"a * (x - y) = c\" using assms(2) by simp\n  have \"f (x + d) - f y = (a * (x + d) + b) - (a * y + b)\" by (simp add: assms(1))\n  have \"f (x + d) - f y = a * (x + d) - a * y\" by (smt (verit) \\<open>f (x + d) - f y = a * (x + d) + b - (a * y + b)\\<close>)\n  have \"f (x + d) - f y = a * (x - y + d)\" by (metis \\<open>f (x + d) - f y = a * (x + d) - a * y\\<close> add.commute add_diff_eq diff_diff_eq2 mult_delta_right right_diff_distrib')\n  then show ?thesis by (smt (verit) \\<open>f x - f y = a * (x - y)\\<close> add.commute assms(2) ring_class.ring_distribs(1))\nqed", "description": "-", "full_code": "theorem linear_function_difference:\n  fixes a b x y :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> z. f z = a * z + b\"\n    and \"f x - f y = c\"\n  shows \"f (x + d) - f y = (a * d + c)\"\nproof -\n  have \"f z = a * z + b\" for z by (simp add: assms(1))\n  have \"f x - f y = (a * x + b) - (a * y + b)\" by (simp add: assms(1))\n  have \"f x - f y = a * (x - y)\" by (smt (verit) \\<open>f x - f y = a * x + b - (a * y + b)\\<close> add_diff_add right_diff_distrib')\n  then have \"a * (x - y) = c\" using assms(2) by simp\n  have \"f (x + d) - f y = (a * (x + d) + b) - (a * y + b)\" by (simp add: assms(1))\n  have \"f (x + d) - f y = a * (x + d) - a * y\" by (smt (verit) \\<open>f (x + d) - f y = a * (x + d) + b - (a * y + b)\\<close>)\n  have \"f (x + d) - f y = a * (x - y + d)\" by (metis \\<open>f (x + d) - f y = a * (x + d) - a * y\\<close> add.commute add_diff_eq diff_diff_eq2 mult_delta_right right_diff_distrib')\n  then show ?thesis by (smt (verit) \\<open>f x - f y = a * (x - y)\\<close> add.commute assms(2) ring_class.ring_distribs(1))\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "mod_10_units_digit": {"skill_name": "mod_10_units_digit", "marker": "lemma mod_10_units_digit:\n  fixes n :: nat\n  shows \"n mod 10 = (n mod 10)\"\nproof -\n  show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_10_units_digit:\n  fixes n :: nat\n  shows \"n mod 10 = (n mod 10)\"\nproof -\n  show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_10_units_digitV2": {"skill_name": "mod_10_units_digitV2", "marker": "lemma mod_10_units_digit:\n  fixes n :: nat\n  shows \"n mod 10 = (n mod 10)\"\nproof -\n  have \"n mod 10 = n mod 10\" by simp\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma mod_10_units_digit:\n  fixes n :: nat\n  shows \"n mod 10 = (n mod 10)\"\nproof -\n  have \"n mod 10 = n mod 10\" by simp\n  thus ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_simple": {"skill_name": "mathd_algebra_109_simple", "marker": "theorem mathd_algebra_109_simple:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = 12\"\n      and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * 4 + 2 * b = 12\" using h1 h0 by simp\n  thus \"b = 0\" by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_simple:\n  fixes a b :: real\n  assumes h0: \"3 * a + 2 * b = 12\"\n      and h1: \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * 4 + 2 * b = 12\" using h1 h0 by simp\n  thus \"b = 0\" by (simp add: algebra_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_linear_equations": {"skill_name": "solve_linear_equations", "marker": "theorem solve_linear_equations:\n  fixes a b x :: real\n  assumes eq1: \"3 * a + 2 * b = 12\"\n    and eq2: \"a = x\"\n  shows \"b = (12 - 3 * x) / 2\"\nproof -\n  have \"3 * a + 2 * b = 12\" using eq1 by simp\n  then have \"3 * x + 2 * b = 12\" using eq2 by simp\n  hence \"2 * b = 12 - 3 * x\" by simp\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem solve_linear_equations:\n  fixes a b x :: real\n  assumes eq1: \"3 * a + 2 * b = 12\"\n    and eq2: \"a = x\"\n  shows \"b = (12 - 3 * x) / 2\"\nproof -\n  have \"3 * a + 2 * b = 12\" using eq1 by simp\n  then have \"3 * x + 2 * b = 12\" using eq2 by simp\n  hence \"2 * b = 12 - 3 * x\" by simp\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "amc12b_2003_p9V2": {"skill_name": "amc12b_2003_p9V2", "marker": "theorem amc12b_2003_p9:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f 6 - f 2 = a * (6 - 2)\" using linear_function_difference assms by simp\n  then have \"12 = 4 * a\" using `f 6 - f 2 = 12` by (simp)\n  then have \"a = 3\" by simp\n  have \"f 12 - f 2 = a * (12 - 2)\" using linear_function_difference assms by simp\n  then show ?thesis using `a = 3` by simp\nqed", "description": "-", "full_code": "lemma linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  have \"f x - f y = (a * x + b) - (a * y + b)\" using assms by simp\n  then show ?thesis by (auto simp: field_simps)\nqed\n\ntheorem amc12b_2003_p9:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f 6 - f 2 = a * (6 - 2)\" using linear_function_difference assms by simp\n  then have \"12 = 4 * a\" using `f 6 - f 2 = 12` by (simp)\n  then have \"a = 3\" by simp\n  have \"f 12 - f 2 = a * (12 - 2)\" using linear_function_difference assms by simp\n  then show ?thesis using `a = 3` by simp\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "linear_function_differenceV6": {"skill_name": "linear_function_differenceV6", "marker": "lemma linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  fix x y :: real\n  have \"f x - f y = (a * x + b) - (a * y + b)\" using assms by simp\n  then have \"f x - f y = a * x - a * y\" by simp\n  then show ?thesis by (smt (verit) assms right_diff_distrib')\nqed", "description": "-", "full_code": "lemma linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  fix x y :: real\n  have \"f x - f y = (a * x + b) - (a * y + b)\" using assms by simp\n  then have \"f x - f y = a * x - a * y\" by simp\n  then show ?thesis by (smt (verit) assms right_diff_distrib')\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "linear_function_differenceV7": {"skill_name": "linear_function_differenceV7", "marker": "lemma linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  have \"f x - f y = (a * x + b) - (a * y + b)\" by (simp add: assms)\n  also have \"... = a * x - a * y\" by (simp)\n  also have \"... = a * (x - y)\" by sos\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  have \"f x - f y = (a * x + b) - (a * y + b)\" by (simp add: assms)\n  also have \"... = a * x - a * y\" by (simp)\n  also have \"... = a * (x - y)\" by sos\n  finally show ?thesis by simp\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "linear_function_differenceV8": {"skill_name": "linear_function_differenceV8", "marker": "theorem linear_function_difference:\n  fixes a b x1 x2 :: real\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x2 - f x1 = (x2 - x1) * a\"\n  shows \"f (x1 + (x2 - x1)) - f x1 = (x2 - x1) * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  then show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem linear_function_difference:\n  fixes a b x1 x2 :: real\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x2 - f x1 = (x2 - x1) * a\"\n  shows \"f (x1 + (x2 - x1)) - f x1 = (x2 - x1) * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  then show ?thesis by (auto simp: field_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "linear_function_differenceV9": {"skill_name": "linear_function_differenceV9", "marker": "theorem linear_function_difference:\n  fixes a b x y :: real\n  assumes \"f x = a * x + b\" \"f y = a * y + b\"\n  shows \"f y - f x = a * (y - x)\"\nproof -\n  have \"f y - f x = (a * y + b) - (a * x + b)\" using assms by simp\n  then show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem linear_function_difference:\n  fixes a b x y :: real\n  assumes \"f x = a * x + b\" \"f y = a * y + b\"\n  shows \"f y - f x = a * (y - x)\"\nproof -\n  have \"f y - f x = (a * y + b) - (a * x + b)\" using assms by simp\n  then show ?thesis by (auto simp: field_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "calculate_2x_squared": {"skill_name": "calculate_2x_squared", "marker": "lemma calculate_2x_squared:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"2 * x^2 = (600 - 52 * sqrt 131) / 16\"\nproof -\n  have \"x^2 = ((13 - sqrt 131) / 4)^2\" using assms by blast\n  then have \"x^2 = (13 - sqrt 131)^2 / 16\" by (simp add: power_divide)\n  have \"(13 - sqrt 131)^2 = 13^2 - 2 * 13 * sqrt 131 + (sqrt 131)^2\" \n    by (smt (verit) diff_add_eq power2_diff)\n  then have \"(13 - sqrt 131)^2 = 169 - 26 * sqrt 131 + 131\" \n    by simp\n  then have \"(13 - sqrt 131)^2 = 300 - 26 * sqrt 131\" by simp\n  have \"x^2 = (300 - 26 * sqrt 131) / 16\" using `x^2 = (13 - sqrt 131)^2 / 16` by (metis \\<open>(13 - sqrt 131)\\<^sup>2 = 300 - 26 * sqrt 131\\<close>)\n  have \"2 * x^2 = 2 * ((300 - 26 * sqrt 131) / 16)\" by (metis \\<open>x\\<^sup>2 = (300 - 26 * sqrt 131) / 16\\<close>)\n  then have \"2 * x^2 = (600 - 52 * sqrt 131) / 16\" by (simp add: algebra_simps)\n  thus \"2 * x^2 = (600 - 52 * sqrt 131) / 16\" by simp\nqed", "description": "-", "full_code": "lemma calculate_2x_squared:\n  fixes x :: real\n  assumes \"x = (13 - sqrt 131) / 4\"\n  shows \"2 * x^2 = (600 - 52 * sqrt 131) / 16\"\nproof -\n  have \"x^2 = ((13 - sqrt 131) / 4)^2\" using assms by blast\n  then have \"x^2 = (13 - sqrt 131)^2 / 16\" by (simp add: power_divide)\n  have \"(13 - sqrt 131)^2 = 13^2 - 2 * 13 * sqrt 131 + (sqrt 131)^2\" \n    by (smt (verit) diff_add_eq power2_diff)\n  then have \"(13 - sqrt 131)^2 = 169 - 26 * sqrt 131 + 131\" \n    by simp\n  then have \"(13 - sqrt 131)^2 = 300 - 26 * sqrt 131\" by simp\n  have \"x^2 = (300 - 26 * sqrt 131) / 16\" using `x^2 = (13 - sqrt 131)^2 / 16` by (metis \\<open>(13 - sqrt 131)\\<^sup>2 = 300 - 26 * sqrt 131\\<close>)\n  have \"2 * x^2 = 2 * ((300 - 26 * sqrt 131) / 16)\" by (metis \\<open>x\\<^sup>2 = (300 - 26 * sqrt 131) / 16\\<close>)\n  then have \"2 * x^2 = (600 - 52 * sqrt 131) / 16\" by (simp add: algebra_simps)\n  thus \"2 * x^2 = (600 - 52 * sqrt 131) / 16\" by simp\nqed", "origin": "do_request", "update_count": 0}, "square_eq_difference": {"skill_name": "square_eq_difference", "marker": "lemma square_eq_difference:\n  fixes a b :: real\n  shows \"a^2 - b^2 = (a - b) * (a + b)\"\nby sos", "description": "-", "full_code": "lemma square_eq_difference:\n  fixes a b :: real\n  shows \"a^2 - b^2 = (a - b) * (a + b)\"\nby sos", "origin": "square_eq", "update_count": 0}, "square_eq_properties": {"skill_name": "square_eq_properties", "marker": "lemma square_eq_properties:\n  fixes a b c :: real\n  assumes \"a = b\" \"b = c\"\n  shows \"a^2 = b^2 \\<and> b^2 = c^2 \\<and> a^2 = c^2\"\nproof -\n  have \"a^2 = b^2\" using square_eq_general assms(1) by simp\n  then have \"b^2 = c^2\" using square_eq_general assms(2) by blast\n  then have \"a^2 = c^2\" using square_eq_general assms(1) assms(2) by blast\n  thus ?thesis by (auto simp: assms)\nqed", "description": "-", "full_code": "lemma square_eq_general:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_eq_properties:\n  fixes a b c :: real\n  assumes \"a = b\" \"b = c\"\n  shows \"a^2 = b^2 \\<and> b^2 = c^2 \\<and> a^2 = c^2\"\nproof -\n  have \"a^2 = b^2\" using square_eq_general assms(1) by simp\n  then have \"b^2 = c^2\" using square_eq_general assms(2) by blast\n  then have \"a^2 = c^2\" using square_eq_general assms(1) assms(2) by blast\n  thus ?thesis by (auto simp: assms)\nqed", "origin": "square_eq", "update_count": 0}, "sqrt_eq": {"skill_name": "sqrt_eq", "marker": "lemma sqrt_eq:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show \"x = 72\" by simp\nqed", "description": "", "full_code": "lemma sqrt_eq:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show \"x = 72\" by simp\nqed", "origin": "data/full_data/debug/valid_rand/mathd_algebra_31.json_v8", "update_count": -1}, "mod_n_casesV4": {"skill_name": "mod_n_casesV4", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n < n\"\nproof -\n  have \"a mod n = a - (n * (a div n))\" by (auto simp: field_simps)\n  then show ?thesis by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n < n\"\nproof -\n  have \"a mod n = a - (n * (a div n))\" by (auto simp: field_simps)\n  then show ?thesis by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)\nqed", "origin": "mod4_cases", "update_count": 0}, "mod_n_casesV5": {"skill_name": "mod_n_casesV5", "marker": "lemma mod_n_cases:\n  fixes a :: int\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n < n\"\nproof -\n  have \"a mod n = a - n * (a div n)\" by (auto simp: field_simps)\n  also have \"... < n\" by (metis Euclidean_Division.pos_mod_bound assms minus_mult_div_eq_mod of_nat_0_less_iff)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n < n\"\nproof -\n  have \"a mod n = a - n * (a div n)\" by (auto simp: field_simps)\n  also have \"... < n\" by (metis Euclidean_Division.pos_mod_bound assms minus_mult_div_eq_mod of_nat_0_less_iff)\n  finally show ?thesis .\nqed", "origin": "mod4_cases", "update_count": 0}, "nonneg_square": {"skill_name": "nonneg_square", "marker": "lemma nonneg_square:\n  fixes a :: real\n  shows \"a^2 \\<ge> 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  thus ?thesis by (simp add: mult_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma nonneg_square:\n  fixes a :: real\n  shows \"a^2 \\<ge> 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  thus ?thesis by (simp add: mult_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "case_analysis_m": {"skill_name": "case_analysis_m", "marker": "lemma case_analysis_m:\n  fixes m :: nat\n  assumes \"m < 2\"\n  shows \"m = 0 \\<or> m = 1\"\nproof -\n  have \"m = 0 \\<or> m = 1 \\<or> m = 2\" by (metis One_nat_def Suc_inject assms less_2_cases)\n  thus ?thesis\n    using assms by auto\nqed", "description": "-", "full_code": "lemma case_analysis_m:\n  fixes m :: nat\n  assumes \"m < 2\"\n  shows \"m = 0 \\<or> m = 1\"\nproof -\n  have \"m = 0 \\<or> m = 1 \\<or> m = 2\" by (metis One_nat_def Suc_inject assms less_2_cases)\n  thus ?thesis\n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "case_analysis_mV2": {"skill_name": "case_analysis_mV2", "marker": "lemma case_analysis_m:\n  fixes m :: nat\n  assumes \"m < 2\"\n  shows \"m = 0 \\<or> m = 1\"\nproof -\n  have \"m = 0 \\<or> m = 1 \\<or> m = 2\" by (metis One_nat_def Suc_inject assms less_2_cases)\n  moreover have \"m < 2 \\<Longrightarrow> m = 2 \\<Longrightarrow> False\" using assms by simp\n  ultimately show ?thesis by (metis assms verit_comp_simplify1(1))\nqed", "description": "-", "full_code": "lemma case_analysis_m:\n  fixes m :: nat\n  assumes \"m < 2\"\n  shows \"m = 0 \\<or> m = 1\"\nproof -\n  have \"m = 0 \\<or> m = 1 \\<or> m = 2\" by (metis One_nat_def Suc_inject assms less_2_cases)\n  moreover have \"m < 2 \\<Longrightarrow> m = 2 \\<Longrightarrow> False\" using assms by simp\n  ultimately show ?thesis by (metis assms verit_comp_simplify1(1))\nqed", "origin": "do_request", "update_count": 0}, "case_analysis_mV3": {"skill_name": "case_analysis_mV3", "marker": "lemma case_analysis_m:\n  fixes m :: nat\n  assumes \"m < 2\"\n  shows \"m = 0 \\<or> m = 1\"\nproof -\n  have \"m = 0 \\<or> m = 1 \\<or> m = 2\" \n    using assms by auto\n  thus ?thesis \n    using `m < 2` by auto\nqed", "description": "-", "full_code": "lemma case_analysis_m:\n  fixes m :: nat\n  assumes \"m < 2\"\n  shows \"m = 0 \\<or> m = 1\"\nproof -\n  have \"m = 0 \\<or> m = 1 \\<or> m = 2\" \n    using assms by auto\n  thus ?thesis \n    using `m < 2` by auto\nqed", "origin": "do_request", "update_count": 0}, "linear_differenceV2": {"skill_name": "linear_differenceV2", "marker": "lemma linear_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f x - f y = (x - y) * a\"\nproof -\n  have \"f x - f y = (a * x + b) - (a * y + b)\" by (simp add: assms(1))\n  then have \"f x - f y = a * x - a * y\" by (simp)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma linear_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f x - f y = (x - y) * a\"\nproof -\n  have \"f x - f y = (a * x + b) - (a * y + b)\" by (simp add: assms(1))\n  then have \"f x - f y = a * x - a * y\" by (simp)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "factor_differenceV4": {"skill_name": "factor_differenceV4", "marker": "lemma factor_difference:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\"\n  shows \"x - y = (x - y) * 1\"\nproof -\n  have \"x - y = (x - y) * 1 + 0\" \n    by (simp add: algebra_simps)\n  also have \"... = (x - y) * 1 + (0 * 1)\" \n    by (simp)\n  also have \"... = (x - y) * 1 + 0\" \n    by (simp)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma factor_difference:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\"\n  shows \"x - y = (x - y) * 1\"\nproof -\n  have \"x - y = (x - y) * 1 + 0\" \n    by (simp add: algebra_simps)\n  also have \"... = (x - y) * 1 + (0 * 1)\" \n    by (simp)\n  also have \"... = (x - y) * 1 + 0\" \n    by (simp)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "factor_differenceV5": {"skill_name": "factor_differenceV5", "marker": "lemma factor_difference:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\"\n  shows \"x - y = (x - y) * 1\"\nproof -\n  have \"x - y = (x - y) * 1\" \n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma factor_difference:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\"\n  shows \"x - y = (x - y) * 1\"\nproof -\n  have \"x - y = (x - y) * 1\" \n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_eq_extendedV3": {"skill_name": "square_eq_extendedV3", "marker": "lemma square_eq_extended:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_eq_extended:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  thus ?thesis by auto\nqed", "origin": "square_eq", "update_count": 0}, "linear_equation_substitutionV3": {"skill_name": "linear_equation_substitutionV3", "marker": "theorem linear_equation_substitution:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = k\"  \n  shows \"b = (12 - 3*k) / 2\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * k + 2 * b = 12\" using h1 eq by simp\n  then have \"2*b = 12 - 3*k\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: divide_simps)\nqed", "description": "-", "full_code": "theorem linear_equation_substitution:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = k\"  \n  shows \"b = (12 - 3*k) / 2\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * k + 2 * b = 12\" using h1 eq by simp\n  then have \"2*b = 12 - 3*k\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: divide_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_substitutionV4": {"skill_name": "linear_equation_substitutionV4", "marker": "theorem linear_equation_substitution:\n  fixes a b c d :: real\n  assumes h0: \"a + b = c\" \n    and h1: \"a = k\"  \n  shows \"b = c - k\"\nproof -\n  have \"b = c - a\" using h0 by simp\n  also have \"... = c - k\" using h1 by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_equation_substitution:\n  fixes a b c d :: real\n  assumes h0: \"a + b = c\" \n    and h1: \"a = k\"  \n  shows \"b = c - k\"\nproof -\n  have \"b = c - a\" using h0 by simp\n  also have \"... = c - k\" using h1 by simp\n  finally show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "even_odd_product": {"skill_name": "even_odd_product", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by (metis evenE)\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis oddE)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by simp\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by (metis evenE)\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis oddE)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by simp\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "even_odd_productV2": {"skill_name": "even_odd_productV2", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (cases b) auto\n  then have \"a * b = (2 * k) * (2 * m + 1)\" using `a = 2 * k` by simp\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" by simp\n  then have \"a * b = 2 * (k * (2 * m) + k)\" by simp\n  thus \"even (a * b)\" by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (cases b) auto\n  then have \"a * b = (2 * k) * (2 * m + 1)\" using `a = 2 * k` by simp\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" by simp\n  then have \"a * b = 2 * (k * (2 * m) + k)\" by simp\n  thus \"even (a * b)\" by auto\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalized": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalized", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalized:\n  fixes a b :: complex\n  assumes h0 : \"a + b = 7\"\n    and h1 : \"2 * a + b = 3\"\n  shows \"b = 7 - a \\<and> a = (3 - b) / 2\"\nproof -\n  have b_eq: \"b = 7 - a\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * a + (7 - a) = 3\" using h1 b_eq by simp\n  have simplified_eq: \"a + 7 = 3\" using eq2_substituted by simp\n  have a_value: \"a = (3 - 7) / 1\" using simplified_eq by (metis add_diff_cancel dbl_inc_simps(3) div_by_1 h0)\n  have b_value: \"b = 7 - a\" using b_eq a_value by simp\n  show ?thesis using a_value b_value by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalized:\n  fixes a b :: complex\n  assumes h0 : \"a + b = 7\"\n    and h1 : \"2 * a + b = 3\"\n  shows \"b = 7 - a \\<and> a = (3 - b) / 2\"\nproof -\n  have b_eq: \"b = 7 - a\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * a + (7 - a) = 3\" using h1 b_eq by simp\n  have simplified_eq: \"a + 7 = 3\" using eq2_substituted by simp\n  have a_value: \"a = (3 - 7) / 1\" using simplified_eq by (metis add_diff_cancel dbl_inc_simps(3) div_by_1 h0)\n  have b_value: \"b = 7 - a\" using b_eq a_value by simp\n  show ?thesis using a_value b_value by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_general": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_general", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_general:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 7 - x \\<and> x = -4\"\nproof -\n  have eq1: \"e = 7 - x\" using h0 by simp\n  have eq2: \"2 * x + (7 - x) = 3\" using h1 eq1 by simp\n  have eq2_simplified: \"x + 7 = 3\" using eq2 by simp\n  have x_value: \"x = -4\" using eq2_simplified by auto\n  have e_value: \"e = 7 - (-4)\" using eq1 x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e=11 \\<and> x= (-4)\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed\n\ntheorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_general:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 7 - x \\<and> x = -4\"\nproof -\n  have eq1: \"e = 7 - x\" using h0 by simp\n  have eq2: \"2 * x + (7 - x) = 3\" using h1 eq1 by simp\n  have eq2_simplified: \"x + 7 = 3\" using eq2 by simp\n  have x_value: \"x = -4\" using eq2_simplified by auto\n  have e_value: \"e = 7 - (-4)\" using eq1 x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "nonzero_divisionV2": {"skill_name": "nonzero_divisionV2", "marker": "lemma nonzero_division:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a / b = c \\<Longrightarrow> a = c * b\"\nproof -\n  assume \"a / b = c\"\n  then have \"a = c * b\" using assms by (simp add: field_simps)\n  thus ?thesis by assumption\nqed", "description": "-", "full_code": "lemma nonzero_division:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a / b = c \\<Longrightarrow> a = c * b\"\nproof -\n  assume \"a / b = c\"\n  then have \"a = c * b\" using assms by (simp add: field_simps)\n  thus ?thesis by assumption\nqed", "origin": "do_request", "update_count": 0}, "nonzero_divisionV3": {"skill_name": "nonzero_divisionV3", "marker": "lemma nonzero_division:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a / b = c \\<Longrightarrow> a = c * b\"\nproof -\n  assume \"a / b = c\"\n  then have \"c * b = a\" \n    using assms(2) by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma nonzero_division:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"a / b = c \\<Longrightarrow> a = c * b\"\nproof -\n  assume \"a / b = c\"\n  then have \"c * b = a\" \n    using assms(2) by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "min_sum_of_squares": {"skill_name": "min_sum_of_squares", "marker": "lemma min_sum_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 >= 0\"\nproof -\n  have \"x^2 >= 0\" by auto\n  moreover have \"y^2 >= 0\" by auto\n  ultimately show \"x^2 + y^2 >= 0\" \n    by auto\nqed", "description": "-", "full_code": "lemma min_sum_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 >= 0\"\nproof -\n  have \"x^2 >= 0\" by auto\n  moreover have \"y^2 >= 0\" by auto\n  ultimately show \"x^2 + y^2 >= 0\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "min_sum_of_squaresV2": {"skill_name": "min_sum_of_squaresV2", "marker": "lemma min_sum_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 >= 0\"\nproof -\n  have \"x^2 >= 0\" by auto\n  moreover have \"y^2 >= 0\" by auto\n  ultimately have \"x^2 + y^2 >= 0 + 0\" by (simp add: add_nonneg_nonneg)\n  thus \"x^2 + y^2 >= 0\" by simp\nqed", "description": "-", "full_code": "lemma min_sum_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 >= 0\"\nproof -\n  have \"x^2 >= 0\" by auto\n  moreover have \"y^2 >= 0\" by auto\n  ultimately have \"x^2 + y^2 >= 0 + 0\" by (simp add: add_nonneg_nonneg)\n  thus \"x^2 + y^2 >= 0\" by simp\nqed", "origin": "do_request", "update_count": 0}, "min_sum_of_squaresV3": {"skill_name": "min_sum_of_squaresV3", "marker": "lemma min_sum_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 >= 0\"\nproof -\n  have \"x^2 >= 0\" \n    by auto\n  moreover have \"y^2 >= 0\" \n    by auto\n  ultimately have \"x^2 + y^2 >= 0 + 0\" \n    by auto\n  thus ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma min_sum_of_squares:\n  fixes x y :: real\n  shows \"x^2 + y^2 >= 0\"\nproof -\n  have \"x^2 >= 0\" \n    by auto\n  moreover have \"y^2 >= 0\" \n    by auto\n  ultimately have \"x^2 + y^2 >= 0 + 0\" \n    by auto\n  thus ?thesis \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_multi_dim": {"skill_name": "mathd_algebra_109_multi_dim", "marker": "theorem mathd_algebra_109_multi_dim:\n  fixes a :: \"real list\" and b :: \"real list\"\n  assumes h0 : \"3 * (a ! 0) + 2 * (b ! 0) = 12\" \n    and h1 : \"a ! 0 = 4\" \n  shows \"b ! 0 = 0\"\nproof -\n  have eq: \"3 * (a ! 0) + 2 * (b ! 0) = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * (b ! 0) = 12\" using h1 eq by simp\n  have simplified: \"12 + 2 * (b ! 0) = 12\" by (smt (verit) sub)\n  have isolate: \"2 * (b ! 0) = 12 - 12\" using simplified by simp\n  have solution: \"(b ! 0) = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_multi:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed\n\ntheorem mathd_algebra_109_multi_dim:\n  fixes a :: \"real list\" and b :: \"real list\"\n  assumes h0 : \"3 * (a ! 0) + 2 * (b ! 0) = 12\" \n    and h1 : \"a ! 0 = 4\" \n  shows \"b ! 0 = 0\"\nproof -\n  have eq: \"3 * (a ! 0) + 2 * (b ! 0) = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * (b ! 0) = 12\" using h1 eq by simp\n  have simplified: \"12 + 2 * (b ! 0) = 12\" by (smt (verit) sub)\n  have isolate: \"2 * (b ! 0) = 12 - 12\" using simplified by simp\n  have solution: \"(b ! 0) = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "simplify_square_root": {"skill_name": "simplify_square_root", "marker": "lemma simplify_square_root:\n  fixes x y :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) * sqrt(x^2) = x^2\" by (simp add: power2_eq_square)\n  then show \"sqrt(x^2) = abs x\"\n  proof (cases \"x >= 0\")\n    case True\n    then have \"abs x = x\" by simp\n    thus ?thesis using `sqrt(x^2) * sqrt(x^2) = x^2` by (auto simp: power2_eq_square)\n  next\n    case False\n    then have \"x < 0\" by simp\n    then have \"abs x = -x\" by simp\n    hence \"sqrt(x^2) = sqrt((-x)^2)\" by (simp add: power2_eq_square)\n    also have \"... = -x\" using `x < 0` by auto\n    finally show ?thesis using `abs x = -x` by simp\n  qed\nqed", "description": "-", "full_code": "lemma simplify_square_root:\n  fixes x y :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) * sqrt(x^2) = x^2\" by (simp add: power2_eq_square)\n  then show \"sqrt(x^2) = abs x\"\n  proof (cases \"x >= 0\")\n    case True\n    then have \"abs x = x\" by simp\n    thus ?thesis using `sqrt(x^2) * sqrt(x^2) = x^2` by (auto simp: power2_eq_square)\n  next\n    case False\n    then have \"x < 0\" by simp\n    then have \"abs x = -x\" by simp\n    hence \"sqrt(x^2) = sqrt((-x)^2)\" by (simp add: power2_eq_square)\n    also have \"... = -x\" using `x < 0` by auto\n    finally show ?thesis using `abs x = -x` by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_rootV2": {"skill_name": "simplify_square_rootV2", "marker": "lemma simplify_square_root:\n  fixes x y :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) * sqrt(x^2) = x^2\" by (simp add: power2_eq_square)\n  then show \"sqrt(x^2) = abs x\"\n  proof (cases \"x < 0\")\n    case True\n    then have \"x^2 = (abs x)^2\" by auto\n    thus ?thesis by auto\n  next\n    case False\n    then have \"x >= 0\" by (simp add: not_less)\n    have \"abs x = x\" by (metis \\<open>0 \\<le> x\\<close> abs_of_nonneg)\n    thus ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma simplify_square_root:\n  fixes x y :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) * sqrt(x^2) = x^2\" by (simp add: power2_eq_square)\n  then show \"sqrt(x^2) = abs x\"\n  proof (cases \"x < 0\")\n    case True\n    then have \"x^2 = (abs x)^2\" by auto\n    thus ?thesis by auto\n  next\n    case False\n    then have \"x >= 0\" by (simp add: not_less)\n    have \"abs x = x\" by (metis \\<open>0 \\<le> x\\<close> abs_of_nonneg)\n    thus ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "floor_bounds": {"skill_name": "floor_bounds", "marker": "lemma floor_bounds:\n  fixes r :: real and k :: real and m :: int\n  assumes \"m = floor (r + k / 100)\"\n  shows \"m \\<le> r + k / 100 \\<and> r + k / 100 < m + 1\"\nproof -\n  have \"m \\<le> r + k / 100\" using assms\n    by auto\n  moreover have \"r + k / 100 < m + 1\" using assms\n    by auto\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_bounds:\n  fixes r :: real and k :: real and m :: int\n  assumes \"m = floor (r + k / 100)\"\n  shows \"m \\<le> r + k / 100 \\<and> r + k / 100 < m + 1\"\nproof -\n  have \"m \\<le> r + k / 100\" using assms\n    by auto\n  moreover have \"r + k / 100 < m + 1\" using assms\n    by auto\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "floor_boundsV2": {"skill_name": "floor_boundsV2", "marker": "lemma floor_bounds:\n  fixes r :: real and k :: int and m :: int\n  assumes \"m = floor (r + k / 100)\"\n  shows \"m \\<le> r + k / 100 \\<and> r + k / 100 < m + 1\"\nproof -\n  have \"m \\<le> r + k / 100\" using assms\n  proof -\n    have \"m = floor (r + k / 100)\" by (simp add: assms)\n    thus \"m \\<le> r + k / 100\" \n      by auto\n  qed\n  moreover have \"r + k / 100 < m + 1\" using assms\n  proof -\n    have \"r + k / 100 < floor (r + k / 100) + 1\" \n      by auto\n    thus \"r + k / 100 < m + 1\" by (simp add: assms)\n  qed\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_bounds:\n  fixes r :: real and k :: int and m :: int\n  assumes \"m = floor (r + k / 100)\"\n  shows \"m \\<le> r + k / 100 \\<and> r + k / 100 < m + 1\"\nproof -\n  have \"m \\<le> r + k / 100\" using assms\n  proof -\n    have \"m = floor (r + k / 100)\" by (simp add: assms)\n    thus \"m \\<le> r + k / 100\" \n      by auto\n  qed\n  moreover have \"r + k / 100 < m + 1\" using assms\n  proof -\n    have \"r + k / 100 < floor (r + k / 100) + 1\" \n      by auto\n    thus \"r + k / 100 < m + 1\" by (simp add: assms)\n  qed\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "units_digit_squareV3": {"skill_name": "units_digit_squareV3", "marker": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto  \n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  then show \"(k^2) mod 10 = 0\" by auto\nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto  \n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  then show \"(k^2) mod 10 = 0\" by auto\nqed", "origin": "do_request", "update_count": 0}, "units_digit_squareV4": {"skill_name": "units_digit_squareV4", "marker": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k mod 10 = 0\" using assms by simp\n  then have \"k = 10 * (k div 10)\" by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 = 100 * (k div 10)^2\" .\n  then have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  also have \"... = 0\" by (simp add: mod_0) \n  thus \"(k^2) mod 10 = 0\" by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k mod 10 = 0\" using assms by simp\n  then have \"k = 10 * (k div 10)\" by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 = 100 * (k div 10)^2\" .\n  then have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  also have \"... = 0\" by (simp add: mod_0) \n  thus \"(k^2) mod 10 = 0\" by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_rootV3": {"skill_name": "simplify_square_rootV3", "marker": "lemma simplify_square_root:\n  fixes x y :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) = sqrt((abs x)^2)\" by (simp add: abs_if)\n  also have \"... = abs x\" by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root:\n  fixes x y :: real\n  shows \"sqrt(x^2) = abs x\"\nproof -\n  have \"sqrt(x^2) = sqrt((abs x)^2)\" by (simp add: abs_if)\n  also have \"... = abs x\" by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_of_sum": {"skill_name": "square_of_sum", "marker": "lemma square_of_sum:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2*a*b + b^2\"\nproof -\n  have \"(a + b)^2 = (a + b) * (a + b)\" by sos\n  also have \"... = a * (a + b) + b * (a + b)\" by sos\n  also have \"... = a^2 + a*b + b*a + b^2\" by sos\n  also have \"... = a^2 + 2*a*b + b^2\" by (simp add: algebra_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_of_sum:\n  fixes a b :: real\n  shows \"(a + b)^2 = a^2 + 2*a*b + b^2\"\nproof -\n  have \"(a + b)^2 = (a + b) * (a + b)\" by sos\n  also have \"... = a * (a + b) + b * (a + b)\" by sos\n  also have \"... = a^2 + a*b + b*a + b^2\" by sos\n  also have \"... = a^2 + 2*a*b + b^2\" by (simp add: algebra_simps)\n  finally show ?thesis .\nqed", "origin": "square_eq", "update_count": 0}, "square_sum_nonneg": {"skill_name": "square_sum_nonneg", "marker": "lemma square_sum_nonneg:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\n  by (simp)", "description": "-", "full_code": "lemma square_sum_nonneg:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\n  by (simp)", "origin": "square_eq", "update_count": 0}, "algebraic_isolation": {"skill_name": "algebraic_isolation", "marker": "lemma algebraic_isolation:\n  fixes x y z :: real\n  assumes \"x + y = z\"\n  shows \"x = z - y\"\nproof -\n  have \"z - y + y = z\" by (simp add: assms)\n  then show \"x = z - y\" using assms by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma algebraic_isolation:\n  fixes x y z :: real\n  assumes \"x + y = z\"\n  shows \"x = z - y\"\nproof -\n  have \"z - y + y = z\" by (simp add: assms)\n  then show \"x = z - y\" using assms by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "square_eq_multi": {"skill_name": "square_eq_multi", "marker": "lemma square_eq_multi:\n  fixes xs :: \"real list\"\n  shows \"(\\<forall>x \\<in> set xs. x = hd xs) \\<Longrightarrow> (\\<forall>x \\<in> set xs. x^2 = (hd xs)^2)\"\nproof (induction xs)\n  case Nil\n  then show ?case by simp\nnext\n  case (Cons x xs)\n  then show ?case\n  proof (cases xs)\n    case Nil\n    then show ?thesis by auto\n  next\n    case (Cons y ys)\n    then have \"x = hd (x # ys)\" by simp\n    then have \"x^2 = (hd (x # ys))^2\" using Cons.prems by (metis)\n    then have \"x^2 = (hd xs)^2\" by (metis Cons.prems list.sel(1) list.set_intros(1) list.set_intros(2) local.Cons one_add_one)\n    moreover have \"\\<forall>z \\<in> set (y # ys). z = hd (x # ys)\" using Cons.prems by (metis list.sel(1) list.set_intros(2) local.Cons)\n    ultimately show ?thesis using Cons.IH by (metis Cons.prems list.sel(1))\n  qed\nqed", "description": "-", "full_code": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_eq_multi:\n  fixes xs :: \"real list\"\n  shows \"(\\<forall>x \\<in> set xs. x = hd xs) \\<Longrightarrow> (\\<forall>x \\<in> set xs. x^2 = (hd xs)^2)\"\nproof (induction xs)\n  case Nil\n  then show ?case by simp\nnext\n  case (Cons x xs)\n  then show ?case\n  proof (cases xs)\n    case Nil\n    then show ?thesis by auto\n  next\n    case (Cons y ys)\n    then have \"x = hd (x # ys)\" by simp\n    then have \"x^2 = (hd (x # ys))^2\" using Cons.prems by (metis)\n    then have \"x^2 = (hd xs)^2\" by (metis Cons.prems list.sel(1) list.set_intros(1) list.set_intros(2) local.Cons one_add_one)\n    moreover have \"\\<forall>z \\<in> set (y # ys). z = hd (x # ys)\" using Cons.prems by (metis list.sel(1) list.set_intros(2) local.Cons)\n    ultimately show ?thesis using Cons.IH by (metis Cons.prems list.sel(1))\n  qed\nqed", "origin": "square_eq", "update_count": 0}, "mathd_algebra_109_evolved": {"skill_name": "mathd_algebra_109_evolved", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"3 * (4) + 2 * b = 12\" using h1 by simp\n  then have \"12 + 2 * b = 12\" by simp\n  then have \"2 * b = 12 - 12\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have \"3 * a + 2 * b = 12\" using h0 by simp\n  then have \"3 * (4) + 2 * b = 12\" using h1 by simp\n  then have \"12 + 2 * b = 12\" by simp\n  then have \"2 * b = 12 - 12\" by simp\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_generalizedV2": {"skill_name": "mathd_algebra_109_generalizedV2", "marker": "lemma mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2*b = c\" using sub by simp\n  thus \"b = (c - 12) / 2\" by simp\nqed", "description": "-", "full_code": "lemma mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have \"12 + 2*b = c\" using sub by simp\n  thus \"b = (c - 12) / 2\" by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mod_multiply": {"skill_name": "mod_multiply", "marker": "lemma mod_multiply:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis assms mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = b + (a div m) * m\" using assms by auto\n  then have \"c * a = c * (b + (a div m) * m)\"\n    by (simp add: algebra_simps)\n  then have \"c * a = (c * b) + (c * (a div m)) * m\"\n    by (simp add: algebra_simps)\n  then show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma mod_multiply:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis assms mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = b + (a div m) * m\" using assms by auto\n  then have \"c * a = c * (b + (a div m) * m)\"\n    by (simp add: algebra_simps)\n  then have \"c * a = (c * b) + (c * (a div m)) * m\"\n    by (simp add: algebra_simps)\n  then show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_multiplyV2": {"skill_name": "mod_multiplyV2", "marker": "lemma mod_multiply:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis assms(1) mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = b + (a div m) * m\" using assms by auto\n  then have \"c * a = c * (b + (a div m) * m)\"\n    by (simp add: algebra_simps)\n  then have \"c * a = c * b + c * (a div m) * m\"\n    by (simp add: algebra_simps)\n  then have \"(c * a) mod m = (c * b + c * (a div m) * m) mod m\"\n    by simp\n  also have \"... = (c * b) mod m\"\n    by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_multiply:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(c * a) mod m = (c * b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis assms(1) mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = b + (a div m) * m\" using assms by auto\n  then have \"c * a = c * (b + (a div m) * m)\"\n    by (simp add: algebra_simps)\n  then have \"c * a = c * b + c * (a div m) * m\"\n    by (simp add: algebra_simps)\n  then have \"(c * a) mod m = (c * b + c * (a div m) * m) mod m\"\n    by simp\n  also have \"... = (c * b) mod m\"\n    by auto\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod4_cases_extended": {"skill_name": "mod4_cases_extended", "marker": "lemma mod4_cases_extended:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" by (simp add: mod_less)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_cases_extended:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" by (simp add: mod_less)\n  then show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "amc12a_2013_p8": {"skill_name": "amc12a_2013_p8", "marker": "theorem amc12a_2013_p8:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (2 * (x - y)) / (x * y)\"\n    using rearranged by sos\n  have factored: \"x - y = (2 * (x - y)) / (x * y)\"\n    using common_den by blast\n  have \"1 = 2 / (x * y)\"\n    using h2 factored by sos\n  have \"x * y = 2\"\n    using `1 = 2 / (x * y)` by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "", "full_code": "theorem amc12a_2013_p8:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (2 * (x - y)) / (x * y)\"\n    using rearranged by sos\n  have factored: \"x - y = (2 * (x - y)) / (x * y)\"\n    using common_den by blast\n  have \"1 = 2 / (x * y)\"\n    using h2 factored by sos\n  have \"x * y = 2\"\n    using `1 = 2 / (x * y)` by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "data/full_data/debug/valid_rand/amc12a_2013_p8.json_v9", "update_count": -1}, "mathd_algebra_multi": {"skill_name": "mathd_algebra_multi", "marker": "theorem mathd_algebra_multi:\n  fixes a b :: real\n  assumes h0 : \"n > 0\"\n    and h1 : \"3*a + 2*b = n\"\n    and h2 : \"a = 4\"\n  shows \"b = (n - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = n\" using h1 by simp\n  have sub: \"3 * 4 + 2 * b = n\" using h2 eq by simp\n  have simplified: \"12 + 2*b = n\" by (smt (verit) sub)\n  have isolate: \"2*b = n - 12\" using simplified by simp\n  have solution: \"b = (n - 12) / 2\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_multi:\n  fixes a b :: real\n  assumes h0 : \"n > 0\"\n    and h1 : \"3*a + 2*b = n\"\n    and h2 : \"a = 4\"\n  shows \"b = (n - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = n\" using h1 by simp\n  have sub: \"3 * 4 + 2 * b = n\" using h2 eq by simp\n  have simplified: \"12 + 2*b = n\" by (smt (verit) sub)\n  have isolate: \"2*b = n - 12\" using simplified by simp\n  have solution: \"b = (n - 12) / 2\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_extendedV5": {"skill_name": "mathd_algebra_109_extendedV5", "marker": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\" \n    and h2 : \"c = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b + c = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b + 0 = 12\" using h1 h2 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_extended:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\" \n    and h2 : \"c = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b + c = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b + 0 = 12\" using h1 h2 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalizedV2": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalizedV2", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalized:\n  fixes x e :: real\n  assumes h0 : \"x + e = k\"\n    and h1 : \"2 * x + e = m\"\n  shows \"e = k - x \\<and> x = (m - k) / (2 - 1)\"\nproof -\n  have e_eq: \"e = k - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (k - x) = m\" using h1 e_eq by simp\n  have simplified_eq: \"x + k = m\" using eq2_substituted by simp\n  have x_value: \"x = (m - k) / (2 - 1)\" using simplified_eq by auto\n  have e_value: \"e = k - (m - k) / (2 - 1)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_generalized:\n  fixes x e :: real\n  assumes h0 : \"x + e = k\"\n    and h1 : \"2 * x + e = m\"\n  shows \"e = k - x \\<and> x = (m - k) / (2 - 1)\"\nproof -\n  have e_eq: \"e = k - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (k - x) = m\" using h1 e_eq by simp\n  have simplified_eq: \"x + k = m\" using eq2_substituted by simp\n  have x_value: \"x = (m - k) / (2 - 1)\" using simplified_eq by auto\n  have e_value: \"e = k - (m - k) / (2 - 1)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "inequality_addition": {"skill_name": "inequality_addition", "marker": "theorem inequality_addition:\n  fixes a b c :: real\n  assumes \"a < b\" and \"c > 0\"\n  shows \"a + c < b + c\"\nproof -\n  have \"a + c - c < b + c - c\" using assms by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem inequality_addition:\n  fixes a b c :: real\n  assumes \"a < b\" and \"c > 0\"\n  shows \"a + c < b + c\"\nproof -\n  have \"a + c - c < b + c - c\" using assms by auto\n  then show ?thesis by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "mod4_cases_expandedV2": {"skill_name": "mod4_cases_expandedV2", "marker": "lemma mod4_cases_expanded:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 = (if a mod 4 = 0 then 0 else\n                  if a mod 4 = 1 then 1 else\n                  if a mod 4 = 2 then 2 else\n                  if a mod 4 = 3 then 3 else\n                  undefined)\"\n    by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_cases_expanded:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 = (if a mod 4 = 0 then 0 else\n                  if a mod 4 = 1 then 1 else\n                  if a mod 4 = 2 then 2 else\n                  if a mod 4 = 3 then 3 else\n                  undefined)\"\n    by auto\n  thus ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "trivial_inequality": {"skill_name": "trivial_inequality", "marker": "lemma trivial_inequality:\n  fixes x :: real\n  shows \"x^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  then show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma trivial_inequality:\n  fixes x :: real\n  shows \"x^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  then show ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "square_eqV3": {"skill_name": "square_eqV3", "marker": "lemma square_eq:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 = b^2 \\<longleftrightarrow> a^2 - b^2 = 0\" by simp\n  also have \"... \\<longleftrightarrow> (a - b) * (a + b) = 0\" using squares_diff by simp\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma squares_diff:\n  fixes a b :: real\n  shows \"a^2 - b^2 = (a - b) * (a + b)\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  thus ?thesis by simp\nqed\n\nlemma square_eq:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 = b^2 \\<longleftrightarrow> a^2 - b^2 = 0\" by simp\n  also have \"... \\<longleftrightarrow> (a - b) * (a + b) = 0\" using squares_diff by simp\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "square": {"skill_name": "square", "marker": "lemma square:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  thus ?thesis\n  proof (cases \"a^2 = b^2\")\n    case True\n    then have \"0 = (a - b) * (a + b)\" by sos\n    hence \"a - b = 0 \\<or> a + b = 0\" by (simp add: mult_eq_0_iff)\n    thus ?thesis by auto\n  next\n    case False\n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma square:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  thus ?thesis\n  proof (cases \"a^2 = b^2\")\n    case True\n    then have \"0 = (a - b) * (a + b)\" by sos\n    hence \"a - b = 0 \\<or> a + b = 0\" by (simp add: mult_eq_0_iff)\n    thus ?thesis by auto\n  next\n    case False\n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sqrt_properties": {"skill_name": "sqrt_properties", "marker": "lemma sqrt_properties:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a + b) \\<le> sqrt a + sqrt b\"\nproof -\n  have \"sqrt (a + b) ^ 2 = a + b\" using assms(1) assms(2) by (simp add: sqrt_def)\n  have \"sqrt a ^ 2 = a\" using assms(1) by (simp add: sqrt_def)\n  have \"sqrt b ^ 2 = b\" using assms(2) by (simp add: sqrt_def)\n  have \"sqrt a + sqrt b \\<ge> 0\" using assms(1) assms(2) by auto\n  then have \"(sqrt a + sqrt b) ^ 2 = sqrt a ^ 2 + 2 * sqrt a * sqrt b + sqrt b ^ 2\"\n    by (smt (verit) power2_sum)\n  also have \"... = a + 2 * sqrt a * sqrt b + b\" by (simp add: `sqrt a ^ 2 = a` `sqrt b ^ 2 = b`)\n  finally show \"sqrt (a + b) \\<le> sqrt a + sqrt b\" \n    using `sqrt (a + b) ^ 2 = a + b` by (metis assms(1) assms(2) sqrt_add_le_add_sqrt)\nqed", "description": "-", "full_code": "lemma sqrt_properties:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a + b) \\<le> sqrt a + sqrt b\"\nproof -\n  have \"sqrt (a + b) ^ 2 = a + b\" using assms(1) assms(2) by (simp add: sqrt_def)\n  have \"sqrt a ^ 2 = a\" using assms(1) by (simp add: sqrt_def)\n  have \"sqrt b ^ 2 = b\" using assms(2) by (simp add: sqrt_def)\n  have \"sqrt a + sqrt b \\<ge> 0\" using assms(1) assms(2) by auto\n  then have \"(sqrt a + sqrt b) ^ 2 = sqrt a ^ 2 + 2 * sqrt a * sqrt b + sqrt b ^ 2\"\n    by (smt (verit) power2_sum)\n  also have \"... = a + 2 * sqrt a * sqrt b + b\" by (simp add: `sqrt a ^ 2 = a` `sqrt b ^ 2 = b`)\n  finally show \"sqrt (a + b) \\<le> sqrt a + sqrt b\" \n    using `sqrt (a + b) ^ 2 = a + b` by (metis assms(1) assms(2) sqrt_add_le_add_sqrt)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_propertiesV2": {"skill_name": "sqrt_propertiesV2", "marker": "lemma sqrt_properties:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a + b) \\<le> sqrt a + sqrt b\"\nproof -\n  have \"sqrt (a + b) ^ 2 = a + b\" using assms(1) assms(2) by (simp add: sqrt_def)\n  have \"sqrt a ^ 2 = a\" using assms(1) by (simp add: sqrt_def)\n  have \"sqrt b ^ 2 = b\" using assms(2) by (simp add: sqrt_def)\n  have \"sqrt (a + b) ^ 2 \\<le> (sqrt a + sqrt b) ^ 2\"\n    by (metis \\<open>(sqrt (a + b))\\<^sup>2 = a + b\\<close> assms(1) assms(2) sqrt_add_le_add_sqrt sqrt_le_D)\n  then have \"a + b \\<le> (sqrt a + sqrt b) ^ 2\" \n    using `sqrt (a + b) ^ 2 = a + b` by simp\n  then show ?thesis \n    using `sqrt a ^ 2 = a` `sqrt b ^ 2 = b` by (metis assms(1) assms(2) sqrt_add_le_add_sqrt)\nqed", "description": "-", "full_code": "lemma sqrt_properties:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a + b) \\<le> sqrt a + sqrt b\"\nproof -\n  have \"sqrt (a + b) ^ 2 = a + b\" using assms(1) assms(2) by (simp add: sqrt_def)\n  have \"sqrt a ^ 2 = a\" using assms(1) by (simp add: sqrt_def)\n  have \"sqrt b ^ 2 = b\" using assms(2) by (simp add: sqrt_def)\n  have \"sqrt (a + b) ^ 2 \\<le> (sqrt a + sqrt b) ^ 2\"\n    by (metis \\<open>(sqrt (a + b))\\<^sup>2 = a + b\\<close> assms(1) assms(2) sqrt_add_le_add_sqrt sqrt_le_D)\n  then have \"a + b \\<le> (sqrt a + sqrt b) ^ 2\" \n    using `sqrt (a + b) ^ 2 = a + b` by simp\n  then show ?thesis \n    using `sqrt a ^ 2 = a` `sqrt b ^ 2 = b` by (metis assms(1) assms(2) sqrt_add_le_add_sqrt)\nqed", "origin": "do_request", "update_count": 0}, "square_eq_generalV2": {"skill_name": "square_eq_generalV2", "marker": "lemma square_eq_general:\n  fixes a b :: real\n  shows \"a = b \\<Longrightarrow> a^2 = b^2\"\n  by simp", "description": "-", "full_code": "lemma square_eq_general:\n  fixes a b :: real\n  shows \"a = b \\<Longrightarrow> a^2 = b^2\"\n  by simp", "origin": "square_eq", "update_count": 0}, "linear_function_differenceV10": {"skill_name": "linear_function_differenceV10", "marker": "lemma linear_function_difference:\n  fixes a b :: real\n    and f :: \"real \\<Rightarrow> real\"\n  assumes h0: \"\\<forall>x. f x = a * x + b\"\n    and h1: \"f y - f x = k\"  \n  shows \"f (y + d) - f x = (d * a) + k\"  \nproof -\n  have \"f (y + d) = a * (y + d) + b\" by (simp add: h0)\n  also have \"... = a * y + a * d + b\" by (simp add: algebra_simps)\n  also have \"... = (a * y + b) + a * d\" by (simp add: algebra_simps)\n  also have \"... = f y + a * d\" by (simp add: h0)\n  finally have \"f (y + d) - f x = (f y - f x) + a * d\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: h1)\nqed", "description": "-", "full_code": "lemma linear_function_difference:\n  fixes a b :: real\n    and f :: \"real \\<Rightarrow> real\"\n  assumes h0: \"\\<forall>x. f x = a * x + b\"\n    and h1: \"f y - f x = k\"  \n  shows \"f (y + d) - f x = (d * a) + k\"  \nproof -\n  have \"f (y + d) = a * (y + d) + b\" by (simp add: h0)\n  also have \"... = a * y + a * d + b\" by (simp add: algebra_simps)\n  also have \"... = (a * y + b) + a * d\" by (simp add: algebra_simps)\n  also have \"... = f y + a * d\" by (simp add: h0)\n  finally have \"f (y + d) - f x = (f y - f x) + a * d\" by (simp add: algebra_simps)\n  thus ?thesis by (simp add: h1)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "floor_function_properties": {"skill_name": "floor_function_properties", "marker": "lemma floor_function_properties:\n  fixes r :: real and k :: int\n  shows \"floor (r + k / 100) = floor r + floor (k / 100) \\<or> floor (r + k / 100) = floor r + floor (k / 100) + 1\"\nproof -\n  have \"floor (k / 100) = n\" if \"floor (k / 100) = n\" for n :: int\n  proof -\n    have \"n \\<le> k / 100\" using that by arith\n    have \"k / 100 < n + 1\" using that by fastforce\n    hence \"n * 100 \\<le> k\" using that by arith\n    also have \"k < (n + 1) * 100\" using that by (metis \\<open>real_of_int k / 100 < real_of_int (n + 1)\\<close> add.commute divide_less_eq_numeral1(1) of_int_less_iff of_int_mult of_int_numeral)\n    finally show ?thesis by (metis that)\n  qed\n  then have \"floor (r + k / 100) = floor r + floor (k / 100) \\<or> floor (r + k / 100) = floor r + floor (k / 100) + 1\"\n  proof (cases \"r + k / 100 < floor r + floor (k / 100) + 1\")\n    case True\n    hence \"floor (r + k / 100) = floor r + floor (k / 100)\" \n      using floor_mono by arith\n    thus ?thesis by auto\n  next\n    case False\n    hence \"floor (r + k / 100) = floor r + floor (k / 100) + 1\"\n      using floor_mono by arith\n    thus ?thesis by auto\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_function_properties:\n  fixes r :: real and k :: int\n  shows \"floor (r + k / 100) = floor r + floor (k / 100) \\<or> floor (r + k / 100) = floor r + floor (k / 100) + 1\"\nproof -\n  have \"floor (k / 100) = n\" if \"floor (k / 100) = n\" for n :: int\n  proof -\n    have \"n \\<le> k / 100\" using that by arith\n    have \"k / 100 < n + 1\" using that by fastforce\n    hence \"n * 100 \\<le> k\" using that by arith\n    also have \"k < (n + 1) * 100\" using that by (metis \\<open>real_of_int k / 100 < real_of_int (n + 1)\\<close> add.commute divide_less_eq_numeral1(1) of_int_less_iff of_int_mult of_int_numeral)\n    finally show ?thesis by (metis that)\n  qed\n  then have \"floor (r + k / 100) = floor r + floor (k / 100) \\<or> floor (r + k / 100) = floor r + floor (k / 100) + 1\"\n  proof (cases \"r + k / 100 < floor r + floor (k / 100) + 1\")\n    case True\n    hence \"floor (r + k / 100) = floor r + floor (k / 100)\" \n      using floor_mono by arith\n    thus ?thesis by auto\n  next\n    case False\n    hence \"floor (r + k / 100) = floor r + floor (k / 100) + 1\"\n      using floor_mono by arith\n    thus ?thesis by auto\n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "square_non_negative": {"skill_name": "square_non_negative", "marker": "lemma square_non_negative:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_non_negative:\n  fixes a :: real\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show ?thesis by auto\nqed", "origin": "square_eq", "update_count": 0}, "square_root_eq": {"skill_name": "square_root_eq", "marker": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  have \"sqrt x = sqrt (y^2)\" using assms(2) by simp\n  then have \"sqrt x = abs y\" by auto\n  thus ?thesis using assms(1) by (simp add: abs_if)\nqed", "description": "-", "full_code": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  have \"sqrt x = sqrt (y^2)\" using assms(2) by simp\n  then have \"sqrt x = abs y\" by auto\n  thus ?thesis using assms(1) by (simp add: abs_if)\nqed", "origin": "do_request", "update_count": 0}, "square_root_eqV2": {"skill_name": "square_root_eqV2", "marker": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  have \"x >= 0\" using assms(2) assms(1) by auto\n  have \"sqrt x ^ 2 = x\" using `x >= 0` by auto\n  from assms(2) have \"sqrt x ^ 2 = (y^2)\" by simp\n  then show ?thesis using `sqrt x ^ 2 = x` by (simp add: assms(1))\nqed", "description": "-", "full_code": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  have \"x >= 0\" using assms(2) assms(1) by auto\n  have \"sqrt x ^ 2 = x\" using `x >= 0` by auto\n  from assms(2) have \"sqrt x ^ 2 = (y^2)\" by simp\n  then show ?thesis using `sqrt x ^ 2 = x` by (simp add: assms(1))\nqed", "origin": "do_request", "update_count": 0}, "square_root_eqV3": {"skill_name": "square_root_eqV3", "marker": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  have \"x = y^2\" using assms(2) by simp\n  then have \"sqrt x = sqrt (y^2)\" by simp\n  then have \"sqrt x = abs y\" by auto\n  then show ?thesis using assms(1) by (simp add: abs_if)\nqed", "description": "-", "full_code": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  have \"x = y^2\" using assms(2) by simp\n  then have \"sqrt x = sqrt (y^2)\" by simp\n  then have \"sqrt x = abs y\" by auto\n  then show ?thesis using assms(1) by (simp add: abs_if)\nqed", "origin": "do_request", "update_count": 0}, "mod_n_casesV6": {"skill_name": "mod_n_casesV6", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. r < n \\<and> (a mod n = r)\"\nproof -\n  obtain r where \"r = a mod n\" by auto\n  hence \"r < n\" using assms by auto\n  thus \"\\<exists>r. r < n \\<and> (a mod n = r)\" by (metis Euclidean_Division.pos_mod_sign \\<open>r = a mod int n\\<close> assms nat_eq_iff nat_less_iff of_nat_0_less_iff)\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. r < n \\<and> (a mod n = r)\"\nproof -\n  obtain r where \"r = a mod n\" by auto\n  hence \"r < n\" using assms by auto\n  thus \"\\<exists>r. r < n \\<and> (a mod n = r)\" by (metis Euclidean_Division.pos_mod_sign \\<open>r = a mod int n\\<close> assms nat_eq_iff nat_less_iff of_nat_0_less_iff)\nqed", "origin": "mod4_cases", "update_count": 0}, "square_root_eqV4": {"skill_name": "square_root_eqV4", "marker": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  from assms(2) have \"x = y^2\" by simp\n  then have \"sqrt x = sqrt (y^2)\" by simp\n  have \"sqrt (y^2) = abs y\" by auto\n  with assms(1) have \"abs y = y\" by (metis \\<open>y >= 0\\<close> abs_of_nonneg)\n  thus ?thesis by (simp add: \\<open>sqrt x = sqrt (y^2)\\<close>)\nqed", "description": "-", "full_code": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  from assms(2) have \"x = y^2\" by simp\n  then have \"sqrt x = sqrt (y^2)\" by simp\n  have \"sqrt (y^2) = abs y\" by auto\n  with assms(1) have \"abs y = y\" by (metis \\<open>y >= 0\\<close> abs_of_nonneg)\n  thus ?thesis by (simp add: \\<open>sqrt x = sqrt (y^2)\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "square_root_eqV5": {"skill_name": "square_root_eqV5", "marker": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  from assms(2) have \"x = y^2\" by simp\n  then have \"sqrt x = sqrt (y^2)\" by simp\n  also have \"... = abs y\" by auto\n  finally show ?thesis using assms(1) by (simp add: abs_of_nonneg)\nqed", "description": "-", "full_code": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  from assms(2) have \"x = y^2\" by simp\n  then have \"sqrt x = sqrt (y^2)\" by simp\n  also have \"... = abs y\" by auto\n  finally show ?thesis using assms(1) by (simp add: abs_of_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "square_root_eqV6": {"skill_name": "square_root_eqV6", "marker": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  have \"sqrt x = sqrt (y^2)\" using assms(2) by auto\n  then have \"sqrt x = abs y\" by auto\n  moreover have \"abs y = y\" using assms(1) by (metis abs_of_nonneg)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_root_eq:\n  fixes x y :: real\n  assumes \"y >= 0\" \"x = y^2\"\n  shows \"sqrt x = y\"\nproof -\n  have \"sqrt x = sqrt (y^2)\" using assms(2) by auto\n  then have \"sqrt x = abs y\" by auto\n  moreover have \"abs y = y\" using assms(1) by (metis abs_of_nonneg)\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "amc12b_2003_p9_generalizedV2": {"skill_name": "amc12b_2003_p9_generalizedV2", "marker": "theorem amc12b_2003_p9_generalized:\n  fixes a b c d :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f c - f d = (c - d) * (a + k)\"\n  shows \"f c - f d = (c - d) * (a + k)\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f c - f d = (a * c + b) - (a * d + b)\" by (simp add: assms(1))\n  have \"f c - f d = a * c - a * d\" by (simp add: assms(1))\n  thus ?thesis by (metis assms(2) add.commute)\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9_generalized:\n  fixes a b c d :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f c - f d = (c - d) * (a + k)\"\n  shows \"f c - f d = (c - d) * (a + k)\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f c - f d = (a * c + b) - (a * d + b)\" by (simp add: assms(1))\n  have \"f c - f d = a * c - a * d\" by (simp add: assms(1))\n  thus ?thesis by (metis assms(2) add.commute)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "linear_equation": {"skill_name": "linear_equation", "marker": "lemma linear_equation:\n  fixes a b :: real\n  assumes h0: \"m * a + n * b = p\"\n    and h1: \"a = c\"\n  shows \"m * c + n * b = p\"\nproof -\n  have eq: \"m * a + n * b = p\" using h0 by simp\n  have sub: \"m * c + n * b = p\" using h1 eq by simp\n  show ?thesis using sub by simp\nqed", "description": "-", "full_code": "lemma linear_equation:\n  fixes a b :: real\n  assumes h0: \"m * a + n * b = p\"\n    and h1: \"a = c\"\n  shows \"m * c + n * b = p\"\nproof -\n  have eq: \"m * a + n * b = p\" using h0 by simp\n  have sub: \"m * c + n * b = p\" using h1 eq by simp\n  show ?thesis using sub by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mod_n_casesV7": {"skill_name": "mod_n_casesV7", "marker": "lemma mod_n_cases:\n  fixes a n :: int\n  assumes \"n > 0\"\n  shows \"\\<exists>r. a mod n = r \\<and> (0 \\<le> r \\<and> r < n)\"\nproof -\n  obtain r where \"0 \\<le> r \\<and> r < n\" and \"a mod n = r\"\n    using assms by fastforce\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a n :: int\n  assumes \"n > 0\"\n  shows \"\\<exists>r. a mod n = r \\<and> (0 \\<le> r \\<and> r < n)\"\nproof -\n  obtain r where \"0 \\<le> r \\<and> r < n\" and \"a mod n = r\"\n    using assms by fastforce\n  thus ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "mod_n_casesV8": {"skill_name": "mod_n_casesV8", "marker": "lemma mod_n_cases:\n  fixes a n :: int\n  assumes \"n > 0\"\n  shows \"\\<exists>r. a mod n = r \\<and> (0 \\<le> r \\<and> r < n)\"\nproof -\n  obtain r where \"r = a mod n\" \n    using assms by auto\n  then show \"\\<exists>r. a mod n = r \\<and> (0 \\<le> r \\<and> r < n)\"\n    by (metis Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign assms)\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a n :: int\n  assumes \"n > 0\"\n  shows \"\\<exists>r. a mod n = r \\<and> (0 \\<le> r \\<and> r < n)\"\nproof -\n  obtain r where \"r = a mod n\" \n    using assms by auto\n  then show \"\\<exists>r. a mod n = r \\<and> (0 \\<le> r \\<and> r < n)\"\n    by (metis Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign assms)\nqed", "origin": "mod4_cases", "update_count": 0}, "sqrt_eq_special_case": {"skill_name": "sqrt_eq_special_case", "marker": "lemma sqrt_eq_special_case:\n  fixes y :: real\n  assumes \"sqrt (x + 9) = y\" \"y = 9\"\n  shows \"x = 72\"\n  using sqrt_eq_extended[of \"x\" \"9\"] assms by simp", "description": "-", "full_code": "lemma sqrt_eq_extended:\n  fixes x y :: real\n  assumes \"sqrt (x + 9) = y\" \"y > 0\"\n  shows \"x = y^2 - 9\"\nproof -\n  have \"x + 9 = y^2\" using assms(1) by (metis assms(2) less_eq_real_def real_sqrt_eq_iff real_sqrt_unique)\n  then show \"x = y^2 - 9\" by simp\nqed\n\nlemma sqrt_eq_special_case:\n  fixes y :: real\n  assumes \"sqrt (x + 9) = y\" \"y = 9\"\n  shows \"x = 72\"\n  using sqrt_eq_extended[of \"x\" \"9\"] assms by simp", "origin": "sqrt_eq", "update_count": 0}, "sqrt_eq_extended": {"skill_name": "sqrt_eq_extended", "marker": "lemma sqrt_eq_extended:\n  fixes x y :: real\n  assumes \"sqrt (x + 9) = y\" \"y > 0\"\n  shows \"x = y^2 - 9\"\nproof -\n  have \"x + 9 = y^2\" using assms(1) by (metis assms(2) less_eq_real_def real_sqrt_eq_iff real_sqrt_unique)\n  then show \"x = y^2 - 9\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq_extended:\n  fixes x y :: real\n  assumes \"sqrt (x + 9) = y\" \"y > 0\"\n  shows \"x = y^2 - 9\"\nproof -\n  have \"x + 9 = y^2\" using assms(1) by (metis assms(2) less_eq_real_def real_sqrt_eq_iff real_sqrt_unique)\n  then show \"x = y^2 - 9\" by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "sqrt_eq_generalized": {"skill_name": "sqrt_eq_generalized", "marker": "lemma sqrt_eq_generalized:\n  fixes x b :: real\n  assumes \"sqrt (x + b) = b\" \"b > 0\"\n  shows \"x = b^2 - b\"\nproof -\n  have \"x + b = b^2\" using assms(1) by (smt (verit) assms(2) less_eq_real_def real_sqrt_le_iff real_sqrt_pow2_iff real_sqrt_zero)\n  then have \"x = b^2 - b\" by simp\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma sqrt_eq_generalized:\n  fixes x b :: real\n  assumes \"sqrt (x + b) = b\" \"b > 0\"\n  shows \"x = b^2 - b\"\nproof -\n  have \"x + b = b^2\" using assms(1) by (smt (verit) assms(2) less_eq_real_def real_sqrt_le_iff real_sqrt_pow2_iff real_sqrt_zero)\n  then have \"x = b^2 - b\" by simp\n  thus ?thesis .\nqed", "origin": "sqrt_eq", "update_count": 0}, "linear_differenceV3": {"skill_name": "linear_differenceV3", "marker": "lemma linear_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes h0: \"\\<forall> x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  fix x y :: real\n  have \"f x - f y = (a * x + b) - (a * y + b)\" using h0 by auto\n  then show \"f x - f y = a * (x - y)\" by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma linear_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes h0: \"\\<forall> x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  fix x y :: real\n  have \"f x - f y = (a * x + b) - (a * y + b)\" using h0 by auto\n  then show \"f x - f y = a * (x - y)\" by (simp add: algebra_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "cross_multiplication": {"skill_name": "cross_multiplication", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"a / b = c / d \\<longleftrightarrow> a * d = b * c\"\nproof -\n  {\n    assume \"a / b = c / d\"\n    then have \"a * d = c * b\" by (metis assms(1) assms(2) frac_eq_eq)\n  }\n  moreover\n  {\n    assume \"a * d = b * c\"\n    then have \"a / b = c / d\" using assms by (simp add: field_simps)\n  }\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"a / b = c / d \\<longleftrightarrow> a * d = b * c\"\nproof -\n  {\n    assume \"a / b = c / d\"\n    then have \"a * d = c * b\" by (metis assms(1) assms(2) frac_eq_eq)\n  }\n  moreover\n  {\n    assume \"a * d = b * c\"\n    then have \"a / b = c / d\" using assms by (simp add: field_simps)\n  }\n  ultimately show ?thesis by auto\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "linear_function_differenceV11": {"skill_name": "linear_function_differenceV11", "marker": "theorem linear_function_difference:\n  fixes a b x1 x2 :: real\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x1 - f x2 = (x1 - x2) * a\"\n  shows \"f x + (x1 - x2) * a = f (x + (x1 - x2))\"\nproof -\n  have \"f x = a * x + b\" by (simp add: assms(1))\n  then show ?thesis\n    by (simp add: assms(1) algebra_simps)\nqed", "description": "-", "full_code": "theorem linear_function_difference:\n  fixes a b x1 x2 :: real\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x1 - f x2 = (x1 - x2) * a\"\n  shows \"f x + (x1 - x2) * a = f (x + (x1 - x2))\"\nproof -\n  have \"f x = a * x + b\" by (simp add: assms(1))\n  then show ?thesis\n    by (simp add: assms(1) algebra_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "sum_terms_count": {"skill_name": "sum_terms_count", "marker": "lemma sum_terms_count:\n  shows \"card {19::nat..<92} = 73\"\n  by auto", "description": "", "full_code": "lemma sum_terms_count:\n  shows \"card {19::nat..<92} = 73\"\n  by auto", "origin": "data/full_data/debug/valid_rand/aime_1991_p6.json_v10", "update_count": -1}, "sqrt_eqV2": {"skill_name": "sqrt_eqV2", "marker": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  from assms show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  from assms show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_eqV3": {"skill_name": "sqrt_eqV3", "marker": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  have \"sqrt a = sqrt b\"\n    using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  have \"sqrt a = sqrt b\"\n    using assms by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_d_cases": {"skill_name": "mod_d_cases", "marker": "lemma mod_d_cases:\n  fixes a :: int and d :: nat\n  assumes \"d > 0\"\n  shows \"a mod d \\<in> {0..d-1}\"\nproof -\n  have \"a mod d < d\" using assms by auto\n  moreover have \"a mod d \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_d_cases:\n  fixes a :: int and d :: nat\n  assumes \"d > 0\"\n  shows \"a mod d \\<in> {0..d-1}\"\nproof -\n  have \"a mod d < d\" using assms by auto\n  moreover have \"a mod d \\<ge> 0\" by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff)\n  ultimately show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "solve_linear_system": {"skill_name": "solve_linear_system", "marker": "lemma solve_linear_system:\n  fixes x e :: complex\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n  shows \"e = 7 - x\"\nproof -\n  have \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma solve_linear_system:\n  fixes x e :: complex\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n  shows \"e = 7 - x\"\nproof -\n  have \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlinear_eq_xpeeq7_2xpeeq3_eeq11_xeqn4": {"skill_name": "algebra_2varlinear_eq_xpeeq7_2xpeeq3_eeq11_xeqn4", "marker": "theorem algebra_2varlinear_eq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: real\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by linarith\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlinear_eq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: real\n  assumes h0: \"x + e = 7\"\n    and h1: \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by linarith\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "sqrt_nonneg": {"skill_name": "sqrt_nonneg", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by (simp add: real_sqrt_eq_iff)\n  then have \"sqrt a \\<ge> 0\" \n    using assms by (simp add: real_sqrt_eq_iff)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by (simp add: real_sqrt_eq_iff)\n  then have \"sqrt a \\<ge> 0\" \n    using assms by (simp add: real_sqrt_eq_iff)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_nonnegV2": {"skill_name": "sqrt_nonnegV2", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms by (simp add: real_sqrt_eq_iff)\n  then show \"sqrt a >= 0\" \n    using `a >= 0` by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms by (simp add: real_sqrt_eq_iff)\n  then show \"sqrt a >= 0\" \n    using `a >= 0` by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_nonnegV3": {"skill_name": "sqrt_nonnegV3", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms by (simp add: real_sqrt_eq_iff)\n  then have \"sqrt a ^ 2 \\<ge> 0\" using assms by auto\n  moreover have \"sqrt a \\<ge> 0\" using `sqrt a ^ 2 = a` by (auto simp add: power2_eq_iff)\n  ultimately show \"sqrt a \\<ge> 0\" by (metis)\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms by (simp add: real_sqrt_eq_iff)\n  then have \"sqrt a ^ 2 \\<ge> 0\" using assms by auto\n  moreover have \"sqrt a \\<ge> 0\" using `sqrt a ^ 2 = a` by (auto simp add: power2_eq_iff)\n  ultimately show \"sqrt a \\<ge> 0\" by (metis)\nqed", "origin": "do_request", "update_count": 0}, "min_product": {"skill_name": "min_product", "marker": "lemma min_product:\n  fixes a b :: real\n  assumes \"a \\<ge> 1\" \"b \\<ge> 1\"\n  shows \"a * b \\<ge> 1\"\nproof -\n  have \"a * b \\<ge> 1 * 1\" by (metis assms(1) assms(2) leD less_1_mult mult.right_neutral mult_1 not_less_iff_gr_or_eq order_less_imp_le)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma min_product:\n  fixes a b :: real\n  assumes \"a \\<ge> 1\" \"b \\<ge> 1\"\n  shows \"a * b \\<ge> 1\"\nproof -\n  have \"a * b \\<ge> 1 * 1\" by (metis assms(1) assms(2) leD less_1_mult mult.right_neutral mult_1 not_less_iff_gr_or_eq order_less_imp_le)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "min_productV2": {"skill_name": "min_productV2", "marker": "lemma min_product:\n  fixes a b :: real\n  assumes \"a \\<ge> 1\" \"b \\<ge> 1\"\n  shows \"a * b \\<ge> 1\"\nproof -\n  have \"a * b \\<ge> 1 * 1\" using assms(1) assms(2) by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma min_product:\n  fixes a b :: real\n  assumes \"a \\<ge> 1\" \"b \\<ge> 1\"\n  shows \"a * b \\<ge> 1\"\nproof -\n  have \"a * b \\<ge> 1 * 1\" using assms(1) assms(2) by sos\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "min_productV3": {"skill_name": "min_productV3", "marker": "lemma min_product:\n  fixes a b :: real\n  assumes \"a \\<ge> 1\" \"b \\<ge> 1\"\n  shows \"a * b \\<ge> 1\"\nproof -\n  from assms have \"a - 1 \\<ge> 0\" and \"b - 1 \\<ge> 0\" by auto\n  then have \"a * b = (1 + (a - 1)) * (1 + (b - 1))\" by (simp add: algebra_simps)\n  also have \"... = 1 + (a - 1) + (b - 1) + (a - 1) * (b - 1)\" by sos\n  finally show \"a * b \\<ge> 1\" by (metis assms(1) assms(2) comm_monoid_mult_class.mult_1 leD less_1_mult mult.right_neutral not_less_iff_gr_or_eq order.strict_iff_order order_less_imp_le)\nqed", "description": "-", "full_code": "lemma min_product:\n  fixes a b :: real\n  assumes \"a \\<ge> 1\" \"b \\<ge> 1\"\n  shows \"a * b \\<ge> 1\"\nproof -\n  from assms have \"a - 1 \\<ge> 0\" and \"b - 1 \\<ge> 0\" by auto\n  then have \"a * b = (1 + (a - 1)) * (1 + (b - 1))\" by (simp add: algebra_simps)\n  also have \"... = 1 + (a - 1) + (b - 1) + (a - 1) * (b - 1)\" by sos\n  finally show \"a * b \\<ge> 1\" by (metis assms(1) assms(2) comm_monoid_mult_class.mult_1 leD less_1_mult mult.right_neutral not_less_iff_gr_or_eq order.strict_iff_order order_less_imp_le)\nqed", "origin": "do_request", "update_count": 0}, "linear_function_differenceV12": {"skill_name": "linear_function_differenceV12", "marker": "lemma linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f m - f n = (m - n) * a\"\nproof -\n  have \"f m - f n = (a * m + b) - (a * n + b)\" by (simp add: assms)\n  then show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f m - f n = (m - n) * a\"\nproof -\n  have \"f m - f n = (a * m + b) - (a * n + b)\" by (simp add: assms)\n  then show ?thesis by (auto simp: field_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "amc12b_2003_p9V3": {"skill_name": "amc12b_2003_p9V3", "marker": "theorem amc12b_2003_p9:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f 6 - f 2 = (6 - 2) * a\" using linear_function_difference[OF assms(1)] by simp\n  then have \"4 * a = 12\" using `f 6 - f 2 = 12` by simp\n  then have \"a = 3\" by (simp add: field_simps)\n  then have \"f 12 - f 2 = (12 - 2) * a\" using linear_function_difference[OF assms(1)] by simp\n  then show ?thesis by (simp add: `a = 3`)\nqed", "description": "-", "full_code": "lemma linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f m - f n = (m - n) * a\"\nproof -\n  have \"f m - f n = (a * m + b) - (a * n + b)\" by (simp add: assms)\n  then show ?thesis by (auto simp: field_simps)\nqed\n\ntheorem amc12b_2003_p9:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f 6 - f 2 = (6 - 2) * a\" using linear_function_difference[OF assms(1)] by simp\n  then have \"4 * a = 12\" using `f 6 - f 2 = 12` by simp\n  then have \"a = 3\" by (simp add: field_simps)\n  then have \"f 12 - f 2 = (12 - 2) * a\" using linear_function_difference[OF assms(1)] by simp\n  then show ?thesis by (simp add: `a = 3`)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "amc12b_2003_p9V4": {"skill_name": "amc12b_2003_p9V4", "marker": "theorem amc12b_2003_p9:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f 6 - f 2 = a * (6 - 2)\" using linear_function_difference[OF assms(1)] by simp\n  have \"f 6 - f 2 = 4 * a\" by (simp add: `f 6 - f 2 = a * (6 - 2)`)\n  then have \"4 * a = 12\" using assms(2) by simp\n  then have \"a = 3\" by simp\n  have \"f 12 - f 2 = a * (12 - 2)\" using linear_function_difference[OF assms(1)] by simp\n  then have \"f 12 - f 2 = 10 * a\" by simp\n  then show ?thesis using `a = 3` by simp\nqed", "description": "-", "full_code": "lemma linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  have \"f x - f y = (a * x + b) - (a * y + b)\" using assms by simp\n  then show ?thesis by (auto simp: field_simps)\nqed\n\ntheorem amc12b_2003_p9:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f 6 - f 2 = a * (6 - 2)\" using linear_function_difference[OF assms(1)] by simp\n  have \"f 6 - f 2 = 4 * a\" by (simp add: `f 6 - f 2 = a * (6 - 2)`)\n  then have \"4 * a = 12\" using assms(2) by simp\n  then have \"a = 3\" by simp\n  have \"f 12 - f 2 = a * (12 - 2)\" using linear_function_difference[OF assms(1)] by simp\n  then have \"f 12 - f 2 = 10 * a\" by simp\n  then show ?thesis using `a = 3` by simp\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "solve_for_b_given_a": {"skill_name": "solve_for_b_given_a", "marker": "theorem solve_for_b_given_a:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_value\"\n    and h2 : \"n > 0\"\n  shows \"b = (p - m*a_value) / n\"\nproof -\n  have eq: \"m*a + n*b = p\" using h0 by simp\n  have sub: \"m*a_value + n*b = p\" using h1 eq by simp\n  have isolate: \"n*b = p - m*a_value\" using sub by simp\n  have solution: \"b = (p - m*a_value) / n\" using isolate by (metis h2 less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem solve_for_b_given_a:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_value\"\n    and h2 : \"n > 0\"\n  shows \"b = (p - m*a_value) / n\"\nproof -\n  have eq: \"m*a + n*b = p\" using h0 by simp\n  have sub: \"m*a_value + n*b = p\" using h1 eq by simp\n  have isolate: \"n*b = p - m*a_value\" using sub by simp\n  have solution: \"b = (p - m*a_value) / n\" using isolate by (metis h2 less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "min_productV4": {"skill_name": "min_productV4", "marker": "lemma min_product:\n  fixes a b :: real\n  assumes \"a \\<ge> 1\" \"b \\<ge> 1\"\n  shows \"a * b \\<ge> 1\"\nproof -\n  from assms have \"a \\<ge> 1\" by simp\n  from assms have \"b \\<ge> 1\" by simp\n  hence \"a * b \\<ge> 1 * 1\" by (metis assms(1) leD less_1_mult mult.right_neutral mult_1 not_less_iff_gr_or_eq order_less_imp_le)\n  thus \"a * b \\<ge> 1\" by simp\nqed", "description": "-", "full_code": "lemma min_product:\n  fixes a b :: real\n  assumes \"a \\<ge> 1\" \"b \\<ge> 1\"\n  shows \"a * b \\<ge> 1\"\nproof -\n  from assms have \"a \\<ge> 1\" by simp\n  from assms have \"b \\<ge> 1\" by simp\n  hence \"a * b \\<ge> 1 * 1\" by (metis assms(1) leD less_1_mult mult.right_neutral mult_1 not_less_iff_gr_or_eq order_less_imp_le)\n  thus \"a * b \\<ge> 1\" by simp\nqed", "origin": "do_request", "update_count": 0}, "product_of_sums": {"skill_name": "product_of_sums", "marker": "lemma product_of_sums:\n  fixes a b c d :: real\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by (simp add: algebra_simps)\n  also have \"... = a * c + a * d + b * (c + d)\" by (simp add: algebra_simps)\n  also have \"... = a * c + a * d + b * c + b * d\" by (simp add: algebra_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma product_of_sums:\n  fixes a b c d :: real\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by (simp add: algebra_simps)\n  also have \"... = a * c + a * d + b * (c + d)\" by (simp add: algebra_simps)\n  also have \"... = a * c + a * d + b * c + b * d\" by (simp add: algebra_simps)\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "product_of_sumsV2": {"skill_name": "product_of_sumsV2", "marker": "lemma product_of_sums:\n  fixes a b c d :: real\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by sos\n  also have \"... = a * c + a * d + b * (c + d)\" by (simp add: distrib_left)\n  also have \"... = a * c + a * d + b * c + b * d\" by (simp add: distrib_left)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma product_of_sums:\n  fixes a b c d :: real\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by sos\n  also have \"... = a * c + a * d + b * (c + d)\" by (simp add: distrib_left)\n  also have \"... = a * c + a * d + b * c + b * d\" by (simp add: distrib_left)\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "solve_linear_equation_with_parameters": {"skill_name": "solve_linear_equation_with_parameters", "marker": "lemma solve_linear_equation_with_parameters:\n  fixes a b c :: real\n  assumes \"a > 0\"\n  assumes \"a*x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a*x + b = c\" using assms by simp\n  then have \"a*x = c - b\" by simp\n  then show ?thesis using `a > 0`\n    by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma solve_linear_equation_with_parameters:\n  fixes a b c :: real\n  assumes \"a > 0\"\n  assumes \"a*x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a*x + b = c\" using assms by simp\n  then have \"a*x = c - b\" by simp\n  then show ?thesis using `a > 0`\n    by (auto simp: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_solutionV4": {"skill_name": "linear_equation_solutionV4", "marker": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0 : \"a > 0\"\n    and h1 : \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using h1 by simp\n  then have \"a * x = c - b\" by simp\n  then show ?thesis using h0 by (auto simp: field_simps)\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0 : \"a > 0\"\n    and h1 : \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using h1 by simp\n  then have \"a * x = c - b\" by simp\n  then show ?thesis using h0 by (auto simp: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_function_differenceV13": {"skill_name": "linear_function_differenceV13", "marker": "theorem linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f x - f 2 = (x - 2) * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  then have \"4 * a = 12\" using assms(2) by auto\n  hence \"a = 3\" by (simp add: field_simps)\n  have \"f x - f 2 = (a * x + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f x - f 2 = a * x - a * 2\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add_diff_cancel_right uminus_add_conv_diff)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem linear_function_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f x - f 2 = (x - 2) * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  then have \"4 * a = 12\" using assms(2) by auto\n  hence \"a = 3\" by (simp add: field_simps)\n  have \"f x - f 2 = (a * x + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f x - f 2 = a * x - a * 2\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add_diff_cancel_right uminus_add_conv_diff)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "sqrt_eq_generalizedV2": {"skill_name": "sqrt_eq_generalizedV2", "marker": "lemma sqrt_eq_generalized:\n  fixes x y :: real\n  assumes \"sqrt (x + y) = y\" \"y \\<ge> 0\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"x + y = y^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then show \"x = y^2 - y\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq_generalized:\n  fixes x y :: real\n  assumes \"sqrt (x + y) = y\" \"y \\<ge> 0\"\n  shows \"x = y^2 - y\"\nproof -\n  have \"x + y = y^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then show \"x = y^2 - y\" by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "even_odd_productV3": {"skill_name": "even_odd_productV3", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by (metis evenE)\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis oddE)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    by (metis `a = 2 * k` `b = 2 * m + 1`)\n  have \"a * b = 2 * k * (2 * m) + 2 * k\" by (smt (verit) \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> add_mult_distrib2 mult.comm_neutral)\n  have \"a * b = 2 * (k * (2 * m) + k)\" by (smt (verit) \\<open>a * b = 2 * k * (2 * m) + 2 * k\\<close> \\<open>a = 2 * k\\<close> ab_semigroup_mult_class.mult_ac(1) add.commute assms(1) div_mult_self2 dvd_div_mult nonzero_mult_div_cancel_left zero_neq_numeral)\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by (metis evenE)\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis oddE)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    by (metis `a = 2 * k` `b = 2 * m + 1`)\n  have \"a * b = 2 * k * (2 * m) + 2 * k\" by (smt (verit) \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> add_mult_distrib2 mult.comm_neutral)\n  have \"a * b = 2 * (k * (2 * m) + k)\" by (smt (verit) \\<open>a * b = 2 * k * (2 * m) + 2 * k\\<close> \\<open>a = 2 * k\\<close> ab_semigroup_mult_class.mult_ac(1) add.commute assms(1) div_mult_self2 dvd_div_mult nonzero_mult_div_cancel_left zero_neq_numeral)\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "even_odd_productV4": {"skill_name": "even_odd_productV4", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by (metis evenE)\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis oddE)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by simp\n  have \"a * b = 2 * (k * (2 * m + 1))\" by (smt (verit) \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> ab_semigroup_mult_class.mult_ac(1))\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by (metis evenE)\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis oddE)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by simp\n  have \"a * b = 2 * (k * (2 * m + 1))\" by (smt (verit) \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> ab_semigroup_mult_class.mult_ac(1))\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_eq_multi": {"skill_name": "sqrt_eq_multi", "marker": "lemma sqrt_eq_multi:\n  fixes x :: real\n  assumes \"sqrt (x + n) = n\" \n      and \"n > 0\"\n  shows \"x = n^2 - n\"\nproof -\n  have \"x + n = n^2\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then have \"x = n^2 - n\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq_multi:\n  fixes x :: real\n  assumes \"sqrt (x + n) = n\" \n      and \"n > 0\"\n  shows \"x = n^2 - n\"\nproof -\n  have \"x + n = n^2\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then have \"x = n^2 - n\" by simp\n  thus ?thesis by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "trivial_inequalityV2": {"skill_name": "trivial_inequalityV2", "marker": "lemma trivial_inequality:\n  fixes x :: real\n  shows \"x^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  then show \"x^2 >= 0\" \n    using mult_nonneg_nonneg[OF le_refl le_refl] by auto\nqed", "description": "-", "full_code": "lemma trivial_inequality:\n  fixes x :: real\n  shows \"x^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by sos\n  then show \"x^2 >= 0\" \n    using mult_nonneg_nonneg[OF le_refl le_refl] by auto\nqed", "origin": "do_request", "update_count": 0}, "trivial_inequalityV3": {"skill_name": "trivial_inequalityV3", "marker": "lemma trivial_inequality:\n  fixes x :: real\n  shows \"x^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by (simp add: power2_eq_square)\n  then show \"x^2 >= 0\"\n  proof (cases \"x >= 0\")\n    case True\n    then have \"x * x >= 0\" using mult_nonneg_nonneg by auto\n    thus ?thesis by simp\n  next\n    case False\n    then have \"x < 0\" by simp\n    hence \"x * x >= 0\" using mult_nonneg_nonneg by auto\n    thus ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma trivial_inequality:\n  fixes x :: real\n  shows \"x^2 >= 0\"\nproof -\n  have \"x^2 = x * x\" by (simp add: power2_eq_square)\n  then show \"x^2 >= 0\"\n  proof (cases \"x >= 0\")\n    case True\n    then have \"x * x >= 0\" using mult_nonneg_nonneg by auto\n    thus ?thesis by simp\n  next\n    case False\n    then have \"x < 0\" by simp\n    hence \"x * x >= 0\" using mult_nonneg_nonneg by auto\n    thus ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_eq_n_dimensions": {"skill_name": "square_eq_n_dimensions", "marker": "lemma square_eq_n_dimensions:\n  fixes a b :: \"real list\"\n  assumes \"length a = n\" and \"length b = n\" and \"a = b\"\n  shows \"sum (\\<lambda>i. a!i^2) {0..n-1} = sum (\\<lambda>i. b!i^2) {0..n-1}\"\nproof -\n  have \"sum (\\<lambda>i. a!i^2) {0..n-1} = sum (\\<lambda>i. b!i^2) {0..n-1}\"\n    by (metis assms(3))\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_eq_n_dimensions:\n  fixes a b :: \"real list\"\n  assumes \"length a = n\" and \"length b = n\" and \"a = b\"\n  shows \"sum (\\<lambda>i. a!i^2) {0..n-1} = sum (\\<lambda>i. b!i^2) {0..n-1}\"\nproof -\n  have \"sum (\\<lambda>i. a!i^2) {0..n-1} = sum (\\<lambda>i. b!i^2) {0..n-1}\"\n    by (metis assms(3))\n  thus ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "square_eq_multi_dim": {"skill_name": "square_eq_multi_dim", "marker": "lemma square_eq_multi_dim:\n  fixes a b :: \"real set\"\n  assumes \"\\<forall>x \\<in> a. \\<forall>y \\<in> b. x = y\"\n  shows \"\\<forall>x \\<in> a. x^2 = (\\<lambda>y. y^2) (x)\"\n  using assms by auto", "description": "-", "full_code": "lemma square_eq_multi:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_eq_multi_dim:\n  fixes a b :: \"real set\"\n  assumes \"\\<forall>x \\<in> a. \\<forall>y \\<in> b. x = y\"\n  shows \"\\<forall>x \\<in> a. x^2 = (\\<lambda>y. y^2) (x)\"\n  using assms by auto", "origin": "square_eq", "update_count": 0}, "floor_boundsV3": {"skill_name": "floor_boundsV3", "marker": "lemma floor_bounds:\n  fixes r :: real\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  have \"floor r \\<le> r\" \n    by auto\n  have \"r < floor r + 1\" \n  proof -\n    have \"floor r < r + 1\" \n      by arith\n    thus \"r < floor r + 1\" \n      by auto\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_bounds:\n  fixes r :: real\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  have \"floor r \\<le> r\" \n    by auto\n  have \"r < floor r + 1\" \n  proof -\n    have \"floor r < r + 1\" \n      by arith\n    thus \"r < floor r + 1\" \n      by auto\n  qed\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "floor_boundsV4": {"skill_name": "floor_boundsV4", "marker": "lemma floor_bounds:\n  fixes r :: real\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  have \"floor r = floor r\" by simp\n  hence \"floor r \\<le> r\" by auto\n  moreover have \"r < floor r + 1\" \n  proof -\n    have \"r < floor r + 1\" by auto\n    thus \"r < floor r + 1\" by simp\n  qed\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_bounds:\n  fixes r :: real\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  have \"floor r = floor r\" by simp\n  hence \"floor r \\<le> r\" by auto\n  moreover have \"r < floor r + 1\" \n  proof -\n    have \"r < floor r + 1\" by auto\n    thus \"r < floor r + 1\" by simp\n  qed\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "square_root_equation": {"skill_name": "square_root_equation", "marker": "lemma square_root_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then show \"x = 72\" by simp\nqed", "description": "-", "full_code": "lemma square_root_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then show \"x = 72\" by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_square": {"skill_name": "sqrt_square", "marker": "lemma sqrt_square:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt (x^2) = x\"\nproof -\n  have \"sqrt (x^2) = x\" if \"x >= 0\" using that by (simp add: real_sqrt_eq_iff)\n  then show ?thesis by (metis assms)\nqed", "description": "-", "full_code": "lemma sqrt_square:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt (x^2) = x\"\nproof -\n  have \"sqrt (x^2) = x\" if \"x >= 0\" using that by (simp add: real_sqrt_eq_iff)\n  then show ?thesis by (metis assms)\nqed", "origin": "sqrt_eq", "update_count": 0}, "sqrt_square_relation": {"skill_name": "sqrt_square_relation", "marker": "lemma sqrt_square_relation:\n  fixes x :: real\n  assumes \"sqrt y = z\" and \"y >= 0\"\n  shows \"y = z^2\"\nproof -\n  have \"y = z^2\" using assms(1) by (metis assms(2) power2_eq_iff_nonneg real_sqrt_eq_iff real_sqrt_power real_sqrt_unique zero_le_power2)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_square_relation:\n  fixes x :: real\n  assumes \"sqrt y = z\" and \"y >= 0\"\n  shows \"y = z^2\"\nproof -\n  have \"y = z^2\" using assms(1) by (metis assms(2) power2_eq_iff_nonneg real_sqrt_eq_iff real_sqrt_power real_sqrt_unique zero_le_power2)\n  then show ?thesis by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "amc12a_generalized": {"skill_name": "amc12a_generalized", "marker": "theorem amc12a_generalized:\n  fixes a b :: real\n  assumes h0 : \"a \\<noteq> 0\"\n    and h1 : \"b \\<noteq> 0\"\n    and h2 : \"a \\<noteq> b\"\n    and h3 : \"a + 2/a = b + 2/b\"\n  shows \"a * b = 2\"\nproof -\n  have eq: \"a + 2/a = b + 2/b\" using h3 by simp\n  have rearranged: \"a - b = (2/b - 2/a)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"a - b = (2 * (a - b)) / (a * b)\"\n    using rearranged by sos\n  have factored: \"a - b = (2 * (a - b)) / (a * b)\"\n    using common_den by blast\n  have \"1 = 2 / (a * b)\"\n    using h2 factored by sos\n  have \"a * b = 2\"\n    using `1 = 2 / (a * b)` by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_generalized:\n  fixes a b :: real\n  assumes h0 : \"a \\<noteq> 0\"\n    and h1 : \"b \\<noteq> 0\"\n    and h2 : \"a \\<noteq> b\"\n    and h3 : \"a + 2/a = b + 2/b\"\n  shows \"a * b = 2\"\nproof -\n  have eq: \"a + 2/a = b + 2/b\" using h3 by simp\n  have rearranged: \"a - b = (2/b - 2/a)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"a - b = (2 * (a - b)) / (a * b)\"\n    using rearranged by sos\n  have factored: \"a - b = (2 * (a - b)) / (a * b)\"\n    using common_den by blast\n  have \"1 = 2 / (a * b)\"\n    using h2 factored by sos\n  have \"a * b = 2\"\n    using `1 = 2 / (a * b)` by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_generalized": {"skill_name": "amc12a_2013_p8_generalized", "marker": "theorem amc12a_2013_p8_generalized:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + a/x = y + a/y\"  \n  shows \"x * y = a\"  \nproof -\n  have eq: \"x + a/x = y + a/y\" using h3 by simp\n  have rearranged: \"x - y = (a/y - a/x)\"\n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (a * (x - y)) / (x * y)\"\n    using rearranged by (smt (verit) diff_frac_eq h0 h1 mult.commute right_diff_distrib')\n  have factored: \"x - y = (a * (x - y)) / (x * y)\"\n    using common_den by blast\n  have \"1 = a / (x * y)\"\n    using h2 factored by sos\n  have \"x * y = a\"\n    using `1 = a / (x * y)` by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_generalized:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + a/x = y + a/y\"  \n  shows \"x * y = a\"  \nproof -\n  have eq: \"x + a/x = y + a/y\" using h3 by simp\n  have rearranged: \"x - y = (a/y - a/x)\"\n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (a * (x - y)) / (x * y)\"\n    using rearranged by (smt (verit) diff_frac_eq h0 h1 mult.commute right_diff_distrib')\n  have factored: \"x - y = (a * (x - y)) / (x * y)\"\n    using common_den by blast\n  have \"1 = a / (x * y)\"\n    using h2 factored by sos\n  have \"x * y = a\"\n    using `1 = a / (x * y)` by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "non_negative_property": {"skill_name": "non_negative_property", "marker": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"0 \\<le> a^2\" by (simp add: power2_eq_square)\n  have \"0 \\<le> b^2\" by (simp add: power2_eq_square)\n  then show \"a^2 + b^2 \\<ge> 0\" \n    using `0 \\<le> a^2` `0 \\<le> b^2` by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"0 \\<le> a^2\" by (simp add: power2_eq_square)\n  have \"0 \\<le> b^2\" by (simp add: power2_eq_square)\n  then show \"a^2 + b^2 \\<ge> 0\" \n    using `0 \\<le> a^2` `0 \\<le> b^2` by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "non_negative_propertyV2": {"skill_name": "non_negative_propertyV2", "marker": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 >= 0\" by (simp add: power2_eq_square)\n  have \"b^2 >= 0\" by (simp add: power2_eq_square)\n  then show \"a^2 + b^2 >= 0\" \n    by auto \nqed", "description": "-", "full_code": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 >= 0\" by (simp add: power2_eq_square)\n  have \"b^2 >= 0\" by (simp add: power2_eq_square)\n  then show \"a^2 + b^2 >= 0\" \n    by auto \nqed", "origin": "do_request", "update_count": 0}, "non_negative_propertyV3": {"skill_name": "non_negative_propertyV3", "marker": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 \\<ge> 0\" by (simp add: power2_eq_square)\n  have \"b^2 \\<ge> 0\" by (simp add: power2_eq_square)\n  then show \"a^2 + b^2 \\<ge> 0\" \n    using `a^2 \\<ge> 0` `b^2 \\<ge> 0` by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 \\<ge> 0\" by (simp add: power2_eq_square)\n  have \"b^2 \\<ge> 0\" by (simp add: power2_eq_square)\n  then show \"a^2 + b^2 \\<ge> 0\" \n    using `a^2 \\<ge> 0` `b^2 \\<ge> 0` by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "minimum_value": {"skill_name": "minimum_value", "marker": "lemma minimum_value:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) - 2 * (x * y) + 1 + (x^2 + 2 * (x * y) + y^2)\"\n    by sos\n  also have \"... = (x^2 * y^2) + (x^2) + (y^2) + 1\"\n    by simp\n  finally show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma minimum_value:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 + (x + y)^2 = (x^2 * y^2) - 2 * (x * y) + 1 + (x^2 + 2 * (x * y) + y^2)\"\n    by sos\n  also have \"... = (x^2 * y^2) + (x^2) + (y^2) + 1\"\n    by simp\n  finally show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "units_digit_squareV5": {"skill_name": "units_digit_squareV5", "marker": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 = 100 * (k div 10)^2\" .\n  then show \"(k^2) mod 10 = 0\" by (simp add: mod_mult_right_eq mod_0) \nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 = 100 * (k div 10)^2\" .\n  then show \"(k^2) mod 10 = 0\" by (simp add: mod_mult_right_eq mod_0) \nqed", "origin": "do_request", "update_count": 0}, "units_digit_squareV6": {"skill_name": "units_digit_squareV6", "marker": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  then have \"k^2 = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  thus \"(k^2) mod 10 = 0\" by (simp add: mod_0)\nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by simp\n  then have \"k^2 = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  thus \"(k^2) mod 10 = 0\" by (simp add: mod_0)\nqed", "origin": "do_request", "update_count": 0}, "units_digit_squareV7": {"skill_name": "units_digit_squareV7", "marker": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" \n    using assms by auto \n  then have \"k^2 = (10 * (k div 10))^2\" \n    by simp\n  also have \"... = 100 * (k div 10)^2\" \n    by simp\n  finally have \"k^2 = 100 * (k div 10)^2\" .\n  then have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" \n    by simp\n  moreover have \"(100 * (k div 10)^2) mod 10 = 0\" \n    by (simp add: mod_mult_self2)\n  ultimately show \"(k^2) mod 10 = 0\" \n    by simp\nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" \n    using assms by auto \n  then have \"k^2 = (10 * (k div 10))^2\" \n    by simp\n  also have \"... = 100 * (k div 10)^2\" \n    by simp\n  finally have \"k^2 = 100 * (k div 10)^2\" .\n  then have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" \n    by simp\n  moreover have \"(100 * (k div 10)^2) mod 10 = 0\" \n    by (simp add: mod_mult_self2)\n  ultimately show \"(k^2) mod 10 = 0\" \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negative_propertyV4": {"skill_name": "non_negative_propertyV4", "marker": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 >= 0\" by (simp add: power2_eq_square)\n  have \"b^2 >= 0\" by (simp add: power2_eq_square)\n  then have \"a^2 + b^2 >= 0 + 0\" by auto\n  thus \"a^2 + b^2 \\<ge> 0\" by simp\nqed", "description": "-", "full_code": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 >= 0\" by (simp add: power2_eq_square)\n  have \"b^2 >= 0\" by (simp add: power2_eq_square)\n  then have \"a^2 + b^2 >= 0 + 0\" by auto\n  thus \"a^2 + b^2 \\<ge> 0\" by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negative_propertyV5": {"skill_name": "non_negative_propertyV5", "marker": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 >= 0\" \n    by (simp add: power2_eq_square)\n  moreover have \"b^2 >= 0\" \n    by (simp add: power2_eq_square)\n  ultimately show \"a^2 + b^2 \\<ge> 0\" \n    by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma non_negative_property:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 >= 0\" \n    by (simp add: power2_eq_square)\n  moreover have \"b^2 >= 0\" \n    by (simp add: power2_eq_square)\n  ultimately show \"a^2 + b^2 \\<ge> 0\" \n    by (simp add: add_nonneg_nonneg)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_eq_generalizedV3": {"skill_name": "sqrt_eq_generalizedV3", "marker": "lemma sqrt_eq_generalized:\n  fixes x :: real and c :: real\n  assumes \"c > 0\" and \"sqrt (x + c) = c\"\n  shows \"x = c^2 - c\"\nproof -\n  have \"x + c = c^2\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then have \"x = c^2 - c\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq_generalized:\n  fixes x :: real and c :: real\n  assumes \"c > 0\" and \"sqrt (x + c) = c\"\n  shows \"x = c^2 - c\"\nproof -\n  have \"x + c = c^2\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then have \"x = c^2 - c\" by simp\n  thus ?thesis by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "square_eq_extendedV4": {"skill_name": "square_eq_extendedV4", "marker": "lemma square_eq_extended:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\" \n    and \"\\<forall> n m. a = n \\<Longrightarrow> b = m \\<Longrightarrow> a^2 = b^2\"\n  using assms by auto", "description": "-", "full_code": "lemma square_eq_extended:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\" \n    and \"\\<forall> n m. a = n \\<Longrightarrow> b = m \\<Longrightarrow> a^2 = b^2\"\n  using assms by auto", "origin": "square_eq", "update_count": 0}, "sum_terms_count_extended": {"skill_name": "sum_terms_count_extended", "marker": "lemma sum_terms_count_extended:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\"\n    using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count:\n  shows \"card {19::nat..<92} = 73\"\n  by auto\n\nlemma sum_terms_count_extended:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\"\n    using assms by auto\n  thus ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_countV2": {"skill_name": "sum_terms_countV2", "marker": "lemma sum_terms_count:\n  fixes n :: nat\n  shows \"card {n::nat..<n+73} = 73\"\n  by auto", "description": "-", "full_code": "lemma sum_terms_count:\n  fixes n :: nat\n  shows \"card {n::nat..<n+73} = 73\"\n  by auto", "origin": "sum_terms_count", "update_count": 0}, "inequality_manipulationV4": {"skill_name": "inequality_manipulationV4", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"c * (b - a) > 0\" using assms(2) by (simp add: mult_pos_pos)\n  have \"a * c < a * c + c * (b - a)\" using assms(1) by (metis \\<open>0 < c * (b - a)\\<close> less_add_same_cancel1)\n  then have \"a * c < b * c\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"c * (b - a) > 0\" using assms(2) by (simp add: mult_pos_pos)\n  have \"a * c < a * c + c * (b - a)\" using assms(1) by (metis \\<open>0 < c * (b - a)\\<close> less_add_same_cancel1)\n  then have \"a * c < b * c\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "inequality_manipulationV5": {"skill_name": "inequality_manipulationV5", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  have \"c * (b - a) > 0\" using `b - a > 0` assms(2) by (simp add: mult_pos_pos)\n  have \"b * c - a * c = c * (b - a)\" using algebra_simps by (auto simp: field_simps)\n  then have \"b * c > a * c\" using `c * (b - a) > 0` by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  have \"c * (b - a) > 0\" using `b - a > 0` assms(2) by (simp add: mult_pos_pos)\n  have \"b * c - a * c = c * (b - a)\" using algebra_simps by (auto simp: field_simps)\n  then have \"b * c > a * c\" using `c * (b - a) > 0` by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "min_of_non_negativesV4": {"skill_name": "min_of_non_negativesV4", "marker": "lemma min_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a >= 0\" using assms(1) by assumption\n  have \"b >= 0\" using assms(2) by assumption\n  then show \"a + b >= 0\" by (metis add_nonneg_nonneg assms(1))\nqed", "description": "-", "full_code": "lemma min_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"a >= 0\" using assms(1) by assumption\n  have \"b >= 0\" using assms(2) by assumption\n  then show \"a + b >= 0\" by (metis add_nonneg_nonneg assms(1))\nqed", "origin": "do_request", "update_count": 0}, "min_of_non_negativesV5": {"skill_name": "min_of_non_negativesV5", "marker": "lemma min_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"0 <= a\" using assms(1) by simp\n  have \"0 <= b\" using assms(2) by simp\n  then have \"0 + 0 <= a + b\" by (metis add_0_iff add_nonneg_nonneg assms(1))\n  thus \"a + b >= 0\" by simp\nqed", "description": "-", "full_code": "lemma min_of_non_negatives:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  have \"0 <= a\" using assms(1) by simp\n  have \"0 <= b\" using assms(2) by simp\n  then have \"0 + 0 <= a + b\" by (metis add_0_iff add_nonneg_nonneg assms(1))\n  thus \"a + b >= 0\" by simp\nqed", "origin": "do_request", "update_count": 0}, "case_analysis_mV4": {"skill_name": "case_analysis_mV4", "marker": "lemma case_analysis_m:\n  fixes m :: nat\n  assumes \"m < 2\"\n  shows \"m = 0 \\<or> m = 1\"\nproof -\n  have \"m < 2\" using assms by simp\n  then show ?thesis\n  proof (cases m)\n    case 0\n    then show ?thesis by auto\n  next\n    case (Suc n)\n    hence \"m = Suc n\" by simp\n    then have \"Suc n < 2\" by (metis Suc_leI assms)\n    thus ?thesis\n      by (metis One_nat_def Suc_inject assms less_2_cases)\n  qed\nqed", "description": "-", "full_code": "lemma case_analysis_m:\n  fixes m :: nat\n  assumes \"m < 2\"\n  shows \"m = 0 \\<or> m = 1\"\nproof -\n  have \"m < 2\" using assms by simp\n  then show ?thesis\n  proof (cases m)\n    case 0\n    then show ?thesis by auto\n  next\n    case (Suc n)\n    hence \"m = Suc n\" by simp\n    then have \"Suc n < 2\" by (metis Suc_leI assms)\n    thus ?thesis\n      by (metis One_nat_def Suc_inject assms less_2_cases)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "case_analysis_mV5": {"skill_name": "case_analysis_mV5", "marker": "lemma case_analysis_m:\n  fixes m :: nat\n  assumes \"m < 2\"\n  shows \"m = 0 \\<or> m = 1\"\nproof -\n  have \"m < 2\" by (rule assms)\n  then show ?thesis\n  proof (cases m)\n    case 0\n    then show ?thesis by auto\n  next\n    case (Suc k)\n    then show ?thesis using `m < 2` by auto\n  qed\nqed", "description": "-", "full_code": "lemma case_analysis_m:\n  fixes m :: nat\n  assumes \"m < 2\"\n  shows \"m = 0 \\<or> m = 1\"\nproof -\n  have \"m < 2\" by (rule assms)\n  then show ?thesis\n  proof (cases m)\n    case 0\n    then show ?thesis by auto\n  next\n    case (Suc k)\n    then show ?thesis using `m < 2` by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sum_terms_count_generalized": {"skill_name": "sum_terms_count_generalized", "marker": "lemma sum_terms_count_generalized:\n  fixes m n :: nat\n  assumes \"m < n\"\n  shows \"card {m::nat..<n} = n - m\"\n  by (simp add: assms)", "description": "-", "full_code": "lemma sum_terms_count_generalized:\n  fixes m n :: nat\n  assumes \"m < n\"\n  shows \"card {m::nat..<n} = n - m\"\n  by (simp add: assms)", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_generalizedV2": {"skill_name": "sum_terms_count_generalizedV2", "marker": "lemma sum_terms_count_generalized:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a..<b} = b - a\" by auto\n  then show ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count_generalized:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a..<b} = b - a\" by auto\n  then show ?thesis using assms by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_generalizedV3": {"skill_name": "sum_terms_count_generalizedV3", "marker": "lemma sum_terms_count_generalized:\n  fixes m n :: nat\n  assumes \"m < n\"\n  shows \"card {m::nat..<n} = n - m\"\nproof -\n  have \"card {m::nat..<n} = n - m\" by (simp add: assms)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count_generalized:\n  fixes m n :: nat\n  assumes \"m < n\"\n  shows \"card {m::nat..<n} = n - m\"\nproof -\n  have \"card {m::nat..<n} = n - m\" by (simp add: assms)\n  then show ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sqrt_equationV2": {"skill_name": "sqrt_equationV2", "marker": "lemma sqrt_equation:\n  fixes x :: real\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof\n  assume \"sqrt (x + 9) = 9\"\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show \"x = 72\" by simp\nnext\n  assume \"x = 72\"\n  then have \"x + 9 = 72 + 9\" by simp\n  then have \"x + 9 = 81\" by simp\n  then show \"sqrt (x + 9) = 9\" by (simp add: real_sqrt_unique)\nqed", "description": "-", "full_code": "lemma sqrt_equation:\n  fixes x :: real\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof\n  assume \"sqrt (x + 9) = 9\"\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show \"x = 72\" by simp\nnext\n  assume \"x = 72\"\n  then have \"x + 9 = 72 + 9\" by simp\n  then have \"x + 9 = 81\" by simp\n  then show \"sqrt (x + 9) = 9\" by (simp add: real_sqrt_unique)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_equationV3": {"skill_name": "sqrt_equationV3", "marker": "lemma sqrt_equation:\n  fixes x :: real\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9 \\<Longrightarrow> x = 72\"\n  proof -\n    assume \"sqrt (x + 9) = 9\"\n    then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n    then have \"x + 9 = 81\" by simp\n    then show \"x = 72\" by simp\n  qed\n  have \"x = 72 \\<Longrightarrow> sqrt (x + 9) = 9\"\n  proof -\n    assume \"x = 72\"\n    then have \"x + 9 = 72 + 9\" by simp\n    then have \"x + 9 = 81\" by simp\n    then show \"sqrt (x + 9) = 9\" by auto\n  qed\n  show \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\" \n    by (metis (full_types) `sqrt (x + 9) = 9 \\<Longrightarrow> x = 72` `x = 72 \\<Longrightarrow> sqrt (x + 9) = 9`)\nqed", "description": "-", "full_code": "lemma sqrt_equation:\n  fixes x :: real\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9 \\<Longrightarrow> x = 72\"\n  proof -\n    assume \"sqrt (x + 9) = 9\"\n    then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n    then have \"x + 9 = 81\" by simp\n    then show \"x = 72\" by simp\n  qed\n  have \"x = 72 \\<Longrightarrow> sqrt (x + 9) = 9\"\n  proof -\n    assume \"x = 72\"\n    then have \"x + 9 = 72 + 9\" by simp\n    then have \"x + 9 = 81\" by simp\n    then show \"sqrt (x + 9) = 9\" by auto\n  qed\n  show \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\" \n    by (metis (full_types) `sqrt (x + 9) = 9 \\<Longrightarrow> x = 72` `x = 72 \\<Longrightarrow> sqrt (x + 9) = 9`)\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq": {"skill_name": "algebra_2varlineareq", "marker": "theorem algebra_2varlineareq:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (a - x) \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = b - a\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel)\n  have e_value: \"e = a - (b - a)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (a - x) \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = b - a\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel)\n  have e_value: \"e = a - (b - a)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "square_properties_mod_4": {"skill_name": "square_properties_mod_4", "marker": "lemma square_properties_mod_4:\n  fixes a :: int\n  shows \"a^2 mod 4 = 0 \\<or> a^2 mod 4 = 1\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  moreover {\n    assume \"a mod 4 = 0\"\n    then have \"a^2 mod 4 = (0^2) mod 4\" by auto\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    then have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    then have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 4 mod 4\" by simp\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    then have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 9 mod 4\" by simp\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_properties_mod_4:\n  fixes a :: int\n  shows \"a^2 mod 4 = 0 \\<or> a^2 mod 4 = 1\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  moreover {\n    assume \"a mod 4 = 0\"\n    then have \"a^2 mod 4 = (0^2) mod 4\" by auto\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    then have \"a^2 mod 4 = (1^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    then have \"a^2 mod 4 = (2^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 4 mod 4\" by simp\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    then have \"a^2 mod 4 = (3^2) mod 4\" by (smt (verit) power_mod)\n    hence \"a^2 mod 4 = 9 mod 4\" by simp\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_equationV4": {"skill_name": "sqrt_equationV4", "marker": "lemma sqrt_equation:\n  fixes x :: real\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof\n  show \"sqrt (x + 9) = 9 \\<Longrightarrow> x = 72\"\n  proof -\n    assume \"sqrt (x + 9) = 9\"\n    have \"x + 9 = 9^2\" using `sqrt (x + 9) = 9` by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n    then have \"x + 9 = 81\" by simp\n    then show \"x = 72\" by simp\n  qed\n  show \"x = 72 \\<Longrightarrow> sqrt (x + 9) = 9\"\n  proof -\n    assume \"x = 72\"\n    have \"sqrt (x + 9) = sqrt (72 + 9)\" by (simp add: `x = 72`)\n    also have \"... = sqrt 81\" by simp\n    also have \"... = 9\" by simp\n    finally show \"sqrt (x + 9) = 9\" .\n  qed\nqed", "description": "-", "full_code": "lemma sqrt_equation:\n  fixes x :: real\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof\n  show \"sqrt (x + 9) = 9 \\<Longrightarrow> x = 72\"\n  proof -\n    assume \"sqrt (x + 9) = 9\"\n    have \"x + 9 = 9^2\" using `sqrt (x + 9) = 9` by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n    then have \"x + 9 = 81\" by simp\n    then show \"x = 72\" by simp\n  qed\n  show \"x = 72 \\<Longrightarrow> sqrt (x + 9) = 9\"\n  proof -\n    assume \"x = 72\"\n    have \"sqrt (x + 9) = sqrt (72 + 9)\" by (simp add: `x = 72`)\n    also have \"... = sqrt 81\" by simp\n    also have \"... = 9\" by simp\n    finally show \"sqrt (x + 9) = 9\" .\n  qed\nqed", "origin": "do_request", "update_count": 0}, "expression_nonneg": {"skill_name": "expression_nonneg", "marker": "lemma expression_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  have \"?E >= 1\" by sos\n  have \"?E = 1\" when \"x = 0\" and \"y = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "description": "", "full_code": "lemma expression_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  have \"?E >= 1\" by sos\n  have \"?E = 1\" when \"x = 0\" and \"y = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "origin": "data/full_data/debug/valid_rand/amc12a_2021_p7.json_v13", "update_count": -1}, "amc12a_2021_p7": {"skill_name": "amc12a_2021_p7", "marker": "theorem amc12a_2021_p7:\n  fixes x y ::real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\n  apply (auto simp:algebra_simps power2_eq_square)\n  using expression_nonneg by sos", "description": "", "full_code": "lemma expression_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  have \"?E >= 1\" by sos\n  have \"?E = 1\" when \"x = 0\" and \"y = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed\n\ntheorem amc12a_2021_p7:\n  fixes x y ::real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\n  apply (auto simp:algebra_simps power2_eq_square)\n  using expression_nonneg by sos", "origin": "data/full_data/debug/valid_rand/amc12a_2021_p7.json_v13", "update_count": -1}, "variable_relationship": {"skill_name": "variable_relationship", "marker": "lemma variable_relationship:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\" \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using assms(4) by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" using eq by (simp add: field_simps)\n  have common_den: \"x - y = (2 * (x - y)) / (x * y)\" \n    using rearranged by sos\n  have \"1 = 2 / (x * y)\" using assms(3) common_den by sos\n  then show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma variable_relationship:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\" \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using assms(4) by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" using eq by (simp add: field_simps)\n  have common_den: \"x - y = (2 * (x - y)) / (x * y)\" \n    using rearranged by sos\n  have \"1 = 2 / (x * y)\" using assms(3) common_den by sos\n  then show ?thesis by (simp add: field_simps)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "rearrangement_of_equation": {"skill_name": "rearrangement_of_equation", "marker": "lemma rearrangement_of_equation:\n  fixes a b c d :: real\n  assumes \"a + c = b + d\"\n  shows \"a - b = d - c\"\nproof -\n  have \"a - b = d - c\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrangement_of_equation:\n  fixes a b c d :: real\n  assumes \"a + c = b + d\"\n  shows \"a - b = d - c\"\nproof -\n  have \"a - b = d - c\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "mathd_algebra_extended": {"skill_name": "mathd_algebra_extended", "marker": "theorem mathd_algebra_extended:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_extended:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "product_relation": {"skill_name": "product_relation", "marker": "lemma product_relation:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\" \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using assms(4) by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (2 * (x - y)) / (x * y)\"\n    using rearranged by sos\n  then have factored: \"x - y = (2 * (x - y)) / (x * y)\"\n    using common_den by blast\n  have \"1 = 2 / (x * y)\"\n    using assms(3) factored by sos\n  then show ?thesis using `1 = 2 / (x * y)` by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma product_relation:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"x \\<noteq> y\" \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using assms(4) by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (2 * (x - y)) / (x * y)\"\n    using rearranged by sos\n  then have factored: \"x - y = (2 * (x - y)) / (x * y)\"\n    using common_den by blast\n  have \"1 = 2 / (x * y)\"\n    using assms(3) factored by sos\n  then show ?thesis using `1 = 2 / (x * y)` by (simp add: field_simps)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "square_root_properties": {"skill_name": "square_root_properties", "marker": "theorem square_root_properties:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x >= 0\" using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem square_root_properties:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x >= 0\" using assms by auto\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "product_inequality": {"skill_name": "product_inequality", "marker": "lemma product_inequality:\n  fixes x y :: real\n  assumes \"0 < x\" \"0 < y\"\n  shows \"x * y > 0\"\nproof -\n  have \"x * y > 0\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma product_inequality:\n  fixes x y :: real\n  assumes \"0 < x\" \"0 < y\"\n  shows \"x * y > 0\"\nproof -\n  have \"x * y > 0\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "absolute_value_inequality_general": {"skill_name": "absolute_value_inequality_general", "marker": "lemma absolute_value_inequality_general:\n  fixes a b :: real\n  assumes h0: \"abs(a - b) < c\"\n  shows \"b - c < a \\<and> a < b + c\"\nproof -\n  have \"a - b < c\" and \"-(a - b) < c\" using assms by auto\n  then have \"b - c < a\" and \"a < b + c\" by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma absolute_value_inequality_general:\n  fixes a b :: real\n  assumes h0: \"abs(a - b) < c\"\n  shows \"b - c < a \\<and> a < b + c\"\nproof -\n  have \"a - b < c\" and \"-(a - b) < c\" using assms by auto\n  then have \"b - c < a\" and \"a < b + c\" by auto\n  then show ?thesis by auto\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "inequality_multiplication": {"skill_name": "inequality_multiplication", "marker": "lemma inequality_multiplication:\n  fixes a b :: real\n  assumes h0: \"0 < b\"\n    and h1: \"a < c\"\n  shows \"a * b < c * b\"\nproof -\n  have \"a * b < c * b\" using h1 h0 by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_multiplication:\n  fixes a b :: real\n  assumes h0: \"0 < b\"\n    and h1: \"a < c\"\n  shows \"a * b < c * b\"\nproof -\n  have \"a * b < c * b\" using h1 h0 by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "square_root_expansion": {"skill_name": "square_root_expansion", "marker": "lemma square_root_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a - b) * (a - b)\" by sos\n  also have \"... = a * a - 2 * a * b + b * b\" \n    by (simp add: algebra_simps)\n  finally show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_root_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a - b) * (a - b)\" by sos\n  also have \"... = a * a - 2 * a * b + b * b\" \n    by (simp add: algebra_simps)\n  finally show ?thesis by sos\nqed", "origin": "do_request", "update_count": 0}, "square_root_expansionV2": {"skill_name": "square_root_expansionV2", "marker": "lemma square_root_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a - b) * (a - b)\" by (simp add: power2_eq_square)\n  also have \"... = a * a - 2 * a * b + b * b\" by (simp add: algebra_simps)\n  also have \"... = a^2 - 2 * a * b + b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_root_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2 * a * b + b^2\"\nproof -\n  have \"(a - b)^2 = (a - b) * (a - b)\" by (simp add: power2_eq_square)\n  also have \"... = a * a - 2 * a * b + b * b\" by (simp add: algebra_simps)\n  also have \"... = a^2 - 2 * a * b + b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "mod_additionV4": {"skill_name": "mod_additionV4", "marker": "lemma mod_addition:\n  fixes a b n x y :: nat\n  assumes \"a mod n = x\" and \"b mod n = y\"\n  shows \"(a + b) mod n = (x + y) mod n\"\nproof -\n  have \"a = x + (a div n) * n\" using assms(1) by auto\n  have \"b = y + (b div n) * n\" using assms(2) by auto\n  then have \"a + b = (x + y) + ((a div n) + (b div n)) * n\" \n    using `a = x + (a div n) * n` by (auto simp: field_simps)\n  then have \"(a + b) mod n = ((x + y) + ((a div n) + (b div n)) * n) mod n\" \n    by simp\n  also have \"... = (x + y) mod n\" \n    by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b n x y :: nat\n  assumes \"a mod n = x\" and \"b mod n = y\"\n  shows \"(a + b) mod n = (x + y) mod n\"\nproof -\n  have \"a = x + (a div n) * n\" using assms(1) by auto\n  have \"b = y + (b div n) * n\" using assms(2) by auto\n  then have \"a + b = (x + y) + ((a div n) + (b div n)) * n\" \n    using `a = x + (a div n) * n` by (auto simp: field_simps)\n  then have \"(a + b) mod n = ((x + y) + ((a div n) + (b div n)) * n) mod n\" \n    by simp\n  also have \"... = (x + y) mod n\" \n    by auto\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "square_nonnegV2": {"skill_name": "square_nonnegV2", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"b^2 = b * b\" by sos\n  moreover have \"a = b\" using assms(1) by simp\n  ultimately show \"a^2 = b^2\" using assms(1) by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"b^2 = b * b\" by sos\n  moreover have \"a = b\" using assms(1) by simp\n  ultimately show \"a^2 = b^2\" using assms(1) by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "square_nonnegV3": {"skill_name": "square_nonnegV3", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  also have \"... = b * b\" using assms(1) by simp\n  finally show \"a^2 = b^2\" by sos\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  also have \"... = b * b\" using assms(1) by simp\n  finally show \"a^2 = b^2\" by sos\nqed", "origin": "do_request", "update_count": 0}, "numbertheory_sqmod4in01d": {"skill_name": "numbertheory_sqmod4in01d", "marker": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  moreover {\n    assume \"a mod 4 = 0\"\n    then have \"a^2 mod 4 = (0^2) mod 4\" by auto\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    then have \"a^2 mod 4 = (1^2) mod 4\" by (smt (z3) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    then have \"a^2 mod 4 = (2^2) mod 4\" by (smt (z3) power_mod)\n    hence \"a^2 mod 4 = 4 mod 4\" by simp\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    then have \"a^2 mod 4 = (3^2) mod 4\" by (smt (z3) power_mod)\n    hence \"a^2 mod 4 = 9 mod 4\" by simp\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  ultimately show ?thesis by auto\nqed", "description": "", "full_code": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  moreover {\n    assume \"a mod 4 = 0\"\n    then have \"a^2 mod 4 = (0^2) mod 4\" by auto\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 1\"\n    then have \"a^2 mod 4 = (1^2) mod 4\" by (smt (z3) power_mod)\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 2\"\n    then have \"a^2 mod 4 = (2^2) mod 4\" by (smt (z3) power_mod)\n    hence \"a^2 mod 4 = 4 mod 4\" by simp\n    hence \"a^2 mod 4 = 0\" by simp\n  }\n  moreover {\n    assume \"a mod 4 = 3\"\n    then have \"a^2 mod 4 = (3^2) mod 4\" by (smt (z3) power_mod)\n    hence \"a^2 mod 4 = 9 mod 4\" by simp\n    hence \"a^2 mod 4 = 1\" by simp\n  }\n  ultimately show ?thesis by auto\nqed", "origin": "data/full_data/debug/valid_rand/numbertheory_sqmod4in01d.json_v14", "update_count": -1}, "sum_terms_count_generalizedV4": {"skill_name": "sum_terms_count_generalizedV4", "marker": "lemma sum_terms_count_generalized:\n  fixes a b :: nat\n  shows \"card {a::nat..<b} = (b - a)\"\n  by auto", "description": "-", "full_code": "lemma sum_terms_count_generalized:\n  fixes a b :: nat\n  shows \"card {a::nat..<b} = (b - a)\"\n  by auto", "origin": "sum_terms_count", "update_count": 0}, "linear_equation_solutionV5": {"skill_name": "linear_equation_solutionV5", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_val\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a_val)/n\"\nproof -\n  have eq: \"m*a + n*b = p\" using h0 by simp\n  have sub: \"m*a_val + n*b = p\" using h1 eq by simp\n  then have \"n*b = p - m*a_val\" by auto\n  then have \"b = (p - m*a_val)/n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_val\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a_val)/n\"\nproof -\n  have eq: \"m*a + n*b = p\" using h0 by simp\n  have sub: \"m*a_val + n*b = p\" using h1 eq by simp\n  then have \"n*b = p - m*a_val\" by auto\n  then have \"b = (p - m*a_val)/n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_solutionV6": {"skill_name": "linear_equation_solutionV6", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a0\"  \n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a0) / n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"b = (p - m*a) / n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  also have \"... = (p - m*a0) / n\" using h1 by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a0\"  \n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a0) / n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"b = (p - m*a) / n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  also have \"... = (p - m*a0) / n\" using h1 by simp\n  finally show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_combination_solve_for_b_with_a": {"skill_name": "linear_combination_solve_for_b_with_a", "marker": "theorem linear_combination_solve_for_b_with_a:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = c\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*c)/n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"b = (p - m*a)/n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  also have \"... = (p - m*c)/n\" using h1 by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_combination_solve_for_b_with_a:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = c\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*c)/n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"b = (p - m*a)/n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  also have \"... = (p - m*c)/n\" using h1 by simp\n  finally show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "combine_modular_results": {"skill_name": "combine_modular_results", "marker": "lemma combine_modular_results:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = 10 * (a div 10)\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + 6\" using assms(2) by presburger\n  then have \"a + b = 10 * (a div 10) + (10 * (b div 10) + 6)\" \n    by (metis \\<open>a = 10 * (a div 10)\\<close>)\n  then have \"a + b = 10 * (a div 10 + b div 10) + 6\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (10 * (a div 10 + b div 10) + 6) mod 10\"\n    by simp\n  also have \"... = 6\"\n    by presburger\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma combine_modular_results:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = 10 * (a div 10)\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + 6\" using assms(2) by presburger\n  then have \"a + b = 10 * (a div 10) + (10 * (b div 10) + 6)\" \n    by (metis \\<open>a = 10 * (a div 10)\\<close>)\n  then have \"a + b = 10 * (a div 10 + b div 10) + 6\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (10 * (a div 10 + b div 10) + 6) mod 10\"\n    by simp\n  also have \"... = 6\"\n    by presburger\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "combine_modular_resultsV2": {"skill_name": "combine_modular_resultsV2", "marker": "lemma combine_modular_results:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = 10 * (a div 10)\" using assms(1) by auto\n  hence \"a + b = 10 * (a div 10) + b\" by simp\n  then have \"(a + b) mod 10 = (10 * (a div 10) + b) mod 10\" by simp\n  also have \"... = (b mod 10)\" by (simp add: mod_add_eq)\n  also have \"... = 6\" using assms(2) by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_modular_results:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = 10 * (a div 10)\" using assms(1) by auto\n  hence \"a + b = 10 * (a div 10) + b\" by simp\n  then have \"(a + b) mod 10 = (10 * (a div 10) + b) mod 10\" by simp\n  also have \"... = (b mod 10)\" by (simp add: mod_add_eq)\n  also have \"... = 6\" using assms(2) by simp\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "product_sum_inequality": {"skill_name": "product_sum_inequality", "marker": "lemma product_sum_inequality:\n  fixes x y :: real\n  assumes \"x > 0\" and \"y > 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 \\<ge> 0\" by simp\n  have \"x^2 \\<ge> 0\" by simp\n  have \"y^2 \\<ge> 0\" by simp\n  have \"?E \\<ge> 1\" using `x > 0` `y > 0` by (smt (verit) \\<open>(x * y - 1)\\<^sup>2 + (x + y)\\<^sup>2 = x\\<^sup>2 * y\\<^sup>2 + x\\<^sup>2 + y\\<^sup>2 + 1\\<close> \\<open>0 \\<le> x\\<^sup>2 * y\\<^sup>2\\<close> \\<open>0 \\<le> x\\<^sup>2\\<close> \\<open>0 \\<le> y\\<^sup>2\\<close>)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma product_sum_inequality:\n  fixes x y :: real\n  assumes \"x > 0\" and \"y > 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 \\<ge> 0\" by simp\n  have \"x^2 \\<ge> 0\" by simp\n  have \"y^2 \\<ge> 0\" by simp\n  have \"?E \\<ge> 1\" using `x > 0` `y > 0` by (smt (verit) \\<open>(x * y - 1)\\<^sup>2 + (x + y)\\<^sup>2 = x\\<^sup>2 * y\\<^sup>2 + x\\<^sup>2 + y\\<^sup>2 + 1\\<close> \\<open>0 \\<le> x\\<^sup>2 * y\\<^sup>2\\<close> \\<open>0 \\<le> x\\<^sup>2\\<close> \\<open>0 \\<le> y\\<^sup>2\\<close>)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "reciprocal_sum_identity": {"skill_name": "reciprocal_sum_identity", "marker": "lemma reciprocal_sum_identity:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"1/x + 1/y = (x + y) / (x * y)\"\nproof -\n  have \"1/x + 1/y = (y + x) / (x * y)\"\n    by (smt (verit) add_divide_distrib assms(1) assms(2) nonzero_divide_mult_cancel_left nonzero_divide_mult_cancel_right)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma reciprocal_sum_identity:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"1/x + 1/y = (x + y) / (x * y)\"\nproof -\n  have \"1/x + 1/y = (y + x) / (x * y)\"\n    by (smt (verit) add_divide_distrib assms(1) assms(2) nonzero_divide_mult_cancel_left nonzero_divide_mult_cancel_right)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "reciprocal_relationship": {"skill_name": "reciprocal_relationship", "marker": "lemma reciprocal_relationship:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"1/x + 1/y = (x + y) / (x * y)\"\nproof -\n  have \"1/x + 1/y = y/(x * y) + x/(x * y)\" by (metis assms(1) assms(2) nonzero_divide_mult_cancel_left nonzero_divide_mult_cancel_right)\n  then have \"1/x + 1/y = (y + x) / (x * y)\" by (smt (verit) add_divide_distrib)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma reciprocal_relationship:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"1/x + 1/y = (x + y) / (x * y)\"\nproof -\n  have \"1/x + 1/y = y/(x * y) + x/(x * y)\" by (metis assms(1) assms(2) nonzero_divide_mult_cancel_left nonzero_divide_mult_cancel_right)\n  then have \"1/x + 1/y = (y + x) / (x * y)\" by (smt (verit) add_divide_distrib)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "general_recurrence_formula": {"skill_name": "general_recurrence_formula", "marker": "lemma general_recurrence_formula:\n  fixes x :: \"nat \\<Rightarrow> int\" and k :: nat\n  assumes \"\\<And>(n::nat). (n \\<ge> 5 \\<Longrightarrow> x n = - x (n-5))\"\n  shows \"x (5*k + n) = (-1)^k * x n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  have \"x (5 * Suc k + n) = x (5 * k + 5 + n)\" by (auto simp: field_simps)\n  also have \"... = - x (5 * k + n)\" using assms(1) by auto\n  finally have \"x (5 * Suc k + n) = - x (5 * k + n)\" .\n  also have \"x (5 * k + n) = (-1)^k * x n\" using Suc.IH by simp\n  thus ?case using `x (5 * Suc k + n) = - x (5 * k + n)` by (simp add: power_Suc)\nqed", "description": "-", "full_code": "lemma general_recurrence_formula:\n  fixes x :: \"nat \\<Rightarrow> int\" and k :: nat\n  assumes \"\\<And>(n::nat). (n \\<ge> 5 \\<Longrightarrow> x n = - x (n-5))\"\n  shows \"x (5*k + n) = (-1)^k * x n\"\nproof (induction k)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc k)\n  have \"x (5 * Suc k + n) = x (5 * k + 5 + n)\" by (auto simp: field_simps)\n  also have \"... = - x (5 * k + n)\" using assms(1) by auto\n  finally have \"x (5 * Suc k + n) = - x (5 * k + n)\" .\n  also have \"x (5 * k + n) = (-1)^k * x n\" using Suc.IH by simp\n  thus ?case using `x (5 * Suc k + n) = - x (5 * k + n)` by (simp add: power_Suc)\nqed", "origin": "do_request", "update_count": 0}, "square_expansion": {"skill_name": "square_expansion", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\n  by sos", "description": "", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\n  by sos", "origin": "data/full_data/debug/valid_rand/mathd_algebra_116.json_v15", "update_count": -1}, "general_product_identity": {"skill_name": "general_product_identity", "marker": "lemma general_product_identity:\n  fixes a b :: real\n  assumes \"a \\<noteq> b\"\n    and \"a + 2/a = b + 2/b\"\n  shows \"a * b = 2\"\nproof -\n  have eq: \"a + 2/a = b + 2/b\" using assms(2) by simp\n  have rearranged: \"a - b = (2/b - 2/a)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"a - b = (2 * (a - b)) / (a * b)\"\n    using rearranged by sos\n  have factored: \"1 = 2 / (a * b)\"\n    using assms(1) common_den by sos\n  have \"a * b = 2\"\n    using `1 = 2 / (a * b)` by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma general_product_identity:\n  fixes a b :: real\n  assumes \"a \\<noteq> b\"\n    and \"a + 2/a = b + 2/b\"\n  shows \"a * b = 2\"\nproof -\n  have eq: \"a + 2/a = b + 2/b\" using assms(2) by simp\n  have rearranged: \"a - b = (2/b - 2/a)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"a - b = (2 * (a - b)) / (a * b)\"\n    using rearranged by sos\n  have factored: \"1 = 2 / (a * b)\"\n    using assms(1) common_den by sos\n  have \"a * b = 2\"\n    using `1 = 2 / (a * b)` by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "fraction_difference": {"skill_name": "fraction_difference", "marker": "lemma fraction_difference:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - c * b) / (b * d)\"\nproof -\n  have \"a / b - c / d = a / b + - (c / d)\" by simp\n  then have \"a / b + - (c / d) = (a * d) / (b * d) + (-c * b) / (b * d)\"\n    using assms by (simp add: field_simps)\n  then show ?thesis by (smt (verit) assms(1) assms(2) diff_frac_eq)\nqed", "description": "-", "full_code": "lemma fraction_difference:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - c * b) / (b * d)\"\nproof -\n  have \"a / b - c / d = a / b + - (c / d)\" by simp\n  then have \"a / b + - (c / d) = (a * d) / (b * d) + (-c * b) / (b * d)\"\n    using assms by (simp add: field_simps)\n  then show ?thesis by (smt (verit) assms(1) assms(2) diff_frac_eq)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "expression_nonneg_generalized": {"skill_name": "expression_nonneg_generalized", "marker": "lemma expression_nonneg_generalized:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by (simp add: assms)\n  have \"x^2 >= 0\" by (simp add: assms)\n  have \"y^2 >= 0\" by (simp add: assms)\n  thus \"?E >= 1\" \n  proof (cases \"x = 0 \\<and> y = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x > 0 \\<or> y > 0\" by (metis assms(1) assms(2) order_less_le)\n    hence \"x^2 * y^2 + x^2 + y^2 + 1 > 1\" using `x >= 0` `y >= 0` by sos\n    thus ?thesis by sos\n  qed\nqed", "description": "-", "full_code": "lemma expression_nonneg_generalized:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by (simp add: assms)\n  have \"x^2 >= 0\" by (simp add: assms)\n  have \"y^2 >= 0\" by (simp add: assms)\n  thus \"?E >= 1\" \n  proof (cases \"x = 0 \\<and> y = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x > 0 \\<or> y > 0\" by (metis assms(1) assms(2) order_less_le)\n    hence \"x^2 * y^2 + x^2 + y^2 + 1 > 1\" using `x >= 0` `y >= 0` by sos\n    thus ?thesis by sos\n  qed\nqed", "origin": "expression_nonneg", "update_count": 0}, "sum_terms_countV3": {"skill_name": "sum_terms_countV3", "marker": "lemma sum_terms_count:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\n  by auto", "description": "-", "full_code": "lemma sum_terms_count:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\n  by auto", "origin": "sum_terms_count", "update_count": 0}, "mod_simplification": {"skill_name": "mod_simplification", "marker": "lemma mod_simplification:\n  fixes x y n a b :: nat\n  assumes \"x mod n = a\" and \"y mod n = b\"\n  shows \"(x + y) mod n = (a + b) mod n\"\nproof -\n  let ?a = \"x mod n\"\n  let ?b = \"y mod n\"\n  have \"x = ?a + (x div n) * n\" and \"y = ?b + (y div n) * n\"\n    by auto \n  have \"x + y = (?a + ?b) + ((x div n) + (y div n)) * n\"\n    by (simp add: algebra_simps)\n  then have \"(x + y) mod n = ((?a + ?b) + ((x div n) + (y div n)) * n) mod n\"\n    by simp\n  also have \"... = (?a + ?b) mod n\"\n    by (simp add: mod_add_eq) \n  also have \"... = (a + b) mod n\"\n    using assms by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_simplification:\n  fixes x y n a b :: nat\n  assumes \"x mod n = a\" and \"y mod n = b\"\n  shows \"(x + y) mod n = (a + b) mod n\"\nproof -\n  let ?a = \"x mod n\"\n  let ?b = \"y mod n\"\n  have \"x = ?a + (x div n) * n\" and \"y = ?b + (y div n) * n\"\n    by auto \n  have \"x + y = (?a + ?b) + ((x div n) + (y div n)) * n\"\n    by (simp add: algebra_simps)\n  then have \"(x + y) mod n = ((?a + ?b) + ((x div n) + (y div n)) * n) mod n\"\n    by simp\n  also have \"... = (?a + ?b) mod n\"\n    by (simp add: mod_add_eq) \n  also have \"... = (a + b) mod n\"\n    using assms by auto\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "square_eq_n_dimensional": {"skill_name": "square_eq_n_dimensional", "marker": "lemma square_eq_n_dimensional:\n  fixes a b :: \"real list\"\n  assumes \"length a = n\" \"length b = n\" \"a = b\"\n  shows \"(\\<Sum>i=0..(n-1). a ! i^2) = (\\<Sum>i=0..(n-1). b ! i^2)\"\nproof -\n  have \"(\\<Sum>i=0..(n-1). a ! i^2) = (\\<Sum>i=0..(n-1). b ! i^2)\"\n  proof (induction n)\n    case 0\n    then show ?case by (metis assms(3))\n  next\n    case (Suc n)\n    then have \"a ! n = b ! n\" using assms(3) by (metis nth_equalityI)\n    then show ?case\n      by (metis assms(3))\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_eq_n_dimensional:\n  fixes a b :: \"real list\"\n  assumes \"length a = n\" \"length b = n\" \"a = b\"\n  shows \"(\\<Sum>i=0..(n-1). a ! i^2) = (\\<Sum>i=0..(n-1). b ! i^2)\"\nproof -\n  have \"(\\<Sum>i=0..(n-1). a ! i^2) = (\\<Sum>i=0..(n-1). b ! i^2)\"\n  proof (induction n)\n    case 0\n    then show ?case by (metis assms(3))\n  next\n    case (Suc n)\n    then have \"a ! n = b ! n\" using assms(3) by (metis nth_equalityI)\n    then show ?case\n      by (metis assms(3))\n  qed\n  thus ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "square_eq_n_dimensionsV2": {"skill_name": "square_eq_n_dimensionsV2", "marker": "lemma square_eq_n_dimensions:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\" \"a = b\"\n  shows \"sum (\\<lambda>i. a ! i ^ 2) (set (upt 0 (length a))) = sum (\\<lambda>i. b ! i ^ 2) (set (upt 0 (length b)))\"\nproof -\n  have \"sum (\\<lambda>i. a ! i ^ 2) (set (upt 0 (length a))) = sum (\\<lambda>i. b ! i ^ 2) (set (upt 0 (length a)))\"\n    by (metis assms(2))\n  then show ?thesis using assms(1) by simp\nqed", "description": "-", "full_code": "lemma square_eq_n_dimensions:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\" \"a = b\"\n  shows \"sum (\\<lambda>i. a ! i ^ 2) (set (upt 0 (length a))) = sum (\\<lambda>i. b ! i ^ 2) (set (upt 0 (length b)))\"\nproof -\n  have \"sum (\\<lambda>i. a ! i ^ 2) (set (upt 0 (length a))) = sum (\\<lambda>i. b ! i ^ 2) (set (upt 0 (length a)))\"\n    by (metis assms(2))\n  then show ?thesis using assms(1) by simp\nqed", "origin": "square_eq", "update_count": 0}, "square_eq_n_dimensionalV2": {"skill_name": "square_eq_n_dimensionalV2", "marker": "lemma square_eq_n_dimensional:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\" \"a = b\"\n  shows \"(\\<Sum>i=0..<length a. a ! i^2) = (\\<Sum>i=0..<length b. b ! i^2)\"\nproof -\n  have \"(\\<Sum>i=0..<length a. a ! i^2) = (\\<Sum>i=0..<length a. b ! i^2)\"\n    by (metis assms(2))\n  then show ?thesis by (metis assms(2))\nqed", "description": "-", "full_code": "lemma square_eq_n_dimensional:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\" \"a = b\"\n  shows \"(\\<Sum>i=0..<length a. a ! i^2) = (\\<Sum>i=0..<length b. b ! i^2)\"\nproof -\n  have \"(\\<Sum>i=0..<length a. a ! i^2) = (\\<Sum>i=0..<length a. b ! i^2)\"\n    by (metis assms(2))\n  then show ?thesis by (metis assms(2))\nqed", "origin": "square_eq", "update_count": 0}, "congruence_expression": {"skill_name": "congruence_expression", "marker": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N = 8 * k + 5\" using assms by simp\n  then show \"N mod 8 = 5\" \n    by (simp add: mod_add_eq)\nqed", "description": "-", "full_code": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N = 8 * k + 5\" using assms by simp\n  then show \"N mod 8 = 5\" \n    by (simp add: mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "congruence_expressionV2": {"skill_name": "congruence_expressionV2", "marker": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N = 8 * k + 5\" using assms by simp\n  thus \"N mod 8 = 5\" \n  proof -\n    have \"N mod 8 = (8 * k + 5) mod 8\" by (metis assms)\n    also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n    also have \"... = (0 + 5 mod 8)\" by (simp add: mod_mult_self2)\n    also have \"... = 5\" by simp\n    finally show \"N mod 8 = 5\" .\n  qed\nqed", "description": "-", "full_code": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N = 8 * k + 5\" using assms by simp\n  thus \"N mod 8 = 5\" \n  proof -\n    have \"N mod 8 = (8 * k + 5) mod 8\" by (metis assms)\n    also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n    also have \"... = (0 + 5 mod 8)\" by (simp add: mod_mult_self2)\n    also have \"... = 5\" by simp\n    finally show \"N mod 8 = 5\" .\n  qed\nqed", "origin": "do_request", "update_count": 0}, "congruence_expressionV3": {"skill_name": "congruence_expressionV3", "marker": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N = 8 * k + 5\" using assms by simp\n  then have \"N mod 8 = (8 * k + 5) mod 8\" by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5 mod 8)\" by (simp add: mod_mult_self2)\n  also have \"... = 5\" by (simp add: mod_0)\n  finally show \"N mod 8 = 5\" .\nqed", "description": "-", "full_code": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N = 8 * k + 5\" using assms by simp\n  then have \"N mod 8 = (8 * k + 5) mod 8\" by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  also have \"... = (0 + 5 mod 8)\" by (simp add: mod_mult_self2)\n  also have \"... = 5\" by (simp add: mod_0)\n  finally show \"N mod 8 = 5\" .\nqed", "origin": "do_request", "update_count": 0}, "congruence_expressionV4": {"skill_name": "congruence_expressionV4", "marker": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  then have \"N mod 8 = (0 + 5 mod 8)\" by (metis add_cancel_right_left calculation mod_mult_self4)\n  thus \"N mod 8 = 5\" by simp\nqed", "description": "-", "full_code": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n  then have \"N mod 8 = (0 + 5 mod 8)\" by (metis add_cancel_right_left calculation mod_mult_self4)\n  thus \"N mod 8 = 5\" by simp\nqed", "origin": "do_request", "update_count": 0}, "congruence_expressionV5": {"skill_name": "congruence_expressionV5", "marker": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N = 8 * k + 5\" using assms by simp\n  then show \"N mod 8 = 5\" \n  proof -\n    have \"N mod 8 = (8 * k + 5) mod 8\" by (metis assms)\n    also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n    then have \"8 * k mod 8 = 0\" by (simp add: mod_mult_self2)\n    hence \"N mod 8 = (0 + 5 mod 8)\" by (metis \\<open>(8 * k + 5) mod 8 = 8 * k mod 8 + 5 mod 8\\<close> add_cancel_left_left calculation mod_mult_self4)\n    thus \"N mod 8 = 5\" by simp\n  qed\nqed", "description": "-", "full_code": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N = 8 * k + 5\" using assms by simp\n  then show \"N mod 8 = 5\" \n  proof -\n    have \"N mod 8 = (8 * k + 5) mod 8\" by (metis assms)\n    also have \"... = (8 * k mod 8 + 5 mod 8)\" by auto\n    then have \"8 * k mod 8 = 0\" by (simp add: mod_mult_self2)\n    hence \"N mod 8 = (0 + 5 mod 8)\" by (metis \\<open>(8 * k + 5) mod 8 = 8 * k mod 8 + 5 mod 8\\<close> add_cancel_left_left calculation mod_mult_self4)\n    thus \"N mod 8 = 5\" by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_n_dimensions": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_n_dimensions", "marker": "lemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_n_dimensions:\n  fixes x e :: \"complex list\"\n  assumes \"length x = n\" \"length e = n\"\n    and h0: \"\\<forall>i. x ! i + e ! i = 7\"\n    and h1: \"\\<forall>i. 2 * (x ! i) + e ! i = 3\"\n  shows \"\\<forall>i. e ! i = 11 \\<and> x ! i = -4\"\nproof -\n  have e_eq: \"\\<forall>i. e ! i = 7 - (x ! i)\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"\\<forall>i. 2 * (x ! i) + (7 - (x ! i)) = 3\" using h1 e_eq by auto\n  have simplified_eq: \"\\<forall>i. (x ! i) + 7 = 3\" using eq2_substituted by auto\n  have x_values: \"\\<forall>i. x ! i = -4\" using simplified_eq by (metis ab_semigroup_add_class.add_ac(1) add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 mult_2)\n  have e_values: \"\\<forall>i. e ! i = 7 - (-4)\" using e_eq x_values by auto\n  show ?thesis using x_values e_values by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e=11 \\<and> x= (-4)\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed\n\nlemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_n_dimensions:\n  fixes x e :: \"complex list\"\n  assumes \"length x = n\" \"length e = n\"\n    and h0: \"\\<forall>i. x ! i + e ! i = 7\"\n    and h1: \"\\<forall>i. 2 * (x ! i) + e ! i = 3\"\n  shows \"\\<forall>i. e ! i = 11 \\<and> x ! i = -4\"\nproof -\n  have e_eq: \"\\<forall>i. e ! i = 7 - (x ! i)\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"\\<forall>i. 2 * (x ! i) + (7 - (x ! i)) = 3\" using h1 e_eq by auto\n  have simplified_eq: \"\\<forall>i. (x ! i) + 7 = 3\" using eq2_substituted by auto\n  have x_values: \"\\<forall>i. x ! i = -4\" using simplified_eq by (metis ab_semigroup_add_class.add_ac(1) add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 mult_2)\n  have e_values: \"\\<forall>i. e ! i = 7 - (-4)\" using e_eq x_values by auto\n  show ?thesis using x_values e_values by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "congruence_expressionV6": {"skill_name": "congruence_expressionV6", "marker": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" \n    using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" \n    by auto\n  also have \"... = (0 + 5 mod 8)\" \n    by (simp add: mod_mult_self2)\n  also have \"... = 5\" \n    by (simp add: mod_0)\n  finally show \"N mod 8 = 5\" .\nqed", "description": "-", "full_code": "lemma congruence_expression:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 8 = 5\"\nproof -\n  have \"N mod 8 = (8 * k + 5) mod 8\" \n    using assms by simp\n  also have \"... = (8 * k mod 8 + 5 mod 8)\" \n    by auto\n  also have \"... = (0 + 5 mod 8)\" \n    by (simp add: mod_mult_self2)\n  also have \"... = 5\" \n    by (simp add: mod_0)\n  finally show \"N mod 8 = 5\" .\nqed", "origin": "do_request", "update_count": 0}, "product_of_nonzero_terms": {"skill_name": "product_of_nonzero_terms", "marker": "lemma product_of_nonzero_terms:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  from assms show ?thesis by simp\nqed", "description": "-", "full_code": "lemma product_of_nonzero_terms:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x * y \\<noteq> 0\"\nproof -\n  from assms show ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "power_mod_10": {"skill_name": "power_mod_10", "marker": "lemma power_mod_10:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod 10 = (a mod 10)^n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^(Suc n) = a^n * a\" by simp\n    hence \"a^(Suc n) mod 10 = (a^n * a) mod 10\" by presburger\n    also have \"... = (a^n mod 10 * a mod 10) mod 10\" by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod 10)^n mod 10 * (a mod 10)) mod 10\" using Suc.IH by (metis \\<open>a ^ Suc n mod 10 = a ^ n * a mod 10\\<close> \\<open>a ^ n * a mod 10 = a ^ n mod 10 * a mod 10 mod 10\\<close> mod_mod_trivial mod_mult_cong mod_mult_eq mult.commute power_Suc power_mod)\n    finally show ?case by (metis power_mod)\n  qed\nqed", "description": "-", "full_code": "lemma power_mod_10:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod 10 = (a mod 10)^n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^(Suc n) = a^n * a\" by simp\n    hence \"a^(Suc n) mod 10 = (a^n * a) mod 10\" by presburger\n    also have \"... = (a^n mod 10 * a mod 10) mod 10\" by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod 10)^n mod 10 * (a mod 10)) mod 10\" using Suc.IH by (metis \\<open>a ^ Suc n mod 10 = a ^ n * a mod 10\\<close> \\<open>a ^ n * a mod 10 = a ^ n mod 10 * a mod 10 mod 10\\<close> mod_mod_trivial mod_mult_cong mod_mult_eq mult.commute power_Suc power_mod)\n    finally show ?case by (metis power_mod)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "power_mod_10V2": {"skill_name": "power_mod_10V2", "marker": "lemma power_mod_10:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"a ^ n mod 10 = (a mod 10) ^ n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a ^ Suc n = a * (a ^ n)\" by simp\n  also have \"... mod 10 = (a * (a ^ n mod 10)) mod 10\" by (metis mod_mult_right_eq)\n  also have \"... = (a mod 10 * (a ^ n mod 10)) mod 10\" using `a > 0` by (metis mod_mult_left_eq)\n  also have \"... = ((a mod 10) * ((a mod 10) ^ n mod 10)) mod 10\" using Suc.IH by simp\n  finally show ?case by (metis power_mod)\nqed", "description": "-", "full_code": "lemma power_mod_10:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"a ^ n mod 10 = (a mod 10) ^ n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a ^ Suc n = a * (a ^ n)\" by simp\n  also have \"... mod 10 = (a * (a ^ n mod 10)) mod 10\" by (metis mod_mult_right_eq)\n  also have \"... = (a mod 10 * (a ^ n mod 10)) mod 10\" using `a > 0` by (metis mod_mult_left_eq)\n  also have \"... = ((a mod 10) * ((a mod 10) ^ n mod 10)) mod 10\" using Suc.IH by simp\n  finally show ?case by (metis power_mod)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_eq_generalizedV4": {"skill_name": "sqrt_eq_generalizedV4", "marker": "lemma sqrt_eq_generalized:\n  fixes x a :: real\n  assumes \"sqrt (x + a) = a\" and \"a > 0\"\n  shows \"x = a^2 - a\"\nproof -\n  have \"x + a = a^2\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then show \"x = a^2 - a\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq_generalized:\n  fixes x a :: real\n  assumes \"sqrt (x + a) = a\" and \"a > 0\"\n  shows \"x = a^2 - a\"\nproof -\n  have \"x + a = a^2\" using assms by (metis add.commute real_sqrt_ge_0_iff real_sqrt_ge_zero real_sqrt_gt_0_iff real_sqrt_pow2 verit_comp_simplify1(3) zero_le_mult_iff zero_le_square)\n  then show \"x = a^2 - a\" by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "square_expansion_cubic": {"skill_name": "square_expansion_cubic", "marker": "lemma square_expansion_cubic:\n  fixes x y z :: real\n  shows \"(x - y - z)^2 = x^2 - 2 * x * (y + z) + (y + z)^2\"\nproof -\n  have \"(y + z)^2 = y^2 + 2 * y * z + z^2\" by sos\n  then show ?thesis \n    by sos\nqed", "description": "-", "full_code": "lemma square_expansion_cubic:\n  fixes x y z :: real\n  shows \"(x - y - z)^2 = x^2 - 2 * x * (y + z) + (y + z)^2\"\nproof -\n  have \"(y + z)^2 = y^2 + 2 * y * z + z^2\" by sos\n  then show ?thesis \n    by sos\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_general": {"skill_name": "square_expansion_general", "marker": "lemma square_expansion_general:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\n  by (simp add: power2_diff)", "description": "-", "full_code": "lemma square_expansion_general:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\n  by (simp add: power2_diff)", "origin": "square_expansion", "update_count": 0}, "lcm_properties": {"skill_name": "lcm_properties", "marker": "lemma lcm_properties:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  have \"lcm a b * gcd a b = a * b\" \n    using lcm_gcd[of a b] assms by auto\n  thus ?thesis \n    by (metis lcm_nat_def)\nqed", "description": "-", "full_code": "lemma lcm_properties:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  have \"lcm a b * gcd a b = a * b\" \n    using lcm_gcd[of a b] assms by auto\n  thus ?thesis \n    by (metis lcm_nat_def)\nqed", "origin": "do_request", "update_count": 0}, "power_mod_10V3": {"skill_name": "power_mod_10V3", "marker": "lemma power_mod_10:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"a ^ n mod 10 = (a mod 10) ^ n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a ^ Suc n = a * a ^ n\" by simp\n  also have \"... mod 10 = (a * a ^ n) mod 10\" by simp\n  finally have \"a ^ Suc n mod 10 = (a mod 10 * a ^ n mod 10) mod 10\" \n    by (metis mod_mod_trivial mod_mult_left_eq power_Suc)\n  also have \"... = ((a mod 10) * (a ^ n mod 10)) mod 10\" by (metis \\<open>a ^ Suc n = a * a ^ n\\<close> calculation mod_mult_eq)\n  finally have \"a ^ Suc n mod 10 = ((a mod 10) * (a ^ n mod 10)) mod 10\" .\n  have \"a ^ n mod 10 = (a mod 10) ^ n mod 10\" by (rule Suc.IH)\n  then show ?case using `a ^ Suc n mod 10 = ((a mod 10) * (a ^ n mod 10)) mod 10` by (metis power_mod)\nqed", "description": "-", "full_code": "lemma power_mod_10:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"a ^ n mod 10 = (a mod 10) ^ n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a ^ Suc n = a * a ^ n\" by simp\n  also have \"... mod 10 = (a * a ^ n) mod 10\" by simp\n  finally have \"a ^ Suc n mod 10 = (a mod 10 * a ^ n mod 10) mod 10\" \n    by (metis mod_mod_trivial mod_mult_left_eq power_Suc)\n  also have \"... = ((a mod 10) * (a ^ n mod 10)) mod 10\" by (metis \\<open>a ^ Suc n = a * a ^ n\\<close> calculation mod_mult_eq)\n  finally have \"a ^ Suc n mod 10 = ((a mod 10) * (a ^ n mod 10)) mod 10\" .\n  have \"a ^ n mod 10 = (a mod 10) ^ n mod 10\" by (rule Suc.IH)\n  then show ?case using `a ^ Suc n mod 10 = ((a mod 10) * (a ^ n mod 10)) mod 10` by (metis power_mod)\nqed", "origin": "do_request", "update_count": 0}, "power_mod_10V4": {"skill_name": "power_mod_10V4", "marker": "lemma power_mod_10:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod 10 = (a mod 10)^n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a^(Suc n) = a * a^n\" by simp\n  then have \"a^(Suc n) mod 10 = (a * a^n) mod 10\" by simp\n  also have \"... = (a mod 10 * a^n mod 10) mod 10\" \n    by (metis mod_mod_trivial mod_mult_left_eq)\n  also have \"... = (a mod 10) * (a^n mod 10) mod 10\" by (metis \\<open>a * a ^ n mod 10 = a mod 10 * a ^ n mod 10 mod 10\\<close> mod_mult_eq)\n  finally show ?case using Suc.IH by (metis power_mod)\nqed", "description": "-", "full_code": "lemma power_mod_10:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod 10 = (a mod 10)^n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then have \"a^(Suc n) = a * a^n\" by simp\n  then have \"a^(Suc n) mod 10 = (a * a^n) mod 10\" by simp\n  also have \"... = (a mod 10 * a^n mod 10) mod 10\" \n    by (metis mod_mod_trivial mod_mult_left_eq)\n  also have \"... = (a mod 10) * (a^n mod 10) mod 10\" by (metis \\<open>a * a ^ n mod 10 = a mod 10 * a ^ n mod 10 mod 10\\<close> mod_mult_eq)\n  finally show ?case using Suc.IH by (metis power_mod)\nqed", "origin": "do_request", "update_count": 0}, "lcm_propertiesV2": {"skill_name": "lcm_propertiesV2", "marker": "lemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof (cases \"a = 0\")\n  case True\n  then show ?thesis\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis by (metis lcm_nat_def)\n  qed\nnext\n  case False\n  then show ?thesis\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by auto\n  next\n    case False\n    then have \"gcd a b > 0\" using `a \\<noteq> 0` `b \\<noteq> 0` by auto\n    have \"lcm a b * gcd a b = a * b\" by (simp add: lcm_gcd)\n    then show ?thesis by (metis lcm_nat_def)\n  qed\nqed", "description": "-", "full_code": "lemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof (cases \"a = 0\")\n  case True\n  then show ?thesis\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis by (metis lcm_nat_def)\n  qed\nnext\n  case False\n  then show ?thesis\n  proof (cases \"b = 0\")\n    case True\n    then show ?thesis by auto\n  next\n    case False\n    then have \"gcd a b > 0\" using `a \\<noteq> 0` `b \\<noteq> 0` by auto\n    have \"lcm a b * gcd a b = a * b\" by (simp add: lcm_gcd)\n    then show ?thesis by (metis lcm_nat_def)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_nonnegV4": {"skill_name": "square_nonnegV4", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  from assms(1) have \"b = a\" by simp\n  then have \"b^2 = a^2\" by (simp add: power2_eq_square)\n  thus \"a^2 = b^2\" by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  from assms(1) have \"b = a\" by simp\n  then have \"b^2 = a^2\" by (simp add: power2_eq_square)\n  thus \"a^2 = b^2\" by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "mod_sum": {"skill_name": "mod_sum", "marker": "lemma mod_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  have \"x mod 10 = x - (x div 10) * 10\" by presburger\n  hence \"x = (x mod 10) + (x div 10) * 10\" by (simp add: algebra_simps)\n  have \"y mod 10 = y - (y div 10) * 10\" by presburger\n  hence \"y = (y mod 10) + (y div 10) * 10\" by (simp add: algebra_simps)\n  then have \"x + y = ((x mod 10) + (y mod 10)) + ((x div 10) + (y div 10)) * 10\" \n    using `x = (x mod 10) + (x div 10) * 10` by (simp add: algebra_simps)\n  then have \"(x + y) mod 10 = (((x mod 10) + (y mod 10)) + ((x div 10) + (y div 10)) * 10) mod 10\" \n    by (simp add: algebra_simps)\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\" \n    by presburger\n  thus ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  have \"x mod 10 = x - (x div 10) * 10\" by presburger\n  hence \"x = (x mod 10) + (x div 10) * 10\" by (simp add: algebra_simps)\n  have \"y mod 10 = y - (y div 10) * 10\" by presburger\n  hence \"y = (y mod 10) + (y div 10) * 10\" by (simp add: algebra_simps)\n  then have \"x + y = ((x mod 10) + (y mod 10)) + ((x div 10) + (y div 10)) * 10\" \n    using `x = (x mod 10) + (x div 10) * 10` by (simp add: algebra_simps)\n  then have \"(x + y) mod 10 = (((x mod 10) + (y mod 10)) + ((x div 10) + (y div 10)) * 10) mod 10\" \n    by (simp add: algebra_simps)\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\" \n    by presburger\n  thus ?thesis by presburger\nqed", "origin": "do_request", "update_count": 0}, "mod_sumV2": {"skill_name": "mod_sumV2", "marker": "lemma mod_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  have \"x = (x mod 10) + 10 * (x div 10)\" by auto\n  have \"y = (y mod 10) + 10 * (y div 10)\" by auto\n  then have \"x + y = ((x mod 10) + (y mod 10)) + 10 * ((x div 10) + (y div 10))\" \n    using `x = (x mod 10) + 10 * (x div 10)` by (simp add: field_simps)\n  then have \"(x + y) mod 10 = (((x mod 10) + (y mod 10)) + 10 * ((x div 10) + (y div 10))) mod 10\" \n    by presburger\n  also have \"... = (x mod 10 + y mod 10) mod 10\" \n    using mod_add_eq by presburger\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  have \"x = (x mod 10) + 10 * (x div 10)\" by auto\n  have \"y = (y mod 10) + 10 * (y div 10)\" by auto\n  then have \"x + y = ((x mod 10) + (y mod 10)) + 10 * ((x div 10) + (y div 10))\" \n    using `x = (x mod 10) + 10 * (x div 10)` by (simp add: field_simps)\n  then have \"(x + y) mod 10 = (((x mod 10) + (y mod 10)) + 10 * ((x div 10) + (y div 10))) mod 10\" \n    by presburger\n  also have \"... = (x mod 10 + y mod 10) mod 10\" \n    using mod_add_eq by presburger\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_sumV3": {"skill_name": "mod_sumV3", "marker": "lemma mod_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  let ?a = \"x mod 10\"\n  let ?b = \"y mod 10\"\n  have \"x = ?a + (x div 10) * 10\" and \"y = ?b + (y div 10) * 10\"\n    by auto\n  then have \"x + y = (?a + ?b) + ((x div 10) + (y div 10)) * 10\"\n    by (simp add: algebra_simps)\n  then have \"(x + y) mod 10 = ((?a + ?b) + ((x div 10) + (y div 10)) * 10) mod 10\"\n    by presburger\n  also have \"... = (?a + ?b) mod 10\"\n    by presburger\n  also have \"... = (x mod 10 + y mod 10) mod 10\"\n    by auto\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  let ?a = \"x mod 10\"\n  let ?b = \"y mod 10\"\n  have \"x = ?a + (x div 10) * 10\" and \"y = ?b + (y div 10) * 10\"\n    by auto\n  then have \"x + y = (?a + ?b) + ((x div 10) + (y div 10)) * 10\"\n    by (simp add: algebra_simps)\n  then have \"(x + y) mod 10 = ((?a + ?b) + ((x div 10) + (y div 10)) * 10) mod 10\"\n    by presburger\n  also have \"... = (?a + ?b) mod 10\"\n    by presburger\n  also have \"... = (x mod 10 + y mod 10) mod 10\"\n    by auto\n  finally show ?thesis by presburger\nqed", "origin": "do_request", "update_count": 0}, "product_prime_condition": {"skill_name": "product_prime_condition", "marker": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(1) assms(2) by (metis assms(3) prime_gt_1_nat)\n  then have \"a * b = 1 * (a * b)\" by simp\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>1 < a * b\\<close> nat_mult_eq_1_iff)\n    then have \"b = 1\" using assms(2) by (metis \\<open>1 < a\\<close> assms(3) less_not_refl2 prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>1 < a * b\\<close> nat_mult_eq_1_iff)\n    then have \"a = 1\" using assms(2) by (metis \\<open>1 < b\\<close> assms(3) less_not_refl2 prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_eq_0_iff nat_neq_iff not_one_less_zero)\nqed", "description": "-", "full_code": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(1) assms(2) by (metis assms(3) prime_gt_1_nat)\n  then have \"a * b = 1 * (a * b)\" by simp\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>1 < a * b\\<close> nat_mult_eq_1_iff)\n    then have \"b = 1\" using assms(2) by (metis \\<open>1 < a\\<close> assms(3) less_not_refl2 prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>1 < a * b\\<close> nat_mult_eq_1_iff)\n    then have \"a = 1\" using assms(2) by (metis \\<open>1 < b\\<close> assms(3) less_not_refl2 prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_eq_0_iff nat_neq_iff not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "mod4_cases_with_int": {"skill_name": "mod4_cases_with_int", "marker": "lemma mod4_cases_with_int:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  obtain b where \"a = 4 * b + (a mod 4)\" by (metis add.commute mod_eqE mod_mod_trivial)\n  hence \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_cases_with_int:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  obtain b where \"a = 4 * b + (a mod 4)\" by (metis add.commute mod_eqE mod_mod_trivial)\n  hence \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" by auto\n  thus ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "cycle_of_units_digit": {"skill_name": "cycle_of_units_digit", "marker": "fun cycle_of_units_digit :: \"nat \\<Rightarrow> nat list\" where\n  \"cycle_of_units_digit b = (if b mod 10 = 0 then [0] else \n    map (\\<lambda>k. (b ^ k) mod 10) [0 ..< 20])\"", "description": "-", "full_code": "fun cycle_of_units_digit :: \"nat \\<Rightarrow> nat list\" where\n  \"cycle_of_units_digit b = (if b mod 10 = 0 then [0] else \n    map (\\<lambda>k. (b ^ k) mod 10) [0 ..< 20])\"", "origin": "do_request", "update_count": 0}, "mod4_cases_with_expressions": {"skill_name": "mod4_cases_with_expressions", "marker": "lemma mod4_cases_with_expressions:\n  fixes a b :: int\n  shows \"a mod 4 = b mod 4 \\<longleftrightarrow> (a - b) mod 4 = 0\"\nproof -\n  {\n    assume \"a mod 4 = b mod 4\"\n    hence \"(a - b) mod 4 = 0\" \n      using mod_add_eq by presburger\n  }\n  moreover\n  {\n    assume \"(a - b) mod 4 = 0\"\n    hence \"a mod 4 = b mod 4\" \n      using mod_diff_eq by presburger\n  }\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_cases_with_expressions:\n  fixes a b :: int\n  shows \"a mod 4 = b mod 4 \\<longleftrightarrow> (a - b) mod 4 = 0\"\nproof -\n  {\n    assume \"a mod 4 = b mod 4\"\n    hence \"(a - b) mod 4 = 0\" \n      using mod_add_eq by presburger\n  }\n  moreover\n  {\n    assume \"(a - b) mod 4 = 0\"\n    hence \"a mod 4 = b mod 4\" \n      using mod_diff_eq by presburger\n  }\n  ultimately show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "amc12b_2003_p9_extendedV3": {"skill_name": "amc12b_2003_p9_extendedV3", "marker": "theorem amc12b_2003_p9_extended:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n    and \"f 12 - f 2 = 30\"\n  shows \"a = 3\"\nproof -\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (smt (verit) \\<open>f 6 - f 2 = a * 6 + b - (a * 2 + b)\\<close>)\n  then have \"4 * a = 12\" using assms(2) by simp\n  thus \"a = 3\" by (simp)\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9_extended:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n    and \"f 12 - f 2 = 30\"\n  shows \"a = 3\"\nproof -\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (smt (verit) \\<open>f 6 - f 2 = a * 6 + b - (a * 2 + b)\\<close>)\n  then have \"4 * a = 12\" using assms(2) by simp\n  thus \"a = 3\" by (simp)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "amc12b_2003_p9_evolved": {"skill_name": "amc12b_2003_p9_evolved", "marker": "theorem amc12b_2003_p9_evolved:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f x - f y = (x - y) * a\"\nproof -\n  have \"f x - f y = (a * x + b) - (a * y + b)\" for x y by (simp add: assms(1))\n  thus ?thesis by (metis add.commute add_diff_cancel_left add_diff_eq assms(1) mult.commute right_diff_distrib)\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9_evolved:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f x - f y = (x - y) * a\"\nproof -\n  have \"f x - f y = (a * x + b) - (a * y + b)\" for x y by (simp add: assms(1))\n  thus ?thesis by (metis add.commute add_diff_cancel_left add_diff_eq assms(1) mult.commute right_diff_distrib)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "expression_nonneg_extended": {"skill_name": "expression_nonneg_extended", "marker": "lemma expression_nonneg_extended:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  show \"?E >= 1\"\n  proof (cases \"x = 0 \\<and> y = 0\")\n    case True\n    then show ?thesis by auto\n  next\n    case False\n    then have \"x^2 + y^2 > 0\" by sos\n    thus ?thesis using `x^2 * y^2 >= 0` by sos\n  qed\nqed", "description": "-", "full_code": "lemma expression_nonneg_extended:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  show \"?E >= 1\"\n  proof (cases \"x = 0 \\<and> y = 0\")\n    case True\n    then show ?thesis by auto\n  next\n    case False\n    then have \"x^2 + y^2 > 0\" by sos\n    thus ?thesis using `x^2 * y^2 >= 0` by sos\n  qed\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "amc12a_2021_p7_v3": {"skill_name": "amc12a_2021_p7_v3", "marker": "theorem amc12a_2021_p7_v3:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y) - 1)^2 + (x + y)^2\"\n    by simp\n  also have \"... = 1 + (x + y)^2 + x^2 * y^2 - 2 * x * y\" by sos\n  finally show ?thesis using expression_nonneg_extended by (metis)\nqed", "description": "-", "full_code": "lemma expression_nonneg_extended:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  show \"?E >= 1\"\n  proof (cases \"x = 0 \\<and> y = 0\")\n    case True\n    then show ?thesis by auto\n  next\n    case False\n    then have \"x^2 + y^2 > 0\" by sos\n    thus ?thesis using `x^2 * y^2 >= 0` by sos\n  qed\nqed\n\ntheorem amc12a_2021_p7_v3:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  have \"((x * y) - 1)^2 + (x + y)^2 = ((x * y) - 1)^2 + (x + y)^2\"\n    by simp\n  also have \"... = 1 + (x + y)^2 + x^2 * y^2 - 2 * x * y\" by sos\n  finally show ?thesis using expression_nonneg_extended by (metis)\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "algebra_2varlineareq_extended": {"skill_name": "algebra_2varlineareq_extended", "marker": "theorem algebra_2varlineareq_extended:\n  fixes x y e :: complex\n  assumes h0 : \"x + y = 7\"\n    and h1 : \"2 * x + y = 3\"\n  shows \"y = 11 \\<and> x = (-4)\"\nproof -\n  have y_eq: \"y = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 y_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 diff_add_eq diff_minus_eq_add mult.commute mult_2_right verit_minus_simplify(4))\n  have y_value: \"y = 7 - (-4)\" using y_eq x_value by simp\n  show ?thesis using x_value y_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed\n\ntheorem algebra_2varlineareq_extended:\n  fixes x y e :: complex\n  assumes h0 : \"x + y = 7\"\n    and h1 : \"2 * x + y = 3\"\n  shows \"y = 11 \\<and> x = (-4)\"\nproof -\n  have y_eq: \"y = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 y_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 diff_add_eq diff_minus_eq_add mult.commute mult_2_right verit_minus_simplify(4))\n  have y_value: \"y = 7 - (-4)\" using y_eq x_value by simp\n  show ?thesis using x_value y_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v2": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v2", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v2:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + e = 3\" using h1 e_eq by simp\n  have \"2 * x + (7 - x) = 3\" using eq2_substituted by (metis e_eq)\n  hence \"x + 7 = 3\" by simp\n  hence \"x = -4\" by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  then show ?thesis using e_eq by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v2:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + e = 3\" using h1 e_eq by simp\n  have \"2 * x + (7 - x) = 3\" using eq2_substituted by (metis e_eq)\n  hence \"x + 7 = 3\" by simp\n  hence \"x = -4\" by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  then show ?thesis using e_eq by (simp add: field_simps)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v3": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v3", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v3:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + e = 3\" using h1 e_eq by simp\n  have \"2 * x + (7 - x) = 3\" using eq2_substituted by (metis e_eq)\n  have \"x + 7 = 3\" by (smt (verit) h0 h1 left_add_twice)\n  have \"x = -4\" using `x + 7 = 3` by (metis add.commute add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v2 diff_add_eq diff_minus_eq_add mult.commute mult_2_right verit_minus_simplify(4))\n  then have \"e = 7 - (-4)\" using e_eq by simp\n  thus ?thesis by (metis \\<open>x = - 4\\<close> algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v2 diff_minus_eq_add h0 h1)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v2:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + e = 3\" using h1 e_eq by simp\n  have \"2 * x + (7 - x) = 3\" using eq2_substituted by (metis e_eq)\n  hence \"x + 7 = 3\" by simp\n  hence \"x = -4\" by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  then show ?thesis using e_eq by (simp add: field_simps)\nqed\n\ntheorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v3:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + e = 3\" using h1 e_eq by simp\n  have \"2 * x + (7 - x) = 3\" using eq2_substituted by (metis e_eq)\n  have \"x + 7 = 3\" by (smt (verit) h0 h1 left_add_twice)\n  have \"x = -4\" using `x + 7 = 3` by (metis add.commute add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v2 diff_add_eq diff_minus_eq_add mult.commute mult_2_right verit_minus_simplify(4))\n  then have \"e = 7 - (-4)\" using e_eq by simp\n  thus ?thesis by (metis \\<open>x = - 4\\<close> algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_v2 diff_minus_eq_add h0 h1)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "integer_distribution": {"skill_name": "integer_distribution", "marker": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\"\n  shows \"x \\<le> n \\<Longrightarrow> y \\<le> n\"\nproof -\n  assume hyp: \"x \\<le> n\"\n  have \"y = n - x\" using assms by simp\n  also have \"... \\<le> n\" using hyp by (simp add: nat_le_linear)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\"\n  shows \"x \\<le> n \\<Longrightarrow> y \\<le> n\"\nproof -\n  assume hyp: \"x \\<le> n\"\n  have \"y = n - x\" using assms by simp\n  also have \"... \\<le> n\" using hyp by (simp add: nat_le_linear)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "solve_for_x": {"skill_name": "solve_for_x", "marker": "lemma solve_for_x:\n  fixes x :: real\n  shows \"9 = sqrt (x + 9) \\<Longrightarrow> x = 72\"\nproof -\n  assume \"9 = sqrt (x + 9)\"\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show \"x = 72\" by simp\nqed", "description": "-", "full_code": "lemma solve_for_x:\n  fixes x :: real\n  shows \"9 = sqrt (x + 9) \\<Longrightarrow> x = 72\"\nproof -\n  assume \"9 = sqrt (x + 9)\"\n  then have \"x + 9 = 9^2\" by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then show \"x = 72\" by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_sqrt_expression": {"skill_name": "simplify_sqrt_expression", "marker": "lemma simplify_sqrt_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt a / b = sqrt (a / (b^2))\"\nproof -\n  have \"sqrt a / b = sqrt a * (1 / b)\" by (simp add: field_simps)\n  also have \"... = sqrt a * sqrt (1 / (b^2))\" using assms by (metis calculation div_by_1 divide_cancel_right divide_divide_eq_left divide_divide_eq_right divide_divide_times_eq divide_eq_eq_numeral1(1) less_eq_real_def mult.commute mult_cancel_left1 mult_cancel_right2 mult_delta_right mult_right_cancel power2_eq_square power_one_over real_sqrt_divide real_sqrt_mult real_sqrt_power real_sqrt_unique zero_neq_numeral zero_neq_one)\n  also have \"... = sqrt (a * (1 / (b^2)))\" by (metis real_sqrt_mult)\n  finally show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma simplify_sqrt_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt a / b = sqrt (a / (b^2))\"\nproof -\n  have \"sqrt a / b = sqrt a * (1 / b)\" by (simp add: field_simps)\n  also have \"... = sqrt a * sqrt (1 / (b^2))\" using assms by (metis calculation div_by_1 divide_cancel_right divide_divide_eq_left divide_divide_eq_right divide_divide_times_eq divide_eq_eq_numeral1(1) less_eq_real_def mult.commute mult_cancel_left1 mult_cancel_right2 mult_delta_right mult_right_cancel power2_eq_square power_one_over real_sqrt_divide real_sqrt_mult real_sqrt_power real_sqrt_unique zero_neq_numeral zero_neq_one)\n  also have \"... = sqrt (a * (1 / (b^2)))\" by (metis real_sqrt_mult)\n  finally show ?thesis by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "simplify_sqrt_expressionV2": {"skill_name": "simplify_sqrt_expressionV2", "marker": "lemma simplify_sqrt_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt a / b = sqrt (a / (b^2))\"\nproof -\n  have \"b^2 > 0\" using assms(2) by (simp add: power2_eq_square)\n  hence \"sqrt (b^2) = b\" by (metis assms(2) less_eq_real_def real_sqrt_unique)\n  have \"sqrt a / b = sqrt a * (1 / b)\" by (simp add: field_split_simps)\n  also have \"... = sqrt a * sqrt (1 / (b^2))\" by (metis \\<open>sqrt (b\\<^sup>2) = b\\<close> calculation one_add_one power2_eq_square real_sqrt_divide real_sqrt_one)\n  finally show ?thesis using `b^2 > 0` by (metis \\<open>sqrt (b\\<^sup>2) = b\\<close> divide_cancel_left divide_divide_eq_left divide_divide_times_eq divide_eq_0_iff divide_eq_eq_numeral1(1) mult.commute mult_cancel_left1 mult_cancel_right1 mult_delta_right mult_left_cancel one_eq_divide_iff power2_eq_square real_sqrt_divide real_sqrt_eq_iff real_sqrt_eq_zero_cancel_iff times_divide_eq_left times_divide_eq_right zero_neq_numeral zero_neq_one)\nqed", "description": "-", "full_code": "lemma simplify_sqrt_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt a / b = sqrt (a / (b^2))\"\nproof -\n  have \"b^2 > 0\" using assms(2) by (simp add: power2_eq_square)\n  hence \"sqrt (b^2) = b\" by (metis assms(2) less_eq_real_def real_sqrt_unique)\n  have \"sqrt a / b = sqrt a * (1 / b)\" by (simp add: field_split_simps)\n  also have \"... = sqrt a * sqrt (1 / (b^2))\" by (metis \\<open>sqrt (b\\<^sup>2) = b\\<close> calculation one_add_one power2_eq_square real_sqrt_divide real_sqrt_one)\n  finally show ?thesis using `b^2 > 0` by (metis \\<open>sqrt (b\\<^sup>2) = b\\<close> divide_cancel_left divide_divide_eq_left divide_divide_times_eq divide_eq_0_iff divide_eq_eq_numeral1(1) mult.commute mult_cancel_left1 mult_cancel_right1 mult_delta_right mult_left_cancel one_eq_divide_iff power2_eq_square real_sqrt_divide real_sqrt_eq_iff real_sqrt_eq_zero_cancel_iff times_divide_eq_left times_divide_eq_right zero_neq_numeral zero_neq_one)\nqed", "origin": "do_request", "update_count": 0}, "specific_sum_terms_count": {"skill_name": "specific_sum_terms_count", "marker": "lemma specific_sum_terms_count:\n  shows \"card {19::nat..<92} = 73\"\n  using sum_terms_count[of 19 92] by simp", "description": "-", "full_code": "lemma sum_terms_count:\n  fixes a b :: nat\n  shows \"card {a ..< b} = b - a\"\nproof -\n  have \"b - a = card {a ..< b}\" \n    by auto \n  thus ?thesis by auto\nqed\n\nlemma specific_sum_terms_count:\n  shows \"card {19::nat..<92} = 73\"\n  using sum_terms_count[of 19 92] by simp", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_countV4": {"skill_name": "sum_terms_countV4", "marker": "lemma sum_terms_count:\n  fixes a b :: nat\n  shows \"card {a ..< b} = b - a\"\nproof -\n  have \"b - a = card {a ..< b}\" \n    by auto \n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_terms_count:\n  fixes a b :: nat\n  shows \"card {a ..< b} = b - a\"\nproof -\n  have \"b - a = card {a ..< b}\" \n    by auto \n  thus ?thesis by auto\nqed", "origin": "sum_terms_count", "update_count": 0}, "mathd_algebra_system": {"skill_name": "mathd_algebra_system", "marker": "theorem mathd_algebra_system:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"2*a - b = d\"\n    and h2 : \"a = 4\"\n  shows \"b = (12 - 3 * 4) / 2\"\nproof -\n  have eq0: \"3*a + 2*b = 12\" using h0 by simp\n  have eq1: \"2*a - b = d\" using h1 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h2 eq0 by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  thus ?thesis using solution by (simp add: h2)\nqed", "description": "-", "full_code": "theorem mathd_algebra_system:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"2*a - b = d\"\n    and h2 : \"a = 4\"\n  shows \"b = (12 - 3 * 4) / 2\"\nproof -\n  have eq0: \"3*a + 2*b = 12\" using h0 by simp\n  have eq1: \"2*a - b = d\" using h1 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h2 eq0 by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  thus ?thesis using solution by (simp add: h2)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_for_b_generalized": {"skill_name": "solve_for_b_generalized", "marker": "theorem solve_for_b_generalized:\n  fixes a b p :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"m \\<noteq> 0\" and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a) / n\"\nproof -\n  have \"n*b = p - m*a\"\n    using h0 by simp\n  then have \"b = (p - m*a)/n\"\n    by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem solve_for_b_generalized:\n  fixes a b p :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"m \\<noteq> 0\" and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a) / n\"\nproof -\n  have \"n*b = p - m*a\"\n    using h0 by simp\n  then have \"b = (p - m*a)/n\"\n    by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_for_b_with_a": {"skill_name": "solve_for_b_with_a", "marker": "theorem solve_for_b_with_a:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_val\" \n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a_val) / n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"b = (p - m*a) / n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis using h1 by simp\nqed", "description": "-", "full_code": "theorem solve_for_b_with_a:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_val\" \n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a_val) / n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"b = (p - m*a) / n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis using h1 by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "combine_modular_resultsV3": {"skill_name": "combine_modular_resultsV3", "marker": "lemma combine_modular_results:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = 10 * (a div 10)\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + 6\" using assms(2) by presburger\n  have \"a + b = (10 * (a div 10)) + (10 * (b div 10) + 6)\"\n    by (metis \\<open>a = 10 * (a div 10)\\<close> \\<open>b = 10 * (b div 10) + 6\\<close>)\n  then have \"a + b = 10 * (a div 10 + b div 10) + 6\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (10 * (a div 10 + b div 10) + 6) mod 10\"\n    by simp\n  also have \"... = (6 mod 10)\"\n    by presburger\n  also have \"... = 6\" by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_modular_results:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" and \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = 10 * (a div 10)\" using assms(1) by auto\n  have \"b = 10 * (b div 10) + 6\" using assms(2) by presburger\n  have \"a + b = (10 * (a div 10)) + (10 * (b div 10) + 6)\"\n    by (metis \\<open>a = 10 * (a div 10)\\<close> \\<open>b = 10 * (b div 10) + 6\\<close>)\n  then have \"a + b = 10 * (a div 10 + b div 10) + 6\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (10 * (a div 10 + b div 10) + 6) mod 10\"\n    by simp\n  also have \"... = (6 mod 10)\"\n    by presburger\n  also have \"... = 6\" by simp\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_propertiesV3": {"skill_name": "sqrt_propertiesV3", "marker": "lemma sqrt_properties:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a + b) \\<le> sqrt a + sqrt b\"\nproof -\n  have \"sqrt (a + b) ^ 2 = a + b\" using assms(1) assms(2) by (simp add: sqrt_def)\n  have \"sqrt a ^ 2 = a\" using assms(1) by (simp add: sqrt_def)\n  have \"sqrt b ^ 2 = b\" using assms(2) by (simp add: sqrt_def)\n  have \"sqrt a + sqrt b \\<ge> 0\" using assms(1) assms(2) by auto\n  have \"(sqrt a + sqrt b) ^ 2 = sqrt a ^ 2 + 2 * sqrt a * sqrt b + sqrt b ^ 2\"\n    by (smt (verit) power2_sum)\n  also have \"... = a + 2 * sqrt a * sqrt b + b\" \n    by (simp add: `sqrt a ^ 2 = a` `sqrt b ^ 2 = b`)\n  finally have \"sqrt (a + b) ^ 2 \\<le> (sqrt a + sqrt b) ^ 2\" \n    using `sqrt (a + b) ^ 2 = a + b` \n    by (metis assms(1) assms(2) power2_eq_square real_sqrt_power sqrt_add_le_add_sqrt sqrt_le_D)\n  thus ?thesis using `sqrt (a + b) ^ 2 = a + b` by (metis assms(1) assms(2) sqrt_add_le_add_sqrt)\nqed", "description": "-", "full_code": "lemma sqrt_properties:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a + b) \\<le> sqrt a + sqrt b\"\nproof -\n  have \"sqrt (a + b) ^ 2 = a + b\" using assms(1) assms(2) by (simp add: sqrt_def)\n  have \"sqrt a ^ 2 = a\" using assms(1) by (simp add: sqrt_def)\n  have \"sqrt b ^ 2 = b\" using assms(2) by (simp add: sqrt_def)\n  have \"sqrt a + sqrt b \\<ge> 0\" using assms(1) assms(2) by auto\n  have \"(sqrt a + sqrt b) ^ 2 = sqrt a ^ 2 + 2 * sqrt a * sqrt b + sqrt b ^ 2\"\n    by (smt (verit) power2_sum)\n  also have \"... = a + 2 * sqrt a * sqrt b + b\" \n    by (simp add: `sqrt a ^ 2 = a` `sqrt b ^ 2 = b`)\n  finally have \"sqrt (a + b) ^ 2 \\<le> (sqrt a + sqrt b) ^ 2\" \n    using `sqrt (a + b) ^ 2 = a + b` \n    by (metis assms(1) assms(2) power2_eq_square real_sqrt_power sqrt_add_le_add_sqrt sqrt_le_D)\n  thus ?thesis using `sqrt (a + b) ^ 2 = a + b` by (metis assms(1) assms(2) sqrt_add_le_add_sqrt)\nqed", "origin": "do_request", "update_count": 0}, "expression_nonneg_simplified": {"skill_name": "expression_nonneg_simplified", "marker": "lemma expression_nonneg_simplified:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  thus \"?E >= 1\" \n  proof (cases \"x = 0 \\<and> y = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x^2 * y^2 >= 0\" by auto\n    then have \"x^2 >= 0\" by auto\n    then have \"y^2 >= 0\" by auto\n    show ?thesis using False by sos\n  qed\nqed", "description": "-", "full_code": "lemma expression_nonneg_simplified:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  thus \"?E >= 1\" \n  proof (cases \"x = 0 \\<and> y = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"x^2 * y^2 >= 0\" by auto\n    then have \"x^2 >= 0\" by auto\n    then have \"y^2 >= 0\" by auto\n    show ?thesis using False by sos\n  qed\nqed", "origin": "expression_nonneg", "update_count": 0}, "expression_nonneg_modified": {"skill_name": "expression_nonneg_modified", "marker": "lemma expression_nonneg_modified:\n  fixes x y a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 + a + b >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2 + a + b\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2) + a + b\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1 + a + b\" by sos\n  have \"x^2 * y^2 >= 0\" by (simp add: power2_eq_square)\n  have \"x^2 >= 0\" by (simp add: power2_eq_square)\n  have \"y^2 >= 0\" by (simp add: power2_eq_square)\n  have \"a >= 0\" using assms(1) by auto\n  have \"b >= 0\" using assms(2) by auto\n  thus \"?E >= 1\" \n    using `x^2 * y^2 >= 0` `x^2 >= 0` `y^2 >= 0` `a >= 0` `b >= 0` \n    by sos\nqed", "description": "-", "full_code": "lemma expression_nonneg_modified:\n  fixes x y a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 + a + b >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2 + a + b\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2) + a + b\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1 + a + b\" by sos\n  have \"x^2 * y^2 >= 0\" by (simp add: power2_eq_square)\n  have \"x^2 >= 0\" by (simp add: power2_eq_square)\n  have \"y^2 >= 0\" by (simp add: power2_eq_square)\n  have \"a >= 0\" using assms(1) by auto\n  have \"b >= 0\" using assms(2) by auto\n  thus \"?E >= 1\" \n    using `x^2 * y^2 >= 0` `x^2 >= 0` `y^2 >= 0` `a >= 0` `b >= 0` \n    by sos\nqed", "origin": "expression_nonneg", "update_count": 0}, "bounds_on_n": {"skill_name": "bounds_on_n", "marker": "lemma bounds_on_N:\n  fixes m :: nat\n  assumes \"N = 24 * m + 21\" \"N < 50\"\n  shows \"m < 2\"\nproof -\n  from assms(2) have \"N < 50\" by simp\n  hence \"24 * m + 21 < 50\" using assms(1) by simp\n  thus ?thesis\n  proof -\n    have \"24 * m < 50 - 21\" by (smt (verit) \\<open>24 * m + 21 < 50\\<close> less_diff_conv)\n    hence \"24 * m < 29\" by simp\n    then show \"m < 2\" by auto\n  qed\nqed", "description": "-", "full_code": "lemma bounds_on_N:\n  fixes m :: nat\n  assumes \"N = 24 * m + 21\" \"N < 50\"\n  shows \"m < 2\"\nproof -\n  from assms(2) have \"N < 50\" by simp\n  hence \"24 * m + 21 < 50\" using assms(1) by simp\n  thus ?thesis\n  proof -\n    have \"24 * m < 50 - 21\" by (smt (verit) \\<open>24 * m + 21 < 50\\<close> less_diff_conv)\n    hence \"24 * m < 29\" by simp\n    then show \"m < 2\" by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "odd_even_product": {"skill_name": "odd_even_product", "marker": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  have \"a mod 2 = 0\" and \"b mod 2 = 1\" using assms by auto\n  have \"a * b mod 2 = (0 * (b mod 2)) mod 2\" \n    using `a mod 2 = 0` by auto\n  moreover have \"(0 * (b mod 2)) mod 2 = 0\" \n    by auto\n  ultimately show \"(a * b) mod 2 = 0\" by simp\nqed", "description": "-", "full_code": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  have \"a mod 2 = 0\" and \"b mod 2 = 1\" using assms by auto\n  have \"a * b mod 2 = (0 * (b mod 2)) mod 2\" \n    using `a mod 2 = 0` by auto\n  moreover have \"(0 * (b mod 2)) mod 2 = 0\" \n    by auto\n  ultimately show \"(a * b) mod 2 = 0\" by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_sqrt_expressionV3": {"skill_name": "simplify_sqrt_expressionV3", "marker": "lemma simplify_sqrt_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt a / b = sqrt (a / (b^2))\"\nproof -\n  have \"b^2 > 0\" using assms(2) by (simp add: power2_eq_square)\n  hence \"sqrt (b^2) = b\" by (metis assms(2) less_eq_real_def real_sqrt_unique)\n  have \"sqrt a / b = sqrt a * (1 / b)\" by (simp add: field_split_simps)\n  also have \"... = sqrt a * (sqrt (1 / (b^2)))\" \n    using `b^2 > 0` by (metis \\<open>sqrt (b\\<^sup>2) = b\\<close> calculation div_by_1 divide_cancel_right divide_divide_eq_left divide_divide_eq_right divide_divide_times_eq divide_eq_eq_numeral1(1) mult.commute mult_cancel_left1 mult_cancel_right1 mult_delta_right mult_right_cancel power2_eq_square power_one_over real_sqrt_divide real_sqrt_mult real_sqrt_power zero_neq_numeral zero_neq_one)\n  also have \"... = sqrt (a * (1 / (b^2)))\" \n    by (metis real_sqrt_mult)\n  finally have \"sqrt a / b = sqrt (a / (b^2))\" \n    using `b^2 > 0` by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma simplify_sqrt_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt a / b = sqrt (a / (b^2))\"\nproof -\n  have \"b^2 > 0\" using assms(2) by (simp add: power2_eq_square)\n  hence \"sqrt (b^2) = b\" by (metis assms(2) less_eq_real_def real_sqrt_unique)\n  have \"sqrt a / b = sqrt a * (1 / b)\" by (simp add: field_split_simps)\n  also have \"... = sqrt a * (sqrt (1 / (b^2)))\" \n    using `b^2 > 0` by (metis \\<open>sqrt (b\\<^sup>2) = b\\<close> calculation div_by_1 divide_cancel_right divide_divide_eq_left divide_divide_eq_right divide_divide_times_eq divide_eq_eq_numeral1(1) mult.commute mult_cancel_left1 mult_cancel_right1 mult_delta_right mult_right_cancel power2_eq_square power_one_over real_sqrt_divide real_sqrt_mult real_sqrt_power zero_neq_numeral zero_neq_one)\n  also have \"... = sqrt (a * (1 / (b^2)))\" \n    by (metis real_sqrt_mult)\n  finally have \"sqrt a / b = sqrt (a / (b^2))\" \n    using `b^2 > 0` by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_sqrt_expressionV4": {"skill_name": "simplify_sqrt_expressionV4", "marker": "lemma simplify_sqrt_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt a / b = sqrt (a / (b^2))\"\nproof -\n  have \"b^2 > 0\" using assms(2) by (simp add: power2_eq_square)\n  hence \"sqrt (b^2) = b\" by (metis assms(2) less_eq_real_def real_sqrt_unique)\n  have \"sqrt a / b = sqrt a * (1 / b)\" by (simp add: field_split_simps)\n  also have \"... = sqrt a * sqrt (1 / (b^2))\" by (metis \\<open>sqrt (b\\<^sup>2) = b\\<close> calculation one_add_one power2_eq_square real_sqrt_divide real_sqrt_one)\n  also have \"... = sqrt (a * (1 / (b^2)))\" by (metis real_sqrt_mult)\n  finally show ?thesis using `b^2 > 0` by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma simplify_sqrt_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt a / b = sqrt (a / (b^2))\"\nproof -\n  have \"b^2 > 0\" using assms(2) by (simp add: power2_eq_square)\n  hence \"sqrt (b^2) = b\" by (metis assms(2) less_eq_real_def real_sqrt_unique)\n  have \"sqrt a / b = sqrt a * (1 / b)\" by (simp add: field_split_simps)\n  also have \"... = sqrt a * sqrt (1 / (b^2))\" by (metis \\<open>sqrt (b\\<^sup>2) = b\\<close> calculation one_add_one power2_eq_square real_sqrt_divide real_sqrt_one)\n  also have \"... = sqrt (a * (1 / (b^2)))\" by (metis real_sqrt_mult)\n  finally show ?thesis using `b^2 > 0` by (simp add: divide_simps)\nqed", "origin": "do_request", "update_count": 0}, "square_eq_n_dimensionsV3": {"skill_name": "square_eq_n_dimensionsV3", "marker": "lemma square_eq_n_dimensions:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\" \"(\\<forall>i. a ! i = b ! i)\"\n  shows \"sum (\\<lambda>i. (a ! i)^2) {0..length a - 1} = sum (\\<lambda>i. (b ! i)^2) {0..length b - 1}\"\nproof -\n  have \"sum (\\<lambda>i. (a ! i)^2) {0..length a - 1} = sum (\\<lambda>i. (b ! i)^2) {0..length b - 1}\" \n    using assms by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_eq_n_dimensions:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\" \"(\\<forall>i. a ! i = b ! i)\"\n  shows \"sum (\\<lambda>i. (a ! i)^2) {0..length a - 1} = sum (\\<lambda>i. (b ! i)^2) {0..length b - 1}\"\nproof -\n  have \"sum (\\<lambda>i. (a ! i)^2) {0..length a - 1} = sum (\\<lambda>i. (b ! i)^2) {0..length b - 1}\" \n    using assms by auto\n  then show ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "sqrt_sum_squares": {"skill_name": "sqrt_sum_squares", "marker": "fun sqrt_sum_squares :: \"real list \\<Rightarrow> real\" where\n  \"sqrt_sum_squares [] = 0\" |\n  \"sqrt_sum_squares (x # xs) = sqrt(x^2 + sqrt_sum_squares xs^2)\"", "description": "-", "full_code": "fun sqrt_sum_squares :: \"real list \\<Rightarrow> real\" where\n  \"sqrt_sum_squares [] = 0\" |\n  \"sqrt_sum_squares (x # xs) = sqrt(x^2 + sqrt_sum_squares xs^2)\"", "origin": "sqrt_eq", "update_count": 0}, "isolate_x": {"skill_name": "isolate_x", "marker": "lemma isolate_x:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"x = 72\"\nproof -\n  have \"x = 81 - 9\" using assms by simp\n  then show \"x = 72\" by simp\nqed", "description": "-", "full_code": "lemma isolate_x:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"x = 72\"\nproof -\n  have \"x = 81 - 9\" using assms by simp\n  then show \"x = 72\" by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_sqrt_expressionV5": {"skill_name": "simplify_sqrt_expressionV5", "marker": "lemma simplify_sqrt_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt a / b = sqrt (a / (b^2))\"\nproof -\n  have \"sqrt a / b = sqrt a * (1 / b)\" by (simp add: field_simps)\n  also have \"... = sqrt a * sqrt (1 / (b^2))\" \n    using assms by (simp add: real_sqrt_divide)\n  also have \"... = sqrt (a * (1 / (b^2)))\" \n    by (metis real_sqrt_mult)\n  also have \"... = sqrt (a / (b^2))\" \n    by (simp add: field_simps)\n  finally show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma simplify_sqrt_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt a / b = sqrt (a / (b^2))\"\nproof -\n  have \"sqrt a / b = sqrt a * (1 / b)\" by (simp add: field_simps)\n  also have \"... = sqrt a * sqrt (1 / (b^2))\" \n    using assms by (simp add: real_sqrt_divide)\n  also have \"... = sqrt (a * (1 / (b^2)))\" \n    by (metis real_sqrt_mult)\n  also have \"... = sqrt (a / (b^2))\" \n    by (simp add: field_simps)\n  finally show ?thesis by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "mod4_cases_extendedV2": {"skill_name": "mod4_cases_extendedV2", "marker": "lemma mod4_cases_extended:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" by (simp add: mod_less)\n  moreover have \"0 \\<le> a mod 4\" by auto\n  ultimately show ?thesis using less_Suc_eq by auto\nqed", "description": "-", "full_code": "lemma mod4_cases_extended:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 < 4\" by (simp add: mod_less)\n  moreover have \"0 \\<le> a mod 4\" by auto\n  ultimately show ?thesis using less_Suc_eq by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "mod4_addition": {"skill_name": "mod4_addition", "marker": "lemma mod4_addition:\n  fixes x y :: int\n  shows \"(x + y) mod 4 = ((x mod 4) + (y mod 4)) mod 4\"\nproof -\n  have \"x mod 4 + y mod 4 < 8\" by (simp add: mod_less)\n  then have \"((x mod 4) + (y mod 4)) mod 4 = (x + y) mod 4\"\n    by presburger\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod4_addition:\n  fixes x y :: int\n  shows \"(x + y) mod 4 = ((x mod 4) + (y mod 4)) mod 4\"\nproof -\n  have \"x mod 4 + y mod 4 < 8\" by (simp add: mod_less)\n  then have \"((x mod 4) + (y mod 4)) mod 4 = (x + y) mod 4\"\n    by presburger\n  thus ?thesis by simp\nqed", "origin": "mod4_cases", "update_count": 0}, "arithmetic_inequalities": {"skill_name": "arithmetic_inequalities", "marker": "lemma arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a < b\" and \"b < c\"\n  shows \"a < c\"\nproof -\n  have \"c - b > 0\" using assms(2) by (simp add: less_diff_eq)\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"b > a\" by (simp add: less_diff_eq)\n  then have \"c > a\" using `c - b > 0` by (simp add: add_pos_nonneg)\n  thus ?thesis by (simp add: less_diff_eq)\nqed", "description": "-", "full_code": "lemma arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a < b\" and \"b < c\"\n  shows \"a < c\"\nproof -\n  have \"c - b > 0\" using assms(2) by (simp add: less_diff_eq)\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"b > a\" by (simp add: less_diff_eq)\n  then have \"c > a\" using `c - b > 0` by (simp add: add_pos_nonneg)\n  thus ?thesis by (simp add: less_diff_eq)\nqed", "origin": "do_request", "update_count": 0}, "arithmetic_inequalitiesV2": {"skill_name": "arithmetic_inequalitiesV2", "marker": "lemma arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a < b\" and \"b < c\"\n  shows \"a < c\"\nproof -\n  from assms(1) have \"b - a > 0\" using less_diff_eq by simp\n  from assms(2) have \"c - b > 0\" using less_diff_eq by simp\n  then have \"c - a = (c - b) + (b - a)\" by (simp add: algebra_simps)\n  then show ?thesis using `b - a > 0` `c - b > 0` by auto\nqed", "description": "-", "full_code": "lemma arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a < b\" and \"b < c\"\n  shows \"a < c\"\nproof -\n  from assms(1) have \"b - a > 0\" using less_diff_eq by simp\n  from assms(2) have \"c - b > 0\" using less_diff_eq by simp\n  then have \"c - a = (c - b) + (b - a)\" by (simp add: algebra_simps)\n  then show ?thesis using `b - a > 0` `c - b > 0` by auto\nqed", "origin": "do_request", "update_count": 0}, "arithmetic_inequalitiesV3": {"skill_name": "arithmetic_inequalitiesV3", "marker": "lemma arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a < b\" and \"b < c\"\n  shows \"a < c\"\nproof -\n  have \"c - b > 0\" using assms(2) by (simp add: less_diff_eq)\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"c - a = (c - b) + (b - a)\" by (simp add: field_simps)\n  then have \"c - a > 0\" using `c - b > 0` and `b - a > 0` by (simp add: add_pos_pos)\n  thus ?thesis using `c - a > 0` by (simp add: less_diff_eq)\nqed", "description": "-", "full_code": "lemma arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a < b\" and \"b < c\"\n  shows \"a < c\"\nproof -\n  have \"c - b > 0\" using assms(2) by (simp add: less_diff_eq)\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"c - a = (c - b) + (b - a)\" by (simp add: field_simps)\n  then have \"c - a > 0\" using `c - b > 0` and `b - a > 0` by (simp add: add_pos_pos)\n  thus ?thesis using `c - a > 0` by (simp add: less_diff_eq)\nqed", "origin": "do_request", "update_count": 0}, "square_equation": {"skill_name": "square_equation", "marker": "lemma square_equation:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = b * b\" by (metis assms power2_eq_square)\n  also have \"... = b^2\" by sos\n  finally show \"a^2 = b^2\" by simp\nqed", "description": "-", "full_code": "lemma square_equation:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = b * b\" by (metis assms power2_eq_square)\n  also have \"... = b^2\" by sos\n  finally show \"a^2 = b^2\" by simp\nqed", "origin": "do_request", "update_count": 0}, "square_of_sum_diff": {"skill_name": "square_of_sum_diff", "marker": "lemma square_of_sum_diff:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a + b)^2 - (a - b)^2 = 4*a*b\"\nproof -\n  have \"(a + b)^2 - (a - b)^2 = (a^2 + 2*a*b + b^2) - (a^2 - 2*a*b + b^2)\"\n    by sos\n  also have \"... = 4*a*b\" by simp\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_of_sum_diff:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a + b)^2 - (a - b)^2 = 4*a*b\"\nproof -\n  have \"(a + b)^2 - (a - b)^2 = (a^2 + 2*a*b + b^2) - (a^2 - 2*a*b + b^2)\"\n    by sos\n  also have \"... = 4*a*b\" by simp\n  finally show ?thesis .\nqed", "origin": "square_eq", "update_count": 0}, "square_sum": {"skill_name": "square_sum", "marker": "lemma square_sum:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a + b)^2 = a^2 + 2*a*b + b^2\"\nproof -\n  have \"(a + b)^2 = a^2 + 2*a*b + b^2\" by sos\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma square_sum:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a + b)^2 = a^2 + 2*a*b + b^2\"\nproof -\n  have \"(a + b)^2 = a^2 + 2*a*b + b^2\" by sos\n  thus ?thesis .\nqed", "origin": "square_eq", "update_count": 0}, "square_eq_for_different_values": {"skill_name": "square_eq_for_different_values", "marker": "lemma square_eq_for_different_values:\n  fixes a b :: real\n  assumes \"a = b\" \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\n  using assms by simp", "description": "-", "full_code": "lemma square_eq_for_different_values:\n  fixes a b :: real\n  assumes \"a = b\" \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\n  using assms by simp", "origin": "square_eq", "update_count": 0}, "general_absolute_value": {"skill_name": "general_absolute_value", "marker": "lemma general_absolute_value:\n  fixes a b :: real\n  assumes \"abs(a - b) < c\"\n  shows \"b - c < a \\<and> a < b + c\"\nproof -\n  have \"a - b < c\" and \"-(a - b) < c\" using assms by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma general_absolute_value:\n  fixes a b :: real\n  assumes \"abs(a - b) < c\"\n  shows \"b - c < a \\<and> a < b + c\"\nproof -\n  have \"a - b < c\" and \"-(a - b) < c\" using assms by auto\n  then show ?thesis by auto\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "arithmetic_inequalitiesV4": {"skill_name": "arithmetic_inequalitiesV4", "marker": "lemma arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a < b\" and \"b < c\"\n  shows \"a < c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  have \"c - b > 0\" using assms(2) by (simp add: less_diff_eq)\n  have \"c - a = (c - b) + (b - a)\" by (simp add: algebra_simps)\n  have \"c - a > 0\" using `b - a > 0` `c - b > 0` by (simp add: add_pos_pos)\n  thus ?thesis using `c - a > 0` by (simp add: less_diff_eq)\nqed", "description": "-", "full_code": "lemma arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a < b\" and \"b < c\"\n  shows \"a < c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  have \"c - b > 0\" using assms(2) by (simp add: less_diff_eq)\n  have \"c - a = (c - b) + (b - a)\" by (simp add: algebra_simps)\n  have \"c - a > 0\" using `b - a > 0` `c - b > 0` by (simp add: add_pos_pos)\n  thus ?thesis using `c - a > 0` by (simp add: less_diff_eq)\nqed", "origin": "do_request", "update_count": 0}, "square_equationV2": {"skill_name": "square_equationV2", "marker": "lemma square_equation:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  also have \"... = b * b\" using assms by (simp add: assms)\n  finally show \"a^2 = b^2\" by sos\nqed", "description": "-", "full_code": "lemma square_equation:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  also have \"... = b * b\" using assms by (simp add: assms)\n  finally show \"a^2 = b^2\" by sos\nqed", "origin": "do_request", "update_count": 0}, "square_equationV3": {"skill_name": "square_equationV3", "marker": "lemma square_equation:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  obtain x where \"a = x\" and \"b = x\" using assms by auto\n  then have \"a^2 = x^2\" by (simp add: power2_eq_square)\n  moreover have \"b^2 = x^2\" by (metis \\<open>a = x\\<close> assms)\n  ultimately show ?thesis by (simp)\nqed", "description": "-", "full_code": "lemma square_equation:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  obtain x where \"a = x\" and \"b = x\" using assms by auto\n  then have \"a^2 = x^2\" by (simp add: power2_eq_square)\n  moreover have \"b^2 = x^2\" by (metis \\<open>a = x\\<close> assms)\n  ultimately show ?thesis by (simp)\nqed", "origin": "do_request", "update_count": 0}, "arithmetic_inequalitiesV5": {"skill_name": "arithmetic_inequalitiesV5", "marker": "lemma arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a < b\" and \"b < c\"\n  shows \"a < c\"\nproof -\n  from assms(1) obtain d where \"d = b - a\" and \"d > 0\" by (auto simp: less_diff_eq)\n  from assms(2) obtain e where \"e = c - b\" and \"e > 0\" by (auto simp: less_diff_eq)\n  have \"c - a = (c - b) + (b - a)\" by (simp add: algebra_simps)\n  also have \"... = e + d\" by (metis \\<open>d = b - a\\<close> \\<open>e = c - b\\<close> add.commute add_diff_cancel_left add_left_imp_eq calculation cancel_ab_semigroup_add_class.diff_right_commute diff_add_cancel diff_diff_eq2 group_cancel.add1 group_cancel.sub2 minus_diff_eq neg_equal_iff_equal uminus_add_conv_diff)\n  finally have \"c - a > 0 + 0\" using `d > 0` `e > 0` by simp\n  thus ?thesis using less_diff_eq by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a < b\" and \"b < c\"\n  shows \"a < c\"\nproof -\n  from assms(1) obtain d where \"d = b - a\" and \"d > 0\" by (auto simp: less_diff_eq)\n  from assms(2) obtain e where \"e = c - b\" and \"e > 0\" by (auto simp: less_diff_eq)\n  have \"c - a = (c - b) + (b - a)\" by (simp add: algebra_simps)\n  also have \"... = e + d\" by (metis \\<open>d = b - a\\<close> \\<open>e = c - b\\<close> add.commute add_diff_cancel_left add_left_imp_eq calculation cancel_ab_semigroup_add_class.diff_right_commute diff_add_cancel diff_diff_eq2 group_cancel.add1 group_cancel.sub2 minus_diff_eq neg_equal_iff_equal uminus_add_conv_diff)\n  finally have \"c - a > 0 + 0\" using `d > 0` `e > 0` by simp\n  thus ?thesis using less_diff_eq by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "expression_nonneg_generalizedV2": {"skill_name": "expression_nonneg_generalizedV2", "marker": "lemma expression_nonneg_generalized:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  hence \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by (simp add: algebra_simps)\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  thus ?thesis using `?E = x^2 * y^2 + x^2 + y^2 + 1` by auto\nqed", "description": "-", "full_code": "lemma expression_nonneg_generalized:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  hence \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by (simp add: algebra_simps)\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  thus ?thesis using `?E = x^2 * y^2 + x^2 + y^2 + 1` by auto\nqed", "origin": "expression_nonneg", "update_count": 0}, "expression_nonneg_with_assumptions": {"skill_name": "expression_nonneg_with_assumptions", "marker": "lemma expression_nonneg_with_assumptions:\n  fixes x y :: real\n  assumes \"1 \\<le> x\" \"1 \\<le> y\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by (auto simp: assms)\n  have \"x^2 >= 0\" by (auto simp: assms)\n  have \"y^2 >= 0\" by (auto simp: assms)\n  then have \"x^2 + y^2 + x^2 * y^2 + 1 >= 1\" by (simp add: algebra_simps)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma expression_nonneg_with_assumptions:\n  fixes x y :: real\n  assumes \"1 \\<le> x\" \"1 \\<le> y\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by (auto simp: assms)\n  have \"x^2 >= 0\" by (auto simp: assms)\n  have \"y^2 >= 0\" by (auto simp: assms)\n  then have \"x^2 + y^2 + x^2 * y^2 + 1 >= 1\" by (simp add: algebra_simps)\n  thus ?thesis by sos\nqed", "origin": "expression_nonneg", "update_count": 0}, "sqrt_difference": {"skill_name": "sqrt_difference", "marker": "lemma sqrt_difference:\n  fixes x y :: real\n  assumes \"sqrt (x + 9) = 9\" \"sqrt (y + 9) = 9\"\n  shows \"x = y\"\nproof -\n  obtain a where \"x + 9 = a^2\" and \"y + 9 = a^2\" using assms by (metis abs_of_nonneg add.commute real_sqrt_abs real_sqrt_eq_iff real_sqrt_ge_0_iff real_sqrt_power zero_le_numeral)\n  then show \"x = y\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma sqrt_difference:\n  fixes x y :: real\n  assumes \"sqrt (x + 9) = 9\" \"sqrt (y + 9) = 9\"\n  shows \"x = y\"\nproof -\n  obtain a where \"x + 9 = a^2\" and \"y + 9 = a^2\" using assms by (metis abs_of_nonneg add.commute real_sqrt_abs real_sqrt_eq_iff real_sqrt_ge_0_iff real_sqrt_power zero_le_numeral)\n  then show \"x = y\" by (simp add: field_simps)\nqed", "origin": "sqrt_eq", "update_count": 0}, "simple_sqrt_eq": {"skill_name": "simple_sqrt_eq", "marker": "lemma simple_sqrt_eq:\n  fixes x :: real\n  assumes \"sqrt x = 3\"\n  shows \"x = 9\"\nproof -\n  have \"x = 3^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma simple_sqrt_eq:\n  fixes x :: real\n  assumes \"sqrt x = 3\"\n  shows \"x = 9\"\nproof -\n  have \"x = 3^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  thus ?thesis by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "sqrt_eq_general": {"skill_name": "sqrt_eq_general", "marker": "lemma sqrt_eq_general:\n  fixes x :: real\n  assumes \"sqrt (x + c) = d\" and \"c > 0\" and \"d > 0\"\n  shows \"x = d^2 - c\"\nproof -\n  have \"x + c = d^2\" using assms by auto\n  then show \"x = d^2 - c\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq_general:\n  fixes x :: real\n  assumes \"sqrt (x + c) = d\" and \"c > 0\" and \"d > 0\"\n  shows \"x = d^2 - c\"\nproof -\n  have \"x + c = d^2\" using assms by auto\n  then show \"x = d^2 - c\" by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "sqrt_simplification": {"skill_name": "sqrt_simplification", "marker": "lemma sqrt_simplification:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt(a) + sqrt(b) = sqrt(a + b + 2*sqrt(a*b))\"\nproof -\n  let ?x = \"sqrt a\"\n  let ?y = \"sqrt b\"\n  have \"a = ?x^2\" using assms(1) by (simp add: sqrt_def)\n  have \"b = ?y^2\" using assms(2) by (simp add: sqrt_def)\n  have \"sqrt(a + b + 2*sqrt(a*b)) = sqrt(?x^2 + ?y^2 + 2*?x*?y)\"\n    by (smt (verit) \\<open>a = (sqrt a)\\<^sup>2\\<close> \\<open>b = (sqrt b)\\<^sup>2\\<close> add.left_cancel mult.commute mult_2_right real_sqrt_eq_iff real_sqrt_mult ring_class.ring_distribs(1))\n  have \"sqrt(?x^2 + ?y^2 + 2*?x*?y) = sqrt((?x + ?y)^2)\"\n    by (simp add: power2_sum)\n  then have \"sqrt(?x^2 + ?y^2 + 2*?x*?y) = ?x + ?y\"\n    by (metis add_nonneg_nonneg assms(1) assms(2) power2_sum real_sqrt_ge_zero real_sqrt_unique)\n  thus ?thesis \n    by (metis \\<open>a = (sqrt a)\\<^sup>2\\<close> \\<open>b = (sqrt b)\\<^sup>2\\<close> \\<open>sqrt (a + b + 2 * sqrt (a * b)) = sqrt ((sqrt a)\\<^sup>2 + (sqrt b)\\<^sup>2 + 2 * sqrt a * sqrt b)\\<close>)\nqed", "description": "-", "full_code": "lemma sqrt_simplification:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt(a) + sqrt(b) = sqrt(a + b + 2*sqrt(a*b))\"\nproof -\n  let ?x = \"sqrt a\"\n  let ?y = \"sqrt b\"\n  have \"a = ?x^2\" using assms(1) by (simp add: sqrt_def)\n  have \"b = ?y^2\" using assms(2) by (simp add: sqrt_def)\n  have \"sqrt(a + b + 2*sqrt(a*b)) = sqrt(?x^2 + ?y^2 + 2*?x*?y)\"\n    by (smt (verit) \\<open>a = (sqrt a)\\<^sup>2\\<close> \\<open>b = (sqrt b)\\<^sup>2\\<close> add.left_cancel mult.commute mult_2_right real_sqrt_eq_iff real_sqrt_mult ring_class.ring_distribs(1))\n  have \"sqrt(?x^2 + ?y^2 + 2*?x*?y) = sqrt((?x + ?y)^2)\"\n    by (simp add: power2_sum)\n  then have \"sqrt(?x^2 + ?y^2 + 2*?x*?y) = ?x + ?y\"\n    by (metis add_nonneg_nonneg assms(1) assms(2) power2_sum real_sqrt_ge_zero real_sqrt_unique)\n  thus ?thesis \n    by (metis \\<open>a = (sqrt a)\\<^sup>2\\<close> \\<open>b = (sqrt b)\\<^sup>2\\<close> \\<open>sqrt (a + b + 2 * sqrt (a * b)) = sqrt ((sqrt a)\\<^sup>2 + (sqrt b)\\<^sup>2 + 2 * sqrt a * sqrt b)\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "sum_natural_numbers": {"skill_name": "sum_natural_numbers", "marker": "lemma sum_natural_numbers:\n  fixes n :: nat\n  shows \"(\\<Sum>k=1..n. k) = n * (n + 1) div 2\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case by auto\nqed", "description": "-", "full_code": "lemma sum_natural_numbers:\n  fixes n :: nat\n  shows \"(\\<Sum>k=1..n. k) = n * (n + 1) div 2\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case by auto\nqed", "origin": "sum_terms_count", "update_count": 0}, "system_of_equations": {"skill_name": "system_of_equations", "marker": "lemma system_of_equations:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  then have \"x + a = b\" by simp\n  then have \"x = b - a\" by (metis add.commute add_diff_cancel_right' diff_add_cancel)\n  show ?thesis using e_eq by (metis \\<open>x = b - a\\<close> div_by_1)\nqed", "description": "-", "full_code": "lemma system_of_equations:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  then have \"x + a = b\" by simp\n  then have \"x = b - a\" by (metis add.commute add_diff_cancel_right' diff_add_cancel)\n  show ?thesis using e_eq by (metis \\<open>x = b - a\\<close> div_by_1)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "square_eq_multiV2": {"skill_name": "square_eq_multiV2", "marker": "lemma square_eq_multi:\n  fixes xs :: \"real list\"\n  assumes \"\\<forall>x \\<in> set xs. x = 0\"\n  shows \"\\<forall>x \\<in> set xs. x^2 = 0\"\nproof -\n  have \"\\<forall>x \\<in> set xs. x^2 = 0\" \n    using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_eq_multi:\n  fixes xs :: \"real list\"\n  assumes \"\\<forall>x \\<in> set xs. x = 0\"\n  shows \"\\<forall>x \\<in> set xs. x^2 = 0\"\nproof -\n  have \"\\<forall>x \\<in> set xs. x^2 = 0\" \n    using assms by auto\n  thus ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "square_eq_dimension": {"skill_name": "square_eq_dimension", "marker": "lemma square_eq_dimension:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\"\n  and \"(\\<forall>i. a ! i = b ! i)\"\n  shows \"(\\<Sum>i. a ! i^2) = (\\<Sum>i. b ! i^2)\"\nproof -\n  have \"\\<forall>i. a ! i^2 = b ! i^2\" using assms(2) by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_eq_dimension:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\"\n  and \"(\\<forall>i. a ! i = b ! i)\"\n  shows \"(\\<Sum>i. a ! i^2) = (\\<Sum>i. b ! i^2)\"\nproof -\n  have \"\\<forall>i. a ! i^2 = b ! i^2\" using assms(2) by auto\n  then show ?thesis by auto\nqed", "origin": "square_eq", "update_count": 0}, "mathd_algebra_general": {"skill_name": "mathd_algebra_general", "marker": "theorem mathd_algebra_general:\n  fixes a b :: real\n  assumes \"k * a + m * b = c\" \n    and \"a = d\"\n    and \"k > 0\" \"m > 0\"\n  shows \"b = (c - k * d) / m\"\nproof -\n  have eq: \"k * a + m * b = c\" using assms(1) by simp\n  have sub: \"k * d + m * b = c\" using assms(2) eq by simp\n  have isolate: \"m * b = c - k * d\" using sub by simp\n  have solution: \"b = (c - k * d) / m\" using isolate by (metis assms(4) less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_general:\n  fixes a b :: real\n  assumes \"k * a + m * b = c\" \n    and \"a = d\"\n    and \"k > 0\" \"m > 0\"\n  shows \"b = (c - k * d) / m\"\nproof -\n  have eq: \"k * a + m * b = c\" using assms(1) by simp\n  have sub: \"k * d + m * b = c\" using assms(2) eq by simp\n  have isolate: \"m * b = c - k * d\" using sub by simp\n  have solution: \"b = (c - k * d) / m\" using isolate by (metis assms(4) less_numeral_extra(3) mult.commute nonzero_mult_div_cancel_right)\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sum_terms_countV5": {"skill_name": "sum_terms_countV5", "marker": "lemma sum_terms_count:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a ..< b} = b - a\" by (simp add: card_atLeastLessThan)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a ..< b} = b - a\" by (simp add: card_atLeastLessThan)\n  then show ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "product_is_prime": {"skill_name": "product_is_prime", "marker": "lemma product_is_prime:\n  fixes n m :: nat\n  assumes \"n > 0\" \"m > 0\" \"prime (n * m)\"\n  shows \"n = 1 \\<or> m = 1\"\nproof -\n  have \"n * m > 1\" using assms(1) assms(2) by (metis assms(3) prime_gt_1_nat)\n  {\n    assume \"n > 1\"\n    then have \"n * m > 1 * 1\" using assms(2) by (metis \\<open>n * m > 1\\<close> nat_mult_eq_1_iff)\n    then have \"m = 1\" using assms(3) by (metis \\<open>1 < n\\<close> less_not_refl3 prime_product)\n  }\n  moreover {\n    assume \"m > 1\"\n    then have \"n * m > 1 * 1\" using assms(1) by (metis \\<open>n * m > 1\\<close> nat_mult_eq_1_iff)\n    then have \"n = 1\" using assms(3) by (metis \\<open>1 < m\\<close> less_not_refl2 prime_product)\n  }\n  ultimately show \"n = 1 \\<or> m = 1\" by (metis \\<open>1 < n * m\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "description": "-", "full_code": "lemma product_is_prime:\n  fixes n m :: nat\n  assumes \"n > 0\" \"m > 0\" \"prime (n * m)\"\n  shows \"n = 1 \\<or> m = 1\"\nproof -\n  have \"n * m > 1\" using assms(1) assms(2) by (metis assms(3) prime_gt_1_nat)\n  {\n    assume \"n > 1\"\n    then have \"n * m > 1 * 1\" using assms(2) by (metis \\<open>n * m > 1\\<close> nat_mult_eq_1_iff)\n    then have \"m = 1\" using assms(3) by (metis \\<open>1 < n\\<close> less_not_refl3 prime_product)\n  }\n  moreover {\n    assume \"m > 1\"\n    then have \"n * m > 1 * 1\" using assms(1) by (metis \\<open>n * m > 1\\<close> nat_mult_eq_1_iff)\n    then have \"n = 1\" using assms(3) by (metis \\<open>1 < m\\<close> less_not_refl2 prime_product)\n  }\n  ultimately show \"n = 1 \\<or> m = 1\" by (metis \\<open>1 < n * m\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "product_is_primeV2": {"skill_name": "product_is_primeV2", "marker": "lemma product_is_prime:\n  fixes n m :: nat\n  assumes \"n > 0\" \"m > 0\" \"prime (n * m)\"\n  shows \"n = 1 \\<or> m = 1\"\nproof -\n  have \"n * m > 1\" using assms(1) assms(2) by (metis Primes.prime_nat_def assms(3) mult.commute prime_nat_iff)\n  {\n    assume \"n > 1\"\n    then have \"n * m > 1 * 1\" using assms(2) by (metis comm_monoid_mult_class.mult_1 less_1_mult mult.commute nat_dvd_not_less nat_mult_1_right nat_neq_iff one_dvd)\n    then have \"m = 1\" using assms(3) by (metis \\<open>1 < n\\<close> less_not_refl3 prime_product)\n  }\n  moreover {\n    assume \"m > 1\"\n    then have \"n * m > 1 * 1\" using assms(1) by (metis comm_monoid_mult_class.mult_1 less_1_mult mult.commute mult.right_neutral nat_dvd_not_less nat_neq_iff one_dvd)\n    then have \"n = 1\" using assms(3) by (metis \\<open>1 < m\\<close> less_not_refl2 prime_product)\n  }\n  ultimately show \"n = 1 \\<or> m = 1\" by (metis \\<open>1 < n * m\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "description": "-", "full_code": "lemma product_is_prime:\n  fixes n m :: nat\n  assumes \"n > 0\" \"m > 0\" \"prime (n * m)\"\n  shows \"n = 1 \\<or> m = 1\"\nproof -\n  have \"n * m > 1\" using assms(1) assms(2) by (metis Primes.prime_nat_def assms(3) mult.commute prime_nat_iff)\n  {\n    assume \"n > 1\"\n    then have \"n * m > 1 * 1\" using assms(2) by (metis comm_monoid_mult_class.mult_1 less_1_mult mult.commute nat_dvd_not_less nat_mult_1_right nat_neq_iff one_dvd)\n    then have \"m = 1\" using assms(3) by (metis \\<open>1 < n\\<close> less_not_refl3 prime_product)\n  }\n  moreover {\n    assume \"m > 1\"\n    then have \"n * m > 1 * 1\" using assms(1) by (metis comm_monoid_mult_class.mult_1 less_1_mult mult.commute mult.right_neutral nat_dvd_not_less nat_neq_iff one_dvd)\n    then have \"n = 1\" using assms(3) by (metis \\<open>1 < m\\<close> less_not_refl2 prime_product)\n  }\n  ultimately show \"n = 1 \\<or> m = 1\" by (metis \\<open>1 < n * m\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_properties": {"skill_name": "floor_sum_properties", "marker": "lemma floor_sum_properties:\n  fixes r :: real and a :: real and b :: real\n  assumes \"a \\<le> r \\<and> r < b\"\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  have \"floor r \\<le> r\" by auto\n  moreover have \"r < floor r + 1\" \n  proof -\n    have \"floor r \\<le> r\" by auto\n    then have \"floor r + 1 \\<le> r + 1\" by (simp add: add_le_mono)\n    also have \"r + 1 < floor r + 2\" \n      using assms by arith\n    finally show ?thesis by auto\n  qed\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_sum_properties:\n  fixes r :: real and a :: real and b :: real\n  assumes \"a \\<le> r \\<and> r < b\"\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  have \"floor r \\<le> r\" by auto\n  moreover have \"r < floor r + 1\" \n  proof -\n    have \"floor r \\<le> r\" by auto\n    then have \"floor r + 1 \\<le> r + 1\" by (simp add: add_le_mono)\n    also have \"r + 1 < floor r + 2\" \n      using assms by arith\n    finally show ?thesis by auto\n  qed\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "count_elements_in_range": {"skill_name": "count_elements_in_range", "marker": "lemma count_elements_in_range:\n  fixes a b :: nat\n  shows \"card {a::nat ..< b} = b - a\"\n  by auto", "description": "-", "full_code": "lemma count_elements_in_range:\n  fixes a b :: nat\n  shows \"card {a::nat ..< b} = b - a\"\n  by auto", "origin": "sum_terms_count", "update_count": 0}, "simplify_square_root_expression": {"skill_name": "simplify_square_root_expression", "marker": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have \"sqrt b * sqrt b = b\" using assms by auto\n  have \"a - sqrt b = a + (- sqrt b)\" by (simp add: algebra_simps)\n  then have \"(a - sqrt b)^2 = (a + (-sqrt b))^2\" by simp\n  also have \"... = a^2 + 2 * a * (-sqrt b) + (-sqrt b)^2\" by (smt (verit) power2_sum)\n  also have \"... = a^2 - 2*a*sqrt b + b\" using `sqrt b * sqrt b = b` by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2*a*sqrt b + b\"\nproof -\n  have \"sqrt b * sqrt b = b\" using assms by auto\n  have \"a - sqrt b = a + (- sqrt b)\" by (simp add: algebra_simps)\n  then have \"(a - sqrt b)^2 = (a + (-sqrt b))^2\" by simp\n  also have \"... = a^2 + 2 * a * (-sqrt b) + (-sqrt b)^2\" by (smt (verit) power2_sum)\n  also have \"... = a^2 - 2*a*sqrt b + b\" using `sqrt b * sqrt b = b` by simp\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_root_expressionV2": {"skill_name": "simplify_square_root_expressionV2", "marker": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2 * a * sqrt b + b\"\nproof -\n  have \"sqrt b >= 0\" using assms(2) by auto\n  have \"(a - sqrt b)^2 = a^2 - 2 * a * sqrt b + (sqrt b)^2\" \n    by (smt (verit) diff_add_eq power2_diff)\n  also have \"... = a^2 - 2 * a * sqrt b + b\" \n    using assms(2) by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a - sqrt b)^2 = a^2 - 2 * a * sqrt b + b\"\nproof -\n  have \"sqrt b >= 0\" using assms(2) by auto\n  have \"(a - sqrt b)^2 = a^2 - 2 * a * sqrt b + (sqrt b)^2\" \n    by (smt (verit) diff_add_eq power2_diff)\n  also have \"... = a^2 - 2 * a * sqrt b + b\" \n    using assms(2) by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "product_is_primeV3": {"skill_name": "product_is_primeV3", "marker": "lemma product_is_prime:\n  fixes n m :: nat\n  assumes \"n > 0\" \"m > 0\" \"prime (n * m)\"\n  shows \"n = 1 \\<or> m = 1\"\nproof -\n  have \"n * m > 1\" using assms(1) assms(2) by (metis prime_gt_1_nat assms(3))\n  {\n    assume \"n > 1\"\n    then have \"n * m > 1 * 1\" using assms(2) by (metis comm_monoid_mult_class.mult_1 less_1_mult mult.commute nat_dvd_not_less nat_mult_1_right nat_neq_iff one_dvd)\n    then have \"m = 1\" using assms(3) by (metis \\<open>1 < n\\<close> less_not_refl3 prime_product)\n  }\n  moreover {\n    assume \"m > 1\"\n    then have \"n * m > 1 * 1\" using assms(1) by (metis comm_monoid_mult_class.mult_1 less_1_mult mult.commute mult.right_neutral nat_dvd_not_less nat_neq_iff one_dvd)\n    then have \"n = 1\" using assms(3) by (metis \\<open>1 < m\\<close> less_not_refl2 prime_product)\n  }\n  ultimately show \"n = 1 \\<or> m = 1\" by (metis \\<open>1 < n * m\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "description": "-", "full_code": "lemma product_is_prime:\n  fixes n m :: nat\n  assumes \"n > 0\" \"m > 0\" \"prime (n * m)\"\n  shows \"n = 1 \\<or> m = 1\"\nproof -\n  have \"n * m > 1\" using assms(1) assms(2) by (metis prime_gt_1_nat assms(3))\n  {\n    assume \"n > 1\"\n    then have \"n * m > 1 * 1\" using assms(2) by (metis comm_monoid_mult_class.mult_1 less_1_mult mult.commute nat_dvd_not_less nat_mult_1_right nat_neq_iff one_dvd)\n    then have \"m = 1\" using assms(3) by (metis \\<open>1 < n\\<close> less_not_refl3 prime_product)\n  }\n  moreover {\n    assume \"m > 1\"\n    then have \"n * m > 1 * 1\" using assms(1) by (metis comm_monoid_mult_class.mult_1 less_1_mult mult.commute mult.right_neutral nat_dvd_not_less nat_neq_iff one_dvd)\n    then have \"n = 1\" using assms(3) by (metis \\<open>1 < m\\<close> less_not_refl2 prime_product)\n  }\n  ultimately show \"n = 1 \\<or> m = 1\" by (metis \\<open>1 < n * m\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_propertiesV2": {"skill_name": "floor_sum_propertiesV2", "marker": "lemma floor_sum_properties:\n  fixes r :: real and a :: real and b :: real\n  assumes \"a \\<le> r \\<and> r < b\"\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  have \"floor r \\<le> r\" \n    by auto\n  moreover have \"r < floor r + 1\" \n    by auto\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_sum_properties:\n  fixes r :: real and a :: real and b :: real\n  assumes \"a \\<le> r \\<and> r < b\"\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  have \"floor r \\<le> r\" \n    by auto\n  moreover have \"r < floor r + 1\" \n    by auto\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "product_is_primeV4": {"skill_name": "product_is_primeV4", "marker": "lemma product_is_prime:\n  fixes n m :: nat\n  assumes \"n > 0\" \"m > 0\" \"prime (n * m)\"\n  shows \"n = 1 \\<or> m = 1\"\nproof -\n  have \"n * m > 1\" using assms(1) assms(2) by (metis Primes.prime_nat_def assms(3) mult.commute prime_nat_iff)\n  {\n    assume \"n > 1\"\n    then have \"n * m > 1 * m\" using assms(2) by auto\n    then have \"n * m > m\" using assms(2) by simp\n    then have \"m = 1\" using assms(3) by (metis dvd_triv_right prime_nat_not_dvd)\n  }\n  moreover {\n    assume \"m > 1\"\n    then have \"n * m > n * 1\" using assms(1) by auto\n    then have \"n * m > n\" using assms(1) by simp\n    then have \"n = 1\" using assms(3) by (metis dvd_triv_left prime_nat_not_dvd)\n  }\n  ultimately show \"n = 1 \\<or> m = 1\" by (metis \\<open>1 < n * m\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "description": "-", "full_code": "lemma product_is_prime:\n  fixes n m :: nat\n  assumes \"n > 0\" \"m > 0\" \"prime (n * m)\"\n  shows \"n = 1 \\<or> m = 1\"\nproof -\n  have \"n * m > 1\" using assms(1) assms(2) by (metis Primes.prime_nat_def assms(3) mult.commute prime_nat_iff)\n  {\n    assume \"n > 1\"\n    then have \"n * m > 1 * m\" using assms(2) by auto\n    then have \"n * m > m\" using assms(2) by simp\n    then have \"m = 1\" using assms(3) by (metis dvd_triv_right prime_nat_not_dvd)\n  }\n  moreover {\n    assume \"m > 1\"\n    then have \"n * m > n * 1\" using assms(1) by auto\n    then have \"n * m > n\" using assms(1) by simp\n    then have \"n = 1\" using assms(3) by (metis dvd_triv_left prime_nat_not_dvd)\n  }\n  ultimately show \"n = 1 \\<or> m = 1\" by (metis \\<open>1 < n * m\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_eq_2d": {"skill_name": "sqrt_eq_2d", "marker": "lemma sqrt_eq_2D:\n  fixes x1 x2 y1 y2 :: real\n  assumes \"sqrt ((x1 - x2)^2 + (y1 - y2)^2) = d\"\n  shows \"d^2 = (x1 - x2)^2 + (y1 - y2)^2\"\nproof -\n  have \"sqrt ((x1 - x2)^2 + (y1 - y2)^2) = d \\<Longrightarrow> (x1 - x2)^2 + (y1 - y2)^2 = d^2\"\n    using assms by auto\n  thus ?thesis by (metis assms)\nqed", "description": "-", "full_code": "lemma sqrt_eq_2D:\n  fixes x1 x2 y1 y2 :: real\n  assumes \"sqrt ((x1 - x2)^2 + (y1 - y2)^2) = d\"\n  shows \"d^2 = (x1 - x2)^2 + (y1 - y2)^2\"\nproof -\n  have \"sqrt ((x1 - x2)^2 + (y1 - y2)^2) = d \\<Longrightarrow> (x1 - x2)^2 + (y1 - y2)^2 = d^2\"\n    using assms by auto\n  thus ?thesis by (metis assms)\nqed", "origin": "sqrt_eq", "update_count": 0}, "square_expansionV2": {"skill_name": "square_expansionV2", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + -y)^2\" by simp\n  then have \"(x - y)^2 = x^2 + 2 * x * (-y) + (-y)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = x^2 - 2 * x * y + y^2\" by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + -y)^2\" by simp\n  then have \"(x - y)^2 = x^2 + 2 * x * (-y) + (-y)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = x^2 - 2 * x * y + y^2\" by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansionV3": {"skill_name": "square_expansionV3", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y) * (x - y) = x * x - 2 * x * y + y * y\" by sos\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y) * (x - y) = x * x - 2 * x * y + y * y\" by sos\n  thus ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "polynomial_combination": {"skill_name": "polynomial_combination", "marker": "lemma polynomial_combination:\n  fixes p q r :: real\n  shows \"(p + q) + r = p + (q + r)\"\nproof -\n  show \"(p + q) + r = p + (q + r)\"\n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma polynomial_combination:\n  fixes p q r :: real\n  shows \"(p + q) + r = p + (q + r)\"\nproof -\n  show \"(p + q) + r = p + (q + r)\"\n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "expression_nonneg_with_constraints": {"skill_name": "expression_nonneg_with_constraints", "marker": "lemma expression_nonneg_with_constraints:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 \\<ge> 0\" using assms by auto\n  have \"x^2 \\<ge> 0\" using assms by auto\n  have \"y^2 \\<ge> 0\" using assms by auto\n  have \"?E \\<ge> 1\" by sos\n  have \"?E = 1\" when \"x = 0\" and \"y = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma expression_nonneg_with_constraints:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 \\<ge> 0\" using assms by auto\n  have \"x^2 \\<ge> 0\" using assms by auto\n  have \"y^2 \\<ge> 0\" using assms by auto\n  have \"?E \\<ge> 1\" by sos\n  have \"?E = 1\" when \"x = 0\" and \"y = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "mathd_algebra_109_evolvedV2": {"skill_name": "mathd_algebra_109_evolvedV2", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = (c - 3*a) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have simplified: \"12 + 2*b = c\" using sub by simp\n  hence \"2*b = c - 12\" by simp\n  thus \"b = (c - 3*a) / 2\" using h1 h2 by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = (c - 3*a) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have simplified: \"12 + 2*b = c\" using sub by simp\n  hence \"2*b = c - 12\" by simp\n  thus \"b = (c - 3*a) / 2\" using h1 h2 by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_generalizedV3": {"skill_name": "mathd_algebra_109_generalizedV3", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c \\<ge> 0\"  \n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have isolate: \"2*b = c - 12\" by (smt (verit) h0 h1)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c \\<ge> 0\"  \n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  have isolate: \"2*b = c - 12\" by (smt (verit) h0 h1)\n  thus ?thesis by auto\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolvedV3": {"skill_name": "mathd_algebra_109_evolvedV3", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"a \\<ge> 0\" and h3 : \"b \\<ge> 0\"  \n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  thus \"b = 0\" using h2 h3 by simp \nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"a \\<ge> 0\" and h3 : \"b \\<ge> 0\"  \n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  thus \"b = 0\" using h2 h3 by simp \nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_linear_equation_generalized": {"skill_name": "solve_linear_equation_generalized", "marker": "lemma solve_linear_equation_generalized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * x + b = c \\<longleftrightarrow> x = (c - b) / a\"\nproof -\n  have \"a * x + b = c \\<longleftrightarrow> a * x = c - b\" using assms by auto\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma solve_linear_equation_generalized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * x + b = c \\<longleftrightarrow> x = (c - b) / a\"\nproof -\n  have \"a * x + b = c \\<longleftrightarrow> a * x = c - b\" using assms by auto\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_linear_equation_generalizedV2": {"skill_name": "solve_linear_equation_generalizedV2", "marker": "theorem solve_linear_equation_generalized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * x + b = c \\<Longrightarrow> x = (c - b) / a\"\nproof -\n  assume eq: \"a * x + b = c\"\n  then have \"a * x = c - b\" by simp\n  then show \"x = (c - b) / a\" using assms by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem solve_linear_equation_generalized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * x + b = c \\<Longrightarrow> x = (c - b) / a\"\nproof -\n  assume eq: \"a * x + b = c\"\n  then have \"a * x = c - b\" by simp\n  then show \"x = (c - b) / a\" using assms by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "solve_linear_equation_with_parametersV2": {"skill_name": "solve_linear_equation_with_parametersV2", "marker": "theorem solve_linear_equation_with_parameters:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" and \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using assms by simp\n  then have \"a * x = c - b\" by simp\n  then show \"x = (c - b) / a\" using assms(1) by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem solve_linear_equation_with_parameters:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" and \"a * x + b = c\"\n  shows \"x = (c - b) / a\"\nproof -\n  have \"a * x + b = c\" using assms by simp\n  then have \"a * x = c - b\" by simp\n  then show \"x = (c - b) / a\" using assms(1) by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sum_terms_count_specific": {"skill_name": "sum_terms_count_specific", "marker": "lemma sum_terms_count_specific:\n  shows \"card {19::nat..<92} = 73\"\n  by (simp add: sum_terms_count_general)", "description": "-", "full_code": "lemma sum_terms_count_general:\n  fixes a b :: nat\n  shows \"card {a..<b} = b - a\"\n  by auto\n\nlemma sum_terms_count_specific:\n  shows \"card {19::nat..<92} = 73\"\n  by (simp add: sum_terms_count_general)", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_range": {"skill_name": "sum_terms_count_range", "marker": "lemma sum_terms_count_range:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a..b} = b - a + 1\"\nproof -\n  have \"card {a..b} = b - a + 1\" using assms\n    by (auto simp: atMost_def atLeast_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count_range:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a..b} = b - a + 1\"\nproof -\n  have \"card {a..b} = b - a + 1\" using assms\n    by (auto simp: atMost_def atLeast_def)\n  thus ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "product_sum_expression": {"skill_name": "product_sum_expression", "marker": "lemma product_sum_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 + y^2 + (x * y)^2 + 1)\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  then have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by (simp add: algebra_simps)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma product_sum_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 + y^2 + (x * y)^2 + 1)\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  then have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by (simp add: algebra_simps)\n  thus ?thesis by sos\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "amc12a_2021_p7V2": {"skill_name": "amc12a_2021_p7V2", "marker": "theorem amc12a_2021_p7:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\n  apply (auto simp: algebra_simps power2_eq_square)\n  using product_sum_expression by (metis add_nonneg_nonneg mult_le_0_iff mult_nonneg_nonneg mult_nonpos_nonpos zero_le_mult_iff zero_le_square)", "description": "-", "full_code": "lemma product_sum_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 = (x^2 + y^2 + (x * y)^2 + 1)\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  then have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by (simp add: algebra_simps)\n  thus ?thesis by sos\nqed\n\ntheorem amc12a_2021_p7:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\n  apply (auto simp: algebra_simps power2_eq_square)\n  using product_sum_expression by (metis add_nonneg_nonneg mult_le_0_iff mult_nonneg_nonneg mult_nonpos_nonpos zero_le_mult_iff zero_le_square)", "origin": "amc12a_2021_p7", "update_count": 0}, "sum_of_squares_nonneg": {"skill_name": "sum_of_squares_nonneg", "marker": "lemma sum_of_squares_nonneg:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\nproof -\n  have \"x^2 \\<ge> 0\" by auto\n  have \"y^2 \\<ge> 0\" by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_of_squares_nonneg:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\nproof -\n  have \"x^2 \\<ge> 0\" by auto\n  have \"y^2 \\<ge> 0\" by auto\n  then show ?thesis by auto\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "expression_nonnegV2": {"skill_name": "expression_nonnegV2", "marker": "lemma expression_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by (simp add: power2_eq_square algebra_simps)\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by (simp add: power2_eq_square algebra_simps)\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" using nonnegativity_of_squares by auto\n  have \"x^2 >= 0\" using nonnegativity_of_squares by auto\n  have \"y^2 >= 0\" using nonnegativity_of_squares by auto\n  have \"?E >= 1\" by sos\n  have \"?E = 1\" when \"x = 0\" and \"y = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma nonnegativity_of_squares:\n  fixes x y :: real\n  shows \"x^2 >= 0 \\<and> y^2 >= 0\"\nproof -\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  then show ?thesis by auto\nqed\n\nlemma expression_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by (simp add: power2_eq_square algebra_simps)\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by (simp add: power2_eq_square algebra_simps)\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" using nonnegativity_of_squares by auto\n  have \"x^2 >= 0\" using nonnegativity_of_squares by auto\n  have \"y^2 >= 0\" using nonnegativity_of_squares by auto\n  have \"?E >= 1\" by sos\n  have \"?E = 1\" when \"x = 0\" and \"y = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "nonnegativity_of_squared_terms": {"skill_name": "nonnegativity_of_squared_terms", "marker": "lemma nonnegativity_of_squared_terms:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 0\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  then have \"?E >= 1\" by sos\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma nonnegativity_of_squared_terms:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 0\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  then have \"?E >= 1\" by sos\n  then show ?thesis by auto\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "mod_n_casesV9": {"skill_name": "mod_n_casesV9", "marker": "lemma mod_n_cases:\n  fixes a :: int\n  assumes \"n > 0\"\n  shows \"0 \\<le> a mod n \\<and> a mod n < n\"\n  by (metis Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign assms)", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int\n  assumes \"n > 0\"\n  shows \"0 \\<le> a mod n \\<and> a mod n < n\"\n  by (metis Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign assms)", "origin": "mod4_cases", "update_count": 0}, "square_nonneg_n_dimensions": {"skill_name": "square_nonneg_n_dimensions", "marker": "lemma square_nonneg_n_dimensions:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\" and \"a = b\" and \"\\<forall>i. a ! i \\<ge> 0\" and \"\\<forall>i. b ! i \\<ge> 0\"\n  shows \"\\<forall>i. a ! i^2 = b ! i^2\"\nproof -\n  have \"a = b \\<Longrightarrow> \\<forall>i. a ! i^2 = b ! i^2\" and \"length a = length b \\<Longrightarrow> True\"\n    by auto\n  hence \"a ! i^2 = b ! i^2\" for i\n    by (metis assms(2) nth_equalityI)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\n  using square_eq[OF assms(1)] by simp\n\nlemma square_nonneg_n_dimensions:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\" and \"a = b\" and \"\\<forall>i. a ! i \\<ge> 0\" and \"\\<forall>i. b ! i \\<ge> 0\"\n  shows \"\\<forall>i. a ! i^2 = b ! i^2\"\nproof -\n  have \"a = b \\<Longrightarrow> \\<forall>i. a ! i^2 = b ! i^2\" and \"length a = length b \\<Longrightarrow> True\"\n    by auto\n  hence \"a ! i^2 = b ! i^2\" for i\n    by (metis assms(2) nth_equalityI)\n  thus ?thesis by auto\nqed", "origin": "square_eq", "update_count": 0}, "square_nonnegV5": {"skill_name": "square_nonnegV5", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\n  using square_eq[OF assms(1)] by simp", "description": "-", "full_code": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\n  using square_eq[OF assms(1)] by simp", "origin": "square_eq", "update_count": 0}, "integer_distributionV2": {"skill_name": "integer_distributionV2", "marker": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\" using assms\n  proof -\n    have \"y = n - x\" using assms(1) by simp\n    also have \"y \\<ge> 0\" using assms(2) by simp\n    ultimately have \"n - x \\<ge> 0\" by (metis add_nonneg_nonneg)\n    thus ?thesis by (metis \\<open>y = n - x\\<close> add_less_same_cancel1 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n  qed\n  moreover have \"y \\<le> n\" using assms\n  proof -\n    have \"x = n - y\" using assms(1) by simp\n    also have \"x \\<ge> 0\" using assms(2) by simp\n    ultimately have \"n - y \\<ge> 0\" by (metis add_nonneg_nonneg)\n    thus ?thesis by (metis \\<open>x = n - y\\<close> add_less_same_cancel2 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n  qed\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\" using assms\n  proof -\n    have \"y = n - x\" using assms(1) by simp\n    also have \"y \\<ge> 0\" using assms(2) by simp\n    ultimately have \"n - x \\<ge> 0\" by (metis add_nonneg_nonneg)\n    thus ?thesis by (metis \\<open>y = n - x\\<close> add_less_same_cancel1 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n  qed\n  moreover have \"y \\<le> n\" using assms\n  proof -\n    have \"x = n - y\" using assms(1) by simp\n    also have \"x \\<ge> 0\" using assms(2) by simp\n    ultimately have \"n - y \\<ge> 0\" by (metis add_nonneg_nonneg)\n    thus ?thesis by (metis \\<open>x = n - y\\<close> add_less_same_cancel2 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n  qed\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "integer_distributionV3": {"skill_name": "integer_distributionV3", "marker": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\" using assms\n  proof -\n    have \"y = n - x\" using assms by simp\n    also have \"y \\<ge> 0\" using assms(2) by simp\n    ultimately have \"n - x \\<ge> 0\" by (simp add: nat_le_linear)\n    hence \"x \\<le> n\" by (metis \\<open>y = n - x\\<close> add_less_same_cancel1 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n    thus ?thesis by simp\n  qed\n  moreover have \"y \\<le> n\" using assms\n  proof -\n    have \"x = n - y\" using assms by simp\n    also have \"x \\<ge> 0\" using assms(3) by simp\n    ultimately have \"n - y \\<ge> 0\" by (simp add: nat_le_linear)\n    hence \"y \\<le> n\" by (metis \\<open>x = n - y\\<close> add_less_same_cancel2 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n    thus ?thesis by simp\n  qed\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\" using assms\n  proof -\n    have \"y = n - x\" using assms by simp\n    also have \"y \\<ge> 0\" using assms(2) by simp\n    ultimately have \"n - x \\<ge> 0\" by (simp add: nat_le_linear)\n    hence \"x \\<le> n\" by (metis \\<open>y = n - x\\<close> add_less_same_cancel1 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n    thus ?thesis by simp\n  qed\n  moreover have \"y \\<le> n\" using assms\n  proof -\n    have \"x = n - y\" using assms by simp\n    also have \"x \\<ge> 0\" using assms(3) by simp\n    ultimately have \"n - y \\<ge> 0\" by (simp add: nat_le_linear)\n    hence \"y \\<le> n\" by (metis \\<open>x = n - y\\<close> add_less_same_cancel2 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n    thus ?thesis by simp\n  qed\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "integer_distributionV4": {"skill_name": "integer_distributionV4", "marker": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\" using assms(1) assms(2) \n  proof -\n    have \"y = n - x\" using assms(1) by simp\n    moreover have \"n - x \\<ge> 0\" using assms(2) by (simp add: nat_le_linear)\n    ultimately show \"x \\<le> n\" by (metis add_less_same_cancel1 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n  qed\n  have \"y \\<le> n\" using assms(1) assms(3)\n  proof -\n    have \"x = n - y\" using assms(1) by simp\n    moreover have \"n - y \\<ge> 0\" using assms(3) by (simp add: nat_le_linear)\n    ultimately show \"y \\<le> n\" by (metis add_less_same_cancel2 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n  qed\n  thus ?thesis by (metis \\<open>x \\<le> n\\<close>)\nqed", "description": "-", "full_code": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\" using assms(1) assms(2) \n  proof -\n    have \"y = n - x\" using assms(1) by simp\n    moreover have \"n - x \\<ge> 0\" using assms(2) by (simp add: nat_le_linear)\n    ultimately show \"x \\<le> n\" by (metis add_less_same_cancel1 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n  qed\n  have \"y \\<le> n\" using assms(1) assms(3)\n  proof -\n    have \"x = n - y\" using assms(1) by simp\n    moreover have \"n - y \\<ge> 0\" using assms(3) by (simp add: nat_le_linear)\n    ultimately show \"y \\<le> n\" by (metis add_less_same_cancel2 assms(1) diff_is_0_eq less_numeral_extra(3) linorder_not_less nle_le)\n  qed\n  thus ?thesis by (metis \\<open>x \\<le> n\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "integer_distributionV5": {"skill_name": "integer_distributionV5", "marker": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\"\n  proof -\n    have \"y = n - x\" using assms(1) by simp\n    then show \"x \\<le> n\" using assms(2) by (metis add.right_neutral assms(1) diff_is_0_eq dual_order.refl nle_le)\n  qed\n  have \"y \\<le> n\"\n  proof -\n    have \"x = n - y\" using assms(1) by simp\n    then show \"y \\<le> n\" using assms(3) by (metis add_0 assms(1) diff_is_0_eq nle_le order_refl)\n  qed\n  thus ?thesis by (metis \\<open>x \\<le> n\\<close>)\nqed", "description": "-", "full_code": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\"\n  proof -\n    have \"y = n - x\" using assms(1) by simp\n    then show \"x \\<le> n\" using assms(2) by (metis add.right_neutral assms(1) diff_is_0_eq dual_order.refl nle_le)\n  qed\n  have \"y \\<le> n\"\n  proof -\n    have \"x = n - y\" using assms(1) by simp\n    then show \"y \\<le> n\" using assms(3) by (metis add_0 assms(1) diff_is_0_eq nle_le order_refl)\n  qed\n  thus ?thesis by (metis \\<open>x \\<le> n\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "integer_distributionV6": {"skill_name": "integer_distributionV6", "marker": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\" using assms\n  proof -\n    have \"x + y = n\" using assms(1) by simp\n    also have \"y \\<ge> 0\" using assms(3) by simp\n    ultimately show ?thesis \n      by auto\n  qed\n  have \"y \\<le> n\" using assms\n  proof -\n    have \"x + y = n\" using assms(1) by simp\n    also have \"x \\<ge> 0\" using assms(2) by simp\n    ultimately show ?thesis \n      by auto\n  qed\n  thus \"x \\<le> n \\<and> y \\<le> n\" by (metis \\<open>x \\<le> n\\<close>)\nqed", "description": "-", "full_code": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\" using assms\n  proof -\n    have \"x + y = n\" using assms(1) by simp\n    also have \"y \\<ge> 0\" using assms(3) by simp\n    ultimately show ?thesis \n      by auto\n  qed\n  have \"y \\<le> n\" using assms\n  proof -\n    have \"x + y = n\" using assms(1) by simp\n    also have \"x \\<ge> 0\" using assms(2) by simp\n    ultimately show ?thesis \n      by auto\n  qed\n  thus \"x \\<le> n \\<and> y \\<le> n\" by (metis \\<open>x \\<le> n\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_inequality": {"skill_name": "floor_sum_inequality", "marker": "lemma floor_sum_inequality:\n  fixes r :: real and k :: int\n  assumes \"a < r \\<and> r < b\"\n  shows \"floor (r + real_of_int k) = floor r + k\"\nproof -\n  have \"floor (r + real_of_int k) = floor r + floor (real_of_int k)\"\n  proof -\n    have \"floor (real_of_int k) = k\" \n      by auto\n    then show ?thesis by auto\n  qed\n  moreover have \"floor r \\<le> r\" \n    using assms by auto\n  hence \"floor r + k \\<le> r + real_of_int k\" \n    using assms by auto\n  moreover have \"r + real_of_int k < floor r + k + 1\"\n  proof -\n    have \"r < floor r + 1\" \n      using assms by auto\n    thus \"r + real_of_int k < floor r + k + 1\" \n      by auto\n  qed\n  ultimately show \"floor (r + real_of_int k) = floor r + k\" \n    by auto\nqed", "description": "-", "full_code": "lemma floor_sum_inequality:\n  fixes r :: real and k :: int\n  assumes \"a < r \\<and> r < b\"\n  shows \"floor (r + real_of_int k) = floor r + k\"\nproof -\n  have \"floor (r + real_of_int k) = floor r + floor (real_of_int k)\"\n  proof -\n    have \"floor (real_of_int k) = k\" \n      by auto\n    then show ?thesis by auto\n  qed\n  moreover have \"floor r \\<le> r\" \n    using assms by auto\n  hence \"floor r + k \\<le> r + real_of_int k\" \n    using assms by auto\n  moreover have \"r + real_of_int k < floor r + k + 1\"\n  proof -\n    have \"r < floor r + 1\" \n      using assms by auto\n    thus \"r + real_of_int k < floor r + k + 1\" \n      by auto\n  qed\n  ultimately show \"floor (r + real_of_int k) = floor r + k\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "square_differenceV2": {"skill_name": "square_differenceV2", "marker": "lemma square_difference:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + -y)^2\" by simp\n  then show ?thesis \n    by (simp add: power2_eq_square algebra_simps)\nqed", "description": "-", "full_code": "lemma square_difference:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + -y)^2\" by simp\n  then show ?thesis \n    by (simp add: power2_eq_square algebra_simps)\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansionV4": {"skill_name": "square_expansionV4", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + (-y))^2\" by (simp add: algebra_simps)\n  also have \"... = x^2 + 2*x*(-y) + (-y)^2\" by sos\n  also have \"... = x^2 - 2*x*y + y^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + (-y))^2\" by (simp add: algebra_simps)\n  also have \"... = x^2 + 2*x*(-y) + (-y)^2\" by sos\n  also have \"... = x^2 - 2*x*y + y^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "polynomial_combinationV2": {"skill_name": "polynomial_combinationV2", "marker": "lemma polynomial_combination:\n  fixes p q r :: real\n  shows \"(p + q) + r = p + (q + r)\"\nproof -\n  have \"p + (q + r) = p + q + r\" by (metis add.assoc)\n  moreover have \"(p + q) + r = p + q + r\" by (metis add.assoc)\n  ultimately show \"(p + q) + r = p + (q + r)\" by auto\nqed", "description": "-", "full_code": "lemma polynomial_combination:\n  fixes p q r :: real\n  shows \"(p + q) + r = p + (q + r)\"\nproof -\n  have \"p + (q + r) = p + q + r\" by (metis add.assoc)\n  moreover have \"(p + q) + r = p + q + r\" by (metis add.assoc)\n  ultimately show \"(p + q) + r = p + (q + r)\" by auto\nqed", "origin": "do_request", "update_count": 0}, "polynomial_combinationV3": {"skill_name": "polynomial_combinationV3", "marker": "lemma polynomial_combination:\n  fixes p q r :: real\n  shows \"(p + q) + r = p + (q + r)\"\nproof -\n  have \"p + (q + r) = p + (r + q)\" \n    by (simp add: algebra_simps)\n  also have \"... = (p + r) + q\" \n    by (simp add: algebra_simps)\n  finally show \"(p + q) + r = p + (q + r)\" \n    using `p + (q + r) = p + (r + q)` by simp\nqed", "description": "-", "full_code": "lemma polynomial_combination:\n  fixes p q r :: real\n  shows \"(p + q) + r = p + (q + r)\"\nproof -\n  have \"p + (q + r) = p + (r + q)\" \n    by (simp add: algebra_simps)\n  also have \"... = (p + r) + q\" \n    by (simp add: algebra_simps)\n  finally show \"(p + q) + r = p + (q + r)\" \n    using `p + (q + r) = p + (r + q)` by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_root_expressionV3": {"skill_name": "simplify_square_root_expressionV3", "marker": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  shows \"sqrt(a^2 - b^2) = sqrt((a - b)*(a + b))\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  hence \"sqrt (a^2 - b^2) = sqrt ((a - b) * (a + b))\" \n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  shows \"sqrt(a^2 - b^2) = sqrt((a - b)*(a + b))\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\" by sos\n  hence \"sqrt (a^2 - b^2) = sqrt ((a - b) * (a + b))\" \n    by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "simplify_square_root_expressionV4": {"skill_name": "simplify_square_root_expressionV4", "marker": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  shows \"sqrt(a^2 - b^2) = sqrt((a - b)*(a + b))\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\"\n    by sos\n  then show ?thesis \n    by (simp add: real_sqrt_mult)\nqed", "description": "-", "full_code": "lemma simplify_square_root_expression:\n  fixes a b :: real\n  shows \"sqrt(a^2 - b^2) = sqrt((a - b)*(a + b))\"\nproof -\n  have \"a^2 - b^2 = (a - b) * (a + b)\"\n    by sos\n  then show ?thesis \n    by (simp add: real_sqrt_mult)\nqed", "origin": "do_request", "update_count": 0}, "expression_nonneg_general": {"skill_name": "expression_nonneg_general", "marker": "lemma expression_nonneg_general:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" using assms by auto\n  have \"x^2 >= 0\" using assms by auto\n  have \"y^2 >= 0\" using assms by auto\n  have \"?E >= 1\" using `x^2 * y^2 >= 0` `x^2 >= 0` `y^2 >= 0` by sos\n  have \"?E = 1\" when \"x = 0\" and \"y = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma expression_nonneg_general:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" using assms by auto\n  have \"x^2 >= 0\" using assms by auto\n  have \"y^2 >= 0\" using assms by auto\n  have \"?E >= 1\" using `x^2 * y^2 >= 0` `x^2 >= 0` `y^2 >= 0` by sos\n  have \"?E = 1\" when \"x = 0\" and \"y = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "origin": "expression_nonneg", "update_count": 0}, "expression_nonneg_3d": {"skill_name": "expression_nonneg_3d", "marker": "lemma expression_nonneg_3D:\n  fixes x y z :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 + ((y * z) - 1)^2 + (y + z)^2 + ((z * x) - 1)^2 + (z + x)^2 >= 3\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2 + ((y * z) - 1)^2 + (y + z)^2 + ((z * x) - 1)^2 + (z + x)^2\"\n  have \"((x * y) - 1)^2 = x^2 * y^2 - 2 * x * y + 1\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"((y * z) - 1)^2 = y^2 * z^2 - 2 * y * z + 1\" by sos\n  have \"(y + z)^2 = y^2 + 2 * y * z + z^2\" by sos\n  have \"((z * x) - 1)^2 = z^2 * x^2 - 2 * z * x + 1\" by sos\n  have \"(z + x)^2 = z^2 + 2 * z * x + x^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2) + (y^2 * z^2 - 2 * y * z + 1) + (y^2 + 2 * y * z + z^2) + (z^2 * x^2 - 2 * z * x + 1) + (z^2 + 2 * z * x + x^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + y^2 * z^2 + z^2 * x^2 + 2 * (x^2 + y^2 + z^2) + 3\"\n    by sos\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"y^2 * z^2 >= 0\" by auto\n  have \"z^2 * x^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  have \"z^2 >= 0\" by auto\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma expression_nonneg_3D:\n  fixes x y z :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 + ((y * z) - 1)^2 + (y + z)^2 + ((z * x) - 1)^2 + (z + x)^2 >= 3\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2 + ((y * z) - 1)^2 + (y + z)^2 + ((z * x) - 1)^2 + (z + x)^2\"\n  have \"((x * y) - 1)^2 = x^2 * y^2 - 2 * x * y + 1\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"((y * z) - 1)^2 = y^2 * z^2 - 2 * y * z + 1\" by sos\n  have \"(y + z)^2 = y^2 + 2 * y * z + z^2\" by sos\n  have \"((z * x) - 1)^2 = z^2 * x^2 - 2 * z * x + 1\" by sos\n  have \"(z + x)^2 = z^2 + 2 * z * x + x^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2) + (y^2 * z^2 - 2 * y * z + 1) + (y^2 + 2 * y * z + z^2) + (z^2 * x^2 - 2 * z * x + 1) + (z^2 + 2 * z * x + x^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + y^2 * z^2 + z^2 * x^2 + 2 * (x^2 + y^2 + z^2) + 3\"\n    by sos\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"y^2 * z^2 >= 0\" by auto\n  have \"z^2 * x^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  have \"z^2 >= 0\" by auto\n  thus ?thesis by sos\nqed", "origin": "expression_nonneg", "update_count": 0}, "real_number_properties": {"skill_name": "real_number_properties", "marker": "lemma real_number_properties:\n  fixes a b c :: real\n  shows \"a + (b + c) = (a + b) + c\"\nproof -\n  have \"b + c = (a + b) + c - a\" by (simp add: algebra_simps)\n  then have \"a + (b + c) = a + ((a + b) + c - a)\" by simp\n  also have \"... = (a + (a + b)) + c - a\" by (simp add: algebra_simps)\n  also have \"... = (a + b) + c\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma real_number_properties:\n  fixes a b c :: real\n  shows \"a + (b + c) = (a + b) + c\"\nproof -\n  have \"b + c = (a + b) + c - a\" by (simp add: algebra_simps)\n  then have \"a + (b + c) = a + ((a + b) + c - a)\" by simp\n  also have \"... = (a + (a + b)) + c - a\" by (simp add: algebra_simps)\n  also have \"... = (a + b) + c\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "real_number_propertiesV2": {"skill_name": "real_number_propertiesV2", "marker": "lemma real_number_properties:\n  fixes a b c :: real\n  shows \"a + (b + c) = (a + b) + c\"\nproof -\n  have \"b + c = (a + b) + c - a\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma real_number_properties:\n  fixes a b c :: real\n  shows \"a + (b + c) = (a + b) + c\"\nproof -\n  have \"b + c = (a + b) + c - a\" by (simp add: algebra_simps)\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "square_modV3": {"skill_name": "square_modV3", "marker": "lemma square_mod:\n  fixes a n :: nat\n  shows \"(a^2) mod n = ((a mod n)^2) mod n\"\nproof -\n  let ?m = \"a mod n\"\n  have \"a = n * (a div n) + ?m\" by auto\n  then show \"(a^2) mod n = ((a mod n)^2) mod n\"\n  proof -\n    have \"a^2 = (n * (a div n) + ?m)^2\"\n      by (simp add: algebra_simps)\n    also have \"... = (n * (a div n))^2 + 2 * (n * (a div n)) * ?m + ?m^2\"\n      by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n    also have \"... = n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2\" by (simp add: algebra_simps)\n    finally have \"a^2 = n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2\" .\n    hence \"a^2 mod n = (n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2) mod n\" by simp\n    then have \"a^2 mod n = (?m^2 mod n)\" by (metis minus_div_mult_eq_mod power_mod)\n    moreover have \"?m^2 mod n = (?m)^2 mod n\" by simp\n    ultimately show \"(a^2) mod n = ((a mod n)^2) mod n\" by simp\n  qed\nqed", "description": "-", "full_code": "lemma square_mod:\n  fixes a n :: nat\n  shows \"(a^2) mod n = ((a mod n)^2) mod n\"\nproof -\n  let ?m = \"a mod n\"\n  have \"a = n * (a div n) + ?m\" by auto\n  then show \"(a^2) mod n = ((a mod n)^2) mod n\"\n  proof -\n    have \"a^2 = (n * (a div n) + ?m)^2\"\n      by (simp add: algebra_simps)\n    also have \"... = (n * (a div n))^2 + 2 * (n * (a div n)) * ?m + ?m^2\"\n      by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n    also have \"... = n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2\" by (simp add: algebra_simps)\n    finally have \"a^2 = n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2\" .\n    hence \"a^2 mod n = (n^2 * (a div n)^2 + 2 * n * (a div n) * ?m + ?m^2) mod n\" by simp\n    then have \"a^2 mod n = (?m^2 mod n)\" by (metis minus_div_mult_eq_mod power_mod)\n    moreover have \"?m^2 mod n = (?m)^2 mod n\" by simp\n    ultimately show \"(a^2) mod n = ((a mod n)^2) mod n\" by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "number_of_terms": {"skill_name": "number_of_terms", "marker": "lemma number_of_terms:\n  fixes x :: nat\n  assumes \"7 * (73 - x) + 8 * x = 546\"\n  shows \"x = 35\"\nproof -\n  have \"7 * (73 - x) + 8 * x = 546\" using assms by simp\n  then have \"511 - 7 * x + 8 * x = 546\" by auto\n  then have \"511 + x = 546\" by simp\n  then have \"x = 546 - 511\" by (simp)\n  then show \"x = 35\" by simp\nqed", "description": "-", "full_code": "lemma number_of_terms:\n  fixes x :: nat\n  assumes \"7 * (73 - x) + 8 * x = 546\"\n  shows \"x = 35\"\nproof -\n  have \"7 * (73 - x) + 8 * x = 546\" using assms by simp\n  then have \"511 - 7 * x + 8 * x = 546\" by auto\n  then have \"511 + x = 546\" by simp\n  then have \"x = 546 - 511\" by (simp)\n  then show \"x = 35\" by simp\nqed", "origin": "do_request", "update_count": 0}, "linear_function_differenceV14": {"skill_name": "linear_function_differenceV14", "marker": "theorem linear_function_difference:\n  fixes a b c d :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f c - f d = e\"\n  shows \"f (c + k) - f d = k * a + e\"\nproof -\n  let ?x = \"c + k\"\n  have \"f ?x = a * ?x + b\" by (simp add: assms(1))\n  have \"f c - f d = (a * c + b) - (a * d + b)\" by (simp add: assms(1))\n  have \"f c - f d = a * (c - d)\" by (metis assms(1) add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute right_diff_distrib' semiring_norm(2))\n  then have \"a * (c - d) = e\" using assms(2) by simp\n  have \"f ?x - f d = (a * ?x + b) - (a * d + b)\" by (simp add: assms(1))\n  have \"f ?x - f d = a * ?x - a * d\" by (metis assms(1) add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute right_diff_distrib' semiring_norm(2))\n  have \"f ?x - f d = a * (c + k - d)\" by (metis \\<open>f (c + k) - f d = a * (c + k) - a * d\\<close> add_diff_eq diff_diff_eq2 mult_delta_right right_diff_distrib')\n  also have \"... = a * (c - d) + a * k\" by sos\n  also have \"... = e + a * k\" using `a * (c - d) = e` by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_function_difference:\n  fixes a b c d :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f c - f d = e\"\n  shows \"f (c + k) - f d = k * a + e\"\nproof -\n  let ?x = \"c + k\"\n  have \"f ?x = a * ?x + b\" by (simp add: assms(1))\n  have \"f c - f d = (a * c + b) - (a * d + b)\" by (simp add: assms(1))\n  have \"f c - f d = a * (c - d)\" by (metis assms(1) add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute right_diff_distrib' semiring_norm(2))\n  then have \"a * (c - d) = e\" using assms(2) by simp\n  have \"f ?x - f d = (a * ?x + b) - (a * d + b)\" by (simp add: assms(1))\n  have \"f ?x - f d = a * ?x - a * d\" by (metis assms(1) add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute right_diff_distrib' semiring_norm(2))\n  have \"f ?x - f d = a * (c + k - d)\" by (metis \\<open>f (c + k) - f d = a * (c + k) - a * d\\<close> add_diff_eq diff_diff_eq2 mult_delta_right right_diff_distrib')\n  also have \"... = a * (c - d) + a * k\" by sos\n  also have \"... = e + a * k\" using `a * (c - d) = e` by simp\n  finally show ?thesis by simp\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "term_distribution": {"skill_name": "term_distribution", "marker": "lemma term_distribution:\n  shows \"num_eights = 35 \\<and> num_sevens = 38\"\nproof -\n  have \"num_eights = 35\" by (simp add: num_eights_def)\n  have \"num_sevens = 38\" by (simp add: num_sevens_def)\n  thus ?thesis by eval\nqed", "description": "-", "full_code": "definition num_sevens :: nat where\n  \"num_sevens = 38\"\n\n\n(* Prove the lemma stating the counts of eights and sevens *)\n\ndefinition num_eights :: nat where\n  \"num_eights = 35\"\n\nlemma term_distribution:\n  shows \"num_eights = 35 \\<and> num_sevens = 38\"\nproof -\n  have \"num_eights = 35\" by (simp add: num_eights_def)\n  have \"num_sevens = 38\" by (simp add: num_sevens_def)\n  thus ?thesis by eval\nqed", "origin": "do_request", "update_count": 0}, "num_eights": {"skill_name": "num_eights", "marker": "definition num_eights :: nat where\n  \"num_eights = 35\"", "description": "-", "full_code": "definition num_eights :: nat where\n  \"num_eights = 35\"", "origin": "do_request", "update_count": 0}, "num_sevens": {"skill_name": "num_sevens", "marker": "definition num_sevens :: nat where\n  \"num_sevens = 38\"\n\n\n(* Prove the lemma stating the counts of eights and sevens *)", "description": "-", "full_code": "definition num_sevens :: nat where\n  \"num_sevens = 38\"\n\n\n(* Prove the lemma stating the counts of eights and sevens *)", "origin": "do_request", "update_count": 0}, "square_eq_reflexivity": {"skill_name": "square_eq_reflexivity", "marker": "lemma square_eq_reflexivity:\n  fixes a :: real\n  shows \"a^2 = a^2\"\n  by simp", "description": "-", "full_code": "lemma square_eq_reflexivity:\n  fixes a :: real\n  shows \"a^2 = a^2\"\n  by simp", "origin": "square_eq", "update_count": 0}, "square_root_square_eq": {"skill_name": "square_root_square_eq", "marker": "lemma square_root_square_eq:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt (a^2) = a\"\n  using assms by auto", "description": "-", "full_code": "lemma square_root_square_eq:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt (a^2) = a\"\n  using assms by auto", "origin": "square_eq", "update_count": 0}, "square_eq_nonneg": {"skill_name": "square_eq_nonneg", "marker": "lemma square_eq_nonneg:\n  fixes a b :: real\n  assumes \"a^2 = b^2\"\n  shows \"a = b \\<or> a = -b\"\nproof -\n  have \"a^2 - b^2 = 0\" using assms by simp\n  then have \"(a - b) * (a + b) = 0\" by sos\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_eq_nonneg:\n  fixes a b :: real\n  assumes \"a^2 = b^2\"\n  shows \"a = b \\<or> a = -b\"\nproof -\n  have \"a^2 - b^2 = 0\" using assms by simp\n  then have \"(a - b) * (a + b) = 0\" by sos\n  thus ?thesis by auto\nqed", "origin": "square_eq", "update_count": 0}, "term_distributionV2": {"skill_name": "term_distributionV2", "marker": "lemma term_distribution:\n  fixes num_eights :: nat\n  fixes num_sevens :: nat\n  assumes \"num_eights + num_sevens = 73\"\n  assumes \"num_eights = 35\"\n  assumes \"num_sevens = 38\"\n  shows \"num_eights = 35 \\<and> num_sevens = 38\"\nproof -\n  have \"num_sevens = 73 - num_eights\" using `num_eights + num_sevens = 73` by simp\n  then have \"num_sevens = 73 - 35\" using `num_eights = 35` by simp\n  then have \"num_sevens = 38\" by simp\n  thus ?thesis using `num_eights = 35` by simp\nqed", "description": "-", "full_code": "lemma term_distribution:\n  fixes num_eights :: nat\n  fixes num_sevens :: nat\n  assumes \"num_eights + num_sevens = 73\"\n  assumes \"num_eights = 35\"\n  assumes \"num_sevens = 38\"\n  shows \"num_eights = 35 \\<and> num_sevens = 38\"\nproof -\n  have \"num_sevens = 73 - num_eights\" using `num_eights + num_sevens = 73` by simp\n  then have \"num_sevens = 73 - 35\" using `num_eights = 35` by simp\n  then have \"num_sevens = 38\" by simp\n  thus ?thesis using `num_eights = 35` by simp\nqed", "origin": "do_request", "update_count": 0}, "term_distributionV3": {"skill_name": "term_distributionV3", "marker": "lemma term_distribution:\n  shows \"num_eights = 35 \\<and> num_sevens = 38\"\nproof -\n  have \"num_eights = 35\" unfolding num_eights_def by simp\n  moreover have \"num_sevens = 38\" unfolding num_sevens_def by simp\n  ultimately show \"num_eights = 35 \\<and> num_sevens = 38\" by simp\nqed", "description": "-", "full_code": "definition num_sevens :: nat where\n  \"num_sevens = 38\"\n\ndefinition num_eights :: nat where\n  \"num_eights = 35\"\n\nlemma term_distribution:\n  shows \"num_eights = 35 \\<and> num_sevens = 38\"\nproof -\n  have \"num_eights = 35\" unfolding num_eights_def by simp\n  moreover have \"num_sevens = 38\" unfolding num_sevens_def by simp\n  ultimately show \"num_eights = 35 \\<and> num_sevens = 38\" by simp\nqed", "origin": "do_request", "update_count": 0}, "num_sevensV2": {"skill_name": "num_sevensV2", "marker": "definition num_sevens :: nat where\n  \"num_sevens = 38\"", "description": "-", "full_code": "definition num_sevens :: nat where\n  \"num_sevens = 38\"", "origin": "do_request", "update_count": 0}, "linear_differenceV4": {"skill_name": "linear_differenceV4", "marker": "lemma linear_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  have \"f x = a * x + b\" and \"f y = a * y + b\" using assms by auto\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma linear_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  have \"f x = a * x + b\" and \"f y = a * y + b\" using assms by auto\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "amc12b_2003_p9V5": {"skill_name": "amc12b_2003_p9V5", "marker": "theorem amc12b_2003_p9:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f 6 - f 2 = a * (6 - 2)\" using linear_difference[OF assms(1)] by simp\n  then have \"f 6 - f 2 = 4 * a\" using `f 6 - f 2 = 12` by simp\n  then have \"a = 3\" by (smt (verit) assms(2))\n  have \"f 12 - f 2 = a * (12 - 2)\" using linear_difference[OF assms(1)] by simp\n  then have \"f 12 - f 2 = 10 * a\" by simp\n  then show ?thesis using `a = 3` by simp\nqed", "description": "-", "full_code": "lemma linear_difference:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n  shows \"f x - f y = a * (x - y)\"\nproof -\n  have \"f x = a * x + b\" and \"f y = a * y + b\" using assms by auto\n  then show ?thesis by (simp add: algebra_simps)\nqed\n\ntheorem amc12b_2003_p9:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f 6 - f 2 = a * (6 - 2)\" using linear_difference[OF assms(1)] by simp\n  then have \"f 6 - f 2 = 4 * a\" using `f 6 - f 2 = 12` by simp\n  then have \"a = 3\" by (smt (verit) assms(2))\n  have \"f 12 - f 2 = a * (12 - 2)\" using linear_difference[OF assms(1)] by simp\n  then have \"f 12 - f 2 = 10 * a\" by simp\n  then show ?thesis using `a = 3` by simp\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "remainder_modulo_extended": {"skill_name": "remainder_modulo_extended", "marker": "lemma remainder_modulo_extended:\n  fixes a d :: int\n  assumes \"d > 0\"\n  shows \"a mod d \\<in> {0..d-1} \\<or> a mod d = -1\"\nproof -\n  have \"a mod d < d\" by (metis Euclidean_Division.pos_mod_bound assms)\n  moreover have \"a mod d \\<ge> 0\" \n    by (metis Euclidean_Division.pos_mod_sign assms)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma remainder_modulo_extended:\n  fixes a d :: int\n  assumes \"d > 0\"\n  shows \"a mod d \\<in> {0..d-1} \\<or> a mod d = -1\"\nproof -\n  have \"a mod d < d\" by (metis Euclidean_Division.pos_mod_bound assms)\n  moreover have \"a mod d \\<ge> 0\" \n    by (metis Euclidean_Division.pos_mod_sign assms)\n  ultimately show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "remainder_modulo_general": {"skill_name": "remainder_modulo_general", "marker": "lemma remainder_modulo_general:\n  fixes a d :: int\n  assumes \"d > 0\"\n  shows \"a mod d \\<in> {0..d-1}\"\nproof -\n  have \"a mod d < d\" by (metis Euclidean_Division.pos_mod_bound assms)\n  moreover have \"a mod d \\<ge> 0\" \n    using assms by auto\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma remainder_modulo_general:\n  fixes a d :: int\n  assumes \"d > 0\"\n  shows \"a mod d \\<in> {0..d-1}\"\nproof -\n  have \"a mod d < d\" by (metis Euclidean_Division.pos_mod_bound assms)\n  moreover have \"a mod d \\<ge> 0\" \n    using assms by auto\n  ultimately show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "count_terms": {"skill_name": "count_terms", "marker": "lemma count_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" using assms by (auto simp add: card_insert_if)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" using assms by (auto simp add: card_insert_if)\n  thus ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_countV6": {"skill_name": "sum_terms_countV6", "marker": "lemma sum_terms_count:\n  shows \"card {19::nat..<92} = 73\"\nproof -\n  have \"card {19::nat..<92} = 92 - 19\" by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count:\n  shows \"card {19::nat..<92} = 73\"\nproof -\n  have \"card {19::nat..<92} = 92 - 19\" by auto\n  then show ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "number_of_termsV2": {"skill_name": "number_of_termsV2", "marker": "lemma number_of_terms:\n  fixes x :: nat\n  assumes \"7 * (73 - x) + 8 * x = 546\"\n  shows \"x = 35\"\nproof -\n  have \"7 * (73 - x) + 8 * x = 546\" using assms by simp\n  then have \"511 - 7 * x + 8 * x = 546\" by simp\n  then have \"511 + x = 546\" by (simp add: algebra_simps)\n  then have \"x = 546 - 511\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma number_of_terms:\n  fixes x :: nat\n  assumes \"7 * (73 - x) + 8 * x = 546\"\n  shows \"x = 35\"\nproof -\n  have \"7 * (73 - x) + 8 * x = 546\" using assms by simp\n  then have \"511 - 7 * x + 8 * x = 546\" by simp\n  then have \"511 + x = 546\" by (simp add: algebra_simps)\n  then have \"x = 546 - 511\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "number_of_termsV3": {"skill_name": "number_of_termsV3", "marker": "lemma number_of_terms:\n  fixes x :: nat\n  assumes \"7 * (73 - x) + 8 * x = 546\"\n  shows \"x = 35\"\nproof -\n  have \"7 * (73 - x) + 8 * x = 546\" using `7 * (73 - x) + 8 * x = 546` by simp\n  then have \"511 - 7*x + 8*x = 546\" by simp\n  then have \"511 + x = 546\" by simp\n  hence \"x = 546 - 511\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma number_of_terms:\n  fixes x :: nat\n  assumes \"7 * (73 - x) + 8 * x = 546\"\n  shows \"x = 35\"\nproof -\n  have \"7 * (73 - x) + 8 * x = 546\" using `7 * (73 - x) + 8 * x = 546` by simp\n  then have \"511 - 7*x + 8*x = 546\" by simp\n  then have \"511 + x = 546\" by simp\n  hence \"x = 546 - 511\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_differenceV3": {"skill_name": "square_differenceV3", "marker": "lemma square_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by (simp add: power2_eq_square algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_difference:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by (simp add: power2_eq_square algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "square_product": {"skill_name": "square_product", "marker": "lemma square_product:\n  fixes a b :: real\n  shows \"(a * b)^2 = a^2 * b^2\"\nproof -\n  have \"(a * b)^2 = a * b * a * b\" by sos\n  also have \"... = (a * a) * (b * b)\" by (simp add: mult.assoc)\n  also have \"... = a^2 * b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_product:\n  fixes a b :: real\n  shows \"(a * b)^2 = a^2 * b^2\"\nproof -\n  have \"(a * b)^2 = a * b * a * b\" by sos\n  also have \"... = (a * a) * (b * b)\" by (simp add: mult.assoc)\n  also have \"... = a^2 * b^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "sqrt_simplificationV2": {"skill_name": "sqrt_simplificationV2", "marker": "lemma sqrt_simplification:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt(a) + sqrt(b) = sqrt(a + b + 2*sqrt(a*b))\"\nproof -\n  have \"sqrt(a) + sqrt(b) \\<ge> 0\" using assms by auto\n  hence \"sqrt(a + b + 2 * sqrt(a * b)) \\<ge> 0\" \n    using assms by auto\n  then have \"sqrt(a) + sqrt(b) = sqrt((sqrt(a) + sqrt(b))^2)\" \n    by (metis \\<open>0 \\<le> sqrt a + sqrt b\\<close> real_sqrt_unique)\n  have \"(sqrt(a) + sqrt(b))^2 = a + b + 2 * sqrt(a) * sqrt(b)\" \n    by (smt (verit) assms(1) assms(2) power2_sum real_sqrt_pow2_iff)\n  also have \"... = a + b + 2 * sqrt(a * b)\" \n    by (metis calculation is_num_normalize(1) mult.commute mult.left_commute real_sqrt_mult)\n  finally have \"sqrt(a + b + 2 * sqrt(a * b)) = sqrt((sqrt(a) + sqrt(b))^2)\" \n    using `sqrt(a) + sqrt(b) \\<ge> 0` by (metis power2_eq_square)\n  thus ?thesis \n    using `sqrt(a) + sqrt(b) = sqrt((sqrt(a) + sqrt(b))^2)` by simp\nqed", "description": "-", "full_code": "lemma sqrt_simplification:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt(a) + sqrt(b) = sqrt(a + b + 2*sqrt(a*b))\"\nproof -\n  have \"sqrt(a) + sqrt(b) \\<ge> 0\" using assms by auto\n  hence \"sqrt(a + b + 2 * sqrt(a * b)) \\<ge> 0\" \n    using assms by auto\n  then have \"sqrt(a) + sqrt(b) = sqrt((sqrt(a) + sqrt(b))^2)\" \n    by (metis \\<open>0 \\<le> sqrt a + sqrt b\\<close> real_sqrt_unique)\n  have \"(sqrt(a) + sqrt(b))^2 = a + b + 2 * sqrt(a) * sqrt(b)\" \n    by (smt (verit) assms(1) assms(2) power2_sum real_sqrt_pow2_iff)\n  also have \"... = a + b + 2 * sqrt(a * b)\" \n    by (metis calculation is_num_normalize(1) mult.commute mult.left_commute real_sqrt_mult)\n  finally have \"sqrt(a + b + 2 * sqrt(a * b)) = sqrt((sqrt(a) + sqrt(b))^2)\" \n    using `sqrt(a) + sqrt(b) \\<ge> 0` by (metis power2_eq_square)\n  thus ?thesis \n    using `sqrt(a) + sqrt(b) = sqrt((sqrt(a) + sqrt(b))^2)` by simp\nqed", "origin": "do_request", "update_count": 0}, "square_expansionV5": {"skill_name": "square_expansionV5", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(-y + x)^2 = x^2 + 2 * (-y) * x + (-y)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = x^2 - 2 * x * y + y^2\" by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(-y + x)^2 = x^2 + 2 * (-y) * x + (-y)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = x^2 - 2 * x * y + y^2\" by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansionV6": {"skill_name": "square_expansionV6", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + -y)^2\" by (simp add: algebra_simps)\n  also have \"... = x^2 + 2*x*(-y) + (-y)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = x^2 - 2*x*y + y^2\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + -y)^2\" by (simp add: algebra_simps)\n  also have \"... = x^2 + 2*x*(-y) + (-y)^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = x^2 - 2*x*y + y^2\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansionV7": {"skill_name": "square_expansionV7", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x)^2 - 2*x*y + (y)^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x)^2 - 2*x*y + (y)^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "floor_boundsV5": {"skill_name": "floor_boundsV5", "marker": "lemma floor_bounds:\n  fixes r :: real\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  let ?n = \"floor r\"\n  have \"r < ?n + 1\" \n  proof -\n    have \"r < ?n + 1\" by auto\n    thus \"r < ?n + 1\" by simp\n  qed\n  moreover have \"?n \\<le> r\" \n  proof -\n    have \"?n = floor r\" by simp\n    thus \"?n \\<le> r\" by auto\n  qed\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_bounds:\n  fixes r :: real\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  let ?n = \"floor r\"\n  have \"r < ?n + 1\" \n  proof -\n    have \"r < ?n + 1\" by auto\n    thus \"r < ?n + 1\" by simp\n  qed\n  moreover have \"?n \\<le> r\" \n  proof -\n    have \"?n = floor r\" by simp\n    thus \"?n \\<le> r\" by auto\n  qed\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "floor_boundsV6": {"skill_name": "floor_boundsV6", "marker": "lemma floor_bounds:\n  fixes r :: real\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  have \"floor r = floor r\" by simp\n  hence \"floor r \\<le> r\" by auto\n  moreover have \"r < floor r + 1\" \n  proof -\n    have \"floor r < floor r + 1\" by simp\n    thus \"r < floor r + 1\" using `floor r \\<le> r` and `floor r < floor r + 1`\n      by auto\n  qed\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_bounds:\n  fixes r :: real\n  shows \"floor r \\<le> r \\<and> r < floor r + 1\"\nproof -\n  have \"floor r = floor r\" by simp\n  hence \"floor r \\<le> r\" by auto\n  moreover have \"r < floor r + 1\" \n  proof -\n    have \"floor r < floor r + 1\" by simp\n    thus \"r < floor r + 1\" using `floor r \\<le> r` and `floor r < floor r + 1`\n      by auto\n  qed\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "inequality_manipulationV6": {"skill_name": "inequality_manipulationV6", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"c * (b - a) > 0\" using assms(2) by (simp add: mult_pos_pos)\n  have \"a * c < a * c + (b - a) * c\" \n    by (metis assms(1) assms(2) comm_semiring_class.distrib le_add_diff_inverse less_eq_real_def mult.commute mult_less_cancel_right_disj)\n  then show ?thesis using `c * (b - a) > 0` by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"c * (b - a) > 0\" using assms(2) by (simp add: mult_pos_pos)\n  have \"a * c < a * c + (b - a) * c\" \n    by (metis assms(1) assms(2) comm_semiring_class.distrib le_add_diff_inverse less_eq_real_def mult.commute mult_less_cancel_right_disj)\n  then show ?thesis using `c * (b - a) > 0` by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "inequality_manipulationV7": {"skill_name": "inequality_manipulationV7", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"c * (b - a) > 0\" using assms(2) by (simp add: mult_pos_pos)\n  moreover have \"a * c < a * c + c * (b - a)\" \n    by (simp add: add_strict_mono assms(1) assms(2))\n  ultimately show ?thesis \n    by (simp add: field_simps) \nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  then have \"c * (b - a) > 0\" using assms(2) by (simp add: mult_pos_pos)\n  moreover have \"a * c < a * c + c * (b - a)\" \n    by (simp add: add_strict_mono assms(1) assms(2))\n  ultimately show ?thesis \n    by (simp add: field_simps) \nqed", "origin": "do_request", "update_count": 0}, "inequality_manipulationV8": {"skill_name": "inequality_manipulationV8", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  have \"c > 0\" using assms(2) by assumption\n  have \"(b - a) * c > 0\" using `b - a > 0` `c > 0` by (simp add: mult_pos_pos)\n  then have \"b * c - a * c > 0\" by (simp add: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a < b\" \"c > 0\"\n  shows \"a * c < b * c\"\nproof -\n  have \"b - a > 0\" using assms(1) by (simp add: less_diff_eq)\n  have \"c > 0\" using assms(2) by assumption\n  have \"(b - a) * c > 0\" using `b - a > 0` `c > 0` by (simp add: mult_pos_pos)\n  then have \"b * c - a * c > 0\" by (simp add: field_simps)\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "mod_m_cases": {"skill_name": "mod_m_cases", "marker": "lemma mod_m_cases:\n  fixes a :: int\n  fixes m :: nat\n  assumes \"m > 0\"\n  shows \"a mod m < m\"\n  by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)", "description": "-", "full_code": "lemma mod_m_cases:\n  fixes a :: int\n  fixes m :: nat\n  assumes \"m > 0\"\n  shows \"a mod m < m\"\n  by (metis Euclidean_Division.pos_mod_bound assms of_nat_0_less_iff)", "origin": "mod4_cases", "update_count": 0}, "generalized_square_expansion": {"skill_name": "generalized_square_expansion", "marker": "lemma generalized_square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  by (simp add: power2_diff)", "description": "-", "full_code": "lemma generalized_square_expansion:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  by (simp add: power2_diff)", "origin": "square_expansion", "update_count": 0}, "algebra_2varlineareq_extended_dimensions": {"skill_name": "algebra_2varlineareq_extended_dimensions", "marker": "theorem algebra_2varlineareq_extended_dimensions:\n  fixes x e :: \"complex list\"\n  assumes h0: \"\\<forall>i. (x ! i) + (e ! i) = 7\" and h1: \"\\<forall>i. 2 * (x ! i) + (e ! i) = 3\"\n  shows \"\\<forall>i. (e ! i) = 11 \\<and> (x ! i) = (-4) \\<and> (e ! i) + (x ! i) = 7\"\nproof -\n  let ?xi = \"x ! 0\" and ?ei = \"e ! 0\"\n  have \"7 = ?xi + ?ei\" using assms(1) by simp\n  have \"3 = 2 * ?xi + ?ei\" using assms(2) by simp\n  have e_eq: \"?ei = 7 - ?xi\" by (metis \\<open>7 = x ! 0 + e ! 0\\<close> add_diff_cancel_left' semiring_norm(5))\n  have eq2_substituted: \"2 * ?xi + (7 - ?xi) = 3\" using e_eq by (metis \\<open>3 = 2 * x ! 0 + e ! 0\\<close>)\n  have simplified_eq: \"?xi + 7 = 3\" using eq2_substituted by simp\n  have xi_value: \"?xi = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have ei_value: \"?ei = 7 - (-4)\" using e_eq xi_value by simp\n  show ?thesis using xi_value ei_value by (smt (verit) algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended h0 h1)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4) \\<and> e + x = 7\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed\n\ntheorem algebra_2varlineareq_extended_dimensions:\n  fixes x e :: \"complex list\"\n  assumes h0: \"\\<forall>i. (x ! i) + (e ! i) = 7\" and h1: \"\\<forall>i. 2 * (x ! i) + (e ! i) = 3\"\n  shows \"\\<forall>i. (e ! i) = 11 \\<and> (x ! i) = (-4) \\<and> (e ! i) + (x ! i) = 7\"\nproof -\n  let ?xi = \"x ! 0\" and ?ei = \"e ! 0\"\n  have \"7 = ?xi + ?ei\" using assms(1) by simp\n  have \"3 = 2 * ?xi + ?ei\" using assms(2) by simp\n  have e_eq: \"?ei = 7 - ?xi\" by (metis \\<open>7 = x ! 0 + e ! 0\\<close> add_diff_cancel_left' semiring_norm(5))\n  have eq2_substituted: \"2 * ?xi + (7 - ?xi) = 3\" using e_eq by (metis \\<open>3 = 2 * x ! 0 + e ! 0\\<close>)\n  have simplified_eq: \"?xi + 7 = 3\" using eq2_substituted by simp\n  have xi_value: \"?xi = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have ei_value: \"?ei = 7 - (-4)\" using e_eq xi_value by simp\n  show ?thesis using xi_value ei_value by (smt (verit) algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended h0 h1)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "fraction_combinationV2": {"skill_name": "fraction_combinationV2", "marker": "lemma fraction_combination:\n  fixes a b c d :: real\n  assumes \"d \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then show ?thesis by (smt (verit) assms(1) assms(2) diff_frac_eq mult.commute)\nqed", "description": "-", "full_code": "lemma fraction_combination:\n  fixes a b c d :: real\n  assumes \"d \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a / b) - (c / d) = (a * d - b * c) / (b * d)\"\nproof -\n  have \"a / b - c / d = (a * d) / (b * d) - (c * b) / (b * d)\"\n    by (simp add: assms(1) assms(2) field_simps)\n  then show ?thesis by (smt (verit) assms(1) assms(2) diff_frac_eq mult.commute)\nqed", "origin": "do_request", "update_count": 0}, "congruence_propertiesV4": {"skill_name": "congruence_propertiesV4", "marker": "lemma congruence_properties:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis assms(1) assms(2) mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = b + (a div m) * m\" and \"c = d + (c div m) * m\"\n    using assms by auto\n  have \"a + c = (b + (a div m) * m) + (d + (c div m) * m)\"\n    by (metis \\<open>a = b + (a div m) * m\\<close> \\<open>c = d + (c div m) * m\\<close>)\n  then have \"a + c = (b + d) + ((a div m) + (c div m)) * m\"\n    by (simp add: algebra_simps)\n  have \"(a + c) mod m = (((b + d) + ((a div m) + (c div m)) * m) mod m)\"\n    by (metis \\<open>a + c = b + d + (a div m + c div m) * m\\<close>)\n  also have \"... = (b + d) mod m\"\n    by auto\n  finally show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma congruence_properties:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis assms(1) assms(2) mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = b + (a div m) * m\" and \"c = d + (c div m) * m\"\n    using assms by auto\n  have \"a + c = (b + (a div m) * m) + (d + (c div m) * m)\"\n    by (metis \\<open>a = b + (a div m) * m\\<close> \\<open>c = d + (c div m) * m\\<close>)\n  then have \"a + c = (b + d) + ((a div m) + (c div m)) * m\"\n    by (simp add: algebra_simps)\n  have \"(a + c) mod m = (((b + d) + ((a div m) + (c div m)) * m) mod m)\"\n    by (metis \\<open>a + c = b + d + (a div m + c div m) * m\\<close>)\n  also have \"... = (b + d) mod m\"\n    by auto\n  finally show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_sumV4": {"skill_name": "mod_sumV4", "marker": "lemma mod_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  let ?a = \"x mod 10\"\n  let ?b = \"y mod 10\"\n  have \"x = ?a + (x div 10) * 10\" and \"y = ?b + (y div 10) * 10\"\n    by auto\n  have \"x + y = (?a + ?b) + ((x div 10) + (y div 10)) * 10\"\n    using `x = ?a + (x div 10) * 10` `y = ?b + (y div 10) * 10`\n    by (simp add: algebra_simps)\n  have \"(x + y) mod 10 = ((?a + ?b) + ((x div 10) + (y div 10)) * 10) mod 10\"\n    by (simp add: algebra_simps)\n  also have \"... = (?a + ?b) mod 10\"\n    by presburger\n  also have \"... = (x mod 10 + y mod 10) mod 10\"\n    by auto\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y :: nat\n  shows \"(x mod 10 + y mod 10) mod 10 = (x + y) mod 10\"\nproof -\n  let ?a = \"x mod 10\"\n  let ?b = \"y mod 10\"\n  have \"x = ?a + (x div 10) * 10\" and \"y = ?b + (y div 10) * 10\"\n    by auto\n  have \"x + y = (?a + ?b) + ((x div 10) + (y div 10)) * 10\"\n    using `x = ?a + (x div 10) * 10` `y = ?b + (y div 10) * 10`\n    by (simp add: algebra_simps)\n  have \"(x + y) mod 10 = ((?a + ?b) + ((x div 10) + (y div 10)) * 10) mod 10\"\n    by (simp add: algebra_simps)\n  also have \"... = (?a + ?b) mod 10\"\n    by presburger\n  also have \"... = (x mod 10 + y mod 10) mod 10\"\n    by auto\n  finally show ?thesis by presburger\nqed", "origin": "do_request", "update_count": 0}, "linear_equation_solutionV7": {"skill_name": "linear_equation_solutionV7", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a0\"  \n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a0)/n\"\nproof -\n  have eq: \"m*a + n*b = p\" using h0 by simp\n  have sub: \"m*a0 + n*b = p\" using h1 eq by simp\n  then have isolation: \"n*b = p - m*a0\" by simp\n  then have \"b = (p - m*a0)/n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a0\"  \n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*a0)/n\"\nproof -\n  have eq: \"m*a + n*b = p\" using h0 by simp\n  have sub: \"m*a0 + n*b = p\" using h1 eq by simp\n  then have isolation: \"n*b = p - m*a0\" by simp\n  then have \"b = (p - m*a0)/n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "square_expansion_with_variable": {"skill_name": "square_expansion_with_variable", "marker": "lemma square_expansion_with_variable:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  by sos", "description": "-", "full_code": "lemma square_expansion_with_variable:\n  fixes a b :: real\n  shows \"(a - b)^2 = a^2 - 2*a*b + b^2\"\n  by sos", "origin": "square_expansion", "update_count": 0}, "mod_arithmetic": {"skill_name": "mod_arithmetic", "marker": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c < a\"\n  shows \"(b + c) mod a = (b mod a + c mod a) mod a\"\nproof -\n  have \"b mod a = b\" using assms(2) by simp\n  have \"c mod a = c\" using assms(3) by simp\n  then have \"(b mod a + c mod a) mod a = (b + c) mod a\"\n    using `b mod a = b` `c mod a = c` by (simp add: algebra_simps)\n  then show ?thesis using `b mod a = b` `c mod a = c` by simp\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c < a\"\n  shows \"(b + c) mod a = (b mod a + c mod a) mod a\"\nproof -\n  have \"b mod a = b\" using assms(2) by simp\n  have \"c mod a = c\" using assms(3) by simp\n  then have \"(b mod a + c mod a) mod a = (b + c) mod a\"\n    using `b mod a = b` `c mod a = c` by (simp add: algebra_simps)\n  then show ?thesis using `b mod a = b` `c mod a = c` by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_n_casesV10": {"skill_name": "mod_n_casesV10", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n < n\"\nproof -\n  have \"a mod n = a - n * (a div n)\" by (auto simp: field_simps)\n  moreover have \"a - n * (a div n) < n\" using assms by (metis Euclidean_Division.pos_mod_bound minus_mult_div_eq_mod of_nat_0_less_iff)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"a mod n < n\"\nproof -\n  have \"a mod n = a - n * (a div n)\" by (auto simp: field_simps)\n  moreover have \"a - n * (a div n) < n\" using assms by (metis Euclidean_Division.pos_mod_bound minus_mult_div_eq_mod of_nat_0_less_iff)\n  ultimately show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "nonnegativity_expression": {"skill_name": "nonnegativity_expression", "marker": "lemma nonnegativity_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" using product_sum_expression by simp\n  have \"?E >= 1\" using `x^2 * y^2 >= 0` by sos\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma product_sum_expression:\n  fixes x y :: real\n  shows \"(x * y - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  let ?E = \"(x * y - 1)^2 + (x + y)^2\"\n  have \"(x * y - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  thus ?thesis by (simp add: algebra_simps)\nqed\n\nlemma nonnegativity_expression:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" using product_sum_expression by simp\n  have \"?E >= 1\" using `x^2 * y^2 >= 0` by sos\n  thus ?thesis by auto\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "product_sum_expressionV2": {"skill_name": "product_sum_expressionV2", "marker": "lemma product_sum_expression:\n  fixes x y :: real\n  shows \"(x * y - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  let ?E = \"(x * y - 1)^2 + (x + y)^2\"\n  have \"(x * y - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma product_sum_expression:\n  fixes x y :: real\n  shows \"(x * y - 1)^2 + (x + y)^2 = (x^2 * y^2 + x^2 + y^2 + 1)\"\nproof -\n  let ?E = \"(x * y - 1)^2 + (x + y)^2\"\n  have \"(x * y - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "product_difference_square": {"skill_name": "product_difference_square", "marker": "lemma product_difference_square:\n  fixes a b :: real\n  shows \"(a * b - 1)^2 + (a + b)^2 >= 1\"\nproof -\n  let ?E = \"(a * b - 1)^2 + (a + b)^2\"\n  have \"(a * b - 1)^2 = (a^2 * b^2 - 2 * a * b + 1)\" by sos\n  have \"(a + b)^2 = a^2 + 2 * a * b + b^2\" by sos\n  have \"?E = (a^2 * b^2 - 2 * a * b + 1) + (a^2 + 2 * a * b + b^2)\"\n    by sos\n  have \"?E = a^2 * b^2 + a^2 + b^2 + 1\" by sos\n  have \"a^2 * b^2 >= 0\" by auto\n  have \"a^2 >= 0\" by auto\n  have \"b^2 >= 0\" by auto\n  then have \"?E >= 1\" by sos\n  have \"?E = 1\" when \"a = 0\" and \"b = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma product_difference_square:\n  fixes a b :: real\n  shows \"(a * b - 1)^2 + (a + b)^2 >= 1\"\nproof -\n  let ?E = \"(a * b - 1)^2 + (a + b)^2\"\n  have \"(a * b - 1)^2 = (a^2 * b^2 - 2 * a * b + 1)\" by sos\n  have \"(a + b)^2 = a^2 + 2 * a * b + b^2\" by sos\n  have \"?E = (a^2 * b^2 - 2 * a * b + 1) + (a^2 + 2 * a * b + b^2)\"\n    by sos\n  have \"?E = a^2 * b^2 + a^2 + b^2 + 1\" by sos\n  have \"a^2 * b^2 >= 0\" by auto\n  have \"a^2 >= 0\" by auto\n  have \"b^2 >= 0\" by auto\n  then have \"?E >= 1\" by sos\n  have \"?E = 1\" when \"a = 0\" and \"b = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "rational_operations": {"skill_name": "rational_operations", "marker": "lemma rational_operations:\n  fixes a b c d :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"(a / b) + (c / d) = (a * d + c * b) / (b * d)\"\nproof -\n  have \"a / b + c / d = (a * d) / (b * d) + (c * b) / (b * d)\"\n    by (smt (verit) assms(2) assms(4) linorder_neq_iff nonzero_mult_divide_mult_cancel_right nonzero_mult_divide_mult_cancel_right2)\n  then have \"a / b + c / d = (a * d + c * b) / (b * d)\"\n    by (smt (verit) add_divide_distrib)\n  thus ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma rational_operations:\n  fixes a b c d :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"(a / b) + (c / d) = (a * d + c * b) / (b * d)\"\nproof -\n  have \"a / b + c / d = (a * d) / (b * d) + (c * b) / (b * d)\"\n    by (smt (verit) assms(2) assms(4) linorder_neq_iff nonzero_mult_divide_mult_cancel_right nonzero_mult_divide_mult_cancel_right2)\n  then have \"a / b + c / d = (a * d + c * b) / (b * d)\"\n    by (smt (verit) add_divide_distrib)\n  thus ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeqm_a_xpeeqb_eeqx": {"skill_name": "algebra_2varlineareq_xpeeqm_a_xpeeqb_eeqx", "marker": "theorem algebra_2varlineareq_xpeeqm_a_xpeeqb_eeqx:\n  fixes x e a b c :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (2*a - b) / 1 \\<and> x = (a - e)\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a)\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel)\n  have e_value: \"e = a - (b - a)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by (simp add: h0)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeqm_a_xpeeqb_eeqx:\n  fixes x e a b c :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (2*a - b) / 1 \\<and> x = (a - e)\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a)\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel)\n  have e_value: \"e = a - (b - a)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by (simp add: h0)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebraic_manipulation": {"skill_name": "algebraic_manipulation", "marker": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"a - c = b\"\nproof -\n  have \"a - c = (b + c) - c\" using assms by simp\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"a - c = b\"\nproof -\n  have \"a - c = (b + c) - c\" using assms by simp\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "algebraic_manipulationV2": {"skill_name": "algebraic_manipulationV2", "marker": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"a - c = b\"\nproof -\n  have \"a - c = (b + c) - c\" using assms by simp\n  also have \"... = b + (c - c)\" by (simp add: algebra_simps)\n  also have \"... = b + 0\" by simp\n  finally show \"a - c = b\" by simp\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"a - c = b\"\nproof -\n  have \"a - c = (b + c) - c\" using assms by simp\n  also have \"... = b + (c - c)\" by (simp add: algebra_simps)\n  also have \"... = b + 0\" by simp\n  finally show \"a - c = b\" by simp\nqed", "origin": "do_request", "update_count": 0}, "rational_operationsV2": {"skill_name": "rational_operationsV2", "marker": "lemma rational_operations:\n  fixes a b c d :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"(a / b) + (c / d) = (a * d + b * c) / (b * d)\"\nproof -\n  have \"a / b + c / d = (a * d) / (b * d) + (b * c) / (b * d)\"\n    by (metis assms(2) assms(4) divide_self dual_order.strict_iff_order mult_cancel_left2 mult_cancel_right1 times_divide_times_eq)\n  then have \"a / b + c / d = (a * d + b * c) / (b * d)\"\n    by (smt (verit) add_divide_distrib)\n  thus ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma rational_operations:\n  fixes a b c d :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"(a / b) + (c / d) = (a * d + b * c) / (b * d)\"\nproof -\n  have \"a / b + c / d = (a * d) / (b * d) + (b * c) / (b * d)\"\n    by (metis assms(2) assms(4) divide_self dual_order.strict_iff_order mult_cancel_left2 mult_cancel_right1 times_divide_times_eq)\n  then have \"a / b + c / d = (a * d + b * c) / (b * d)\"\n    by (smt (verit) add_divide_distrib)\n  thus ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "square_expansion_with_coefficients": {"skill_name": "square_expansion_with_coefficients", "marker": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(a * x - b * y) ^ 2 = a^2 * x^2 - 2 * a * b * x * y + b^2 * y^2\"\nproof -\n  have \"((a * x) - (b * y))^2 = (a * x)^2 - 2 * (a * x) * (b * y) + (b * y)^2\" by sos\n  thus ?thesis by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(a * x - b * y) ^ 2 = a^2 * x^2 - 2 * a * b * x * y + b^2 * y^2\"\nproof -\n  have \"((a * x) - (b * y))^2 = (a * x)^2 - 2 * (a * x) * (b * y) + (b * y)^2\" by sos\n  thus ?thesis by (simp add: power2_eq_square)\nqed", "origin": "square_expansion", "update_count": 0}, "square_of_sum_and_difference": {"skill_name": "square_of_sum_and_difference", "marker": "lemma square_of_sum_and_difference:\n  fixes x y :: real\n  shows \"(x + y)^2 - (x - y)^2 = 4 * x * y\"\nproof -\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"(x - y)^2 = x^2 - 2 * x * y + y^2\" by sos\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_of_sum_and_difference:\n  fixes x y :: real\n  shows \"(x + y)^2 - (x - y)^2 = 4 * x * y\"\nproof -\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"(x - y)^2 = x^2 - 2 * x * y + y^2\" by sos\n  thus ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_nonnegativity": {"skill_name": "square_expansion_with_nonnegativity", "marker": "lemma square_expansion_with_nonnegativity:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\"\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\n  by sos", "description": "-", "full_code": "lemma square_expansion_with_nonnegativity:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\"\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\n  by sos", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_additional_terms": {"skill_name": "square_expansion_with_additional_terms", "marker": "lemma square_expansion_with_additional_terms:\n  fixes a b x y :: real\n  shows \"(x + a - (y + b))^2 = (x - y)^2 + 2*(x - y)*(a - b) + (a - b)^2\"\nproof -\n  have \"(x + a - (y + b))^2 = (x - y + a - b)^2\" by sos\n  also have \"... = (x - y)^2 + 2*(x - y)*(a - b) + (a - b)^2\" by sos\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_expansion_with_additional_terms:\n  fixes a b x y :: real\n  shows \"(x + a - (y + b))^2 = (x - y)^2 + 2*(x - y)*(a - b) + (a - b)^2\"\nproof -\n  have \"(x + a - (y + b))^2 = (x - y + a - b)^2\" by sos\n  also have \"... = (x - y)^2 + 2*(x - y)*(a - b) + (a - b)^2\" by sos\n  finally show ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_additive_identity": {"skill_name": "square_expansion_with_additive_identity", "marker": "lemma square_expansion_with_additive_identity:\n  fixes x y z :: real\n  shows \"(x - y + z)^2 = (x + z)^2 - 2 * (x + z) * y + y^2\"\nproof -\n  have \"(x - y + z)^2 = (x + z - y)^2\" by sos\n  also have \"... = (x + z)^2 - 2 * (x + z) * y + y^2\" by sos\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_expansion_with_additive_identity:\n  fixes x y z :: real\n  shows \"(x - y + z)^2 = (x + z)^2 - 2 * (x + z) * y + y^2\"\nproof -\n  have \"(x - y + z)^2 = (x + z - y)^2\" by sos\n  also have \"... = (x + z)^2 - 2 * (x + z) * y + y^2\" by sos\n  finally show ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_generalized": {"skill_name": "square_expansion_generalized", "marker": "lemma square_expansion_generalized:\n  fixes a b c :: real\n  shows \"(a - b)^2 + c^2 = a^2 - 2*a*b + b^2 + c^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion_generalized:\n  fixes a b c :: real\n  shows \"(a - b)^2 + c^2 = a^2 - 2*a*b + b^2 + c^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by sos\n  thus ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_cubic_extension": {"skill_name": "square_expansion_with_cubic_extension", "marker": "lemma square_expansion_with_cubic_extension:\n  fixes x y z :: real\n  shows \"(x - y - z)^2 = x^2 - 2 * x * (y + z) + (y + z)^2\"\nproof -\n  have \"(x - y - z)^2 = (x - (y + z))^2\" by sos\n  also have \"... = x^2 - 2 * x * (y + z) + (y + z)^2\" by sos\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_expansion_with_cubic_extension:\n  fixes x y z :: real\n  shows \"(x - y - z)^2 = x^2 - 2 * x * (y + z) + (y + z)^2\"\nproof -\n  have \"(x - y - z)^2 = (x - (y + z))^2\" by sos\n  also have \"... = x^2 - 2 * x * (y + z) + (y + z)^2\" by sos\n  finally show ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_factorization": {"skill_name": "square_expansion_with_factorization", "marker": "lemma square_expansion_with_factorization:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y)^2 = (x - y) * (x - y)\" by sos\n  also have \"... = x * (x - y) - y * (x - y)\" by sos\n  also have \"... = x^2 - y * x - y * x + y^2\" by sos\n  also have \"... = x^2 - 2 * x * y + y^2\" by simp\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma square_expansion_with_factorization:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y)^2 = (x - y) * (x - y)\" by sos\n  also have \"... = x * (x - y) - y * (x - y)\" by sos\n  also have \"... = x^2 - y * x - y * x + y^2\" by sos\n  also have \"... = x^2 - 2 * x * y + y^2\" by simp\n  finally show ?thesis .\nqed", "origin": "square_expansion", "update_count": 0}, "count_terms_in_interval": {"skill_name": "count_terms_in_interval", "marker": "lemma count_terms_in_interval:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a ..< b} = b - a\"\nproof -\n  have \"card {a ..< b} = b - a\" using assms by simp\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma count_terms_in_interval:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a ..< b} = b - a\"\nproof -\n  have \"card {a ..< b} = b - a\" using assms by simp\n  then show ?thesis by auto\nqed", "origin": "sum_terms_count", "update_count": 0}, "mod_arithmeticV2": {"skill_name": "mod_arithmeticV2", "marker": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c < a\"\n  shows \"(b + c) mod a = (b mod a + c mod a) mod a\"\nproof -\n  have \"b mod a = b\" using assms(2) by simp\n  have \"c mod a = c\" using assms(3) by simp\n  then have \"(b mod a + c mod a) = b + c\" using `b mod a = b` `c mod a = c` by simp\n  thus ?thesis \n    using `a > 0` by (simp add: mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c < a\"\n  shows \"(b + c) mod a = (b mod a + c mod a) mod a\"\nproof -\n  have \"b mod a = b\" using assms(2) by simp\n  have \"c mod a = c\" using assms(3) by simp\n  then have \"(b mod a + c mod a) = b + c\" using `b mod a = b` `c mod a = c` by simp\n  thus ?thesis \n    using `a > 0` by (simp add: mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "mod_arithmeticV3": {"skill_name": "mod_arithmeticV3", "marker": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c < a\"\n  shows \"(b + c) mod a = (b mod a + c mod a) mod a\"\nproof -\n  have \"b mod a = b\" and \"c mod a = c\" \n    using assms by auto\n  then have \"(b mod a + c mod a) mod a = (b + c) mod a\"\n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c < a\"\n  shows \"(b + c) mod a = (b mod a + c mod a) mod a\"\nproof -\n  have \"b mod a = b\" and \"c mod a = c\" \n    using assms by auto\n  then have \"(b mod a + c mod a) mod a = (b + c) mod a\"\n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_arithmeticV4": {"skill_name": "mod_arithmeticV4", "marker": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c < a\"\n  shows \"(b + c) mod a = (b mod a + c mod a) mod a\"\nproof -\n  have \"b mod a = b\" using assms(2) by simp\n  have \"c mod a = c\" using assms(3) by simp\n  then have \"b mod a + c mod a = b + c\" using `b mod a = b` by simp\n  then have \"(b + c) mod a = (b + c) mod a\" by simp\n  thus ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c < a\"\n  shows \"(b + c) mod a = (b mod a + c mod a) mod a\"\nproof -\n  have \"b mod a = b\" using assms(2) by simp\n  have \"c mod a = c\" using assms(3) by simp\n  then have \"b mod a + c mod a = b + c\" using `b mod a = b` by simp\n  then have \"(b + c) mod a = (b + c) mod a\" by simp\n  thus ?thesis by presburger\nqed", "origin": "do_request", "update_count": 0}, "mod16_cases": {"skill_name": "mod16_cases", "marker": "lemma mod16_cases:\n  fixes a :: nat\n  shows \"a mod 16 = 0 \\<or> a mod 16 = 1 \\<or> a mod 16 = 2 \\<or> a mod 16 = 3 \\<or> a mod 16 = 4 \\<or> a mod 16 = 5 \\<or> a mod 16 = 6 \\<or> a mod 16 = 7 \\<or> a mod 16 = 8 \\<or> a mod 16 = 9 \\<or> a mod 16 = 10 \\<or> a mod 16 = 11 \\<or> a mod 16 = 12 \\<or> a mod 16 = 13 \\<or> a mod 16 = 14 \\<or> a mod 16 = 15\"\n  by presburger", "description": "-", "full_code": "lemma mod16_cases:\n  fixes a :: nat\n  shows \"a mod 16 = 0 \\<or> a mod 16 = 1 \\<or> a mod 16 = 2 \\<or> a mod 16 = 3 \\<or> a mod 16 = 4 \\<or> a mod 16 = 5 \\<or> a mod 16 = 6 \\<or> a mod 16 = 7 \\<or> a mod 16 = 8 \\<or> a mod 16 = 9 \\<or> a mod 16 = 10 \\<or> a mod 16 = 11 \\<or> a mod 16 = 12 \\<or> a mod 16 = 13 \\<or> a mod 16 = 14 \\<or> a mod 16 = 15\"\n  by presburger", "origin": "mod4_cases", "update_count": 0}, "square_and_negation": {"skill_name": "square_and_negation", "marker": "lemma square_and_negation:\n  fixes a b :: real\n  assumes \"a = b\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\n  using assms by (simp add: power2_eq_square)", "description": "-", "full_code": "lemma square_and_negation:\n  fixes a b :: real\n  assumes \"a = b\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"a^2 = b^2\"\n  using assms by (simp add: power2_eq_square)", "origin": "square_eq", "update_count": 0}, "square_negation": {"skill_name": "square_negation", "marker": "lemma square_negation:\n  fixes a b :: real\n  shows \"(-a)^2 = a^2\"\n  by (simp add: power2_eq_square)", "description": "-", "full_code": "lemma square_negation:\n  fixes a b :: real\n  shows \"(-a)^2 = a^2\"\n  by (simp add: power2_eq_square)", "origin": "square_eq", "update_count": 0}, "amc12a_2013_p8_3d": {"skill_name": "amc12a_2013_p8_3d", "marker": "theorem amc12a_2013_p8_3d:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\"\n    and h4 : \"y\\<noteq>z\"\n    and h5 : \"x\\<noteq>z\"\n    and h6 : \"x + 2/x = y + 2/y\"\n    and h7 : \"y + 2/y = z + 2/z\"\n  shows \"x * y * z = 2\"\nproof -\n  have eq1: \"x + 2/x = y + 2/y\" using h6 by simp\n  have eq2: \"y + 2/y = z + 2/z\" using h7 by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" \n    using eq1 by (simp add: field_simps)\n  have rearranged2: \"y - z = (2/z - 2/y)\" \n    using eq2 by (simp add: field_simps)\n  have common_den1: \"x - y = (2 * (x - y)) / (x * y)\"\n    using rearranged1 by sos\n  have common_den2: \"y - z = (2 * (y - z)) / (y * z)\"\n    using rearranged2 by sos\n  have factored1: \"x - y = (2 * (x - y)) / (x * y)\"\n    using common_den1 by blast\n  have factored2: \"y - z = (2 * (y - z)) / (y * z)\"\n    using common_den2 by blast\n  have \"1 = 2 / (x * y)\"\n    using h3 factored1 by sos\n  have \"1 = 2 / (y * z)\"\n    using h4 factored2 by sos\n  then have \"x * y * z = 2\"\n    using `1 = 2 / (x * y)` and `1 = 2 / (y * z)` by (metis add_diff_cancel_left' dbl_simps(3) diff_add_cancel divide_eq_eq_1 eq_divide_eq h1 h2 h5 rearranged2)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_3d:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\"\n    and h4 : \"y\\<noteq>z\"\n    and h5 : \"x\\<noteq>z\"\n    and h6 : \"x + 2/x = y + 2/y\"\n    and h7 : \"y + 2/y = z + 2/z\"\n  shows \"x * y * z = 2\"\nproof -\n  have eq1: \"x + 2/x = y + 2/y\" using h6 by simp\n  have eq2: \"y + 2/y = z + 2/z\" using h7 by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" \n    using eq1 by (simp add: field_simps)\n  have rearranged2: \"y - z = (2/z - 2/y)\" \n    using eq2 by (simp add: field_simps)\n  have common_den1: \"x - y = (2 * (x - y)) / (x * y)\"\n    using rearranged1 by sos\n  have common_den2: \"y - z = (2 * (y - z)) / (y * z)\"\n    using rearranged2 by sos\n  have factored1: \"x - y = (2 * (x - y)) / (x * y)\"\n    using common_den1 by blast\n  have factored2: \"y - z = (2 * (y - z)) / (y * z)\"\n    using common_den2 by blast\n  have \"1 = 2 / (x * y)\"\n    using h3 factored1 by sos\n  have \"1 = 2 / (y * z)\"\n    using h4 factored2 by sos\n  then have \"x * y * z = 2\"\n    using `1 = 2 / (x * y)` and `1 = 2 / (y * z)` by (metis add_diff_cancel_left' dbl_simps(3) diff_add_cancel divide_eq_eq_1 eq_divide_eq h1 h2 h5 rearranged2)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12b_2003_p9_extendedV4": {"skill_name": "amc12b_2003_p9_extendedV4", "marker": "theorem amc12b_2003_p9_extended:\n  fixes a b c :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f c - f 2 = 12\"\n  shows \"f (c + 6) - f 2 = 12 + 6 * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f c - f 2 = (a * c + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f c - f 2 = a * c - a * 2\" by (metis add_diff_cancel_right assms(1) uminus_add_conv_diff)\n  hence \"a * (c - 2) = 12\" using `f c - f 2 = 12` by (auto simp: field_simps)\n  have \"f (c + 6) - f 2 = (a * (c + 6) + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f (c + 6) - f 2 = a * (c + 6) - a * 2\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left diff_diff_eq2 diff_minus_eq_add one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib right_diff_distrib' semiring_norm(2))\n  have \"f (c + 6) - f 2 = a * (c - 2 + 6)\" by (smt (verit) \\<open>a * (c - 2) = 12\\<close> \\<open>f (c + 6) - f 2 = a * (c + 6) - a * 2\\<close> \\<open>f c - f 2 = a * c - a * 2\\<close> add_diff_add add_implies_diff assms(2) right_diff_distrib')\n  thus \"f (c + 6) - f 2 = 12 + 6 * a\" by (metis \\<open>a * (c - 2) = 12\\<close> algebra_simps)\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9_extended:\n  fixes a b c :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f c - f 2 = 12\"\n  shows \"f (c + 6) - f 2 = 12 + 6 * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f c - f 2 = (a * c + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f c - f 2 = a * c - a * 2\" by (metis add_diff_cancel_right assms(1) uminus_add_conv_diff)\n  hence \"a * (c - 2) = 12\" using `f c - f 2 = 12` by (auto simp: field_simps)\n  have \"f (c + 6) - f 2 = (a * (c + 6) + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f (c + 6) - f 2 = a * (c + 6) - a * 2\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left diff_diff_eq2 diff_minus_eq_add one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib right_diff_distrib' semiring_norm(2))\n  have \"f (c + 6) - f 2 = a * (c - 2 + 6)\" by (smt (verit) \\<open>a * (c - 2) = 12\\<close> \\<open>f (c + 6) - f 2 = a * (c + 6) - a * 2\\<close> \\<open>f c - f 2 = a * c - a * 2\\<close> add_diff_add add_implies_diff assms(2) right_diff_distrib')\n  thus \"f (c + 6) - f 2 = 12 + 6 * a\" by (metis \\<open>a * (c - 2) = 12\\<close> algebra_simps)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "mathd_algebra_109_evolvedV4": {"skill_name": "mathd_algebra_109_evolvedV4", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = (c - 3 * a) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  hence \"12 + 2*b = c\" by simp\n  then have \"2*b = c - 12\" by (simp add: algebra_simps)\n  hence \"b = (c - 12) / 2\" by (simp add: field_simps)\n  thus ?thesis using h2 by (metis \\<open>2 * b = c - 12\\<close> add_diff_cancel_left' dbl_def dbl_inc_simps(3) dbl_simps(3) h0 mult.commute mult_2)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 12\"\n  shows \"b = (c - 3 * a) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  hence \"12 + 2*b = c\" by simp\n  then have \"2*b = c - 12\" by (simp add: algebra_simps)\n  hence \"b = (c - 12) / 2\" by (simp add: field_simps)\n  thus ?thesis using h2 by (metis \\<open>2 * b = c - 12\\<close> add_diff_cancel_left' dbl_def dbl_inc_simps(3) dbl_simps(3) h0 mult.commute mult_2)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "square_expansionV8": {"skill_name": "square_expansionV8", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + (-y))^2\" by (simp)\n  then show ?thesis by (simp add: power2_eq_square algebra_simps)\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + (-y))^2\" by (simp)\n  then show ?thesis by (simp add: power2_eq_square algebra_simps)\nqed", "origin": "square_expansion", "update_count": 0}, "mod_add": {"skill_name": "mod_add", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = (a mod m) + (a div m) * m\" by auto\n  have \"b = (b mod m) + (b div m) * m\" by auto\n  then have \"a + b = (a mod m + b mod m) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = (a mod m) + (a div m) * m\" by auto\n  have \"b = (b mod m) + (b div m) * m\" by auto\n  then have \"a + b = (a mod m + b mod m) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then show ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_addV2": {"skill_name": "mod_addV2", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by simp\nnext\n  case False\n  then have \"m > 0\" by simp\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = ?x + (a div m) * m\" and \"b = ?y + (b div m) * m\" \n    by auto\n  then have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((?x + ?y) + ((a div m) + (b div m)) * m) mod m\" \n    by simp\n  also have \"... = (?x + ?y) mod m\" \n    by (simp add: mod_add_eq)\n  finally show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by simp\nnext\n  case False\n  then have \"m > 0\" by simp\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = ?x + (a div m) * m\" and \"b = ?y + (b div m) * m\" \n    by auto\n  then have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((?x + ?y) + ((a div m) + (b div m)) * m) mod m\" \n    by simp\n  also have \"... = (?x + ?y) mod m\" \n    by (simp add: mod_add_eq)\n  finally show ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_addV3": {"skill_name": "mod_addV3", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  let ?a' = \"a mod m\"\n  let ?b' = \"b mod m\"\n  have \"a = ?a' + (a div m) * m\" by auto\n  have \"b = ?b' + (b div m) * m\" by auto\n  then have \"a + b = (?a' + (a div m) * m) + (?b' + (b div m) * m)\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (?a' + ?b') + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  let ?a' = \"a mod m\"\n  let ?b' = \"b mod m\"\n  have \"a = ?a' + (a div m) * m\" by auto\n  have \"b = ?b' + (b div m) * m\" by auto\n  then have \"a + b = (?a' + (a div m) * m) + (?b' + (b div m) * m)\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (?a' + ?b') + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_square": {"skill_name": "mod_square", "marker": "lemma mod_square:\n  fixes a m :: nat\n  shows \"(a mod m)^2 mod m = (a^2) mod m\"\nproof -\n  let ?x = \"a mod m\"\n  have \"a = m * (a div m) + ?x\" by auto\n  then show \"(?x)^2 mod m = (a^2) mod m\"\n  proof -\n    have \"a^2 = (m * (a div m) + ?x)^2\"\n      by (simp add: algebra_simps)\n    also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * ?x + ?x^2\"\n      by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n    also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * ?x + ?x^2\" by (simp add: algebra_simps)\n    finally have \"a^2 = m^2 * (a div m)^2 + 2 * m * (a div m) * ?x + ?x^2\" .\n    hence \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * ?x + ?x^2) mod m\" by simp\n    then have \"a^2 mod m = (?x^2 mod m)\" by (metis minus_div_mult_eq_mod power_mod)\n    moreover have \"?x^2 mod m = (?x)^2 mod m\" by simp\n    ultimately show \"(a mod m)^2 mod m = (a^2) mod m\" by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a m :: nat\n  shows \"(a mod m)^2 mod m = (a^2) mod m\"\nproof -\n  let ?x = \"a mod m\"\n  have \"a = m * (a div m) + ?x\" by auto\n  then show \"(?x)^2 mod m = (a^2) mod m\"\n  proof -\n    have \"a^2 = (m * (a div m) + ?x)^2\"\n      by (simp add: algebra_simps)\n    also have \"... = (m * (a div m))^2 + 2 * (m * (a div m)) * ?x + ?x^2\"\n      by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n    also have \"... = m^2 * (a div m)^2 + 2 * m * (a div m) * ?x + ?x^2\" by (simp add: algebra_simps)\n    finally have \"a^2 = m^2 * (a div m)^2 + 2 * m * (a div m) * ?x + ?x^2\" .\n    hence \"a^2 mod m = (m^2 * (a div m)^2 + 2 * m * (a div m) * ?x + ?x^2) mod m\" by simp\n    then have \"a^2 mod m = (?x^2 mod m)\" by (metis minus_div_mult_eq_mod power_mod)\n    moreover have \"?x^2 mod m = (?x)^2 mod m\" by simp\n    ultimately show \"(a mod m)^2 mod m = (a^2) mod m\" by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mod_addV4": {"skill_name": "mod_addV4", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = m * (a div m) + ?x\" by auto\n  have \"b = m * (b div m) + ?y\" by auto\n  then show ?thesis\n  proof -\n    have \"a + b = m * (a div m) + ?x + m * (b div m) + ?y\" by (simp add: algebra_simps)\n    also have \"... = m * ((a div m) + (b div m)) + (?x + ?y)\" by (simp add: algebra_simps)\n    finally have \"a + b = m * ((a div m) + (b div m)) + (?x + ?y)\" .\n    hence \"(a + b) mod m = (?x + ?y) mod m\" by (metis mod_add_eq)\n    thus ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = m * (a div m) + ?x\" by auto\n  have \"b = m * (b div m) + ?y\" by auto\n  then show ?thesis\n  proof -\n    have \"a + b = m * (a div m) + ?x + m * (b div m) + ?y\" by (simp add: algebra_simps)\n    also have \"... = m * ((a div m) + (b div m)) + (?x + ?y)\" by (simp add: algebra_simps)\n    finally have \"a + b = m * ((a div m) + (b div m)) + (?x + ?y)\" .\n    hence \"(a + b) mod m = (?x + ?y) mod m\" by (metis mod_add_eq)\n    thus ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mod_addV5": {"skill_name": "mod_addV5", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = (a div m) * m + ?x\" by simp\n  have \"b = (b div m) * m + ?y\" by simp\n  then have \"a + b = ((a div m) + (b div m)) * m + (?x + ?y)\" \n    by (simp add: algebra_simps)\n  hence \"(a + b) mod m = (?x + ?y) mod m\" \n    by (metis mod_add_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = (a div m) * m + ?x\" by simp\n  have \"b = (b div m) * m + ?y\" by simp\n  then have \"a + b = ((a div m) + (b div m)) * m + (?x + ?y)\" \n    by (simp add: algebra_simps)\n  hence \"(a + b) mod m = (?x + ?y) mod m\" \n    by (metis mod_add_eq)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_addV6": {"skill_name": "mod_addV6", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = (a div m) * m + (a mod m)\" by auto\n  have \"b = (b div m) * m + (b mod m)\" by auto\n  then have \"a + b = (a div m) * m + (b div m) * m + (a mod m) + (b mod m)\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((a div m + b div m) * m + (a mod m + b mod m)) mod m\"\n    by (simp add: algebra_simps)\n  also have \"... = (a mod m + b mod m) mod m\"\n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  have \"a = (a div m) * m + (a mod m)\" by auto\n  have \"b = (b div m) * m + (b mod m)\" by auto\n  then have \"a + b = (a div m) * m + (b div m) * m + (a mod m) + (b mod m)\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((a div m + b div m) * m + (a mod m + b mod m)) mod m\"\n    by (simp add: algebra_simps)\n  also have \"... = (a mod m + b mod m) mod m\"\n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_addV7": {"skill_name": "mod_addV7", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  let ?am = \"a mod m\" and ?bm = \"b mod m\"\n  have \"a = ?am + (a div m) * m\" by auto\n  have \"b = ?bm + (b div m) * m\" by auto\n  then have \"a + b = (?am + (a div m) * m) + (?bm + (b div m) * m)\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (?am + ?bm) + ((a div m) + (b div m)) * m\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = (?am + ?bm) mod m\"\n    by auto\n  then show ?thesis by (simp add: mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  let ?am = \"a mod m\" and ?bm = \"b mod m\"\n  have \"a = ?am + (a div m) * m\" by auto\n  have \"b = ?bm + (b div m) * m\" by auto\n  then have \"a + b = (?am + (a div m) * m) + (?bm + (b div m) * m)\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (?am + ?bm) + ((a div m) + (b div m)) * m\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = (?am + ?bm) mod m\"\n    by auto\n  then show ?thesis by (simp add: mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "mod_addV8": {"skill_name": "mod_addV8", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  hence \"a mod m < m\" and \"b mod m < m\" by auto\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = ?x + (a div m) * m\" and \"b = ?y + (b div m) * m\"\n    by auto\n  have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((?x + ?y) + ((a div m) + (b div m)) * m) mod m\"\n    by simp\n  also have \"... = (?x + ?y) mod m\"\n    by auto\n  finally show ?thesis\n    by auto\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  hence \"a mod m < m\" and \"b mod m < m\" by auto\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = ?x + (a div m) * m\" and \"b = ?y + (b div m) * m\"\n    by auto\n  have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((?x + ?y) + ((a div m) + (b div m)) * m) mod m\"\n    by simp\n  also have \"... = (?x + ?y) mod m\"\n    by auto\n  finally show ?thesis\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_integer": {"skill_name": "floor_sum_integer", "marker": "lemma floor_sum_integer:\n  fixes r :: real and n :: nat\n  assumes \"n \\<in> {19::nat..<92}\"\n  shows \"floor (r + n / 100) \\<in> {floor r, floor r + 1}\"\nproof -\n  let ?m = \"floor r\"\n  have \"r + n / 100 \\<ge> ?m\" \n  proof -\n    have \"n / 100 < 1\" \n      using assms by (auto simp: lessThan_iff)\n    thus \"r + n / 100 \\<ge> ?m\" \n      using `n \\<in> {19::nat..<92}` by arith\n  qed\n  moreover have \"r + n / 100 < ?m + 1 + 1\" \n  proof -\n    have \"n / 100 < 1\" \n      using assms by (auto simp: lessThan_iff)\n    thus \"r + n / 100 < ?m + 1 + 1\" \n      using `n \\<in> {19::nat..<92}` by arith\n  qed\n  ultimately show ?thesis \n  proof (cases \"r + n / 100 < ?m + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) \\<open>real_of_int \\<lfloor>r\\<rfloor> \\<le> r + real n / 100\\<close> floor_eq_iff insertCI of_int_1 of_int_add)\n  next\n    case False\n    then show ?thesis \n      by (smt (verit) \\<open>r + real n / 100 < real_of_int (\\<lfloor>r\\<rfloor> + 1 + 1)\\<close> floor_eq_iff insertI1 insertI2 of_int_1 of_int_add verit_comp_simplify1(3))\n  qed\nqed", "description": "-", "full_code": "lemma floor_sum_integer:\n  fixes r :: real and n :: nat\n  assumes \"n \\<in> {19::nat..<92}\"\n  shows \"floor (r + n / 100) \\<in> {floor r, floor r + 1}\"\nproof -\n  let ?m = \"floor r\"\n  have \"r + n / 100 \\<ge> ?m\" \n  proof -\n    have \"n / 100 < 1\" \n      using assms by (auto simp: lessThan_iff)\n    thus \"r + n / 100 \\<ge> ?m\" \n      using `n \\<in> {19::nat..<92}` by arith\n  qed\n  moreover have \"r + n / 100 < ?m + 1 + 1\" \n  proof -\n    have \"n / 100 < 1\" \n      using assms by (auto simp: lessThan_iff)\n    thus \"r + n / 100 < ?m + 1 + 1\" \n      using `n \\<in> {19::nat..<92}` by arith\n  qed\n  ultimately show ?thesis \n  proof (cases \"r + n / 100 < ?m + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) \\<open>real_of_int \\<lfloor>r\\<rfloor> \\<le> r + real n / 100\\<close> floor_eq_iff insertCI of_int_1 of_int_add)\n  next\n    case False\n    then show ?thesis \n      by (smt (verit) \\<open>r + real n / 100 < real_of_int (\\<lfloor>r\\<rfloor> + 1 + 1)\\<close> floor_eq_iff insertI1 insertI2 of_int_1 of_int_add verit_comp_simplify1(3))\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_eq_for_c": {"skill_name": "square_eq_for_c", "marker": "lemma square_eq_for_c:\n  fixes a b c :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using square_eq_generalized[of a b] assms by simp", "description": "-", "full_code": "lemma square_eq_generalized:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_eq_for_c:\n  fixes a b c :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using square_eq_generalized[of a b] assms by simp", "origin": "square_eq", "update_count": 0}, "square_eq_variable": {"skill_name": "square_eq_variable", "marker": "lemma square_eq_variable:\n  fixes x y :: real\n  assumes \"x = y\"\n  shows \"x^2 = y^2\"\n  using assms square_eq_generalized by simp", "description": "-", "full_code": "lemma square_eq_generalized:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_eq_variable:\n  fixes x y :: real\n  assumes \"x = y\"\n  shows \"x^2 = y^2\"\n  using assms square_eq_generalized by simp", "origin": "square_eq", "update_count": 0}, "combine_like_terms": {"skill_name": "combine_like_terms", "marker": "lemma combine_like_terms:\n  fixes a b c d :: real\n  shows \"(a + b) + (c + d) = (a + c) + (b + d)\"\nproof -\n  have \"(a + b) + (c + d) = a + (b + (c + d))\" by auto\n  also have \"... = a + ((b + c) + d)\" by auto\n  also have \"... = (a + (b + c)) + d\" by auto\n  also have \"... = (a + c) + (b + d)\" by auto\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma combine_like_terms:\n  fixes a b c d :: real\n  shows \"(a + b) + (c + d) = (a + c) + (b + d)\"\nproof -\n  have \"(a + b) + (c + d) = a + (b + (c + d))\" by auto\n  also have \"... = a + ((b + c) + d)\" by auto\n  also have \"... = (a + (b + c)) + d\" by auto\n  also have \"... = (a + c) + (b + d)\" by auto\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "combine_like_termsV2": {"skill_name": "combine_like_termsV2", "marker": "lemma combine_like_terms:\n  fixes a b c d :: real\n  shows \"(a + b) + (c + d) = (a + c) + (b + d)\"\nproof -\n  have \"(a + b) + (c + d) = a + (b + (c + d))\" \n    by (metis add.assoc)\n  also have \"... = a + ((b + c) + d)\" \n    by (metis add.assoc)\n  also have \"... = (a + (b + c)) + d\" \n    by (metis add.assoc)\n  also have \"... = ((a + b) + c) + d\" \n    by (metis add.assoc)\n  finally have \"((a + b) + c) + d = (a + c) + (b + d)\" \n    by auto\n  thus ?thesis \n    by (simp add: add.assoc)\nqed", "description": "-", "full_code": "lemma combine_like_terms:\n  fixes a b c d :: real\n  shows \"(a + b) + (c + d) = (a + c) + (b + d)\"\nproof -\n  have \"(a + b) + (c + d) = a + (b + (c + d))\" \n    by (metis add.assoc)\n  also have \"... = a + ((b + c) + d)\" \n    by (metis add.assoc)\n  also have \"... = (a + (b + c)) + d\" \n    by (metis add.assoc)\n  also have \"... = ((a + b) + c) + d\" \n    by (metis add.assoc)\n  finally have \"((a + b) + c) + d = (a + c) + (b + d)\" \n    by auto\n  thus ?thesis \n    by (simp add: add.assoc)\nqed", "origin": "do_request", "update_count": 0}, "combine_like_termsV3": {"skill_name": "combine_like_termsV3", "marker": "lemma combine_like_terms:\n  fixes a b c d :: real\n  shows \"(a + b) + (c + d) = (a + c) + (b + d)\"\nproof -\n  have \"(a + b) + (c + d) = a + (b + (c + d))\" \n    by (simp add: ac_simps)\n  also have \"... = a + ((b + c) + d)\" \n    by (simp add: ac_simps)\n  also have \"... = (a + (b + c)) + d\" \n    by (simp add: ac_simps)\n  also have \"... = ((a + b) + c) + d\" \n    by (simp add: ac_simps)\n  finally show ?thesis \n    by (simp add: ac_simps)\nqed", "description": "-", "full_code": "lemma combine_like_terms:\n  fixes a b c d :: real\n  shows \"(a + b) + (c + d) = (a + c) + (b + d)\"\nproof -\n  have \"(a + b) + (c + d) = a + (b + (c + d))\" \n    by (simp add: ac_simps)\n  also have \"... = a + ((b + c) + d)\" \n    by (simp add: ac_simps)\n  also have \"... = (a + (b + c)) + d\" \n    by (simp add: ac_simps)\n  also have \"... = ((a + b) + c) + d\" \n    by (simp add: ac_simps)\n  finally show ?thesis \n    by (simp add: ac_simps)\nqed", "origin": "do_request", "update_count": 0}, "combine_like_termsV4": {"skill_name": "combine_like_termsV4", "marker": "lemma combine_like_terms:\n  fixes a b c d :: real\n  shows \"(a + b) + (c + d) = (a + c) + (b + d)\"\nproof -\n  have \"(a + b) + (c + d) = a + b + c + d\" by (simp add: algebra_simps)\n  also have \"... = (a + c) + (b + d)\" by (simp add: algebra_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma combine_like_terms:\n  fixes a b c d :: real\n  shows \"(a + b) + (c + d) = (a + c) + (b + d)\"\nproof -\n  have \"(a + b) + (c + d) = a + b + c + d\" by (simp add: algebra_simps)\n  also have \"... = (a + c) + (b + d)\" by (simp add: algebra_simps)\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "mod_n_casesV11": {"skill_name": "mod_n_casesV11", "marker": "lemma mod_n_cases:\n  fixes a n :: int\n  assumes \"n > 0\"\n  shows \"\\<exists>r. r < n \\<and> (a mod n = r)\"\nproof -\n  obtain r where \"r = a mod n\" by auto\n  then have \"0 \\<le> r\" using assms by auto\n  moreover have \"r < n\" using assms by (metis Euclidean_Division.pos_mod_bound \\<open>r = a mod n\\<close>)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a n :: int\n  assumes \"n > 0\"\n  shows \"\\<exists>r. r < n \\<and> (a mod n = r)\"\nproof -\n  obtain r where \"r = a mod n\" by auto\n  then have \"0 \\<le> r\" using assms by auto\n  moreover have \"r < n\" using assms by (metis Euclidean_Division.pos_mod_bound \\<open>r = a mod n\\<close>)\n  ultimately show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "solve_linear_systemV2": {"skill_name": "solve_linear_systemV2", "marker": "lemma solve_linear_system:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"(1 * x) + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a) / 1\" using simplified_eq by auto\n  have e_value: \"e = a - ((b - a) / 1)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "lemma solve_linear_system:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"(1 * x) + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a) / 1\" using simplified_eq by auto\n  have e_value: \"e = a - ((b - a) / 1)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "linear_equation_system_solution": {"skill_name": "linear_equation_system_solution", "marker": "lemma linear_equation_system_solution:\n  fixes x e :: complex\n  assumes \"x + e = a\" \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / (2 - 1)\"\nproof -\n  have e_eq: \"e = a - x\" using assms(1) by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using assms(2) e_eq by simp\n  then have simplified_eq: \"x + a = b\" by simp\n  have x_value: \"x = b - a\" using simplified_eq by (metis add.commute add_diff_cancel_right' algebra_simps)\n  show ?thesis using x_value e_eq by simp\nqed", "description": "-", "full_code": "lemma linear_equation_system_solution:\n  fixes x e :: complex\n  assumes \"x + e = a\" \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / (2 - 1)\"\nproof -\n  have e_eq: \"e = a - x\" using assms(1) by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using assms(2) e_eq by simp\n  then have simplified_eq: \"x + a = b\" by simp\n  have x_value: \"x = b - a\" using simplified_eq by (metis add.commute add_diff_cancel_right' algebra_simps)\n  show ?thesis using x_value e_eq by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "sum_terms_countV7": {"skill_name": "sum_terms_countV7", "marker": "lemma sum_terms_count:\n  fixes d :: nat\n  shows \"card {19::nat..<19 + d} = d\" \nproof -\n  have \"19 + d - 19 = d\" by simp\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_terms_count:\n  fixes d :: nat\n  shows \"card {19::nat..<19 + d} = d\" \nproof -\n  have \"19 + d - 19 = d\" by simp\n  then show ?thesis by auto\nqed", "origin": "sum_terms_count", "update_count": 0}, "linear_combination_solve_for_b_generalized": {"skill_name": "linear_combination_solve_for_b_generalized", "marker": "theorem linear_combination_solve_for_b_generalized:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = k\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*k)/n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"b = (p - m*k)/n\" using h1 by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by (metis h2 mult.commute nonzero_mult_div_cancel_right)\nqed", "description": "-", "full_code": "theorem linear_combination_solve_for_b_generalized:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = k\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*k)/n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"b = (p - m*k)/n\" using h1 by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by (metis h2 mult.commute nonzero_mult_div_cancel_right)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mod4_cases_extendedV3": {"skill_name": "mod4_cases_extendedV3", "marker": "lemma mod4_cases_extended:\n  fixes a :: int\n  assumes \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n  shows \"a mod 4 < 4\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" using assms by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_cases_extended:\n  fixes a :: int\n  assumes \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n  shows \"a mod 4 < 4\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" using assms by simp\n  thus ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "mod4_and_negatives": {"skill_name": "mod4_and_negatives", "marker": "lemma mod4_and_negatives:\n  fixes a :: int\n  assumes \"a < 0\"\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 = (a + 4 * (if a mod 4 < 0 then 1 else 0)) mod 4\" \n    by auto\n  then show ?thesis \n    using mod4_properties by auto\nqed", "description": "-", "full_code": "lemma mod4_properties:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\n  by auto\n\nlemma mod4_and_negatives:\n  fixes a :: int\n  assumes \"a < 0\"\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"a mod 4 = (a + 4 * (if a mod 4 < 0 then 1 else 0)) mod 4\" \n    by auto\n  then show ?thesis \n    using mod4_properties by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "square_differenceV4": {"skill_name": "square_differenceV4", "marker": "lemma square_difference:\n  fixes a b :: real\n  shows \"(a - b) * (a + b) = a^2 - b^2\"\nproof -\n  have \"(a - b) * (a + b) = a^2 + a * b - b * a - b^2\"\n    by sos\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_difference:\n  fixes a b :: real\n  shows \"(a - b) * (a + b) = a^2 - b^2\"\nproof -\n  have \"(a - b) * (a + b) = a^2 + a * b - b * a - b^2\"\n    by sos\n  then show ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "mod_sumV5": {"skill_name": "mod_sumV5", "marker": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" using assms(1) by simp\n  hence \"x mod m + y mod m = x + (y mod m)\" using assms(2) by simp\n  hence \"x mod m + y mod m = x + y\" using assms(2) by simp\n  then have \"(x + y) mod m = (x + y) mod m\" by simp\n  moreover have \"(x mod m + y mod m) mod m = (x + y) mod m\" using `x mod m + y mod m = x + y` by simp\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" using assms(1) by simp\n  hence \"x mod m + y mod m = x + (y mod m)\" using assms(2) by simp\n  hence \"x mod m + y mod m = x + y\" using assms(2) by simp\n  then have \"(x + y) mod m = (x + y) mod m\" by simp\n  moreover have \"(x mod m + y mod m) mod m = (x + y) mod m\" using `x mod m + y mod m = x + y` by simp\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "linear_equation_solutionV8": {"skill_name": "linear_equation_solutionV8", "marker": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = x\"  \n  shows \"b = (c - 3*x) / 2\"  \nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * x + 2 * b = c\" using h1 eq by simp\n  have isolate: \"2*b = c - 3*x\" using sub by simp\n  have solution: \"b = (c - 3*x) / 2\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = x\"  \n  shows \"b = (c - 3*x) / 2\"  \nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * x + 2 * b = c\" using h1 eq by simp\n  have isolate: \"2*b = c - 3*x\" using sub by simp\n  have solution: \"b = (c - 3*x) / 2\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mod_sumV6": {"skill_name": "mod_sumV6", "marker": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" and \"y mod m = y\"\n    using assms by simp_all\n  then have \"x mod m + y mod m = x + y\" \n    by (simp add: algebra_simps)\n  then have \"(x + y) mod m = (x + y) mod m\" \n    by simp\n  thus ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" and \"y mod m = y\"\n    using assms by simp_all\n  then have \"x mod m + y mod m = x + y\" \n    by (simp add: algebra_simps)\n  then have \"(x + y) mod m = (x + y) mod m\" \n    by simp\n  thus ?thesis by presburger\nqed", "origin": "do_request", "update_count": 0}, "mod_sumV7": {"skill_name": "mod_sumV7", "marker": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" and \"y mod m = y\" \n    using assms by auto\n  then have \"x mod m + y mod m = x + y\"\n    by simp\n  thus ?thesis \n    using assms by auto\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" and \"y mod m = y\" \n    using assms by auto\n  then have \"x mod m + y mod m = x + y\"\n    by simp\n  thus ?thesis \n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_sumV8": {"skill_name": "mod_sumV8", "marker": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" using assms(1) by simp\n  have \"y mod m = y\" using assms(2) by simp\n  then have \"x + y = (x mod m) + (y mod m)\" by (metis \\<open>x mod m = x\\<close>)\n  hence \"(x + y) mod m = (x mod m + y mod m) mod m\" \n    using mod_add_eq by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" using assms(1) by simp\n  have \"y mod m = y\" using assms(2) by simp\n  then have \"x + y = (x mod m) + (y mod m)\" by (metis \\<open>x mod m = x\\<close>)\n  hence \"(x + y) mod m = (x mod m + y mod m) mod m\" \n    using mod_add_eq by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_sumV9": {"skill_name": "mod_sumV9", "marker": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" using assms(1) by simp\n  hence \"x + y = (x mod m) + y\" by (simp add: algebra_simps)\n  have \"y mod m = y\" using assms(2) by simp\n  hence \"x + y = (x mod m) + (y mod m)\" by (metis \\<open>x + y = x mod m + y\\<close>)\n  then have \"(x + y) mod m = ((x mod m) + (y mod m)) mod m\" \n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" using assms(1) by simp\n  hence \"x + y = (x mod m) + y\" by (simp add: algebra_simps)\n  have \"y mod m = y\" using assms(2) by simp\n  hence \"x + y = (x mod m) + (y mod m)\" by (metis \\<open>x + y = x mod m + y\\<close>)\n  then have \"(x + y) mod m = ((x mod m) + (y mod m)) mod m\" \n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_sumV10": {"skill_name": "mod_sumV10", "marker": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" using assms(1) by simp\n  have \"y mod m = y\" using assms(2) by simp\n  then have \"x mod m + y mod m = x + y\" \n    by (metis \\<open>x mod m = x\\<close>)\n  moreover have \"(x + y) mod m = (x mod m + y mod m) mod m\" \n    using `x mod m = x` `y mod m = y` by (simp add: mod_add_eq)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" using assms(1) by simp\n  have \"y mod m = y\" using assms(2) by simp\n  then have \"x mod m + y mod m = x + y\" \n    by (metis \\<open>x mod m = x\\<close>)\n  moreover have \"(x + y) mod m = (x mod m + y mod m) mod m\" \n    using `x mod m = x` `y mod m = y` by (simp add: mod_add_eq)\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_sumV11": {"skill_name": "mod_sumV11", "marker": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" using assms(1) by simp\n  have \"y mod m = y\" using assms(2) by simp\n  hence \"x mod m + y mod m = x + y\" by (metis \\<open>x mod m = x\\<close>)\n  then have \"(x mod m + y mod m) mod m = (x + y) mod m\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y m :: nat\n  assumes \"x < m\" \"y < m\"\n  shows \"(x + y) mod m = (x mod m + y mod m) mod m\"\nproof -\n  have \"x mod m = x\" using assms(1) by simp\n  have \"y mod m = y\" using assms(2) by simp\n  hence \"x mod m + y mod m = x + y\" by (metis \\<open>x mod m = x\\<close>)\n  then have \"(x mod m + y mod m) mod m = (x + y) mod m\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "linear_equation_solver": {"skill_name": "linear_equation_solver", "marker": "lemma linear_equation_solver:\n  fixes a b c :: real\n  assumes h0: \"3*a + 2*b = c\"\n    and h1: \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  then have \"12 + 2*b = c\" by simp\n  then have \"2*b = c - 12\" by simp\n  then show ?thesis by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma linear_equation_solver:\n  fixes a b c :: real\n  assumes h0: \"3*a + 2*b = c\"\n    and h1: \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  then have \"12 + 2*b = c\" by simp\n  then have \"2*b = c - 12\" by simp\n  then show ?thesis by (simp add: divide_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "linear_equation_single_solution": {"skill_name": "linear_equation_single_solution", "marker": "theorem linear_equation_single_solution:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2 * b = 12\" by (smt (verit) sub)\n  have isolate: \"2 * b = 12 - 12\" using simplified by simp\n  have solution: \"b = (12 - 3 * a) / 2\" using h1 by (smt (verit) add_right_imp_eq divide_eq_0_iff eq_iff_diff_eq_0 h0 isolate simplified)\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem linear_equation_single_solution:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = (12 - 3 * a) / 2\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2 * b = 12\" by (smt (verit) sub)\n  have isolate: \"2 * b = 12 - 12\" using simplified by simp\n  have solution: \"b = (12 - 3 * a) / 2\" using h1 by (smt (verit) add_right_imp_eq divide_eq_0_iff eq_iff_diff_eq_0 h0 isolate simplified)\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "units_digit_squareV8": {"skill_name": "units_digit_squareV8", "marker": "lemma units_digit_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  let ?d = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?d\" by auto\n  then show \"(n^2) mod 10 = (?d)^2 mod 10\"\n  proof -\n    have \"n^2 = (10 * (n div 10) + ?d)^2\" by (simp add: algebra_simps)\n    also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?d + ?d^2\" \n      by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n    also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" \n      by (simp add: power2_eq_square)\n    finally have \"n^2 = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" .\n    then show \"n^2 mod 10 = (?d^2) mod 10\" \n      by (metis power_mod)\n  qed\nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  let ?d = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?d\" by auto\n  then show \"(n^2) mod 10 = (?d)^2 mod 10\"\n  proof -\n    have \"n^2 = (10 * (n div 10) + ?d)^2\" by (simp add: algebra_simps)\n    also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?d + ?d^2\" \n      by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n    also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" \n      by (simp add: power2_eq_square)\n    finally have \"n^2 = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" .\n    then show \"n^2 mod 10 = (?d^2) mod 10\" \n      by (metis power_mod)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_mod_n": {"skill_name": "square_mod_n", "marker": "lemma square_mod_n:\n  fixes a n :: int\n  shows \"(a^2) mod n = ((a mod n)^2) mod n\"\nproof -\n  have \"a mod n = a - (n * (a div n))\" by (auto simp: field_simps)\n  then show ?thesis\n  proof (cases \"n = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a^2 = (n * (a div n) + (a mod n))^2\"\n      by auto\n    then have \"(a^2) mod n = ((n * (a div n) + (a mod n))^2) mod n\"\n      by auto\n    also have \"... = ((a mod n)^2) mod n\"\n      by (metis calculation minus_div_mult_eq_mod power_mod)\n    finally show ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma square_mod_n:\n  fixes a n :: int\n  shows \"(a^2) mod n = ((a mod n)^2) mod n\"\nproof -\n  have \"a mod n = a - (n * (a div n))\" by (auto simp: field_simps)\n  then show ?thesis\n  proof (cases \"n = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a^2 = (n * (a div n) + (a mod n))^2\"\n      by auto\n    then have \"(a^2) mod n = ((n * (a div n) + (a mod n))^2) mod n\"\n      by auto\n    also have \"... = ((a mod n)^2) mod n\"\n      by (metis calculation minus_div_mult_eq_mod power_mod)\n    finally show ?thesis by simp\n  qed\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "units_digit_squareV9": {"skill_name": "units_digit_squareV9", "marker": "lemma units_digit_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  let ?d = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?d\" by auto\n  then have \"n^2 = (10 * (n div 10) + ?d)^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?d + ?d^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" by (simp add: power2_eq_square)\n  finally have \"n^2 = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" .\n  then have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2) mod 10\" by simp\n  then have \"n^2 mod 10 = (?d^2 mod 10)\" by (metis power_mod)\n  moreover have \"?d^2 mod 10 = (?d)^2 mod 10\" by simp\n  ultimately show \"(n^2) mod 10 = (n mod 10)^2 mod 10\" by simp\nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  let ?d = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?d\" by auto\n  then have \"n^2 = (10 * (n div 10) + ?d)^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?d + ?d^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" by (simp add: power2_eq_square)\n  finally have \"n^2 = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" .\n  then have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2) mod 10\" by simp\n  then have \"n^2 mod 10 = (?d^2 mod 10)\" by (metis power_mod)\n  moreover have \"?d^2 mod 10 = (?d)^2 mod 10\" by simp\n  ultimately show \"(n^2) mod 10 = (n mod 10)^2 mod 10\" by simp\nqed", "origin": "do_request", "update_count": 0}, "units_digit_squareV10": {"skill_name": "units_digit_squareV10", "marker": "lemma units_digit_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  let ?d = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?d\" by auto\n  then have \"n^2 = (10 * (n div 10) + ?d)^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?d + ?d^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" by (simp add: power2_eq_square)\n  finally have \"n^2 = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" .\n  then have \"n^2 mod 10 = (?d^2 mod 10)\" by (metis power_mod)\n  moreover have \"?d^2 mod 10 = (?d)^2 mod 10\" by simp\n  ultimately show \"(n^2) mod 10 = (n mod 10)^2 mod 10\" by simp\nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes n :: nat\n  shows \"(n^2) mod 10 = (n mod 10)^2 mod 10\"\nproof -\n  let ?d = \"n mod 10\"\n  have \"n = 10 * (n div 10) + ?d\" by auto\n  then have \"n^2 = (10 * (n div 10) + ?d)^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?d + ?d^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" by (simp add: power2_eq_square)\n  finally have \"n^2 = 100 * (n div 10)^2 + 20 * (n div 10) * ?d + ?d^2\" .\n  then have \"n^2 mod 10 = (?d^2 mod 10)\" by (metis power_mod)\n  moreover have \"?d^2 mod 10 = (?d)^2 mod 10\" by simp\n  ultimately show \"(n^2) mod 10 = (n mod 10)^2 mod 10\" by simp\nqed", "origin": "do_request", "update_count": 0}, "square_expansionV9": {"skill_name": "square_expansionV9", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y)^2 = (x - y) * (x - y)\" by sos\n  also have \"... = x * x - 2 * x * y + y * y\" by (simp add: algebra_simps)\n  finally show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y)^2 = (x - y) * (x - y)\" by sos\n  also have \"... = x * x - 2 * x * y + y * y\" by (simp add: algebra_simps)\n  finally show ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "square_differenceV5": {"skill_name": "square_differenceV5", "marker": "lemma square_difference:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(-y + x)^2 = (-y)^2 + 2 * (-y) * x + x^2\"\n    by (simp add: power2_eq_square algebra_simps)\n  also have \"... = y^2 - 2 * y * x + x^2\"\n    by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_difference:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(-y + x)^2 = (-y)^2 + 2 * (-y) * x + x^2\"\n    by (simp add: power2_eq_square algebra_simps)\n  also have \"... = y^2 - 2 * y * x + x^2\"\n    by (simp add: power2_eq_square algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_of_fraction": {"skill_name": "square_of_fraction", "marker": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" by (simp add: field_simps)\n  also have \"... = a^2 * (1 / b)^2\" by (simp add: power2_eq_square)\n  also have \"... = a^2 / (b^2)\" by (simp add: power2_eq_square)\n  finally show \"(a / b)^2 = a^2 / b^2\" by simp\nqed", "description": "-", "full_code": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" by (simp add: field_simps)\n  also have \"... = a^2 * (1 / b)^2\" by (simp add: power2_eq_square)\n  also have \"... = a^2 / (b^2)\" by (simp add: power2_eq_square)\n  finally show \"(a / b)^2 = a^2 / b^2\" by simp\nqed", "origin": "do_request", "update_count": 0}, "square_of_fractionV2": {"skill_name": "square_of_fractionV2", "marker": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" by (simp add: divide_simps)\n  also have \"... = a^2 * (1 / b)^2\" by (auto simp: field_simps)\n  also have \"... = a^2 / b^2\" by (simp add: power2_eq_square)\n  finally show \"(a / b)^2 = a^2 / b^2\" by simp\nqed", "description": "-", "full_code": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" by (simp add: divide_simps)\n  also have \"... = a^2 * (1 / b)^2\" by (auto simp: field_simps)\n  also have \"... = a^2 / b^2\" by (simp add: power2_eq_square)\n  finally show \"(a / b)^2 = a^2 / b^2\" by simp\nqed", "origin": "do_request", "update_count": 0}, "square_of_fractionV3": {"skill_name": "square_of_fractionV3", "marker": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"((a / b)^2) = (a * a) / (b * b)\" by (simp add: power2_eq_square)\n  also have \"... = a^2 / b^2\" by sos\n  finally show \"(a / b)^2 = a^2 / b^2\" by simp\nqed", "description": "-", "full_code": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"((a / b)^2) = (a * a) / (b * b)\" by (simp add: power2_eq_square)\n  also have \"... = a^2 / b^2\" by sos\n  finally show \"(a / b)^2 = a^2 / b^2\" by simp\nqed", "origin": "do_request", "update_count": 0}, "square_of_fractionV4": {"skill_name": "square_of_fractionV4", "marker": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" \n    by (simp add: field_simps)  \n  also have \"... = a^2 * (1 / b)^2\" \n    by (simp add: power2_eq_square)  \n  also have \"... = a^2 / b^2\" \n    by (simp add: power2_eq_square)  \n  finally show \"(a / b)^2 = a^2 / b^2\" \n    by auto  \nqed", "description": "-", "full_code": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"(a / b)^2 = (a * (1 / b))^2\" \n    by (simp add: field_simps)  \n  also have \"... = a^2 * (1 / b)^2\" \n    by (simp add: power2_eq_square)  \n  also have \"... = a^2 / b^2\" \n    by (simp add: power2_eq_square)  \n  finally show \"(a / b)^2 = a^2 / b^2\" \n    by auto  \nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_generalized": {"skill_name": "mathd_algebra_generalized", "marker": "theorem mathd_algebra_generalized:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a + b = d\"\n  shows \"b = (c - 3*a) / 2\"\nproof -\n  have eq1: \"3*a + 2*b = c\" using h0 by simp\n  have eq2: \"a + b = d\" using h1 by simp\n  have isolate_b: \"b = d - a\" using eq2 by simp\n  have substitution: \"3*a + 2*(d - a) = c\" using isolate_b eq1 by simp\n  have simplified: \"3*a + 2*d - 2*a = c\" by (smt (verit) h0 h1)\n  have isolate_a: \"a + 2*d = c\" by (smt (verit) h0 h1)\n  have result: \"b = (c - 3*a) / 2\" using eq1 by auto\n  show ?thesis using result by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_generalized:\n  fixes a b c d :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a + b = d\"\n  shows \"b = (c - 3*a) / 2\"\nproof -\n  have eq1: \"3*a + 2*b = c\" using h0 by simp\n  have eq2: \"a + b = d\" using h1 by simp\n  have isolate_b: \"b = d - a\" using eq2 by simp\n  have substitution: \"3*a + 2*(d - a) = c\" using isolate_b eq1 by simp\n  have simplified: \"3*a + 2*d - 2*a = c\" by (smt (verit) h0 h1)\n  have isolate_a: \"a + 2*d = c\" by (smt (verit) h0 h1)\n  have result: \"b = (c - 3*a) / 2\" using eq1 by auto\n  show ?thesis using result by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "square_of_fractionV5": {"skill_name": "square_of_fractionV5", "marker": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"((a / b) ^ 2) = (a ^ 2) / (b ^ 2)\"\n    by (simp add: power2_eq_square)\n  thus ?thesis by (simp add: assms)\nqed", "description": "-", "full_code": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"((a / b) ^ 2) = (a ^ 2) / (b ^ 2)\"\n    by (simp add: power2_eq_square)\n  thus ?thesis by (simp add: assms)\nqed", "origin": "do_request", "update_count": 0}, "square_of_fractionV6": {"skill_name": "square_of_fractionV6", "marker": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"((a / b)^2) = (a^2 / (b^2))\"\n    by (simp add: power_divide assms)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_of_fraction:\n  fixes a b :: real\n  assumes \"b > 0\"\n  shows \"(a / b)^2 = a^2 / b^2\"\nproof -\n  have \"((a / b)^2) = (a^2 / (b^2))\"\n    by (simp add: power_divide assms)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_eq_multi_dim": {"skill_name": "sqrt_eq_multi_dim", "marker": "lemma sqrt_eq_multi_dim:\n  fixes x :: real\n  assumes \"sqrt (x + d) = c\" and \"d > 0\" and \"c > 0\"\n  shows \"x = c^2 - d\"\nproof -\n  have \"x + d = c^2\" using assms by auto\n  then have \"x = c^2 - d\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq_multi_dim:\n  fixes x :: real\n  assumes \"sqrt (x + d) = c\" and \"d > 0\" and \"c > 0\"\n  shows \"x = c^2 - d\"\nproof -\n  have \"x + d = c^2\" using assms by auto\n  then have \"x = c^2 - d\" by simp\n  thus ?thesis by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "function_composition": {"skill_name": "function_composition", "marker": "definition function_composition :: \"('b \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'c\" (infixr \"\\<circ>\\<^sub>f\" 55) where\n\"function_composition g f x = g (f x)\"\nprimrec function_composition_multi :: \"('a \\<Rightarrow> 'a) list \\<Rightarrow> 'a \\<Rightarrow> 'a\" (infixr \"\\<circ>\\<^sub>f\\<^sub>m\\<^sub>u\\<^sub>l\\<^sub>t\\<^sub>i\" 55) where\n\"function_composition_multi [] x = x\" |\n\"function_composition_multi (f#fs) x = f (function_composition_multi fs x)\"", "description": "-", "full_code": "definition function_composition :: \"('b \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'c\" (infixr \"\\<circ>\\<^sub>f\" 55) where\n\"function_composition g f x = g (f x)\"\nprimrec function_composition_multi :: \"('a \\<Rightarrow> 'a) list \\<Rightarrow> 'a \\<Rightarrow> 'a\" (infixr \"\\<circ>\\<^sub>f\\<^sub>m\\<^sub>u\\<^sub>l\\<^sub>t\\<^sub>i\" 55) where\n\"function_composition_multi [] x = x\" |\n\"function_composition_multi (f#fs) x = f (function_composition_multi fs x)\"", "origin": "amc12b_2003_p9", "update_count": 0}, "amc12b_2003_p9_multi": {"skill_name": "amc12b_2003_p9_multi", "marker": "theorem amc12b_2003_p9_multi:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n    and \"f 10 - f 2 = 20\"  \n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (smt (verit) \\<open>f 6 - f 2 = a * 6 + b - (a * 2 + b)\\<close>)\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  have \"a = 3\" by (smt (verit) \\<open>4 * a = 12\\<close>)\n  have \"f 12 - f 2 = (a * 12 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 12 - f 2 = 12 * a - 2 * a\" by (smt (verit) \\<open>f 12 - f 2 = a * 12 + b - (a * 2 + b)\\<close>)\n  have \"f 12 - f 2 = 10 * a\" by (smt (verit) \\<open>f 12 - f 2 = 12 * a - 2 * a\\<close>)\n  then have \"f 12 - f 2 = 10 * 3\" using `a = 3` by simp\n  show ?thesis by (smt (verit) \\<open>f 12 - f 2 = 10 * 3\\<close>)\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  have \"a = 3\" by (smt (verit) \\<open>4 * a = 12\\<close>)\n  have \"f 12 - f 2 = (a * 12 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 12 - f 2 = 12 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"f 12 - f 2 = 10 * a\" by (smt (verit) \\<open>f 12 - f 2 = 12 * a - 2 * a\\<close>)\n  then have \"f 12 - f 2 = 10 * 3\" using `a = 3` by simp\n  show ?thesis by (smt (verit) \\<open>f 12 - f 2 = 10 * 3\\<close>)\nqed\n\ntheorem amc12b_2003_p9_multi:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n    and \"f 10 - f 2 = 20\"  \n  shows \"f 12 - f 2 = 30\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (smt (verit) \\<open>f 6 - f 2 = a * 6 + b - (a * 2 + b)\\<close>)\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  have \"a = 3\" by (smt (verit) \\<open>4 * a = 12\\<close>)\n  have \"f 12 - f 2 = (a * 12 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 12 - f 2 = 12 * a - 2 * a\" by (smt (verit) \\<open>f 12 - f 2 = a * 12 + b - (a * 2 + b)\\<close>)\n  have \"f 12 - f 2 = 10 * a\" by (smt (verit) \\<open>f 12 - f 2 = 12 * a - 2 * a\\<close>)\n  then have \"f 12 - f 2 = 10 * 3\" using `a = 3` by simp\n  show ?thesis by (smt (verit) \\<open>f 12 - f 2 = 10 * 3\\<close>)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "solve_linear_systemV3": {"skill_name": "solve_linear_systemV3", "marker": "lemma solve_linear_system:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"  \n    and h1 : \"2 * x + e = b\"  \n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a)\" using simplified_eq by (simp add: field_simps)\n  have e_value: \"e = a - (b - a)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "lemma solve_linear_system:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"  \n    and h1 : \"2 * x + e = b\"  \n  shows \"e = a - x \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a)\" using simplified_eq by (simp add: field_simps)\n  have e_value: \"e = a - (b - a)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "amc12a_2013_p8_evolved": {"skill_name": "amc12a_2013_p8_evolved", "marker": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  obtain a where \"a = x * y\" using h0 h1 by auto\n  have eq: \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (2 * (x - y)) / (x * y)\"\n    using rearranged by sos\n  have factored: \"x - y = (2 * (x - y)) / a\"\n    using common_den by (metis \\<open>a = x * y\\<close> add_diff_add diff_diff_eq2 divide_eq_0_iff frac_eq_eq mult.commute mult_2)\n  have \"1 = 2 / a\"\n    using h2 factored by sos\n  thus ?thesis using `1 = 2 / a` by (metis \\<open>a = x * y\\<close> dbl_simps(3) one_eq_divide_iff)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  obtain a where \"a = x * y\" using h0 h1 by auto\n  have eq: \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (2 * (x - y)) / (x * y)\"\n    using rearranged by sos\n  have factored: \"x - y = (2 * (x - y)) / a\"\n    using common_den by (metis \\<open>a = x * y\\<close> add_diff_add diff_diff_eq2 divide_eq_0_iff frac_eq_eq mult.commute mult_2)\n  have \"1 = 2 / a\"\n    using h2 factored by sos\n  thus ?thesis using `1 = 2 / a` by (metis \\<open>a = x * y\\<close> dbl_simps(3) one_eq_divide_iff)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "sqrt_limit": {"skill_name": "sqrt_limit", "marker": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 81\" using assms by simp\n  then show \"sqrt (x + 9) = 9\" \n    by auto\nqed", "description": "-", "full_code": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 81\" using assms by simp\n  then show \"sqrt (x + 9) = 9\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_limitV2": {"skill_name": "sqrt_limitV2", "marker": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"sqrt (x + 9) = sqrt 81\" using assms by simp\n  then show \"sqrt (x + 9) = 9\" by (simp add: real_sqrt_unique)\nqed", "description": "-", "full_code": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"sqrt (x + 9) = sqrt 81\" using assms by simp\n  then show \"sqrt (x + 9) = 9\" by (simp add: real_sqrt_unique)\nqed", "origin": "do_request", "update_count": 0}, "square_identity": {"skill_name": "square_identity", "marker": "lemma square_identity:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 = b^2 \\<longleftrightarrow> (a - b) * (a + b) = 0\" \n    by sos\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_identity:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 = b^2 \\<longleftrightarrow> (a - b) * (a + b) = 0\" \n    by sos\n  then show ?thesis by auto\nqed", "origin": "square_eq", "update_count": 0}, "sqrt_difference_property": {"skill_name": "sqrt_difference_property", "marker": "lemma sqrt_difference_property:\n  fixes a b :: real\n  assumes \"a + 9 = b + 9\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  have \"a = b\" using assms by simp\n  thus \"sqrt a = sqrt b\" using real_sqrt_eq_iff by simp\nqed", "description": "-", "full_code": "lemma sqrt_difference_property:\n  fixes a b :: real\n  assumes \"a + 9 = b + 9\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  have \"a = b\" using assms by simp\n  thus \"sqrt a = sqrt b\" using real_sqrt_eq_iff by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "sqrt_identity_for_nonneg": {"skill_name": "sqrt_identity_for_nonneg", "marker": "lemma sqrt_identity_for_nonneg:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt (x^2) = x\"\nproof -\n  have \"sqrt (x^2) = x\" using assms by auto\n  thus \"sqrt (x^2) = x\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_identity_for_nonneg:\n  fixes x :: real\n  assumes \"x \\<ge> 0\"\n  shows \"sqrt (x^2) = x\"\nproof -\n  have \"sqrt (x^2) = x\" using assms by auto\n  thus \"sqrt (x^2) = x\" by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "sqrt_equivalence": {"skill_name": "sqrt_equivalence", "marker": "theorem sqrt_equivalence:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"sqrt (x + 9) = 9\"\n  using assms by simp", "description": "-", "full_code": "theorem sqrt_equivalence:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"sqrt (x + 9) = 9\"\n  using assms by simp", "origin": "sqrt_eq", "update_count": 0}, "sqrt_limitV3": {"skill_name": "sqrt_limitV3", "marker": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 81\" using assms by simp\n  then have \"sqrt (x + 9) = sqrt 81\" by simp\n  then show \"sqrt (x + 9) = 9\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"sqrt (x + 9) = 9\"\nproof -\n  have \"x + 9 = 81\" using assms by simp\n  then have \"sqrt (x + 9) = sqrt 81\" by simp\n  then show \"sqrt (x + 9) = 9\" by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_evolved_complex": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_evolved_complex", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_evolved_complex:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" by (metis add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved is_num_normalize(1) mult.commute mult_2_right simplified_eq)\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed\n\ntheorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_evolved_complex:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" by (metis add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_evolved is_num_normalize(1) mult.commute mult_2_right simplified_eq)\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "real_number_propertiesV3": {"skill_name": "real_number_propertiesV3", "marker": "lemma real_number_properties:\n  fixes a b c :: real\n  shows \"a + (b + c) = (a + b) + c\"\nproof -\n  have \"a + (b + c) = a + (c + b)\" by (simp add: algebra_simps)\n  also have \"... = (a + c) + b\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma real_number_properties:\n  fixes a b c :: real\n  shows \"a + (b + c) = (a + b) + c\"\nproof -\n  have \"a + (b + c) = a + (c + b)\" by (simp add: algebra_simps)\n  also have \"... = (a + c) + b\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "square_preserves_equality": {"skill_name": "square_preserves_equality", "marker": "lemma square_preserves_equality:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  also have \"... = b * b\" using assms(1) by simp\n  also have \"... = b^2\" by sos\n  finally show \"a^2 = b^2\" .\nqed", "description": "-", "full_code": "lemma square_preserves_equality:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  also have \"... = b * b\" using assms(1) by simp\n  also have \"... = b^2\" by sos\n  finally show \"a^2 = b^2\" .\nqed", "origin": "do_request", "update_count": 0}, "square_preserves_equalityV2": {"skill_name": "square_preserves_equalityV2", "marker": "lemma square_preserves_equality:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by (simp add: assms(1))\n  then have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"... = b * b\" using assms(1) by simp\n  finally show \"a^2 = b^2\" by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_preserves_equality:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by (simp add: assms(1))\n  then have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"... = b * b\" using assms(1) by simp\n  finally show \"a^2 = b^2\" by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "square_preserves_equalityV3": {"skill_name": "square_preserves_equalityV3", "marker": "lemma square_preserves_equality:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"... = b * b\" using assms(1) by (simp)\n  also have \"... = b^2\" by (simp add: power2_eq_square)\n  finally show \"a^2 = b^2\" by simp\nqed", "description": "-", "full_code": "lemma square_preserves_equality:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"... = b * b\" using assms(1) by (simp)\n  also have \"... = b^2\" by (simp add: power2_eq_square)\n  finally show \"a^2 = b^2\" by simp\nqed", "origin": "do_request", "update_count": 0}, "square_preserves_equalityV4": {"skill_name": "square_preserves_equalityV4", "marker": "lemma square_preserves_equality:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  obtain c where \"a = c\" \"b = c\" using assms(1) by auto\n  then show \"a^2 = b^2\" by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_preserves_equality:\n  fixes a b :: real\n  assumes \"a = b\" \"a >= 0\" \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  obtain c where \"a = c\" \"b = c\" using assms(1) by auto\n  then show \"a^2 = b^2\" by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "squareV2": {"skill_name": "squareV2", "marker": "lemma square:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 = b^2 \\<longleftrightarrow> a^2 - b^2 = 0\" by simp\n  also have \"... \\<longleftrightarrow> (a - b) * (a + b) = 0\" by sos\n  also have \"... \\<longleftrightarrow> a - b = 0 \\<or> a + b = 0\" by (simp add: mult_eq_0_iff)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma square:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 = b^2 \\<longleftrightarrow> a^2 - b^2 = 0\" by simp\n  also have \"... \\<longleftrightarrow> (a - b) * (a + b) = 0\" by sos\n  also have \"... \\<longleftrightarrow> a - b = 0 \\<or> a + b = 0\" by (simp add: mult_eq_0_iff)\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "amc12b_2003_p9_extendedV5": {"skill_name": "amc12b_2003_p9_extendedV5", "marker": "theorem amc12b_2003_p9_extended:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f (n + 10) - f (n) = 10 * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  have \"a = 3\" by (smt (verit) \\<open>4 * a = 12\\<close>)\n  have \"f (n + 10) - f n = (a * (n + 10) + b) - (a * n + b)\" by (simp add: assms(1))\n  have \"f (n + 10) - f n = a * (n + 10) - a * n\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute)\n  then show ?thesis using `a = 3` by simp\nqed", "description": "-", "full_code": "theorem amc12b_2003_p9_extended:\n  fixes a b :: real and f :: \"real \\<Rightarrow> real\"\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f 6 - f 2 = 12\"\n  shows \"f (n + 10) - f (n) = 10 * a\"\nproof -\n  have \"f x = a * x + b\" for x by (simp add: assms(1))\n  have \"f 6 - f 2 = (a * 6 + b) - (a * 2 + b)\" by (simp add: assms(1))\n  have \"f 6 - f 2 = 6 * a - 2 * a\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute numeral_BitM one_plus_BitM or_not_num_neg.simps(2) right_diff_distrib' semiring_norm(2))\n  have \"4 * a = 12\" using `f 6 - f 2 = 12` by (smt (verit) \\<open>f 6 - f 2 = 6 * a - 2 * a\\<close>)\n  have \"a = 3\" by (smt (verit) \\<open>4 * a = 12\\<close>)\n  have \"f (n + 10) - f n = (a * (n + 10) + b) - (a * n + b)\" by (simp add: assms(1))\n  have \"f (n + 10) - f n = a * (n + 10) - a * n\" by (metis \\<open>\\<And>x. f x = a * x + b\\<close> add.commute add_diff_cancel_left dbl_def dbl_simps(3) diff_diff_eq diff_minus_eq_add left_diff_distrib' mult.commute)\n  then show ?thesis using `a = 3` by simp\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV2": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV2", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 7 - x \\<and> x = (-4) \\<and> e = 11\"\nproof -\n  from h0 have \"e = 7 - x\" by (auto simp: field_simps)\n  from h1 have \"2 * x + e = 3\" by simp\n  hence \"2 * x + (7 - x) = 3\" by (metis \\<open>e = 7 - x\\<close>)\n  hence \"x + 7 = 3\" by simp\n  then have \"x = -4\" by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  then have \"e = 7 - (-4)\" by (metis \\<open>e = 7 - x\\<close>)\n  thus ?thesis by (metis \\<open>e = 7 - x\\<close> \\<open>x = - 4\\<close> add.commute algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 h0 h1 uminus_add_conv_diff)\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e=11 \\<and> x= (-4)\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed\n\ntheorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 7 - x \\<and> x = (-4) \\<and> e = 11\"\nproof -\n  from h0 have \"e = 7 - x\" by (auto simp: field_simps)\n  from h1 have \"2 * x + e = 3\" by simp\n  hence \"2 * x + (7 - x) = 3\" by (metis \\<open>e = 7 - x\\<close>)\n  hence \"x + 7 = 3\" by simp\n  then have \"x = -4\" by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  then have \"e = 7 - (-4)\" by (metis \\<open>e = 7 - x\\<close>)\n  thus ?thesis by (metis \\<open>e = 7 - x\\<close> \\<open>x = - 4\\<close> add.commute algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 h0 h1 uminus_add_conv_diff)\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "isolate_xV2": {"skill_name": "isolate_xV2", "marker": "lemma isolate_x:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 81\" using assms by simp\n  then have \"x = 81 - 9\" by (simp add: algebra_simps)\n  then show \"x = 72\" by simp\nqed", "description": "-", "full_code": "lemma isolate_x:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 81\" using assms by simp\n  then have \"x = 81 - 9\" by (simp add: algebra_simps)\n  then show \"x = 72\" by simp\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complicated": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complicated", "marker": "lemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complicated:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"x + e = 2 * x + e + 4\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 diff_add_eq diff_minus_eq_add mult.commute mult_2_right verit_minus_simplify(4))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  thus ?thesis using x_value e_value by simp\nqed\n\nlemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_complicated:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n    and h2 : \"x + e = 2 * x + e + 4\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_minus_cancel algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 diff_add_eq diff_minus_eq_add mult.commute mult_2_right verit_minus_simplify(4))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpler": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpler", "marker": "lemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpler:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x + e = 7 \\<Longrightarrow> 2 * x + e = 3 \\<Longrightarrow> e = 11 \\<and> x = -4\"\n  using h0 h1 algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 by simp", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = (-4)\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  thus ?thesis using x_value e_value by simp\nqed\n\nlemma algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_simpler:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"x + e = 7 \\<Longrightarrow> 2 * x + e = 3 \\<Longrightarrow> e = 11 \\<and> x = -4\"\n  using h0 h1 algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 by simp", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "sqrt_and_square": {"skill_name": "sqrt_and_square", "marker": "lemma sqrt_and_square:\n  fixes x :: real\n  shows \"sqrt (x^2) = abs x\"\nproof -\n  have \"sqrt (x^2) = sqrt ((if x < 0 then -x else x)^2)\" by (simp add: if_splits)\n  then show \"sqrt (x^2) = abs x\" by auto\nqed", "description": "-", "full_code": "lemma sqrt_and_square:\n  fixes x :: real\n  shows \"sqrt (x^2) = abs x\"\nproof -\n  have \"sqrt (x^2) = sqrt ((if x < 0 then -x else x)^2)\" by (simp add: if_splits)\n  then show \"sqrt (x^2) = abs x\" by auto\nqed", "origin": "sqrt_eq", "update_count": 0}, "expression_square_nonneg": {"skill_name": "expression_square_nonneg", "marker": "lemma expression_square_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 0\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by (simp add: mult_nonneg_nonneg)\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  thus ?thesis using `x^2 * y^2 >= 0` `x^2 >= 0` `y^2 >= 0` by auto\nqed", "description": "-", "full_code": "lemma expression_square_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 0\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" by (simp add: mult_nonneg_nonneg)\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  thus ?thesis using `x^2 * y^2 >= 0` `x^2 >= 0` `y^2 >= 0` by auto\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "combined_expression_nonneg": {"skill_name": "combined_expression_nonneg", "marker": "lemma combined_expression_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  hence \"?E \\<ge> 1\" \n    using sum_of_squares_nonneg by (simp add: add_nonneg_nonneg)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_of_squares_nonneg:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\n  by auto\n\nlemma combined_expression_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  hence \"?E \\<ge> 1\" \n    using sum_of_squares_nonneg by (simp add: add_nonneg_nonneg)\n  thus ?thesis by auto\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "product_minus_one_nonneg": {"skill_name": "product_minus_one_nonneg", "marker": "lemma product_minus_one_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 \\<ge> 0\"\n  by auto", "description": "-", "full_code": "lemma product_minus_one_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 \\<ge> 0\"\n  by auto", "origin": "amc12a_2021_p7", "update_count": 0}, "amc12a_2021_p7V3": {"skill_name": "amc12a_2021_p7V3", "marker": "theorem amc12a_2021_p7:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\n  using combined_expression_nonneg by (simp add: algebra_simps)", "description": "-", "full_code": "lemma sum_of_squares_nonneg:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\n  by auto\n\nlemma combined_expression_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  hence \"?E \\<ge> 1\" \n    using sum_of_squares_nonneg by (simp add: add_nonneg_nonneg)\n  thus ?thesis by auto\nqed\n\ntheorem amc12a_2021_p7:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\n  using combined_expression_nonneg by (simp add: algebra_simps)", "origin": "amc12a_2021_p7", "update_count": 0}, "count_range_elements": {"skill_name": "count_range_elements", "marker": "lemma count_range_elements:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a..b} = b - a + 1\"\nproof -\n  have \"card {a..b} = b - a + 1\" using assms\n  proof (induction b)\n    case 0\n    then show ?case by auto\n  next\n    case (Suc b)\n    then show ?case \n      using Suc.prems \n      by auto\n  qed\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_range_elements:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a..b} = b - a + 1\"\nproof -\n  have \"card {a..b} = b - a + 1\" using assms\n  proof (induction b)\n    case 0\n    then show ?case by auto\n  next\n    case (Suc b)\n    then show ?case \n      using Suc.prems \n      by auto\n  qed\n  then show ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "polynomial_combinationV4": {"skill_name": "polynomial_combinationV4", "marker": "lemma polynomial_combination:\n  fixes p q r :: real\n  shows \"(p + q) + r = p + (q + r)\"\nproof -\n  have \"p + (q + r) = (p + q) + r\" \n    by (metis add.assoc)  \n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma polynomial_combination:\n  fixes p q r :: real\n  shows \"(p + q) + r = p + (q + r)\"\nproof -\n  have \"p + (q + r) = (p + q) + r\" \n    by (metis add.assoc)  \n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "polynomial_combinationV5": {"skill_name": "polynomial_combinationV5", "marker": "lemma polynomial_combination:\n  fixes p q r :: real\n  shows \"(p + q) + r = p + (q + r)\"\nproof -\n  show \"(p + q) + r = p + (q + r)\"\n  proof -\n    have \"p + (q + r) = (p + q) + r\" by (simp add: algebra_simps)\n    thus ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma polynomial_combination:\n  fixes p q r :: real\n  shows \"(p + q) + r = p + (q + r)\"\nproof -\n  show \"(p + q) + r = p + (q + r)\"\n  proof -\n    have \"p + (q + r) = (p + q) + r\" by (simp add: algebra_simps)\n    thus ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mod_additionV5": {"skill_name": "mod_additionV5", "marker": "lemma mod_addition:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  hence \"a mod m < m\" and \"b mod m < m\" by auto\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = ?x + (a div m) * m\" by auto\n  have \"b = ?y + (b div m) * m\" by auto\n  have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((?x + ?y) + ((a div m) + (b div m)) * m) mod m\" \n    by (simp add: algebra_simps)\n  also have \"... = (?x + ?y) mod m\" \n    by (simp add: mod_mult_eq)\n  also have \"... = ((a mod m) + (b mod m)) mod m\" \n    by (simp add: algebra_simps)\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  hence \"a mod m < m\" and \"b mod m < m\" by auto\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = ?x + (a div m) * m\" by auto\n  have \"b = ?y + (b div m) * m\" by auto\n  have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((?x + ?y) + ((a div m) + (b div m)) * m) mod m\" \n    by (simp add: algebra_simps)\n  also have \"... = (?x + ?y) mod m\" \n    by (simp add: mod_mult_eq)\n  also have \"... = ((a mod m) + (b mod m)) mod m\" \n    by (simp add: algebra_simps)\n  finally show ?thesis by presburger\nqed", "origin": "do_request", "update_count": 0}, "square_root_equivalence_extended": {"skill_name": "square_root_equivalence_extended", "marker": "lemma square_root_equivalence_extended:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\n  using assms by auto", "description": "-", "full_code": "lemma square_root_equivalence_extended:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\n  using assms by auto", "origin": "square_eq", "update_count": 0}, "square_eq_reversed": {"skill_name": "square_eq_reversed", "marker": "lemma square_eq_reversed:\n  fixes a b :: real\n  assumes \"a^2 = b^2\"\n  shows \"a = b \\<or> a = -b\"\n  using assms by (metis power2_eq_iff)", "description": "-", "full_code": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_eq_reversed:\n  fixes a b :: real\n  assumes \"a^2 = b^2\"\n  shows \"a = b \\<or> a = -b\"\n  using assms by (metis power2_eq_iff)", "origin": "square_eq", "update_count": 0}, "units_digit_squareV11": {"skill_name": "units_digit_squareV11", "marker": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  obtain n where \"k = 10 * n\" using assms by auto\n  then have \"k^2 = (10 * n)^2\" by simp\n  also have \"... = 100 * n^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 = 100 * n^2\" .\n  then show \"(k^2) mod 10 = 0\" \n    using mod_mult_self2[of 100 \"n^2\"] by simp\nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  obtain n where \"k = 10 * n\" using assms by auto\n  then have \"k^2 = (10 * n)^2\" by simp\n  also have \"... = 100 * n^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 = 100 * n^2\" .\n  then show \"(k^2) mod 10 = 0\" \n    using mod_mult_self2[of 100 \"n^2\"] by simp\nqed", "origin": "do_request", "update_count": 0}, "units_digit_squareV12": {"skill_name": "units_digit_squareV12", "marker": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" \n    using assms by auto \n  then have \"k^2 = (10 * (k div 10))^2\" \n    by simp\n  also have \"... = 100 * (k div 10)^2\" \n    by (simp add: power2_eq_square)\n  finally have \"k^2 = 100 * (k div 10)^2\" .\n  have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" \n    by (metis \\<open>(10 * (k div 10))\\<^sup>2 = 100 * (k div 10)\\<^sup>2\\<close> \\<open>k\\<^sup>2 = (10 * (k div 10))\\<^sup>2\\<close>)\n  moreover have \"(100 * (k div 10)^2) mod 10 = 0\" \n    by (simp add: mod_mult_self2)\n  ultimately show \"(k^2) mod 10 = 0\" \n    by simp\nqed", "description": "-", "full_code": "lemma units_digit_square:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"(k^2) mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" \n    using assms by auto \n  then have \"k^2 = (10 * (k div 10))^2\" \n    by simp\n  also have \"... = 100 * (k div 10)^2\" \n    by (simp add: power2_eq_square)\n  finally have \"k^2 = 100 * (k div 10)^2\" .\n  have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" \n    by (metis \\<open>(10 * (k div 10))\\<^sup>2 = 100 * (k div 10)\\<^sup>2\\<close> \\<open>k\\<^sup>2 = (10 * (k div 10))\\<^sup>2\\<close>)\n  moreover have \"(100 * (k div 10)^2) mod 10 = 0\" \n    by (simp add: mod_mult_self2)\n  ultimately show \"(k^2) mod 10 = 0\" \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "isolate_variableV5": {"skill_name": "isolate_variableV5", "marker": "lemma isolate_variable:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  from assms have \"c - b + b = c\" by (simp add: algebra_simps)\n  then have \"c - b = a + b - b\" by (metis add.commute add_cancel_right_right assms cancel_ab_semigroup_add_class.diff_right_commute crossproduct_eq diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_diff_eq eq_iff_diff_eq_0 minus_diff_eq mult.commute mult_cancel_right1 mult_eq_0_iff mult_minus_right neg_0_equal_iff_equal zero_neq_neg_one)\n  also have \"... = a\" by (simp add: algebra_simps)\n  finally show \"a = c - b\" by simp\nqed", "description": "-", "full_code": "lemma isolate_variable:\n  fixes a b c :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  from assms have \"c - b + b = c\" by (simp add: algebra_simps)\n  then have \"c - b = a + b - b\" by (metis add.commute add_cancel_right_right assms cancel_ab_semigroup_add_class.diff_right_commute crossproduct_eq diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_diff_eq eq_iff_diff_eq_0 minus_diff_eq mult.commute mult_cancel_right1 mult_eq_0_iff mult_minus_right neg_0_equal_iff_equal zero_neq_neg_one)\n  also have \"... = a\" by (simp add: algebra_simps)\n  finally show \"a = c - b\" by simp\nqed", "origin": "do_request", "update_count": 0}, "odd_even_productV2": {"skill_name": "odd_even_productV2", "marker": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  have \"a mod 2 = 0\" using assms(1) by auto\n  have \"b mod 2 = 1\" using assms(2) by auto\n  obtain k where \"a = 2 * k\" using `a mod 2 = 0` by auto\n  obtain m where \"b = 2 * m + 1\" using `b mod 2 = 1` by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" by simp\n  then have \"a * b = 2 * (k * (2 * m) + k)\" by (simp add: distrib_left)\n  thus \"(a * b) mod 2 = 0\" \n    using `a * b = 2 * (k * (2 * m) + k)` by auto\nqed", "description": "-", "full_code": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"(a * b) mod 2 = 0\"\nproof -\n  have \"a mod 2 = 0\" using assms(1) by auto\n  have \"b mod 2 = 1\" using assms(2) by auto\n  obtain k where \"a = 2 * k\" using `a mod 2 = 0` by auto\n  obtain m where \"b = 2 * m + 1\" using `b mod 2 = 1` by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" by simp\n  then have \"a * b = 2 * (k * (2 * m) + k)\" by (simp add: distrib_left)\n  thus \"(a * b) mod 2 = 0\" \n    using `a * b = 2 * (k * (2 * m) + k)` by auto\nqed", "origin": "do_request", "update_count": 0}, "sum_terms_count_with_bounds": {"skill_name": "sum_terms_count_with_bounds", "marker": "lemma sum_terms_count_with_bounds:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = length [x. x \\<leftarrow> [a..b-1]]\" by (metis One_nat_def Suc_pred' add_cancel_right_left assms cancel_ab_semigroup_add_class.diff_right_commute card_atLeastLessThan diff_Suc_eq_diff_pred int_Suc int_ops(6) length_upto map_ident nat_int not_gr_zero not_less_eq of_nat_0_less_iff of_nat_1 of_nat_1_eq_iff of_nat_add of_nat_less_0_iff of_nat_less_iff zero_less_diff zless_nat_eq_int_zless)\n  also have \"... = b - a\" by (metis calculation card_atLeastLessThan map_ident)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma sum_terms_count_with_bounds:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = length [x. x \\<leftarrow> [a..b-1]]\" by (metis One_nat_def Suc_pred' add_cancel_right_left assms cancel_ab_semigroup_add_class.diff_right_commute card_atLeastLessThan diff_Suc_eq_diff_pred int_Suc int_ops(6) length_upto map_ident nat_int not_gr_zero not_less_eq of_nat_0_less_iff of_nat_1 of_nat_1_eq_iff of_nat_add of_nat_less_0_iff of_nat_less_iff zero_less_diff zless_nat_eq_int_zless)\n  also have \"... = b - a\" by (metis calculation card_atLeastLessThan map_ident)\n  finally show ?thesis .\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_floor_bounds": {"skill_name": "sum_floor_bounds", "marker": "lemma sum_floor_bounds:\n  fixes r :: real and k :: nat\n  assumes \"19 \\<le> k\" \"k \\<le> 91\"\n  shows \"floor (r + k / 100) \\<in> {floor r, floor r + 1}\"\nproof -\n  let ?m = \"floor r\"\n  have \"r + k / 100 \\<ge> ?m\" \n  proof -\n    have \"k / 100 < 1\" \n      using assms by (auto simp: lessThan_iff)\n    thus \"r + k / 100 \\<ge> ?m\" \n      using `k \\<ge> 19` by arith\n  qed\n  moreover have \"r + k / 100 < ?m + 1 + 1\" \n  proof -\n    have \"k / 100 < 1\" \n      using assms by (auto simp: lessThan_iff)\n    thus \"r + k / 100 < ?m + 1 + 1\" \n      using `k \\<le> 91` by arith\n  qed\n  ultimately show ?thesis \n  proof (cases \"r + k / 100 < ?m + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) \\<open>real_of_int \\<lfloor>r\\<rfloor> \\<le> r + real k / 100\\<close> floor_eq_iff insertCI of_int_1 of_int_add)\n  next\n    case False\n    then show ?thesis \n      by (smt (verit) \\<open>r + real k / 100 < real_of_int (\\<lfloor>r\\<rfloor> + 1 + 1)\\<close> floor_eq_iff insertI1 insertI2 of_int_1 of_int_add verit_comp_simplify1(3))\n  qed\nqed", "description": "-", "full_code": "lemma sum_floor_bounds:\n  fixes r :: real and k :: nat\n  assumes \"19 \\<le> k\" \"k \\<le> 91\"\n  shows \"floor (r + k / 100) \\<in> {floor r, floor r + 1}\"\nproof -\n  let ?m = \"floor r\"\n  have \"r + k / 100 \\<ge> ?m\" \n  proof -\n    have \"k / 100 < 1\" \n      using assms by (auto simp: lessThan_iff)\n    thus \"r + k / 100 \\<ge> ?m\" \n      using `k \\<ge> 19` by arith\n  qed\n  moreover have \"r + k / 100 < ?m + 1 + 1\" \n  proof -\n    have \"k / 100 < 1\" \n      using assms by (auto simp: lessThan_iff)\n    thus \"r + k / 100 < ?m + 1 + 1\" \n      using `k \\<le> 91` by arith\n  qed\n  ultimately show ?thesis \n  proof (cases \"r + k / 100 < ?m + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) \\<open>real_of_int \\<lfloor>r\\<rfloor> \\<le> r + real k / 100\\<close> floor_eq_iff insertCI of_int_1 of_int_add)\n  next\n    case False\n    then show ?thesis \n      by (smt (verit) \\<open>r + real k / 100 < real_of_int (\\<lfloor>r\\<rfloor> + 1 + 1)\\<close> floor_eq_iff insertI1 insertI2 of_int_1 of_int_add verit_comp_simplify1(3))\n  qed\nqed", "origin": "do_request", "update_count": 0}, "quadratic_minimum": {"skill_name": "quadratic_minimum", "marker": "lemma quadratic_minimum:\n  fixes x :: real\n  shows \"x^2 - 6*x + 13 >= 4\"\nproof -\n  have \"x^2 - 6*x + 9 >= 0\" by sos\n  then have \"x^2 - 6*x + 13 = (x - 3)^2 + 4\" by sos\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma quadratic_minimum:\n  fixes x :: real\n  shows \"x^2 - 6*x + 13 >= 4\"\nproof -\n  have \"x^2 - 6*x + 9 >= 0\" by sos\n  then have \"x^2 - 6*x + 13 = (x - 3)^2 + 4\" by sos\n  thus ?thesis by auto\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "linear_system_solutionV3": {"skill_name": "linear_system_solutionV3", "marker": "theorem linear_system_solution:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2 * b = 12\" by (smt (verit) sub)\n  have isolate: \"2 * b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem linear_system_solution:\n  fixes a b :: real\n  assumes h0 : \"3 * a + 2 * b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3 * a + 2 * b = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = 12\" using h1 eq by simp\n  have simplified: \"12 + 2 * b = 12\" by (smt (verit) sub)\n  have isolate: \"2 * b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sum_floor_boundsV2": {"skill_name": "sum_floor_boundsV2", "marker": "lemma sum_floor_bounds:\n  fixes r :: real and k :: nat\n  assumes \"19 \\<le> k\" \"k \\<le> 91\"\n  shows \"floor (r + k / 100) \\<in> {floor r, floor r + 1}\"\nproof -\n  let ?m = \"floor r\"\n  have \"r + k / 100 \\<ge> ?m\" \n  proof -\n    have \"k / 100 < 1\" \n      using assms by auto\n    thus \"r + k / 100 \\<ge> ?m\" \n      using `k \\<ge> 19` by arith\n  qed\n  moreover have \"r + k / 100 < ?m + 2\" \n  proof -\n    have \"k / 100 < 1\" \n      using assms by auto\n    thus \"r + k / 100 < ?m + 2\" \n      using `k \\<le> 91` by arith\n  qed\n  ultimately show ?thesis \n  proof (cases \"r + k / 100 < ?m + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) `?m \\<le> r + k / 100` floor_eq_iff insertCI of_int_1 of_int_add)\n  next\n    case False\n    then show ?thesis \n      by (smt (verit) `r + k / 100 < ?m + 2` floor_eq_iff insertI1 insertI2 of_int_1 of_int_add)\n  qed\nqed", "description": "-", "full_code": "lemma sum_floor_bounds:\n  fixes r :: real and k :: nat\n  assumes \"19 \\<le> k\" \"k \\<le> 91\"\n  shows \"floor (r + k / 100) \\<in> {floor r, floor r + 1}\"\nproof -\n  let ?m = \"floor r\"\n  have \"r + k / 100 \\<ge> ?m\" \n  proof -\n    have \"k / 100 < 1\" \n      using assms by auto\n    thus \"r + k / 100 \\<ge> ?m\" \n      using `k \\<ge> 19` by arith\n  qed\n  moreover have \"r + k / 100 < ?m + 2\" \n  proof -\n    have \"k / 100 < 1\" \n      using assms by auto\n    thus \"r + k / 100 < ?m + 2\" \n      using `k \\<le> 91` by arith\n  qed\n  ultimately show ?thesis \n  proof (cases \"r + k / 100 < ?m + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) `?m \\<le> r + k / 100` floor_eq_iff insertCI of_int_1 of_int_add)\n  next\n    case False\n    then show ?thesis \n      by (smt (verit) `r + k / 100 < ?m + 2` floor_eq_iff insertI1 insertI2 of_int_1 of_int_add)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mod10_cases": {"skill_name": "mod10_cases", "marker": "lemma mod10_cases:\n  fixes a :: int\n  shows \"a mod 10 = 0 \\<or> a mod 10 = 1 \\<or> a mod 10 = 2 \\<or> a mod 10 = 3 \\<or> a mod 10 = 4 \\<or> a mod 10 = 5 \\<or> a mod 10 = 6 \\<or> a mod 10 = 7 \\<or> a mod 10 = 8 \\<or> a mod 10 = 9\"\n  by presburger", "description": "-", "full_code": "lemma mod10_cases:\n  fixes a :: int\n  shows \"a mod 10 = 0 \\<or> a mod 10 = 1 \\<or> a mod 10 = 2 \\<or> a mod 10 = 3 \\<or> a mod 10 = 4 \\<or> a mod 10 = 5 \\<or> a mod 10 = 6 \\<or> a mod 10 = 7 \\<or> a mod 10 = 8 \\<or> a mod 10 = 9\"\n  by presburger", "origin": "mod4_cases", "update_count": 0}, "amc12_generalized": {"skill_name": "amc12_generalized", "marker": "theorem amc12_generalized:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\"\n    and h1: \"y \\<noteq> 0\"\n    and h2: \"x \\<noteq> y\"\n    and h3: \"x + a/x = y + a/y\"  \n  shows \"x * y = a\"\nproof -\n  have eq: \"x + a / x = y + a / y\" using h3 by simp\n  have rearranged: \"x - y = (a / y - a / x)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (a * (x - y)) / (x * y)\"\n    using rearranged by (smt (verit) diff_frac_eq h0 h1 mult.commute right_diff_distrib')\n  have factored: \"1 = a / (x * y)\"\n    using h2 common_den by sos\n  hence \"x * y = a\" \n    using `1 = a / (x * y)` by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12_generalized:\n  fixes x y :: real\n  assumes h0: \"x \\<noteq> 0\"\n    and h1: \"y \\<noteq> 0\"\n    and h2: \"x \\<noteq> y\"\n    and h3: \"x + a/x = y + a/y\"  \n  shows \"x * y = a\"\nproof -\n  have eq: \"x + a / x = y + a / y\" using h3 by simp\n  have rearranged: \"x - y = (a / y - a / x)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (a * (x - y)) / (x * y)\"\n    using rearranged by (smt (verit) diff_frac_eq h0 h1 mult.commute right_diff_distrib')\n  have factored: \"1 = a / (x * y)\"\n    using h2 common_den by sos\n  hence \"x * y = a\" \n    using `1 = a / (x * y)` by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "mod_addV9": {"skill_name": "mod_addV9", "marker": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?a' = \"a mod n\"\n  let ?b' = \"b mod n\"\n  have \"a = ?a' + (a div n) * n\" using assms by auto\n  have \"b = ?b' + (b div n) * n\" using assms by auto\n  then have \"a + b = (?a' + (a div n) * n) + (?b' + (b div n) * n)\"\n    by (simp add: algebra_simps)\n  thus ?thesis \n  proof -\n    have \"a + b = (?a' + ?b') + ((a div n) + (b div n)) * n\"\n      by (simp add: algebra_simps)\n    then have \"(a + b) mod n = ((?a' + ?b') + ((a div n) + (b div n)) * n) mod n\"\n      by simp\n    also have \"... = ((?a' + ?b') mod n) + (((a div n) + (b div n)) * n mod n)\"\n      by auto\n    also have \"... = (?a' + ?b') mod n\"\n      by (simp add: mod_mult_self1)\n    finally show ?thesis using mod_add_eq by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?a' = \"a mod n\"\n  let ?b' = \"b mod n\"\n  have \"a = ?a' + (a div n) * n\" using assms by auto\n  have \"b = ?b' + (b div n) * n\" using assms by auto\n  then have \"a + b = (?a' + (a div n) * n) + (?b' + (b div n) * n)\"\n    by (simp add: algebra_simps)\n  thus ?thesis \n  proof -\n    have \"a + b = (?a' + ?b') + ((a div n) + (b div n)) * n\"\n      by (simp add: algebra_simps)\n    then have \"(a + b) mod n = ((?a' + ?b') + ((a div n) + (b div n)) * n) mod n\"\n      by simp\n    also have \"... = ((?a' + ?b') mod n) + (((a div n) + (b div n)) * n mod n)\"\n      by auto\n    also have \"... = (?a' + ?b') mod n\"\n      by (simp add: mod_mult_self1)\n    finally show ?thesis using mod_add_eq by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mod_addV10": {"skill_name": "mod_addV10", "marker": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?a' = \"a mod n\"\n  let ?b' = \"b mod n\"\n  have \"a = ?a' + (a div n) * n\" by (simp add: div_mult_mod_eq)\n  have \"b = ?b' + (b div n) * n\" by (simp add: div_mult_mod_eq)\n  then have \"a + b = (?a' + (a div n) * n) + (?b' + (b div n) * n)\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (?a' + ?b') + ((a div n) + (b div n)) * n\"\n    by (simp add: algebra_simps)\n  hence \"(a + b) mod n = ((?a' + ?b') + ((a div n) + (b div n)) * n) mod n\"\n    by simp\n  also have \"... = ((?a' + ?b') mod n)\"\n    by auto\n  finally show ?thesis \n    by (simp add: mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?a' = \"a mod n\"\n  let ?b' = \"b mod n\"\n  have \"a = ?a' + (a div n) * n\" by (simp add: div_mult_mod_eq)\n  have \"b = ?b' + (b div n) * n\" by (simp add: div_mult_mod_eq)\n  then have \"a + b = (?a' + (a div n) * n) + (?b' + (b div n) * n)\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (?a' + ?b') + ((a div n) + (b div n)) * n\"\n    by (simp add: algebra_simps)\n  hence \"(a + b) mod n = ((?a' + ?b') + ((a div n) + (b div n)) * n) mod n\"\n    by simp\n  also have \"... = ((?a' + ?b') mod n)\"\n    by auto\n  finally show ?thesis \n    by (simp add: mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "mod_addV11": {"skill_name": "mod_addV11", "marker": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?a' = \"a mod n\"\n  let ?b' = \"b mod n\"\n  have \"a = ?a' + (a div n) * n\" by auto\n  have \"b = ?b' + (b div n) * n\" by auto\n  then have \"a + b = (?a' + (a div n) * n) + (?b' + (b div n) * n)\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (?a' + ?b') + ((a div n) + (b div n)) * n\" \n    by (simp add: algebra_simps)\n  have \"((a + b) mod n) = ((?a' + ?b') + ((a div n) + (b div n)) * n) mod n\" \n    by presburger\n  also have \"... = ((?a' + ?b') mod n)\" \n    by auto\n  finally show ?thesis \n    by (simp add: mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?a' = \"a mod n\"\n  let ?b' = \"b mod n\"\n  have \"a = ?a' + (a div n) * n\" by auto\n  have \"b = ?b' + (b div n) * n\" by auto\n  then have \"a + b = (?a' + (a div n) * n) + (?b' + (b div n) * n)\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (?a' + ?b') + ((a div n) + (b div n)) * n\" \n    by (simp add: algebra_simps)\n  have \"((a + b) mod n) = ((?a' + ?b') + ((a div n) + (b div n)) * n) mod n\" \n    by presburger\n  also have \"... = ((?a' + ?b') mod n)\" \n    by auto\n  finally show ?thesis \n    by (simp add: mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "mod_addV12": {"skill_name": "mod_addV12", "marker": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?x = \"a mod n\"\n  let ?y = \"b mod n\"\n  have \"a = (a div n) * n + ?x\" by auto\n  have \"b = (b div n) * n + ?y\" by auto\n  then have \"a + b = ((a div n) + (b div n)) * n + (?x + ?y)\" \n    by (simp add: algebra_simps)\n  hence \"(a + b) mod n = (?x + ?y) mod n\" \n    by (metis assms mod_add_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?x = \"a mod n\"\n  let ?y = \"b mod n\"\n  have \"a = (a div n) * n + ?x\" by auto\n  have \"b = (b div n) * n + ?y\" by auto\n  then have \"a + b = ((a div n) + (b div n)) * n + (?x + ?y)\" \n    by (simp add: algebra_simps)\n  hence \"(a + b) mod n = (?x + ?y) mod n\" \n    by (metis assms mod_add_eq)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_addV13": {"skill_name": "mod_addV13", "marker": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?x = \"a mod n\"\n  let ?y = \"b mod n\"\n  have \"a = (a div n) * n + ?x\" by auto\n  have \"b = (b div n) * n + ?y\" by auto\n  then have \"a + b = ((a div n) + (b div n)) * n + (?x + ?y)\" \n    by (simp add: algebra_simps)\n  have \"(a + b) mod n = (((a div n) + (b div n)) * n + (?x + ?y)) mod n\"\n    by (auto simp: field_simps)\n  also have \"... = (?x + ?y) mod n\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?x = \"a mod n\"\n  let ?y = \"b mod n\"\n  have \"a = (a div n) * n + ?x\" by auto\n  have \"b = (b div n) * n + ?y\" by auto\n  then have \"a + b = ((a div n) + (b div n)) * n + (?x + ?y)\" \n    by (simp add: algebra_simps)\n  have \"(a + b) mod n = (((a div n) + (b div n)) * n + (?x + ?y)) mod n\"\n    by (auto simp: field_simps)\n  also have \"... = (?x + ?y) mod n\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "linear_equation_solutionV9": {"skill_name": "linear_equation_solutionV9", "marker": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = c\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*c)/n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"n*b = p - m*c\" using h1 by simp\n  then have \"b = (p - m*c)/n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem linear_equation_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = c\"\n    and h2 : \"n \\<noteq> 0\"\n  shows \"b = (p - m*c)/n\"\nproof -\n  have \"n*b = p - m*a\" using h0 by simp\n  then have \"n*b = p - m*c\" using h1 by simp\n  then have \"b = (p - m*c)/n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  then show ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mod_addV14": {"skill_name": "mod_addV14", "marker": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  have \"a = (a div n) * n + (a mod n)\" by auto\n  have \"b = (b div n) * n + (b mod n)\" by auto\n  then have \"a + b = (a div n) * n + (b div n) * n + (a mod n) + (b mod n)\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod n = ((a div n + b div n) * n + (a mod n + b mod n)) mod n\"\n    by (simp add: algebra_simps)\n  also have \"... = (a mod n + b mod n) mod n\" \n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  have \"a = (a div n) * n + (a mod n)\" by auto\n  have \"b = (b div n) * n + (b mod n)\" by auto\n  then have \"a + b = (a div n) * n + (b div n) * n + (a mod n) + (b mod n)\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod n = ((a div n + b div n) * n + (a mod n + b mod n)) mod n\"\n    by (simp add: algebra_simps)\n  also have \"... = (a mod n + b mod n) mod n\" \n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_addV15": {"skill_name": "mod_addV15", "marker": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?x = \"a mod n\"\n  let ?y = \"b mod n\"\n  have \"a = (a div n) * n + ?x\" by auto\n  have \"b = (b div n) * n + ?y\" by auto\n  then have \"a + b = (a div n) * n + (b div n) * n + ?x + ?y\" \n    by (simp add: algebra_simps)\n  let ?k = \"(a div n) + (b div n)\"\n  have \"a + b = ?k * n + (?x + ?y)\" by (simp add: algebra_simps)\n  then show ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  let ?x = \"a mod n\"\n  let ?y = \"b mod n\"\n  have \"a = (a div n) * n + ?x\" by auto\n  have \"b = (b div n) * n + ?y\" by auto\n  then have \"a + b = (a div n) * n + (b div n) * n + ?x + ?y\" \n    by (simp add: algebra_simps)\n  let ?k = \"(a div n) + (b div n)\"\n  have \"a + b = ?k * n + (?x + ?y)\" by (simp add: algebra_simps)\n  then show ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "linear_combination_of_equations": {"skill_name": "linear_combination_of_equations", "marker": "lemma linear_combination_of_equations:\n  fixes a b :: complex\n  assumes \"a + b = 7\" \"2 * a + b = 3\"\n  shows \"b = 11 \\<and> a = -4\"\nproof -\n  have b_eq: \"b = 7 - a\" using assms(1) by (auto simp: field_simps)\n  have eq2_substituted: \"2 * a + (7 - a) = 3\" using assms(2) b_eq by simp\n  have simplified_eq: \"a + 7 = 3\" using eq2_substituted by simp\n  have a_value: \"a = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have b_value: \"b = 7 - (-4)\" using b_eq a_value by simp\n  show ?thesis using a_value b_value by simp\nqed", "description": "-", "full_code": "lemma linear_combination_of_equations:\n  fixes a b :: complex\n  assumes \"a + b = 7\" \"2 * a + b = 3\"\n  shows \"b = 11 \\<and> a = -4\"\nproof -\n  have b_eq: \"b = 7 - a\" using assms(1) by (auto simp: field_simps)\n  have eq2_substituted: \"2 * a + (7 - a) = 3\" using assms(2) b_eq by simp\n  have simplified_eq: \"a + 7 = 3\" using eq2_substituted by simp\n  have a_value: \"a = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have b_value: \"b = 7 - (-4)\" using b_eq a_value by simp\n  show ?thesis using a_value b_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebraic_manipulationV3": {"skill_name": "algebraic_manipulationV3", "marker": "lemma algebraic_manipulation:\n  fixes x y z :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have \"(x + y)^2 = (x + y) * (x + y)\" by sos\n  also have \"... = x * (x + y) + y * (x + y)\" by sos\n  also have \"... = x^2 + x * y + y * x + y^2\" by sos\n  also have \"... = x^2 + 2 * x * y + y^2\" by (simp add: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes x y z :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have \"(x + y)^2 = (x + y) * (x + y)\" by sos\n  also have \"... = x * (x + y) + y * (x + y)\" by sos\n  also have \"... = x^2 + x * y + y * x + y^2\" by sos\n  also have \"... = x^2 + 2 * x * y + y^2\" by (simp add: field_simps)\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "mod_addV16": {"skill_name": "mod_addV16", "marker": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  have \"a = (a div n) * n + (a mod n)\" using assms by auto\n  have \"b = (b div n) * n + (b mod n)\" using assms by auto\n  then have \"a + b = ((a div n) * n + (b div n) * n) + (a mod n) + (b mod n)\" \n    by (simp add: algebra_simps)\n  then have \"a + b = ((a div n + b div n) * n) + (a mod n + b mod n)\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod n = (((a div n + b div n) * n) + (a mod n + b mod n)) mod n\" \n    by (simp add: algebra_simps)\n  also have \"... = ((a mod n + b mod n) + ((a div n + b div n) * n)) mod n\" \n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by (simp only: add.assoc mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  have \"a = (a div n) * n + (a mod n)\" using assms by auto\n  have \"b = (b div n) * n + (b mod n)\" using assms by auto\n  then have \"a + b = ((a div n) * n + (b div n) * n) + (a mod n) + (b mod n)\" \n    by (simp add: algebra_simps)\n  then have \"a + b = ((a div n + b div n) * n) + (a mod n + b mod n)\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod n = (((a div n + b div n) * n) + (a mod n + b mod n)) mod n\" \n    by (simp add: algebra_simps)\n  also have \"... = ((a mod n + b mod n) + ((a div n + b div n) * n)) mod n\" \n    by (simp add: algebra_simps)\n  finally show ?thesis \n    by (simp only: add.assoc mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "mod_addV17": {"skill_name": "mod_addV17", "marker": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  have \"a = (a div n) * n + (a mod n)\" by auto\n  have \"b = (b div n) * n + (b mod n)\" by auto\n  then have \"a + b = ((a div n) + (b div n)) * n + (a mod n) + (b mod n)\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod n = (((a div n) + (b div n)) * n + (a mod n) + (b mod n)) mod n\"\n    by simp\n  also have \"... = ((a mod n) + (b mod n)) mod n\"\n  proof -\n    have \"((a div n) + (b div n)) * n mod n = 0\" \n      using assms by auto\n    then show ?thesis \n      by (metis calculation mod_add_eq)\n  qed\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b) mod n = ((a mod n) + (b mod n)) mod n\"\nproof -\n  have \"a = (a div n) * n + (a mod n)\" by auto\n  have \"b = (b div n) * n + (b mod n)\" by auto\n  then have \"a + b = ((a div n) + (b div n)) * n + (a mod n) + (b mod n)\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod n = (((a div n) + (b div n)) * n + (a mod n) + (b mod n)) mod n\"\n    by simp\n  also have \"... = ((a mod n) + (b mod n)) mod n\"\n  proof -\n    have \"((a div n) + (b div n)) * n mod n = 0\" \n      using assms by auto\n    then show ?thesis \n      by (metis calculation mod_add_eq)\n  qed\n  finally show ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "algebraic_manipulationV4": {"skill_name": "algebraic_manipulationV4", "marker": "lemma algebraic_manipulation:\n  fixes x y z :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes x y z :: real\n  shows \"(x + y)^2 = x^2 + 2 * x * y + y^2\"\nproof -\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" \n    by sos\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_eq_n_dimensionsV4": {"skill_name": "square_eq_n_dimensionsV4", "marker": "lemma square_eq_n_dimensions:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\" and \"\\<forall>i. a!i = b!i\"\n  shows \"(\\<Sum>i. a!i^2) = (\\<Sum>i. b!i^2)\"\nproof -\n  have \"(\\<Sum>i. a!i^2) = (\\<Sum>i. (b!i)^2)\"\n    by (metis assms(2) sum.cong)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_eq_n_dimensions:\n  fixes a b :: \"real list\"\n  assumes \"length a = length b\" and \"\\<forall>i. a!i = b!i\"\n  shows \"(\\<Sum>i. a!i^2) = (\\<Sum>i. b!i^2)\"\nproof -\n  have \"(\\<Sum>i. a!i^2) = (\\<Sum>i. (b!i)^2)\"\n    by (metis assms(2) sum.cong)\n  thus ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "square_eq_n_dimensionalV3": {"skill_name": "square_eq_n_dimensionalV3", "marker": "lemma square_eq_n_dimensional:\n  fixes a b :: \"real list\"\n  assumes \"length a = n\" and \"length b = n\" and \"a = b\"\n  shows \"sum (\\<lambda>i. a ! i ^ 2) {0 ..< n} = sum (\\<lambda>i. b ! i ^ 2) {0 ..< n}\"\nproof -\n  have \"sum (\\<lambda>i. a ! i ^ 2) {0 ..< n} = sum (\\<lambda>i. (b ! i) ^ 2) {0 ..< n}\"\n    using assms(3) by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_eq_n_dimensional:\n  fixes a b :: \"real list\"\n  assumes \"length a = n\" and \"length b = n\" and \"a = b\"\n  shows \"sum (\\<lambda>i. a ! i ^ 2) {0 ..< n} = sum (\\<lambda>i. b ! i ^ 2) {0 ..< n}\"\nproof -\n  have \"sum (\\<lambda>i. a ! i ^ 2) {0 ..< n} = sum (\\<lambda>i. (b ! i) ^ 2) {0 ..< n}\"\n    using assms(3) by auto\n  thus ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "square_eq_generalV3": {"skill_name": "square_eq_generalV3", "marker": "lemma square_eq_general:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 = b^2 \\<longleftrightarrow> (a - b) * (a + b) = 0\" by sos\n  also have \"... \\<longleftrightarrow> a - b = 0 \\<or> a + b = 0\" by (simp add: mult_eq_0_iff)\n  also have \"... \\<longleftrightarrow> a = b \\<or> a = -b\" by linarith\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_eq_general:\n  fixes a b :: real\n  shows \"a^2 = b^2 \\<longleftrightarrow> a = b \\<or> a = -b\"\nproof -\n  have \"a^2 = b^2 \\<longleftrightarrow> (a - b) * (a + b) = 0\" by sos\n  also have \"... \\<longleftrightarrow> a - b = 0 \\<or> a + b = 0\" by (simp add: mult_eq_0_iff)\n  also have \"... \\<longleftrightarrow> a = b \\<or> a = -b\" by linarith\n  finally show ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "square_eq_with_assumption": {"skill_name": "square_eq_with_assumption", "marker": "lemma square_eq_with_assumption:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by (simp add: square_eq_general)", "description": "-", "full_code": "lemma square_eq_general:\n  fixes a b :: real\n  shows \"a^2 - b^2 = (a - b) * (a + b)\"\n  by sos\n\nlemma square_eq_with_assumption:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by (simp add: square_eq_general)", "origin": "square_eq", "update_count": 0}, "mod4_cases_extendedV4": {"skill_name": "mod4_cases_extendedV4", "marker": "lemma mod4_cases_extended:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"0 \\<le> a mod 4\" by auto\n  moreover have \"a mod 4 < 4\" by auto\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_cases_extended:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\"\nproof -\n  have \"0 \\<le> a mod 4\" by auto\n  moreover have \"a mod 4 < 4\" by auto\n  ultimately show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "sqrt_squareV2": {"skill_name": "sqrt_squareV2", "marker": "lemma sqrt_square:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt (x^2) = x\"\nproof -\n  have \"sqrt (x^2) = sqrt (x^2) * 1\" by simp\n  also have \"... = x\" using assms by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_square:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt (x^2) = x\"\nproof -\n  have \"sqrt (x^2) = sqrt (x^2) * 1\" by simp\n  also have \"... = x\" using assms by auto\n  finally show ?thesis by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "floor_propertiesV4": {"skill_name": "floor_propertiesV4", "marker": "lemma floor_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  obtain n :: int where \"floor x = n\" by auto\n  have \"n \\<le> x\" using `floor x = n` by auto\n  have \"x < n + 1\" using `floor x = n` by auto\n  hence \"n + 1 \\<le> x + 1\" by (smt (verit) \\<open>real_of_int n \\<le> x\\<close> add_mono_thms_linordered_semiring(2) of_int_1 of_int_add)\n  also have \"x + 1 < n + 2\" by (smt (verit) \\<open>x < real_of_int (n + 1)\\<close> add_le_imp_le_right int_le_real_less)\n  finally have \"floor (x + 1) = n + 1\" \n    by (metis \\<open>\\<lfloor>x\\<rfloor> = n\\<close> add.commute floor_add one_add_floor) \n  thus \"floor (x + 1) = floor x + 1\" \n    using `floor x = n` by auto\nqed", "description": "-", "full_code": "lemma floor_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  obtain n :: int where \"floor x = n\" by auto\n  have \"n \\<le> x\" using `floor x = n` by auto\n  have \"x < n + 1\" using `floor x = n` by auto\n  hence \"n + 1 \\<le> x + 1\" by (smt (verit) \\<open>real_of_int n \\<le> x\\<close> add_mono_thms_linordered_semiring(2) of_int_1 of_int_add)\n  also have \"x + 1 < n + 2\" by (smt (verit) \\<open>x < real_of_int (n + 1)\\<close> add_le_imp_le_right int_le_real_less)\n  finally have \"floor (x + 1) = n + 1\" \n    by (metis \\<open>\\<lfloor>x\\<rfloor> = n\\<close> add.commute floor_add one_add_floor) \n  thus \"floor (x + 1) = floor x + 1\" \n    using `floor x = n` by auto\nqed", "origin": "do_request", "update_count": 0}, "product_prime": {"skill_name": "product_prime", "marker": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * b\" using assms(1) by (metis Primes.prime_nat_def assms(2) comm_monoid_mult_class.mult_1 less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"p > b\" using assms(1) by simp\n    then have \"b = 1\" using assms(2) by (smt (verit) \\<open>1 < a\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > a * 1\" using assms(1) by (metis \\<open>1 < p\\<close> calculation comm_monoid_mult_class.mult_1 less_numeral_extra(4) mult.comm_neutral not_less_iff_gr_or_eq order.strict_trans)\n    then have \"p > a\" using assms(1) by simp\n    then have \"a = 1\" using assms(2) by (smt (verit) \\<open>1 < b\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * b\" using assms(1) by (metis Primes.prime_nat_def assms(2) comm_monoid_mult_class.mult_1 less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"p > b\" using assms(1) by simp\n    then have \"b = 1\" using assms(2) by (smt (verit) \\<open>1 < a\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > a * 1\" using assms(1) by (metis \\<open>1 < p\\<close> calculation comm_monoid_mult_class.mult_1 less_numeral_extra(4) mult.comm_neutral not_less_iff_gr_or_eq order.strict_trans)\n    then have \"p > a\" using assms(1) by simp\n    then have \"a = 1\" using assms(2) by (smt (verit) \\<open>1 < b\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "origin": "do_request", "update_count": 0}, "algebra_2varlineareqV2": {"skill_name": "algebra_2varlineareqV2", "marker": "theorem algebra_2varlineareq:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (a * 2 - b) / 1 \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a)\" using simplified_eq by auto\n  have e_value: \"e = a - (b - a)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq:\n  fixes x e :: complex\n  assumes h0 : \"x + e = a\"\n    and h1 : \"2 * x + e = b\"\n  shows \"e = (a * 2 - b) / 1 \\<and> x = (b - a) / 1\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = (b - a)\" using simplified_eq by auto\n  have e_value: \"e = a - (b - a)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "product_primeV2": {"skill_name": "product_primeV2", "marker": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>p > 1\\<close> nat_mult_eq_1_iff)\n    then have \"b = 1\" using assms(2) by (metis \\<open>1 < a\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>p > 1\\<close> nat_mult_eq_1_iff)\n    then have \"a = 1\" using assms(2) by (metis \\<open>1 < b\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>p > 1\\<close> nat_mult_eq_1_iff)\n    then have \"b = 1\" using assms(2) by (metis \\<open>1 < a\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>p > 1\\<close> nat_mult_eq_1_iff)\n    then have \"a = 1\" using assms(2) by (metis \\<open>1 < b\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "origin": "do_request", "update_count": 0}, "product_primeV3": {"skill_name": "product_primeV3", "marker": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"b = 1\" using assms(2) by (metis \\<open>1 < a\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"a = 1\" using assms(2) by (metis \\<open>1 < b\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"b = 1\" using assms(2) by (metis \\<open>1 < a\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"a = 1\" using assms(2) by (metis \\<open>1 < b\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_109_evolvedV5": {"skill_name": "mathd_algebra_109_evolvedV5", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b + c = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b + 0 = 12\" using h1 h2 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b + c = 12\"\n    and h1 : \"a = 4\"\n    and h2 : \"c = 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b + c = 12\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b + 0 = 12\" using h1 h2 eq by simp\n  have simplified: \"12 + 2*b = 12\" by (smt (verit) sub)\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "count_terms_cardinality": {"skill_name": "count_terms_cardinality", "marker": "lemma count_terms_cardinality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a..b-1} = b - a\" by (metis Suc_pred' assms bot_nat_0.extremum_strict card_atLeastAtMost zero_less_iff_neq_zero)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms_cardinality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a..b-1} = b - a\" by (metis Suc_pred' assms bot_nat_0.extremum_strict card_atLeastAtMost zero_less_iff_neq_zero)\n  thus ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "square_eq_n_dims": {"skill_name": "square_eq_n_dims", "marker": "lemma square_eq_n_dims:\n  fixes a b :: \"real list\" \n  assumes \"a = b\"\n  shows \"map (\\<lambda>x. x^2) a = map (\\<lambda>x. x^2) b\"\nproof -\n  have \"length a = length b\" using assms by auto\n  then show ?thesis\n    using assms by auto\nqed", "description": "-", "full_code": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_eq_n_dims:\n  fixes a b :: \"real list\" \n  assumes \"a = b\"\n  shows \"map (\\<lambda>x. x^2) a = map (\\<lambda>x. x^2) b\"\nproof -\n  have \"length a = length b\" using assms by auto\n  then show ?thesis\n    using assms by auto\nqed", "origin": "square_eq", "update_count": 0}, "square_eq_multiV3": {"skill_name": "square_eq_multiV3", "marker": "lemma square_eq_multi:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\" and \"(-a)^2 = (-b)^2\"\n  using assms by auto", "description": "-", "full_code": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_eq_multi:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\" and \"(-a)^2 = (-b)^2\"\n  using assms by auto", "origin": "square_eq", "update_count": 0}, "product_primeV4": {"skill_name": "product_primeV4", "marker": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"p > 1\" using assms(1) by simp\n    then have \"b < p\" using `a * b = p` and `a > 1` by (metis Primes.prime_nat_def assms(2) less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"b = 1\" using assms(2) by (smt (verit) \\<open>1 < a\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"p > 1\" using assms(1) by simp\n    then have \"a < p\" using `a * b = p` and `b > 1` by (metis calculation less_numeral_extra(4) not_less_iff_gr_or_eq order.strict_trans)\n    then have \"a = 1\" using assms(2) by (smt (verit) \\<open>1 < b\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"p > 1\" using assms(1) by simp\n    then have \"b < p\" using `a * b = p` and `a > 1` by (metis Primes.prime_nat_def assms(2) less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"b = 1\" using assms(2) by (smt (verit) \\<open>1 < a\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"p > 1\" using assms(1) by simp\n    then have \"a < p\" using `a * b = p` and `b > 1` by (metis calculation less_numeral_extra(4) not_less_iff_gr_or_eq order.strict_trans)\n    then have \"a = 1\" using assms(2) by (smt (verit) \\<open>1 < b\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "origin": "do_request", "update_count": 0}, "product_primeV5": {"skill_name": "product_primeV5", "marker": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"p > 1\" by (metis \\<open>1 < p\\<close>)\n    then have \"b < p\" using assms(1) by (metis Primes.prime_nat_def \\<open>1 < a\\<close> assms(2) less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"b = 1\" using assms(2) by (smt (verit) \\<open>1 < a\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"p > 1\" by (metis \\<open>1 < p\\<close>)\n    then have \"a < p\" using assms(1) by (metis \\<open>1 < b\\<close> calculation less_numeral_extra(4) not_less_iff_gr_or_eq order.strict_trans)\n    then have \"a = 1\" using assms(2) by (smt (verit) \\<open>1 < b\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"p > 1\" by (metis \\<open>1 < p\\<close>)\n    then have \"b < p\" using assms(1) by (metis Primes.prime_nat_def \\<open>1 < a\\<close> assms(2) less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"b = 1\" using assms(2) by (smt (verit) \\<open>1 < a\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"p > 1\" by (metis \\<open>1 < p\\<close>)\n    then have \"a < p\" using assms(1) by (metis \\<open>1 < b\\<close> calculation less_numeral_extra(4) not_less_iff_gr_or_eq order.strict_trans)\n    then have \"a = 1\" using assms(2) by (smt (verit) \\<open>1 < b\\<close> assms(1) less_numeral_extra(4) prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "origin": "do_request", "update_count": 0}, "product_primeV6": {"skill_name": "product_primeV6", "marker": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>p > 1\\<close> nat_mult_eq_1_iff)\n    then have \"b < p\" using assms(1) by (metis Primes.prime_nat_def \\<open>1 < a\\<close> assms(2) less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"b = 1\" using assms(2) by (metis \\<open>1 < a\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>p > 1\\<close> nat_mult_eq_1_iff)\n    then have \"a < p\" using assms(1) by (metis \\<open>1 < b\\<close> \\<open>1 < p\\<close> calculation less_numeral_extra(4) not_less_iff_gr_or_eq order.strict_trans)\n    then have \"a = 1\" using assms(2) by (metis \\<open>1 < b\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>p > 1\\<close> nat_mult_eq_1_iff)\n    then have \"b < p\" using assms(1) by (metis Primes.prime_nat_def \\<open>1 < a\\<close> assms(2) less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"b = 1\" using assms(2) by (metis \\<open>1 < a\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(1) by (metis \\<open>p > 1\\<close> nat_mult_eq_1_iff)\n    then have \"a < p\" using assms(1) by (metis \\<open>1 < b\\<close> \\<open>1 < p\\<close> calculation less_numeral_extra(4) not_less_iff_gr_or_eq order.strict_trans)\n    then have \"a = 1\" using assms(2) by (metis \\<open>1 < b\\<close> assms(1) dual_order.irrefl prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "origin": "do_request", "update_count": 0}, "linear_equation_substitutionV5": {"skill_name": "linear_equation_substitutionV5", "marker": "lemma linear_equation_substitution:\n  fixes a b c d :: real\n  assumes \"3 * a + 2 * b = c\" and \"a = d\"\n  shows \"2 * b = c - 3 * d\"\nproof -\n  have \"3 * a + 2 * b = c\" using assms(1) by simp\n  then have \"3 * d + 2 * b = c\" using assms(2) by simp\n  hence \"2 * b = c - 3 * d\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma linear_equation_substitution:\n  fixes a b c d :: real\n  assumes \"3 * a + 2 * b = c\" and \"a = d\"\n  shows \"2 * b = c - 3 * d\"\nproof -\n  have \"3 * a + 2 * b = c\" using assms(1) by simp\n  then have \"3 * d + 2 * b = c\" using assms(2) by simp\n  hence \"2 * b = c - 3 * d\" by simp\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sum_mod": {"skill_name": "sum_mod", "marker": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  let ?x = \"a mod 10\"\n  let ?y = \"b mod 10\"\n  have \"a = ?x + (a div 10) * 10\" and \"b = ?y + (b div 10) * 10\"\n    by auto\n  then have \"a + b = (?x + ?y) + ((a div 10) + (b div 10)) * 10\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((?x + ?y) + ((a div 10) + (b div 10)) * 10) mod 10\"\n    by presburger\n  also have \"... = (?x + ?y) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n    by auto\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  let ?x = \"a mod 10\"\n  let ?y = \"b mod 10\"\n  have \"a = ?x + (a div 10) * 10\" and \"b = ?y + (b div 10) * 10\"\n    by auto\n  then have \"a + b = (?x + ?y) + ((a div 10) + (b div 10)) * 10\"\n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = ((?x + ?y) + ((a div 10) + (b div 10)) * 10) mod 10\"\n    by presburger\n  also have \"... = (?x + ?y) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n    by auto\n  finally show ?thesis by presburger\nqed", "origin": "do_request", "update_count": 0}, "sum_modV2": {"skill_name": "sum_modV2", "marker": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a mod 10 = a - (a div 10) * 10\" by presburger\n  then have \"a = (a mod 10) + (a div 10) * 10\" by (simp add: algebra_simps)\n  have \"b mod 10 = b - (b div 10) * 10\" by presburger\n  then have \"b = (b mod 10) + (b div 10) * 10\" by (simp add: algebra_simps)\n  then have \"a + b = ((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10\" \n    using `a = (a mod 10) + (a div 10) * 10` by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10) mod 10\" \n    by (simp add: algebra_simps)\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\" \n    by presburger\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a mod 10 = a - (a div 10) * 10\" by presburger\n  then have \"a = (a mod 10) + (a div 10) * 10\" by (simp add: algebra_simps)\n  have \"b mod 10 = b - (b div 10) * 10\" by presburger\n  then have \"b = (b mod 10) + (b div 10) * 10\" by (simp add: algebra_simps)\n  then have \"a + b = ((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10\" \n    using `a = (a mod 10) + (a div 10) * 10` by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10) mod 10\" \n    by (simp add: algebra_simps)\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\" \n    by presburger\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sum_modV3": {"skill_name": "sum_modV3", "marker": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a mod 10 = a - (a div 10) * 10\" by presburger\n  hence \"a = (a mod 10) + (a div 10) * 10\" by (simp add: algebra_simps)\n  have \"b mod 10 = b - (b div 10) * 10\" by presburger\n  hence \"b = (b mod 10) + (b div 10) * 10\" by (simp add: algebra_simps)\n  then have \"a + b = ((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10\"\n    using `a = (a mod 10) + (a div 10) * 10` by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10) mod 10\"\n    by (simp add: algebra_simps)\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\"\n    by presburger\n  thus ?thesis by presburger\nqed", "description": "-", "full_code": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a mod 10 = a - (a div 10) * 10\" by presburger\n  hence \"a = (a mod 10) + (a div 10) * 10\" by (simp add: algebra_simps)\n  have \"b mod 10 = b - (b div 10) * 10\" by presburger\n  hence \"b = (b mod 10) + (b div 10) * 10\" by (simp add: algebra_simps)\n  then have \"a + b = ((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10\"\n    using `a = (a mod 10) + (a div 10) * 10` by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10) mod 10\"\n    by (simp add: algebra_simps)\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\"\n    by presburger\n  thus ?thesis by presburger\nqed", "origin": "do_request", "update_count": 0}, "sum_modV4": {"skill_name": "sum_modV4", "marker": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\n  by presburger", "description": "-", "full_code": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\n  by presburger", "origin": "do_request", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eextended": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eextended", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eextended:\n  fixes x y e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + y = 3\"\n    and h2 : \"y = e\"  \n  shows \"e = 11 \\<and> x = (-4) \\<and> y = 11\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by (metis h2 one_plus_BitM or_not_num_neg.simps(2) uminus_add_conv_diff)\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  have y_value: \"y = e\" using h2 e_value by simp\n  show ?thesis using x_value e_value y_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eextended:\n  fixes x y e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + y = 3\"\n    and h2 : \"y = e\"  \n  shows \"e = 11 \\<and> x = (-4) \\<and> y = 11\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by (metis h2 one_plus_BitM or_not_num_neg.simps(2) uminus_add_conv_diff)\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  have y_value: \"y = e\" using h2 e_value by simp\n  show ?thesis using x_value e_value y_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_general": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_general", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_general:\n  fixes x y :: complex\n  assumes h0 : \"x + y = a\"          \n    and h1 : \"2 * x + y = b\"        \n  shows \"y = a - x \\<and> x = (b - a) / 1\" \nproof -\n  have y_eq: \"y = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 y_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = b - a\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have y_value: \"y = a - (b - a)\" using y_eq x_value by simp\n  show ?thesis using x_value y_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_general:\n  fixes x y :: complex\n  assumes h0 : \"x + y = a\"          \n    and h1 : \"2 * x + y = b\"        \n  shows \"y = a - x \\<and> x = (b - a) / 1\" \nproof -\n  have y_eq: \"y = a - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 y_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = b - a\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have y_value: \"y = a - (b - a)\" using y_eq x_value by simp\n  show ?thesis using x_value y_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "product_even_odd": {"skill_name": "product_even_odd", "marker": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  have \"even a\" using assms(1) by auto\n  then obtain k where \"a = 2 * k\" by (metis evenE)\n  have \"odd b\" using assms(2) by auto\n  then obtain m where \"b = 2 * m + 1\" by (metis oddE)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  then have \"a * b = 2 * (k * (2 * m + 1))\" \n    by (simp add: algebra_simps)\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  have \"even a\" using assms(1) by auto\n  then obtain k where \"a = 2 * k\" by (metis evenE)\n  have \"odd b\" using assms(2) by auto\n  then obtain m where \"b = 2 * m + 1\" by (metis oddE)\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` `b = 2 * m + 1` by simp\n  then have \"a * b = 2 * (k * (2 * m + 1))\" \n    by (simp add: algebra_simps)\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "chinese_remainder_theorem": {"skill_name": "chinese_remainder_theorem", "marker": "lemma chinese_remainder_theorem:\n  fixes a b c d :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n    and \"x mod a = b\" \"x mod c = d\"\n  shows \"\\<exists>k. x = b + a * k\"\nproof -\n  obtain k where \"x = b + a * k\" \n    using assms(5) by (metis mod_div_mult_eq mult.commute)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma chinese_remainder_theorem:\n  fixes a b c d :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n    and \"x mod a = b\" \"x mod c = d\"\n  shows \"\\<exists>k. x = b + a * k\"\nproof -\n  obtain k where \"x = b + a * k\" \n    using assms(5) by (metis mod_div_mult_eq mult.commute)\n  then show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "chinese_remainder_theoremV2": {"skill_name": "chinese_remainder_theoremV2", "marker": "lemma chinese_remainder_theorem:\n  fixes a b c d x :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n    and \"x mod a = b\" \"x mod c = d\"\n  shows \"\\<exists>k. x = b + a * k\"\nproof -\n  let ?k = \"x div a\"\n  have \"x = a * ?k + (x mod a)\" \n    by auto\n  then have \"x = a * ?k + b\" using assms(5) by simp\n  thus ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma chinese_remainder_theorem:\n  fixes a b c d x :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n    and \"x mod a = b\" \"x mod c = d\"\n  shows \"\\<exists>k. x = b + a * k\"\nproof -\n  let ?k = \"x div a\"\n  have \"x = a * ?k + (x mod a)\" \n    by auto\n  then have \"x = a * ?k + b\" using assms(5) by simp\n  thus ?thesis by (auto simp: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "chinese_remainder_theoremV3": {"skill_name": "chinese_remainder_theoremV3", "marker": "lemma chinese_remainder_theorem:\n  fixes a b c d x :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n    and \"x mod a = b\" \"x mod c = d\"\n  shows \"\\<exists>k. x = b + a * k\"\nproof -\n  have \"x mod a = b\" by (simp add: assms(5))\n  have \"x mod c = d\" by (simp add: assms(6))\n  let ?k = \"x div a\"\n  have \"x = a * ?k + (x mod a)\" by auto\n  also have \"... = a * ?k + b\" using `x mod a = b` by simp\n  finally have \"x = b + a * ?k\" by simp\n  have \"?k = x div a\" by simp\n  then show \"\\<exists>k. x = b + a * k\" by (metis \\<open>x = b + a * (x div a)\\<close>)\nqed", "description": "-", "full_code": "lemma chinese_remainder_theorem:\n  fixes a b c d x :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n    and \"x mod a = b\" \"x mod c = d\"\n  shows \"\\<exists>k. x = b + a * k\"\nproof -\n  have \"x mod a = b\" by (simp add: assms(5))\n  have \"x mod c = d\" by (simp add: assms(6))\n  let ?k = \"x div a\"\n  have \"x = a * ?k + (x mod a)\" by auto\n  also have \"... = a * ?k + b\" using `x mod a = b` by simp\n  finally have \"x = b + a * ?k\" by simp\n  have \"?k = x div a\" by simp\n  then show \"\\<exists>k. x = b + a * k\" by (metis \\<open>x = b + a * (x div a)\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "square_eq_in_n_dimensions": {"skill_name": "square_eq_in_n_dimensions", "marker": "lemma square_eq_in_n_dimensions:\n  fixes a b :: \"real set\"\n  assumes \"a = b\"\n  shows \"(\\<Sum>x\\<in>a. x^2) = (\\<Sum>x\\<in>b. x^2)\"\n  using assms by auto", "description": "-", "full_code": "lemma square_eq_in_n_dimensions:\n  fixes a b :: \"real set\"\n  assumes \"a = b\"\n  shows \"(\\<Sum>x\\<in>a. x^2) = (\\<Sum>x\\<in>b. x^2)\"\n  using assms by auto", "origin": "square_eq", "update_count": 0}, "real_number_propertiesV4": {"skill_name": "real_number_propertiesV4", "marker": "lemma real_number_properties:\n  fixes x y z :: real\n  assumes \"x = y\"\n  shows \"x + z = y + z\"\nproof -\n  have \"x + z = y + z\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma real_number_properties:\n  fixes x y z :: real\n  assumes \"x = y\"\n  shows \"x + z = y + z\"\nproof -\n  have \"x + z = y + z\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "product_even_oddV2": {"skill_name": "product_even_oddV2", "marker": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\n  by (metis assms(1) even_mult_iff)", "description": "-", "full_code": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\n  by (metis assms(1) even_mult_iff)", "origin": "do_request", "update_count": 0}, "product_even_oddV3": {"skill_name": "product_even_oddV3", "marker": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  have \"even a\" using assms(1) by auto\n  have \"odd b\" using assms(2) by auto\n  obtain k where \"a = 2 * k\" using evenE[of a] by (metis assms(1))\n  obtain m where \"b = 2 * m + 1\" using oddE[of b] by (metis assms(2))\n  then have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` by simp\n  then have \"a * b = 2 * k * 2 * m + 2 * k\" by (simp add: distrib_left)\n  then have \"a * b = 2 * (k * (2 * m) + k)\" by (simp add: algebra_simps)\n  thus \"even (a * b)\" by auto\nqed", "description": "-", "full_code": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  have \"even a\" using assms(1) by auto\n  have \"odd b\" using assms(2) by auto\n  obtain k where \"a = 2 * k\" using evenE[of a] by (metis assms(1))\n  obtain m where \"b = 2 * m + 1\" using oddE[of b] by (metis assms(2))\n  then have \"a * b = (2 * k) * (2 * m + 1)\" \n    using `a = 2 * k` by simp\n  then have \"a * b = 2 * k * 2 * m + 2 * k\" by (simp add: distrib_left)\n  then have \"a * b = 2 * (k * (2 * m) + k)\" by (simp add: algebra_simps)\n  thus \"even (a * b)\" by auto\nqed", "origin": "do_request", "update_count": 0}, "product_even_oddV4": {"skill_name": "product_even_oddV4", "marker": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  have \"even a\" using assms(1) by assumption\n  hence \"\\<exists>k. a = 2 * k\" by (metis evenE)\n  then obtain k where \"a = 2 * k\" by auto\n  have \"odd b\" using assms(2) by assumption\n  hence \"\\<exists>m. b = 2 * m + 1\" by (metis oddE)\n  then obtain m where \"b = 2 * m + 1\" by auto\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" \n    by (simp add: distrib_left)\n  then have \"a * b = 2 * (k * (2 * m) + k)\" \n    by (simp add: ring_distribs)\n  thus \"even (a * b)\" \n    by auto\nqed", "description": "-", "full_code": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"even a\" \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  have \"even a\" using assms(1) by assumption\n  hence \"\\<exists>k. a = 2 * k\" by (metis evenE)\n  then obtain k where \"a = 2 * k\" by auto\n  have \"odd b\" using assms(2) by assumption\n  hence \"\\<exists>m. b = 2 * m + 1\" by (metis oddE)\n  then obtain m where \"b = 2 * m + 1\" by auto\n  have \"a * b = (2 * k) * (2 * m + 1)\" \n    by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m) + 2 * k\" \n    by (simp add: distrib_left)\n  then have \"a * b = 2 * (k * (2 * m) + k)\" \n    by (simp add: ring_distribs)\n  thus \"even (a * b)\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "mod4_properties": {"skill_name": "mod4_properties", "marker": "lemma mod4_properties:\n  fixes n :: nat\n  shows \"n mod 4 < 4\"\nproof -\n  have \"n mod 4 = 0 \\<or> n mod 4 = 1 \\<or> n mod 4 = 2 \\<or> n mod 4 = 3\" \n    by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_properties:\n  fixes n :: nat\n  shows \"n mod 4 < 4\"\nproof -\n  have \"n mod 4 = 0 \\<or> n mod 4 = 1 \\<or> n mod 4 = 2 \\<or> n mod 4 = 3\" \n    by auto\n  then show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "square_eq_diff": {"skill_name": "square_eq_diff", "marker": "lemma square_eq_diff:\n  fixes a b :: real\n  shows \"(a - b) * (a + b) = a^2 - b^2\"\n  by sos", "description": "-", "full_code": "lemma square_eq_diff:\n  fixes a b :: real\n  shows \"(a - b) * (a + b) = a^2 - b^2\"\n  by sos", "origin": "square_eq", "update_count": 0}, "mod_squareV2": {"skill_name": "mod_squareV2", "marker": "lemma mod_square:\n  fixes x :: nat\n  shows \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\nproof -\n  let ?d = \"x mod 10\"\n  have \"x = 10 * (x div 10) + ?d\" by auto\n  then show \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\n  proof -\n    have \"x^2 = (10 * (x div 10) + ?d)^2\"\n      by (simp add: algebra_simps)\n    also have \"... = (10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?d + ?d^2\"\n      by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n    also have \"... = 100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2\" \n      by (simp add: power2_eq_square)\n    finally have \"x^2 = 100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2\" .\n    hence \"x^2 mod 10 = (100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2) mod 10\" \n      by simp\n    then have \"x^2 mod 10 = (?d^2 mod 10)\" \n      by (metis power_mod)\n    moreover have \"?d^2 mod 10 = (?d)^2 mod 10\" \n      by simp\n    ultimately show \"(x^2) mod 10 = (x mod 10)^2 mod 10\" \n      by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes x :: nat\n  shows \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\nproof -\n  let ?d = \"x mod 10\"\n  have \"x = 10 * (x div 10) + ?d\" by auto\n  then show \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\n  proof -\n    have \"x^2 = (10 * (x div 10) + ?d)^2\"\n      by (simp add: algebra_simps)\n    also have \"... = (10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?d + ?d^2\"\n      by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n    also have \"... = 100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2\" \n      by (simp add: power2_eq_square)\n    finally have \"x^2 = 100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2\" .\n    hence \"x^2 mod 10 = (100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2) mod 10\" \n      by simp\n    then have \"x^2 mod 10 = (?d^2 mod 10)\" \n      by (metis power_mod)\n    moreover have \"?d^2 mod 10 = (?d)^2 mod 10\" \n      by simp\n    ultimately show \"(x^2) mod 10 = (x mod 10)^2 mod 10\" \n      by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mod_squareV3": {"skill_name": "mod_squareV3", "marker": "lemma mod_square:\n  fixes x :: nat\n  shows \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\nproof -\n  let ?d = \"x mod 10\"\n  have \"x = 10 * (x div 10) + ?d\" by auto\n  then have \"x^2 = (10 * (x div 10) + ?d)^2\" by simp\n  also have \"... = (10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?d + ?d^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2\" by (simp add: power2_eq_square)\n  finally have \"x^2 = 100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2\" .\n  then have \"x^2 mod 10 = (100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2) mod 10\" by simp\n  then have \"x^2 mod 10 = (?d^2 mod 10)\" by (metis power_mod)\n  moreover have \"?d^2 mod 10 = (?d)^2 mod 10\" by simp\n  ultimately show \"(x^2) mod 10 = (x mod 10)^2 mod 10\" by simp\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes x :: nat\n  shows \"(x^2) mod 10 = (x mod 10)^2 mod 10\"\nproof -\n  let ?d = \"x mod 10\"\n  have \"x = 10 * (x div 10) + ?d\" by auto\n  then have \"x^2 = (10 * (x div 10) + ?d)^2\" by simp\n  also have \"... = (10 * (x div 10))^2 + 2 * (10 * (x div 10)) * ?d + ?d^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2\" by (simp add: power2_eq_square)\n  finally have \"x^2 = 100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2\" .\n  then have \"x^2 mod 10 = (100 * (x div 10)^2 + 20 * (x div 10) * ?d + ?d^2) mod 10\" by simp\n  then have \"x^2 mod 10 = (?d^2 mod 10)\" by (metis power_mod)\n  moreover have \"?d^2 mod 10 = (?d)^2 mod 10\" by simp\n  ultimately show \"(x^2) mod 10 = (x mod 10)^2 mod 10\" by simp\nqed", "origin": "do_request", "update_count": 0}, "sum_terms_count_generalizedV5": {"skill_name": "sum_terms_count_generalizedV5", "marker": "lemma sum_terms_count_generalized:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\n  by (metis (no_types, lifting) atLeastLessThan_iff card_atLeastLessThan)", "description": "-", "full_code": "lemma sum_terms_count_generalized:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\n  by (metis (no_types, lifting) atLeastLessThan_iff card_atLeastLessThan)", "origin": "sum_terms_count", "update_count": 0}, "square_expansion_combined": {"skill_name": "square_expansion_combined", "marker": "lemma square_expansion_combined:\n  fixes x y z :: real\n  shows \"(x + y - z)^2 = (x - z + y)^2\"\nproof -\n  have \"(x + y - z)^2 = (x - z + y)^2\" by (simp add: algebra_simps)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_expansion_combined:\n  fixes x y z :: real\n  shows \"(x + y - z)^2 = (x - z + y)^2\"\nproof -\n  have \"(x + y - z)^2 = (x - z + y)^2\" by (simp add: algebra_simps)\n  thus ?thesis by auto\nqed", "origin": "square_expansion", "update_count": 0}, "sum_terms_count_non_empty": {"skill_name": "sum_terms_count_non_empty", "marker": "lemma sum_terms_count_non_empty:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} > 0\"\nproof -\n  have \"b - a > 0\" using assms by auto\n  thus ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sum_terms_count:\n  shows \"card {19::nat..<92} = 73\"\n  by auto\n\nlemma sum_terms_count_non_empty:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} > 0\"\nproof -\n  have \"b - a > 0\" using assms by auto\n  thus ?thesis using assms by auto\nqed", "origin": "sum_terms_count", "update_count": 0}, "square_expansion_with_coefficientsV2": {"skill_name": "square_expansion_with_coefficientsV2", "marker": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(a * c - b * d)^2 = (a^2 * c^2) - 2 * (a * c) * (b * d) + (b^2 * d^2)\"\nproof -\n  have \"(a * c - b * d)^2 = (a * c)^2 - 2 * (a * c) * (b * d) + (b * d)^2\"\n    by sos\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion_with_coefficients:\n  fixes a b c d :: real\n  shows \"(a * c - b * d)^2 = (a^2 * c^2) - 2 * (a * c) * (b * d) + (b^2 * d^2)\"\nproof -\n  have \"(a * c - b * d)^2 = (a * c)^2 - 2 * (a * c) * (b * d) + (b * d)^2\"\n    by sos\n  thus ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_coefficientsV3": {"skill_name": "square_expansion_with_coefficientsV3", "marker": "lemma square_expansion_with_coefficients:\n  fixes m n x y :: real\n  shows \"(m*x - n*y)^2 = m^2 * x^2 - 2 * m * n * x * y + n^2 * y^2\"\nproof -\n  have \"(m*x - n*y) * (m*x - n*y) = (m*x)^2 - 2*(m*x)*(n*y) + (n*y)^2\" by sos\n  thus ?thesis by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_expansion_with_coefficients:\n  fixes m n x y :: real\n  shows \"(m*x - n*y)^2 = m^2 * x^2 - 2 * m * n * x * y + n^2 * y^2\"\nproof -\n  have \"(m*x - n*y) * (m*x - n*y) = (m*x)^2 - 2*(m*x)*(n*y) + (n*y)^2\" by sos\n  thus ?thesis by (simp add: power2_eq_square)\nqed", "origin": "square_expansion", "update_count": 0}, "square_expansion_with_var": {"skill_name": "square_expansion_with_var", "marker": "lemma square_expansion_with_var:\n  fixes a b c d :: real\n  shows \"(a - b)^2 + (c - d)^2 = a^2 - 2*a*b + b^2 + c^2 - 2*c*d + d^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by (simp add: square_expansion_general)\n  moreover have \"(c - d)^2 = c^2 - 2*c*d + d^2\" by (simp add: square_expansion_general)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion_general:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y) * (x - y) = x * x - 2 * x * y + y * y\" by sos\n  thus ?thesis by sos\nqed\n\nlemma square_expansion_with_var:\n  fixes a b c d :: real\n  shows \"(a - b)^2 + (c - d)^2 = a^2 - 2*a*b + b^2 + c^2 - 2*c*d + d^2\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by (simp add: square_expansion_general)\n  moreover have \"(c - d)^2 = c^2 - 2*c*d + d^2\" by (simp add: square_expansion_general)\n  ultimately show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "mathd_algebra_109_evolvedV6": {"skill_name": "mathd_algebra_109_evolvedV6", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * a + 2 * b = 12\" using eq by simp\n  have sub_a: \"3 * 4 + 2 * b = 12\" using h1 sub by simp\n  have simplified: \"12 + 2*b = 12\" using sub_a by simp\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  have eq: \"3*a + 2*b = 12\" using h0 by simp\n  have sub: \"3 * a + 2 * b = 12\" using eq by simp\n  have sub_a: \"3 * 4 + 2 * b = 12\" using h1 sub by simp\n  have simplified: \"12 + 2*b = 12\" using sub_a by simp\n  have isolate: \"2*b = 12 - 12\" using simplified by simp\n  have solution: \"b = 0\" using isolate by simp\n  thus ?thesis by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "square_expansionV10": {"skill_name": "square_expansionV10", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + -y)^2\" by simp\n  also have \"... = x^2 + 2 * x * (-y) + (-y)^2\" by sos\n  also have \"... = x^2 - 2 * x * y + y^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + -y)^2\" by simp\n  also have \"... = x^2 + 2 * x * (-y) + (-y)^2\" by sos\n  also have \"... = x^2 - 2 * x * y + y^2\" by (simp add: power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "absolute_value_triangle_inequality": {"skill_name": "absolute_value_triangle_inequality", "marker": "lemma absolute_value_triangle_inequality:\n  fixes a b :: real\n  assumes \"abs(a) + abs(b) < c\"\n  shows \"a + b < c\" and \"a + b > -c\"\nproof -\n  have \"a < c - abs(b)\" and \"a > -c + abs(b)\" \n    using assms by auto\n  then show \"a + b < c\" and \"a + b > -c\" by auto\nqed", "description": "-", "full_code": "lemma absolute_value_triangle_inequality:\n  fixes a b :: real\n  assumes \"abs(a) + abs(b) < c\"\n  shows \"a + b < c\" and \"a + b > -c\"\nproof -\n  have \"a < c - abs(b)\" and \"a > -c + abs(b)\" \n    using assms by auto\n  then show \"a + b < c\" and \"a + b > -c\" by auto\nqed", "origin": "square_expansion", "update_count": 0}, "square_difference_expansion": {"skill_name": "square_difference_expansion", "marker": "lemma square_difference_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + -y)^2\" by simp\n  then have \"... = x^2 + 2 * x * (-y) + (-y)^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  then show ?thesis by (simp add: power2_eq_square algebra_simps)\nqed", "description": "-", "full_code": "lemma square_difference_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + -y)^2\" by simp\n  then have \"... = x^2 + 2 * x * (-y) + (-y)^2\" \n    by (simp add: power2_eq_square algebra_simps)\n  then show ?thesis by (simp add: power2_eq_square algebra_simps)\nqed", "origin": "square_expansion", "update_count": 0}, "mod4_cases_extendedV5": {"skill_name": "mod4_cases_extendedV5", "marker": "lemma mod4_cases_extended:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3 \\<or> a mod 4 = -1 \\<or> a mod 4 = -2 \\<or> a mod 4 = -3\"\nproof -\n  have \"a mod 4 = (a mod 4 + 4) mod 4\" by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod4_cases_extended:\n  fixes a :: int\n  shows \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3 \\<or> a mod 4 = -1 \\<or> a mod 4 = -2 \\<or> a mod 4 = -3\"\nproof -\n  have \"a mod 4 = (a mod 4 + 4) mod 4\" by auto\n  then show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "mod4_propertiesV2": {"skill_name": "mod4_propertiesV2", "marker": "lemma mod4_properties:\n  fixes a b :: int\n  shows \"a mod 4 = b mod 4 \\<Longrightarrow> (a - b) mod 4 = 0\"\nproof -\n  assume \"a mod 4 = b mod 4\"\n  then obtain k where \"a = 4 * k + b mod 4\" by (metis add.commute mod_eqE mod_mod_trivial)\n  thus \"(a - b) mod 4 = 0\" by presburger\nqed", "description": "-", "full_code": "lemma mod4_properties:\n  fixes a b :: int\n  shows \"a mod 4 = b mod 4 \\<Longrightarrow> (a - b) mod 4 = 0\"\nproof -\n  assume \"a mod 4 = b mod 4\"\n  then obtain k where \"a = 4 * k + b mod 4\" by (metis add.commute mod_eqE mod_mod_trivial)\n  thus \"(a - b) mod 4 = 0\" by presburger\nqed", "origin": "mod4_cases", "update_count": 0}, "mod_additionV6": {"skill_name": "mod_additionV6", "marker": "lemma mod_addition:\n  fixes a b n x y :: nat\n  assumes \"a mod n = x\" and \"b mod n = y\"\n  shows \"(a + b) mod n = (x + y) mod n\"\nproof -\n  from assms have \"a = x + (a div n) * n\" and \"b = y + (b div n) * n\"\n    by auto\n  then have \"a + b = (x + y) + ((a div n) + (b div n)) * n\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod n = ((x + y) + ((a div n) + (b div n)) * n) mod n\" \n    by simp\n  also have \"... = (x + y) mod n\" \n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b n x y :: nat\n  assumes \"a mod n = x\" and \"b mod n = y\"\n  shows \"(a + b) mod n = (x + y) mod n\"\nproof -\n  from assms have \"a = x + (a div n) * n\" and \"b = y + (b div n) * n\"\n    by auto\n  then have \"a + b = (x + y) + ((a div n) + (b div n)) * n\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod n = ((x + y) + ((a div n) + (b div n)) * n) mod n\" \n    by simp\n  also have \"... = (x + y) mod n\" \n    by (simp add: mod_add_eq)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "integer_distributionV7": {"skill_name": "integer_distributionV7", "marker": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\"\n  shows \"x \\<le> n \\<Longrightarrow> y \\<le> n\"\nproof -\n  assume hyp_x: \"x \\<le> n\"\n  have \"y = n - x\" using assms by simp\n  moreover have \"n - x \\<ge> 0\" using hyp_x by (simp add: nat_le_linear)\n  ultimately have \"y \\<le> n\" by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\"\n  shows \"x \\<le> n \\<Longrightarrow> y \\<le> n\"\nproof -\n  assume hyp_x: \"x \\<le> n\"\n  have \"y = n - x\" using assms by simp\n  moreover have \"n - x \\<ge> 0\" using hyp_x by (simp add: nat_le_linear)\n  ultimately have \"y \\<le> n\" by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "integer_distributionV8": {"skill_name": "integer_distributionV8", "marker": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\"\n  shows \"x \\<le> n \\<Longrightarrow> y \\<le> n\"\nproof -\n  assume \"x \\<le> n\"  \n  from assms have \"y = n - x\" by simp  \n  also have \"n - x \\<ge> 0\" using `x \\<le> n` by auto  \n  ultimately have \"y \\<le> n\" by (simp add: le_diff_eq)  \n  thus ?thesis by simp  \nqed", "description": "-", "full_code": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\"\n  shows \"x \\<le> n \\<Longrightarrow> y \\<le> n\"\nproof -\n  assume \"x \\<le> n\"  \n  from assms have \"y = n - x\" by simp  \n  also have \"n - x \\<ge> 0\" using `x \\<le> n` by auto  \n  ultimately have \"y \\<le> n\" by (simp add: le_diff_eq)  \n  thus ?thesis by simp  \nqed", "origin": "do_request", "update_count": 0}, "square_differenceV6": {"skill_name": "square_differenceV6", "marker": "lemma square_difference:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = x^2 - 2*x*y + y^2\" by sos\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma square_difference:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(x - y)^2 = x^2 - 2*x*y + y^2\" by sos\n  then show ?thesis by auto\nqed", "origin": "square_expansion", "update_count": 0}, "linear_combination_solution": {"skill_name": "linear_combination_solution", "marker": "theorem linear_combination_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_value\"  \n    and h2 : \"n \\<noteq> 0\"  \n  shows \"b = (p - m*a_value)/n\"\nproof -\n  have eq: \"m*a_value + n*b = p\" using h0 h1 by simp\n  have rearrange: \"n*b = p - m*a_value\" using eq by simp\n  then have solution: \"b = (p - m*a_value)/n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem linear_combination_solution:\n  fixes a b :: real\n  assumes h0 : \"m*a + n*b = p\"\n    and h1 : \"a = a_value\"  \n    and h2 : \"n \\<noteq> 0\"  \n  shows \"b = (p - m*a_value)/n\"\nproof -\n  have eq: \"m*a_value + n*b = p\" using h0 h1 by simp\n  have rearrange: \"n*b = p - m*a_value\" using eq by simp\n  then have solution: \"b = (p - m*a_value)/n\" by (metis h2 mult.commute nonzero_mult_div_cancel_right)\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "expression_nonnegV3": {"skill_name": "expression_nonnegV3", "marker": "lemma expression_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 \\<ge> 0\" by (simp add: nonnegativity_of_squares)\n  have \"x^2 \\<ge> 0\" by (simp add: nonnegativity_of_squares)\n  have \"y^2 \\<ge> 0\" by (simp add: nonnegativity_of_squares)\n  then have \"?E \\<ge> 1\" by sos\n  have \"?E = 1\" when \"x = 0\" and \"y = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma nonnegativity_of_squares:\n  fixes a b :: real\n  shows \"a^2 + b^2 \\<ge> 0\"\nproof -\n  have \"a^2 \\<ge> 0\" by auto\n  have \"b^2 \\<ge> 0\" by auto\n  then show ?thesis by auto\nqed\n\nlemma expression_nonneg:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 \\<ge> 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 \\<ge> 0\" by (simp add: nonnegativity_of_squares)\n  have \"x^2 \\<ge> 0\" by (simp add: nonnegativity_of_squares)\n  have \"y^2 \\<ge> 0\" by (simp add: nonnegativity_of_squares)\n  then have \"?E \\<ge> 1\" by sos\n  have \"?E = 1\" when \"x = 0\" and \"y = 0\" \n    using that by auto\n  thus ?thesis by sos\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "square_expansionV11": {"skill_name": "square_expansionV11", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(-y)^2 = y^2\" by simp\n  have \"(x - y)^2 = x^2 - 2 * x * y + y^2\" using power2_eq_square by (smt (verit) diff_add_eq power2_diff)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(-y)^2 = y^2\" by simp\n  have \"(x - y)^2 = x^2 - 2 * x * y + y^2\" using power2_eq_square by (smt (verit) diff_add_eq power2_diff)\n  thus ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "square_difference_expansionV2": {"skill_name": "square_difference_expansionV2", "marker": "lemma square_difference_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(-y)^2 = y^2\" by (simp add: power2_eq_square)\n  have \"(-2 * x * -y) = 2 * x * y\" by (simp add: algebra_simps)\n  show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_difference_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(-y)^2 = y^2\" by (simp add: power2_eq_square)\n  have \"(-2 * x * -y) = 2 * x * y\" by (simp add: algebra_simps)\n  show ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "linear_function_differenceV15": {"skill_name": "linear_function_differenceV15", "marker": "theorem linear_function_difference:\n  fixes a b x1 x2 :: real\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x2 - f x1 = d\"\n  shows \"f (x2 + k) - f x1 = d + (k * a)\"\nproof -\n  have \"f x2 - f x1 = (a * x2 + b) - (a * x1 + b)\" by (simp add: assms(1))\n  have \"f x2 - f x1 = a * x2 - a * x1\" by (smt (verit) \\<open>f x2 - f x1 = a * x2 + b - (a * x1 + b)\\<close>)\n  have \"f (x2 + k) - f x1 = (a * (x2 + k) + b) - (a * x1 + b)\" by (simp add: assms(1))\n  then have \"f (x2 + k) - f x1 = a * (x2 + k) - a * x1\" by (simp)\n  then have \"f (x2 + k) - f x1 = (a * x2 - a * x1) + (a * k)\" by (simp add: algebra_simps)\n  then show ?thesis using assms(2) by (metis \\<open>f x2 - f x1 = a * x2 - a * x1\\<close> add.commute mult.commute mult_delta_right)\nqed", "description": "-", "full_code": "theorem linear_function_difference:\n  fixes a b x1 x2 :: real\n  assumes \"\\<forall> x. f x = a * x + b\"\n    and \"f x2 - f x1 = d\"\n  shows \"f (x2 + k) - f x1 = d + (k * a)\"\nproof -\n  have \"f x2 - f x1 = (a * x2 + b) - (a * x1 + b)\" by (simp add: assms(1))\n  have \"f x2 - f x1 = a * x2 - a * x1\" by (smt (verit) \\<open>f x2 - f x1 = a * x2 + b - (a * x1 + b)\\<close>)\n  have \"f (x2 + k) - f x1 = (a * (x2 + k) + b) - (a * x1 + b)\" by (simp add: assms(1))\n  then have \"f (x2 + k) - f x1 = a * (x2 + k) - a * x1\" by (simp)\n  then have \"f (x2 + k) - f x1 = (a * x2 - a * x1) + (a * k)\" by (simp add: algebra_simps)\n  then show ?thesis using assms(2) by (metis \\<open>f x2 - f x1 = a * x2 - a * x1\\<close> add.commute mult.commute mult_delta_right)\nqed", "origin": "amc12b_2003_p9", "update_count": 0}, "integer_distributionV9": {"skill_name": "integer_distributionV9", "marker": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\"\n  proof -\n    have \"y = n - x\" using assms(1) by simp\n    then show \"x \\<le> n\" using assms(3) by (metis add.right_neutral assms(1) diff_is_0_eq dual_order.refl nle_le)\n  qed\n  have \"y \\<le> n\"\n  proof -\n    have \"x = n - y\" using assms(1) by simp\n    then show \"y \\<le> n\" using assms(2) by (metis add_0 assms(1) diff_is_0_eq nle_le order_refl)\n  qed\n  thus ?thesis by (metis \\<open>x \\<le> n\\<close>)\nqed", "description": "-", "full_code": "lemma integer_distribution:\n  fixes n :: nat\n  assumes \"x + y = n\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"x \\<le> n \\<and> y \\<le> n\"\nproof -\n  have \"x \\<le> n\"\n  proof -\n    have \"y = n - x\" using assms(1) by simp\n    then show \"x \\<le> n\" using assms(3) by (metis add.right_neutral assms(1) diff_is_0_eq dual_order.refl nle_le)\n  qed\n  have \"y \\<le> n\"\n  proof -\n    have \"x = n - y\" using assms(1) by simp\n    then show \"y \\<le> n\" using assms(2) by (metis add_0 assms(1) diff_is_0_eq nle_le order_refl)\n  qed\n  thus ?thesis by (metis \\<open>x \\<le> n\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "mod_n_casesV12": {"skill_name": "mod_n_casesV12", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>k. a mod n = k \\<and> (k < n)\"\nproof -\n  obtain k where \"a mod n = k\" by auto\n  then have \"k < n\" using assms by auto\n  then show ?thesis using `a mod n = k` by auto\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>k. a mod n = k \\<and> (k < n)\"\nproof -\n  obtain k where \"a mod n = k\" by auto\n  then have \"k < n\" using assms by auto\n  then show ?thesis using `a mod n = k` by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "mod_n_casesV13": {"skill_name": "mod_n_casesV13", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. r < n \\<and> (a mod n = r)\"\nproof -\n  have \"a mod n < n\" using assms by (simp add: mod_less)\n  then obtain r where \"a mod n = r\" by auto\n  thus ?thesis using `a mod n < n` by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff of_nat_less_iff zero_le_imp_eq_int)\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. r < n \\<and> (a mod n = r)\"\nproof -\n  have \"a mod n < n\" using assms by (simp add: mod_less)\n  then obtain r where \"a mod n = r\" by auto\n  thus ?thesis using `a mod n < n` by (metis Euclidean_Division.pos_mod_sign assms of_nat_0_less_iff of_nat_less_iff zero_le_imp_eq_int)\nqed", "origin": "mod4_cases", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_e_xeqn4_parametric": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_e_xeqn4_parametric", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_e_xeqn4_parametric:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 7 - x \\<and> x = (3 - e) / 2\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  show ?thesis using e_eq eq2_substituted by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_e_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed\n\ntheorem algebra_2varlineareq_xpeeq7_2xpeeq3_e_xeqn4_parametric:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 7 - x \\<and> x = (3 - e) / 2\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  show ?thesis using e_eq eq2_substituted by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_e_xeqn4_extended": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_e_xeqn4_extended", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_e_xeqn4_extended:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by auto\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_e_xeqn4:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed\n\ntheorem algebra_2varlineareq_xpeeq7_2xpeeq3_e_xeqn4_extended:\n  fixes x e :: real\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 11 \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (auto simp: field_simps)\n  have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 e_eq by simp\n  have simplified_eq: \"x + 7 = 3\" using eq2_substituted by simp\n  have x_value: \"x = -4\" using simplified_eq by auto\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  show ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_more_general": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_more_general", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_more_general:\n  fixes x e :: real\n  assumes h0 : \"x + e = a\" \n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / (2 - 1)\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = b - a\" using simplified_eq by (metis add.commute add_diff_cancel_right')\n  show ?thesis using x_value e_eq by auto\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_more_general:\n  fixes x e :: real\n  assumes h0 : \"x + e = a\" \n    and h1 : \"2 * x + e = b\"\n  shows \"e = a - x \\<and> x = (b - a) / (2 - 1)\"\nproof -\n  have e_eq: \"e = a - x\" using h0 by (simp add: field_simps)\n  have eq2_substituted: \"2 * x + (a - x) = b\" using h1 e_eq by simp\n  have simplified_eq: \"x + a = b\" using eq2_substituted by simp\n  have x_value: \"x = b - a\" using simplified_eq by (metis add.commute add_diff_cancel_right')\n  show ?thesis using x_value e_eq by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "prime_product": {"skill_name": "prime_product", "marker": "lemma prime_product:\n  fixes a b p :: nat\n  assumes \"prime p\" and \"p = a * b\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(1) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>p > 1\\<close> mult.comm_neutral)\n    then have \"b < p\" using assms(2) assms(1) by (metis Primes.prime_nat_def \\<open>1 < a\\<close> less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"b = 1\" using assms(1) by (metis \\<open>1 < a\\<close> assms(2) dual_order.irrefl prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>p > 1\\<close> mult.comm_neutral)\n    then have \"a < p\" using assms(2) assms(1) by (metis \\<open>1 < b\\<close> \\<open>1 < p\\<close> calculation less_numeral_extra(4) not_less_iff_gr_or_eq order.strict_trans)\n    then have \"a = 1\" using assms(1) by (metis \\<open>1 < b\\<close> assms(2) dual_order.irrefl prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(2) assms(1) prime_product)\nqed", "description": "-", "full_code": "lemma prime_product:\n  fixes a b p :: nat\n  assumes \"prime p\" and \"p = a * b\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(1) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>p > 1\\<close> mult.comm_neutral)\n    then have \"b < p\" using assms(2) assms(1) by (metis Primes.prime_nat_def \\<open>1 < a\\<close> less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"b = 1\" using assms(1) by (metis \\<open>1 < a\\<close> assms(2) dual_order.irrefl prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>p > 1\\<close> mult.comm_neutral)\n    then have \"a < p\" using assms(2) assms(1) by (metis \\<open>1 < b\\<close> \\<open>1 < p\\<close> calculation less_numeral_extra(4) not_less_iff_gr_or_eq order.strict_trans)\n    then have \"a = 1\" using assms(1) by (metis \\<open>1 < b\\<close> assms(2) dual_order.irrefl prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(2) assms(1) prime_product)\nqed", "origin": "do_request", "update_count": 0}, "prime_productV2": {"skill_name": "prime_productV2", "marker": "lemma prime_product:\n  fixes a b p :: nat\n  assumes \"prime p\" and \"p = a * b\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(1) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"b < p\" using assms(2) by (metis Primes.prime_nat_def \\<open>1 < a\\<close> assms(1) less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"b = 1\" using assms(1) by (smt (verit) \\<open>1 < a\\<close> assms(2) less_numeral_extra(4) prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"a < p\" using assms(2) by (metis \\<open>1 < b\\<close> \\<open>1 < p\\<close> calculation less_numeral_extra(4) not_less_iff_gr_or_eq order.strict_trans)\n    then have \"a = 1\" using assms(1) by (smt (verit) \\<open>1 < b\\<close> assms(2) less_numeral_extra(4) prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "description": "-", "full_code": "lemma prime_product:\n  fixes a b p :: nat\n  assumes \"prime p\" and \"p = a * b\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(1) by (metis prime_gt_1_nat)\n  {\n    assume \"a > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"b < p\" using assms(2) by (metis Primes.prime_nat_def \\<open>1 < a\\<close> assms(1) less_numeral_extra(4) mult.right_neutral prime_product)\n    then have \"b = 1\" using assms(1) by (smt (verit) \\<open>1 < a\\<close> assms(2) less_numeral_extra(4) prime_product)\n  }\n  moreover {\n    assume \"b > 1\"\n    then have \"a * b > 1 * 1\" using assms(2) by (metis \\<open>1 < p\\<close> mult.comm_neutral)\n    then have \"a < p\" using assms(2) by (metis \\<open>1 < b\\<close> \\<open>1 < p\\<close> calculation less_numeral_extra(4) not_less_iff_gr_or_eq order.strict_trans)\n    then have \"a = 1\" using assms(1) by (smt (verit) \\<open>1 < b\\<close> assms(2) less_numeral_extra(4) prime_product)\n  }\n  ultimately show \"a = 1 \\<or> b = 1\" by (metis Primes.prime_nat_def assms(1) assms(2) prime_product)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_eq_and_bound": {"skill_name": "sqrt_eq_and_bound", "marker": "lemma sqrt_eq_and_bound:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72 \\<and> x \\<ge> 0\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then have \"x = 81 - 9\" by simp\n  thus \"x = 72 \\<and> x \\<ge> 0\" by auto\nqed", "description": "-", "full_code": "lemma sqrt_eq_and_bound:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72 \\<and> x \\<ge> 0\"\nproof -\n  have \"x + 9 = 9^2\" using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"x + 9 = 81\" by simp\n  then have \"x = 81 - 9\" by simp\n  thus \"x = 72 \\<and> x \\<ge> 0\" by auto\nqed", "origin": "sqrt_eq", "update_count": 0}, "sqrt_eq_quadratic": {"skill_name": "sqrt_eq_quadratic", "marker": "lemma sqrt_eq_quadratic:\n  fixes a b c :: real\n  assumes \"sqrt (a*x^2 + b*x + c) = d\" \"d > 0\"\n  shows \"a*x^2 + b*x + c = d^2\"\nproof -\n  have \"a*x^2 + b*x + c = d^2\" using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq_quadratic:\n  fixes a b c :: real\n  assumes \"sqrt (a*x^2 + b*x + c) = d\" \"d > 0\"\n  shows \"a*x^2 + b*x + c = d^2\"\nproof -\n  have \"a*x^2 + b*x + c = d^2\" using assms by auto\n  thus ?thesis by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "add_mod": {"skill_name": "add_mod", "marker": "lemma add_mod:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  let ?a' = \"a mod m\"\n  let ?b' = \"b mod m\"\n  have \"a = (a div m) * m + ?a'\" by auto\n  have \"b = (b div m) * m + ?b'\" by auto\n  then have \"a + b = ((a div m) + (b div m)) * m + (?a' + ?b')\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((a div m + b div m) * m + (?a' + ?b')) mod m\" \n    by simp\n  also have \"... = (?a' + ?b') mod m\" \n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma add_mod:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  let ?a' = \"a mod m\"\n  let ?b' = \"b mod m\"\n  have \"a = (a div m) * m + ?a'\" by auto\n  have \"b = (b div m) * m + ?b'\" by auto\n  then have \"a + b = ((a div m) + (b div m)) * m + (?a' + ?b')\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = ((a div m + b div m) * m + (?a' + ?b')) mod m\" \n    by simp\n  also have \"... = (?a' + ?b') mod m\" \n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "add_modV2": {"skill_name": "add_modV2", "marker": "lemma add_mod:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = ?x + (a div m) * m\" by auto\n  have \"b = ?y + (b div m) * m\" by auto\n  then have \"a + b = (?x + (a div m) * m) + (?y + (b div m) * m)\" \n    by (simp add: algebra_simps)\n  then have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  hence \"(a + b) mod m = (?x + ?y) mod m\" \n    by (metis mod_add_eq)\n  thus ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma add_mod:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = ?x + (a div m) * m\" by auto\n  have \"b = ?y + (b div m) * m\" by auto\n  then have \"a + b = (?x + (a div m) * m) + (?y + (b div m) * m)\" \n    by (simp add: algebra_simps)\n  then have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  hence \"(a + b) mod m = (?x + ?y) mod m\" \n    by (metis mod_add_eq)\n  thus ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "add_modV3": {"skill_name": "add_modV3", "marker": "lemma add_mod:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis \n    by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = (a div m) * m + ?x\" by auto\n  have \"b = (b div m) * m + ?y\" by auto\n  have \"a + b = ((a div m) * m + ?x) + ((b div m) * m + ?y)\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\"\n    by (simp add: algebra_simps)\n  thus ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma add_mod:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof (cases \"m = 0\")\n  case True\n  then show ?thesis \n    by (metis mod_by_0)\nnext\n  case False\n  then have \"m > 0\" by simp\n  let ?x = \"a mod m\"\n  let ?y = \"b mod m\"\n  have \"a = (a div m) * m + ?x\" by auto\n  have \"b = (b div m) * m + ?y\" by auto\n  have \"a + b = ((a div m) * m + ?x) + ((b div m) * m + ?y)\"\n    by (simp add: algebra_simps)\n  then have \"a + b = (?x + ?y) + ((a div m) + (b div m)) * m\"\n    by (simp add: algebra_simps)\n  thus ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "linear_combinationV3": {"skill_name": "linear_combinationV3", "marker": "lemma linear_combination:\n  fixes a b c d :: nat\n  assumes \"a * x + b * y = c\"\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"  \n  shows \"x = (c - b * y) / a\"\nproof -\n  have \"a * x = c - b * y\" using assms(1) by simp\n  have \"x = (c - b * y) / a\" using `a * x = c - b * y` by (smt (verit) assms(2) diff_divide_distrib div_mult_self1_is_m mod_mult_self1_is_0 of_nat_0 real_of_nat_div4 real_of_nat_div_aux)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma linear_combination:\n  fixes a b c d :: nat\n  assumes \"a * x + b * y = c\"\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"  \n  shows \"x = (c - b * y) / a\"\nproof -\n  have \"a * x = c - b * y\" using assms(1) by simp\n  have \"x = (c - b * y) / a\" using `a * x = c - b * y` by (smt (verit) assms(2) diff_divide_distrib div_mult_self1_is_m mod_mult_self1_is_0 of_nat_0 real_of_nat_div4 real_of_nat_div_aux)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_expansionV12": {"skill_name": "square_expansionV12", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(-y + x)^2 = (-y)^2 + 2*(-y)*x + x^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = y^2 - 2*y*x + x^2\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2*x*y + y^2\"\nproof -\n  have \"(-y + x)^2 = (-y)^2 + 2*(-y)*x + x^2\" by (simp add: power2_eq_square algebra_simps)\n  also have \"... = y^2 - 2*y*x + x^2\" by (simp add: algebra_simps)\n  finally show ?thesis by simp\nqed", "origin": "square_expansion", "update_count": 0}, "absolute_value_sum": {"skill_name": "absolute_value_sum", "marker": "lemma absolute_value_sum:\n  fixes a b :: real\n  shows \"abs(a + b) \\<le> abs(a) + abs(b)\"\n  by (metis abs_triangle_ineq)", "description": "-", "full_code": "lemma absolute_value_sum:\n  fixes a b :: real\n  shows \"abs(a + b) \\<le> abs(a) + abs(b)\"\n  by (metis abs_triangle_ineq)", "origin": "amc12a_2021_p7", "update_count": 0}, "squared_difference_inequality": {"skill_name": "squared_difference_inequality", "marker": "lemma squared_difference_inequality:\n  fixes a b :: real\n  shows \"(a - b)^2 >= 0\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by sos\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma squared_difference_inequality:\n  fixes a b :: real\n  shows \"(a - b)^2 >= 0\"\nproof -\n  have \"(a - b)^2 = a^2 - 2*a*b + b^2\" by sos\n  thus ?thesis by sos\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "absolute_value_difference": {"skill_name": "absolute_value_difference", "marker": "lemma absolute_value_difference:\n  fixes a b :: real\n  shows \"abs(a - b) = sqrt((a - b)^2)\"\nproof -\n  have \"abs(a - b)^2 = (a - b)^2\" by (simp add: power2_eq_square)\n  thus ?thesis by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma absolute_value_difference:\n  fixes a b :: real\n  shows \"abs(a - b) = sqrt((a - b)^2)\"\nproof -\n  have \"abs(a - b)^2 = (a - b)^2\" by (simp add: power2_eq_square)\n  thus ?thesis by (simp add: power2_eq_square)\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "mathd_algebra_109_generalizedV4": {"skill_name": "mathd_algebra_109_generalizedV4", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have \"3 * a + 2 * b = c\" using h0 by simp\n  then have \"3 * 4 + 2 * b = c\" using h1 by simp\n  then have \"12 + 2 * b = c\" by simp\n  thus \"b = (c - 12) / 2\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have \"3 * a + 2 * b = c\" using h0 by simp\n  then have \"3 * 4 + 2 * b = c\" using h1 by simp\n  then have \"12 + 2 * b = c\" by simp\n  thus \"b = (c - 12) / 2\" by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_generalizedV5": {"skill_name": "mathd_algebra_109_generalizedV5", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  then have simplified: \"12 + 2*b = c\" by simp\n  have isolate: \"2*b = c - 12\" using simplified by simp\n  thus ?thesis using isolate by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3*a + 2*b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  have eq: \"3*a + 2*b = c\" using h0 by simp\n  have sub: \"3 * 4 + 2 * b = c\" using h1 eq by simp\n  then have simplified: \"12 + 2*b = c\" by simp\n  have isolate: \"2*b = c - 12\" using simplified by simp\n  thus ?thesis using isolate by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sum_of_squares_greater_equal_zero": {"skill_name": "sum_of_squares_greater_equal_zero", "marker": "lemma sum_of_squares_greater_equal_zero:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\n  by simp", "description": "-", "full_code": "lemma sum_of_squares_greater_equal_zero:\n  fixes x y :: real\n  shows \"x^2 + y^2 \\<ge> 0\"\n  by simp", "origin": "square_expansion", "update_count": 0}, "sum_of_squares_difference": {"skill_name": "sum_of_squares_difference", "marker": "lemma sum_of_squares_difference:\n  fixes x y :: real\n  assumes \"x + y = c\" \"x - y = d\"\n  shows \"x^2 + y^2 = (c^2 + d^2) / 2\"\nproof -\n  have \"x^2 + y^2 = (x + y)^2 - 2*x*y\" by sos\n  moreover have \"x*y = ((x+y)^2 - (x-y)^2) / 4\" using assms by sos\n  ultimately show ?thesis\n    using assms by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma sum_of_squares_difference:\n  fixes x y :: real\n  assumes \"x + y = c\" \"x - y = d\"\n  shows \"x^2 + y^2 = (c^2 + d^2) / 2\"\nproof -\n  have \"x^2 + y^2 = (x + y)^2 - 2*x*y\" by sos\n  moreover have \"x*y = ((x+y)^2 - (x-y)^2) / 4\" using assms by sos\n  ultimately show ?thesis\n    using assms by (simp add: algebra_simps)\nqed", "origin": "square_expansion", "update_count": 0}, "expanded_form_with_two_variables": {"skill_name": "expanded_form_with_two_variables", "marker": "lemma expanded_form_with_two_variables:\n  fixes x y z :: real\n  shows \"(x + y + z)^2 = x^2 + y^2 + z^2 + 2*(x*y + y*z + x*z)\"\nproof -\n  have \"x + y + z = (x + y) + z\" by simp\n  then have \"(x + y + z)^2 = ((x + y) + z)^2\" by simp\n  also have \"... = (x + y)^2 + 2*(x + y)*z + z^2\" by sos\n  also have \"... = (x^2 + 2*x*y + y^2) + 2*(x + y)*z + z^2\" by sos\n  also have \"... = x^2 + y^2 + z^2 + 2*x*y + 2*z*(x + y)\" by auto\n  finally show ?thesis by sos\nqed", "description": "-", "full_code": "lemma expanded_form_with_two_variables:\n  fixes x y z :: real\n  shows \"(x + y + z)^2 = x^2 + y^2 + z^2 + 2*(x*y + y*z + x*z)\"\nproof -\n  have \"x + y + z = (x + y) + z\" by simp\n  then have \"(x + y + z)^2 = ((x + y) + z)^2\" by simp\n  also have \"... = (x + y)^2 + 2*(x + y)*z + z^2\" by sos\n  also have \"... = (x^2 + 2*x*y + y^2) + 2*(x + y)*z + z^2\" by sos\n  also have \"... = x^2 + y^2 + z^2 + 2*x*y + 2*z*(x + y)\" by auto\n  finally show ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV3": {"skill_name": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extendedV3", "marker": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 7 - x \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  then have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 by simp\n  have \"x + 7 = 3\" using eq2_substituted by simp\n  hence x_value: \"x = -4\" by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  thus ?thesis using x_value e_value by simp\nqed", "description": "-", "full_code": "theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4_extended:\n  fixes x e :: complex\n  assumes h0 : \"x + e = 7\"\n    and h1 : \"2 * x + e = 3\"\n  shows \"e = 7 - x \\<and> x = -4\"\nproof -\n  have e_eq: \"e = 7 - x\" using h0 by (simp add: field_simps)\n  then have eq2_substituted: \"2 * x + (7 - x) = 3\" using h1 by simp\n  have \"x + 7 = 3\" using eq2_substituted by simp\n  hence x_value: \"x = -4\" by (metis add.commute add_diff_cancel_right' dbl_simps(1) dbl_simps(5) diff_add_cancel diff_numeral_simps(1) diff_numeral_special(1) sub_num_simps(3) sub_num_simps(6) sub_num_simps(9))\n  have e_value: \"e = 7 - (-4)\" using e_eq x_value by simp\n  thus ?thesis using x_value e_value by simp\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "square_expansionV13": {"skill_name": "square_expansionV13", "marker": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + (-y))^2\" by (simp add: algebra_simps)\n  then have \"... = x^2 + 2 * x * (-y) + (-y)^2\" by sos\n  then have \"... = x^2 - 2 * x * y + y^2\" by (simp add: power2_eq_square)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_expansion:\n  fixes x y :: real\n  shows \"(x - y)^2 = x^2 - 2 * x * y + y^2\"\nproof -\n  have \"(x - y)^2 = (x + (-y))^2\" by (simp add: algebra_simps)\n  then have \"... = x^2 + 2 * x * (-y) + (-y)^2\" by sos\n  then have \"... = x^2 - 2 * x * y + y^2\" by (simp add: power2_eq_square)\n  thus ?thesis by sos\nqed", "origin": "square_expansion", "update_count": 0}, "difference_of_squares": {"skill_name": "difference_of_squares", "marker": "lemma difference_of_squares:\n  fixes x y :: real\n  shows \"x^2 - y^2 = (x - y) * (x + y)\"\n  by sos", "description": "-", "full_code": "lemma difference_of_squares:\n  fixes x y :: real\n  shows \"x^2 - y^2 = (x - y) * (x + y)\"\n  by sos", "origin": "square_expansion", "update_count": 0}, "sum_terms_countV8": {"skill_name": "sum_terms_countV8", "marker": "lemma sum_terms_count:\n  fixes lower :: nat and upper :: nat\n  assumes \"lower < upper\"\n  shows \"card {lower::nat..<upper} = upper - lower\"\nproof -\n  have \"card {lower::nat..<upper} = upper - lower\" \n    by auto\n  then show ?thesis by (metis assms)\nqed", "description": "-", "full_code": "lemma sum_terms_count:\n  fixes lower :: nat and upper :: nat\n  assumes \"lower < upper\"\n  shows \"card {lower::nat..<upper} = upper - lower\"\nproof -\n  have \"card {lower::nat..<upper} = upper - lower\" \n    by auto\n  then show ?thesis by (metis assms)\nqed", "origin": "sum_terms_count", "update_count": 0}, "count_natural_numbers": {"skill_name": "count_natural_numbers", "marker": "lemma count_natural_numbers:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" \n    by (simp add: card_image)\n  thus ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma count_natural_numbers:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" \n    by (simp add: card_image)\n  thus ?thesis using assms by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_floor_boundsV3": {"skill_name": "sum_floor_boundsV3", "marker": "lemma sum_floor_bounds:\n  fixes r :: real and n :: nat\n  assumes \"19 \\<le> n\" \"n \\<le> 91\"\n  shows \"floor (r + n / 100) \\<in> {floor r, floor r + 1}\"\nproof -\n  have \"floor r \\<le> r\" and \"r < floor r + 1\" by auto\n  have \"0 \\<le> n / 100\" by simp\n  then have \"floor (r + n / 100) \\<le> floor r + 1\" by (smt (verit) \\<open>r < real_of_int (\\<lfloor>r\\<rfloor> + 1)\\<close> add_increasing antisym_conv1 assms(2) dense_ge_bounded floor_eq2 floor_mono leD leI le_divide_eq_1_pos le_floor_iff less_le_not_le nless_le numeral_Bit0 numeral_Bit1 numeral_One numeral_less_real_of_nat_iff of_int_1 of_int_less_1_iff of_nat_1 of_nat_numeral)\n  then show ?thesis using assms by (smt (verit) \\<open>0 \\<le> real n / 100\\<close> \\<open>real_of_int \\<lfloor>r\\<rfloor> \\<le> r\\<close> floor_eq2 insertI1 insertI2 insert_iff le_floor_iff of_int_add of_int_le_1_iff verit_la_disequality)\nqed", "description": "-", "full_code": "lemma sum_floor_bounds:\n  fixes r :: real and n :: nat\n  assumes \"19 \\<le> n\" \"n \\<le> 91\"\n  shows \"floor (r + n / 100) \\<in> {floor r, floor r + 1}\"\nproof -\n  have \"floor r \\<le> r\" and \"r < floor r + 1\" by auto\n  have \"0 \\<le> n / 100\" by simp\n  then have \"floor (r + n / 100) \\<le> floor r + 1\" by (smt (verit) \\<open>r < real_of_int (\\<lfloor>r\\<rfloor> + 1)\\<close> add_increasing antisym_conv1 assms(2) dense_ge_bounded floor_eq2 floor_mono leD leI le_divide_eq_1_pos le_floor_iff less_le_not_le nless_le numeral_Bit0 numeral_Bit1 numeral_One numeral_less_real_of_nat_iff of_int_1 of_int_less_1_iff of_nat_1 of_nat_numeral)\n  then show ?thesis using assms by (smt (verit) \\<open>0 \\<le> real n / 100\\<close> \\<open>real_of_int \\<lfloor>r\\<rfloor> \\<le> r\\<close> floor_eq2 insertI1 insertI2 insert_iff le_floor_iff of_int_add of_int_le_1_iff verit_la_disequality)\nqed", "origin": "sum_terms_count", "update_count": 0}, "square_eq_n_dimensionsV5": {"skill_name": "square_eq_n_dimensionsV5", "marker": "lemma square_eq_n_dimensions:\n  fixes x y :: \"real list\"\n  assumes \"length x = length y\" \"x = y\"\n  shows \"sum_list (map (\\<lambda>i. x ! i ^ 2) [0..<length x]) = sum_list (map (\\<lambda>i. y ! i ^ 2) [0..<length y])\"\nproof -\n  have \"map (\\<lambda>i. x ! i ^ 2) [0..<length x] = map (\\<lambda>i. y ! i ^ 2) [0..<length y]\"\n    by (metis assms(2) nth_equalityI)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_eq:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\n  using assms by simp\n\nlemma square_eq_n_dimensions:\n  fixes x y :: \"real list\"\n  assumes \"length x = length y\" \"x = y\"\n  shows \"sum_list (map (\\<lambda>i. x ! i ^ 2) [0..<length x]) = sum_list (map (\\<lambda>i. y ! i ^ 2) [0..<length y])\"\nproof -\n  have \"map (\\<lambda>i. x ! i ^ 2) [0..<length x] = map (\\<lambda>i. y ! i ^ 2) [0..<length y]\"\n    by (metis assms(2) nth_equalityI)\n  thus ?thesis by simp\nqed", "origin": "square_eq", "update_count": 0}, "nonneg_sum_of_squares": {"skill_name": "nonneg_sum_of_squares", "marker": "lemma nonneg_sum_of_squares:\n  fixes a b c :: real\n  shows \"(a^2 + b^2) + c^2 >= 0\"\nproof -\n  have \"a^2 >= 0\" by auto\n  have \"b^2 >= 0\" by auto\n  have \"c^2 >= 0\" by auto\n  then show ?thesis by (simp add: add_nonneg_nonneg)\nqed", "description": "-", "full_code": "lemma nonneg_sum_of_squares:\n  fixes a b c :: real\n  shows \"(a^2 + b^2) + c^2 >= 0\"\nproof -\n  have \"a^2 >= 0\" by auto\n  have \"b^2 >= 0\" by auto\n  have \"c^2 >= 0\" by auto\n  then show ?thesis by (simp add: add_nonneg_nonneg)\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "real_distributive": {"skill_name": "real_distributive", "marker": "lemma real_distributive:\n  fixes a b c :: real\n  shows \"a * (b + c) = a * b + a * c\"\nproof -\n  have \"a * (b + c) = a * b + a * c\" by (simp add: distrib_left)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma real_distributive:\n  fixes a b c :: real\n  shows \"a * (b + c) = a * b + a * c\"\nproof -\n  have \"a * (b + c) = a * b + a * c\" by (simp add: distrib_left)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "expression_nonneg_simplifiedV2": {"skill_name": "expression_nonneg_simplifiedV2", "marker": "lemma expression_nonneg_simplified:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  then have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by simp\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  thus \"?E >= 1\" using `x^2 * y^2 >= 0` by sos\nqed", "description": "-", "full_code": "lemma expression_nonneg_simplified:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  then have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by simp\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  thus \"?E >= 1\" using `x^2 * y^2 >= 0` by sos\nqed", "origin": "amc12a_2021_p7", "update_count": 0}, "amc12a_2021_p7_simplified": {"skill_name": "amc12a_2021_p7_simplified", "marker": "theorem amc12a_2021_p7_simplified:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\n  using expression_nonneg_simplified by auto", "description": "-", "full_code": "lemma expression_nonneg_simplified:\n  fixes x y :: real\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  then have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by simp\n  have \"x^2 * y^2 >= 0\" by auto\n  have \"x^2 >= 0\" by auto\n  have \"y^2 >= 0\" by auto\n  thus \"?E >= 1\" using `x^2 * y^2 >= 0` by sos\nqed\n\ntheorem amc12a_2021_p7_simplified:\n  fixes x y :: real\n  shows \"1 \\<le> ((x * y) - 1)^2 + (x + y)^2\"\n  using expression_nonneg_simplified by auto", "origin": "amc12a_2021_p7", "update_count": 0}, "multi_variable_linear_system": {"skill_name": "multi_variable_linear_system", "marker": "theorem multi_variable_linear_system:\n  fixes a b c d :: real\n  assumes h0 : \"2*a + 3*b + d = 10\"\n    and h1 : \"a + b = 3\"\n  shows \"b = 3 - a \\<and> d = 10 - 2*a - 3*(3 - a)\"\nproof -\n  have eq1: \"2*a + 3*b + d = 10\" using h0 by simp\n  have eq2: \"a + b = 3\" using h1 by simp\n  then have b_expr: \"b = 3 - a\" by simp\n  have substitute_d: \"d = 10 - 2*a - 3*(3 - a)\" using eq1 b_expr by simp\n  show ?thesis using b_expr substitute_d by auto\nqed", "description": "-", "full_code": "theorem multi_variable_linear_system:\n  fixes a b c d :: real\n  assumes h0 : \"2*a + 3*b + d = 10\"\n    and h1 : \"a + b = 3\"\n  shows \"b = 3 - a \\<and> d = 10 - 2*a - 3*(3 - a)\"\nproof -\n  have eq1: \"2*a + 3*b + d = 10\" using h0 by simp\n  have eq2: \"a + b = 3\" using h1 by simp\n  then have b_expr: \"b = 3 - a\" by simp\n  have substitute_d: \"d = 10 - 2*a - 3*(3 - a)\" using eq1 b_expr by simp\n  show ?thesis using b_expr substitute_d by auto\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "threshold_for_eight": {"skill_name": "threshold_for_eight", "marker": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  have \"8 \\<le> r + 57 / 100\" \n  proof -\n    have \"floor (r + 57 / 100) = 8\" by (simp add: assms)\n    thus \"8 \\<le> r + 57 / 100\" \n      by (metis dual_order.refl numeral_le_floor)\n  qed\n  moreover have \"r + 57 / 100 < 9\" \n  proof -\n    have \"floor (r + 57 / 100) < 9\" \n      by (simp add: assms)\n    thus \"r + 57 / 100 < 9\" \n      by auto\n  qed\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  have \"8 \\<le> r + 57 / 100\" \n  proof -\n    have \"floor (r + 57 / 100) = 8\" by (simp add: assms)\n    thus \"8 \\<le> r + 57 / 100\" \n      by (metis dual_order.refl numeral_le_floor)\n  qed\n  moreover have \"r + 57 / 100 < 9\" \n  proof -\n    have \"floor (r + 57 / 100) < 9\" \n      by (simp add: assms)\n    thus \"r + 57 / 100 < 9\" \n      by auto\n  qed\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "threshold_for_eightV2": {"skill_name": "threshold_for_eightV2", "marker": "lemma threshold_for_eight:\n  fixes r :: real\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  let ?x = \"r + 57 / 100\"\n  have \"floor ?x = 8\" using assms by simp\n  have \"8 \\<le> ?x\" \n  proof -\n    have \"8 = floor ?x\" by (simp add: `floor ?x = 8`)\n    thus \"8 \\<le> ?x\"\n      by arith\n  qed\n  moreover have \"?x < 9\" \n  proof -\n    have \"9 = floor ?x + 1\" by (metis ab_semigroup_add_class.add_ac(1) add.commute add.left_commute add_left_imp_eq add_right_imp_eq assms numeral_plus_numeral one_plus_numeral semiring_norm(4) semiring_norm(5) semiring_norm(8))\n    thus \"?x < 9\" using `floor ?x = 8` \n      by arith\n  qed\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma threshold_for_eight:\n  fixes r :: real\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  let ?x = \"r + 57 / 100\"\n  have \"floor ?x = 8\" using assms by simp\n  have \"8 \\<le> ?x\" \n  proof -\n    have \"8 = floor ?x\" by (simp add: `floor ?x = 8`)\n    thus \"8 \\<le> ?x\"\n      by arith\n  qed\n  moreover have \"?x < 9\" \n  proof -\n    have \"9 = floor ?x + 1\" by (metis ab_semigroup_add_class.add_ac(1) add.commute add.left_commute add_left_imp_eq add_right_imp_eq assms numeral_plus_numeral one_plus_numeral semiring_norm(4) semiring_norm(5) semiring_norm(8))\n    thus \"?x < 9\" using `floor ?x = 8` \n      by arith\n  qed\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "threshold_for_eightV3": {"skill_name": "threshold_for_eightV3", "marker": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  have \"8 \\<le> r + 57 / 100\" \n  proof -\n    have \"floor (r + 57 / 100) = 8\" \n      using assms by simp\n    then show \"8 \\<le> r + 57 / 100\" \n      by (metis dual_order.refl numeral_le_floor)\n  qed\n  have \"r + 57 / 100 < 9\" \n  proof -\n    have \"floor (r + 57 / 100) < 9\" \n      using assms by simp\n    then show \"r + 57 / 100 < 9\" \n      by auto\n  qed\n  thus ?thesis by (metis \\<open>(8::'a) \\<le> r + (57::'a) / (100::'a)\\<close>)\nqed", "description": "-", "full_code": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  have \"8 \\<le> r + 57 / 100\" \n  proof -\n    have \"floor (r + 57 / 100) = 8\" \n      using assms by simp\n    then show \"8 \\<le> r + 57 / 100\" \n      by (metis dual_order.refl numeral_le_floor)\n  qed\n  have \"r + 57 / 100 < 9\" \n  proof -\n    have \"floor (r + 57 / 100) < 9\" \n      using assms by simp\n    then show \"r + 57 / 100 < 9\" \n      by auto\n  qed\n  thus ?thesis by (metis \\<open>(8::'a) \\<le> r + (57::'a) / (100::'a)\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "threshold_for_eightV4": {"skill_name": "threshold_for_eightV4", "marker": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  have \"8 \\<le> r + 57 / 100\" \n  proof -\n    have \"floor (r + 57 / 100) = 8\" \n      using assms by simp\n    thus \"8 \\<le> r + 57 / 100\" \n      by (metis dual_order.refl numeral_le_floor)\n  qed\n  have \"r + 57 / 100 < 9\" \n  proof -\n    have \"floor (r + 57 / 100) = 8\" \n      using assms by simp\n    thus \"r + 57 / 100 < 9\" \n      by (smt (verit) floor_le_numeral floor_less_one floor_less_one floor_numeral floor_one floor_one less_numeral_extra(4) numeral_Bit0 numeral_One numeral_plus_one numeral_plus_one semiring_norm(2) semiring_norm(5))\n  qed\n  thus ?thesis by (metis \\<open>(8::'a) \\<le> r + (57::'a) / (100::'a)\\<close>)\nqed", "description": "-", "full_code": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  have \"8 \\<le> r + 57 / 100\" \n  proof -\n    have \"floor (r + 57 / 100) = 8\" \n      using assms by simp\n    thus \"8 \\<le> r + 57 / 100\" \n      by (metis dual_order.refl numeral_le_floor)\n  qed\n  have \"r + 57 / 100 < 9\" \n  proof -\n    have \"floor (r + 57 / 100) = 8\" \n      using assms by simp\n    thus \"r + 57 / 100 < 9\" \n      by (smt (verit) floor_le_numeral floor_less_one floor_less_one floor_numeral floor_one floor_one less_numeral_extra(4) numeral_Bit0 numeral_One numeral_plus_one numeral_plus_one semiring_norm(2) semiring_norm(5))\n  qed\n  thus ?thesis by (metis \\<open>(8::'a) \\<le> r + (57::'a) / (100::'a)\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "sum_of_values": {"skill_name": "sum_of_values", "marker": "lemma sum_of_values:\n  shows \"21 + 45 = 66\"\nproof -\n  have \"21 + 45 = 66\" \n    by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_of_values:\n  shows \"21 + 45 = 66\"\nproof -\n  have \"21 + 45 = 66\" \n    by simp\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "power_mod": {"skill_name": "power_mod", "marker": "lemma power_mod:\n  fixes a :: nat and b :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then show ?case by (metis mod_mult_left_eq power_mod)\nqed", "description": "", "full_code": "lemma power_mod:\n  fixes a :: nat and b :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then show ?case by (metis mod_mult_left_eq power_mod)\nqed", "origin": "data/full_data/debug/valid_rand/amc12a_2008_p15.json_v46", "update_count": -1}, "mathd_algebra_109_generalizedV6": {"skill_name": "mathd_algebra_109_generalizedV6", "marker": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  from h1 have \"3 * 4 + 2 * b = c\" by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  then have \"12 + 2 * b = c\" by simp\n  hence \"2 * b = c - 12\" by simp\n  thus \"b = (c - 12) / 2\" by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_generalized:\n  fixes a b c :: real\n  assumes h0 : \"3 * a + 2 * b = c\"\n    and h1 : \"a = 4\"\n  shows \"b = (c - 12) / 2\"\nproof -\n  from h1 have \"3 * 4 + 2 * b = c\" by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  then have \"12 + 2 * b = c\" by simp\n  hence \"2 * b = c - 12\" by simp\n  thus \"b = (c - 12) / 2\" by (simp add: field_simps)\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "mathd_algebra_109_evolvedV7": {"skill_name": "mathd_algebra_109_evolvedV7", "marker": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  from h1 have \"3 * 4 + 2 * b = 12\" by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  then have \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 12 - 12\" by simp\n  thus \"b = 0\" by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_109_evolved:\n  fixes a b :: real\n  assumes h0 : \"3*a + 2*b = 12\"\n    and h1 : \"a = 4\"\n  shows \"b = 0\"\nproof -\n  from h1 have \"3 * 4 + 2 * b = 12\" by (metis dbl_inc_simps(3) dbl_simps(3) h0)\n  then have \"12 + 2 * b = 12\" by simp\n  hence \"2 * b = 12 - 12\" by simp\n  thus \"b = 0\" by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "sum_terms_count_extendedV2": {"skill_name": "sum_terms_count_extendedV2", "marker": "lemma sum_terms_count_extended:\n  fixes lower :: nat and upper :: nat\n  assumes \"lower < upper\"\n  shows \"card {lower::nat..<upper} = upper - lower\"\n  using assms by auto", "description": "-", "full_code": "lemma sum_terms_count_extended:\n  fixes lower :: nat and upper :: nat\n  assumes \"lower < upper\"\n  shows \"card {lower::nat..<upper} = upper - lower\"\n  using assms by auto", "origin": "sum_terms_count", "update_count": 0}, "nonzero_product": {"skill_name": "nonzero_product", "marker": "lemma nonzero_product:\n  fixes a b :: real\n  assumes h0: \"a \\<noteq> 0\" and h1: \"b \\<noteq> 0\"\n  shows \"a * b \\<noteq> 0\"\nproof -\n  have \"a * b = 0 \\<Longrightarrow> a = 0 \\<or> b = 0\" by (simp add: mult_eq_0_iff)\n  then show ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma nonzero_product:\n  fixes a b :: real\n  assumes h0: \"a \\<noteq> 0\" and h1: \"b \\<noteq> 0\"\n  shows \"a * b \\<noteq> 0\"\nproof -\n  have \"a * b = 0 \\<Longrightarrow> a = 0 \\<or> b = 0\" by (simp add: mult_eq_0_iff)\n  then show ?thesis using assms by auto\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "threshold_for_eightV5": {"skill_name": "threshold_for_eightV5", "marker": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  let ?x = \"r + 57 / 100\"\n  have \"floor ?x = 8\" using assms by simp\n  then have \"8 \\<le> ?x\" \n    by (metis dual_order.refl numeral_le_floor)\n  have \"floor ?x < 9\" using `floor ?x = 8` by simp\n  then have \"?x < 9\" \n    by auto\n  thus ?thesis by (metis \\<open>(8::'a) \\<le> r + (57::'a) / (100::'a)\\<close>)\nqed", "description": "-", "full_code": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  let ?x = \"r + 57 / 100\"\n  have \"floor ?x = 8\" using assms by simp\n  then have \"8 \\<le> ?x\" \n    by (metis dual_order.refl numeral_le_floor)\n  have \"floor ?x < 9\" using `floor ?x = 8` by simp\n  then have \"?x < 9\" \n    by auto\n  thus ?thesis by (metis \\<open>(8::'a) \\<le> r + (57::'a) / (100::'a)\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "threshold_for_eightV6": {"skill_name": "threshold_for_eightV6", "marker": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  let ?x = \"r + 57 / 100\"\n  have \"floor ?x = 8\" using assms by simp\n  have \"8 \\<le> ?x\" \n  proof -\n    have \"floor ?x = 8\" by (simp add: `floor ?x = 8`)\n    thus \"8 \\<le> ?x\" \n      by (metis dual_order.refl numeral_le_floor)\n  qed\n  have \"?x < 9\" \n  proof -\n    have \"floor ?x < 9\" by (simp add: `floor ?x = 8`)\n    thus \"?x < 9\" \n      by auto\n  qed\n  thus \"8 \\<le> ?x \\<and> ?x < 9\" by (metis \\<open>(8::'a) \\<le> r + (57::'a) / (100::'a)\\<close>)\nqed", "description": "-", "full_code": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  let ?x = \"r + 57 / 100\"\n  have \"floor ?x = 8\" using assms by simp\n  have \"8 \\<le> ?x\" \n  proof -\n    have \"floor ?x = 8\" by (simp add: `floor ?x = 8`)\n    thus \"8 \\<le> ?x\" \n      by (metis dual_order.refl numeral_le_floor)\n  qed\n  have \"?x < 9\" \n  proof -\n    have \"floor ?x < 9\" by (simp add: `floor ?x = 8`)\n    thus \"?x < 9\" \n      by auto\n  qed\n  thus \"8 \\<le> ?x \\<and> ?x < 9\" by (metis \\<open>(8::'a) \\<le> r + (57::'a) / (100::'a)\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "mathd_algebra_generalizedV2": {"skill_name": "mathd_algebra_generalizedV2", "marker": "theorem mathd_algebra_generalized:\n  fixes a b d :: real\n  assumes h0 : \"d*(3*a + 2*b) = 12 * d\"\n  and h1 : \"a = 4\"\n  and h2 : \"d > 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"d*(3*a + 2*b) = 12 * d\" using h0 by simp\n  have sub: \"d*(3 * 4 + 2 * b) = 12 * d\" using h1 eq by simp\n  have simplified: \"12 * d + 2 * d * b = 12 * d\" by (metis ab_semigroup_mult_class.mult_ac(1) add.commute add_right_cancel h0 h1 is_num_normalize(1) left_add_twice mult.commute mult_2 mult_2_right numeral_times_numeral ring_class.ring_distribs(1) semiring_norm(12) semiring_norm(14))\n  have isolate: \"2 * d * b = 12 * d - 12 * d\" using simplified by simp\n  have solution: \"b = 0\" using isolate by (metis add.commute add_0_iff diff_add_cancel diff_self double_zero_sym h2 less_iff_diff_less_0 mult_2 no_zero_divisors verit_comp_simplify1(1))\n  show ?thesis using solution by simp\nqed", "description": "-", "full_code": "theorem mathd_algebra_generalized:\n  fixes a b d :: real\n  assumes h0 : \"d*(3*a + 2*b) = 12 * d\"\n  and h1 : \"a = 4\"\n  and h2 : \"d > 0\"\n  shows \"b = 0\"\nproof -\n  have eq: \"d*(3*a + 2*b) = 12 * d\" using h0 by simp\n  have sub: \"d*(3 * 4 + 2 * b) = 12 * d\" using h1 eq by simp\n  have simplified: \"12 * d + 2 * d * b = 12 * d\" by (metis ab_semigroup_mult_class.mult_ac(1) add.commute add_right_cancel h0 h1 is_num_normalize(1) left_add_twice mult.commute mult_2 mult_2_right numeral_times_numeral ring_class.ring_distribs(1) semiring_norm(12) semiring_norm(14))\n  have isolate: \"2 * d * b = 12 * d - 12 * d\" using simplified by simp\n  have solution: \"b = 0\" using isolate by (metis add.commute add_0_iff diff_add_cancel diff_self double_zero_sym h2 less_iff_diff_less_0 mult_2 no_zero_divisors verit_comp_simplify1(1))\n  show ?thesis using solution by simp\nqed", "origin": "mathd_algebra_109", "update_count": 0}, "limit_sqrt": {"skill_name": "limit_sqrt", "marker": "lemma limit_sqrt:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x = 9 \\<longleftrightarrow> x = 81\"\nproof -\n  have \"sqrt x = 9 \\<longleftrightarrow> x = 9^2\" \n    by (metis abs_numeral assms real_sqrt_abs real_sqrt_pow2)\n  thus ?thesis by simp\nqed", "description": "", "full_code": "lemma limit_sqrt:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x = 9 \\<longleftrightarrow> x = 81\"\nproof -\n  have \"sqrt x = 9 \\<longleftrightarrow> x = 9^2\" \n    by (metis abs_numeral assms real_sqrt_abs real_sqrt_pow2)\n  thus ?thesis by simp\nqed", "origin": "data/full_data/debug/valid_rand/mathd_algebra_31.json_v47", "update_count": -1}, "threshold_for_eightV7": {"skill_name": "threshold_for_eightV7", "marker": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  let ?x = \"r + 57 / 100\"\n  have \"floor ?x = 8\" using assms by simp\n  have \"8 \\<le> ?x\" \n  proof -\n    have \"floor ?x = 8\" by (simp add: `floor ?x = 8`)\n    thus \"8 \\<le> ?x\" \n      by (metis dual_order.refl numeral_le_floor)\n  qed\n  have \"floor ?x < 9\" using `floor ?x = 8` by simp\n  hence \"?x < 9\" \n  proof -\n    have \"floor ?x < 9\" by (simp add: `floor ?x = 8`)\n    thus \"?x < 9\" \n      by auto\n  qed\n  thus \"8 \\<le> ?x \\<and> ?x < 9\" by (metis \\<open>(8::'a) \\<le> r + (57::'a) / (100::'a)\\<close>)\nqed", "description": "-", "full_code": "lemma threshold_for_eight:\n  assumes \"floor (r + 57 / 100) = 8\"\n  shows \"8 \\<le> r + 57 / 100 \\<and> r + 57 / 100 < 9\"\nproof -\n  let ?x = \"r + 57 / 100\"\n  have \"floor ?x = 8\" using assms by simp\n  have \"8 \\<le> ?x\" \n  proof -\n    have \"floor ?x = 8\" by (simp add: `floor ?x = 8`)\n    thus \"8 \\<le> ?x\" \n      by (metis dual_order.refl numeral_le_floor)\n  qed\n  have \"floor ?x < 9\" using `floor ?x = 8` by simp\n  hence \"?x < 9\" \n  proof -\n    have \"floor ?x < 9\" by (simp add: `floor ?x = 8`)\n    thus \"?x < 9\" \n      by auto\n  qed\n  thus \"8 \\<le> ?x \\<and> ?x < 9\" by (metis \\<open>(8::'a) \\<le> r + (57::'a) / (100::'a)\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "algebra_nvar_linear_eq_multiple": {"skill_name": "algebra_nvar_linear_eq_multiple", "marker": "theorem algebra_nvar_linear_eq_multiple:\n  fixes x1 x2 x3 e1 e2 e3 :: complex\n  assumes h0: \"x1 + e1 = a\"\n    and h1: \"x2 + e2 = b\"\n    and h2: \"x3 + e3 = c\"\n    and h3: \"x1 + x2 + x3 = d\"\n  shows \"e1 = a - x1 \\<and> e2 = b - x2 \\<and> e3 = c - x3\"\nproof -\n  have e1_eq: \"e1 = a - x1\" using h0 by (auto simp: field_simps)\n  have e2_eq: \"e2 = b - x2\" using h1 by (auto simp: field_simps)\n  have e3_eq: \"e3 = c - x3\" using h2 by (auto simp: field_simps)\n  show ?thesis using e1_eq e2_eq e3_eq by auto\nqed", "description": "-", "full_code": "theorem algebra_nvar_linear_eq:\n  fixes x1 x2 e1 e2 :: complex\n  assumes h0 : \"x1 + e1 = a\"\n    and h1 : \"b * x1 + e2 = c\"\n  shows \"e1 = a - x1 \\<and> e2 = c - b * x1\"\nproof -\n  have e1_eq: \"e1 = a - x1\" using h0 by (auto simp: field_simps)\n  have e2_eq: \"e2 = c - b * x1\" using h1 by (auto simp: field_simps)\n  show ?thesis using e1_eq e2_eq by auto\nqed\n\ntheorem algebra_nvar_linear_eq_multiple:\n  fixes x1 x2 x3 e1 e2 e3 :: complex\n  assumes h0: \"x1 + e1 = a\"\n    and h1: \"x2 + e2 = b\"\n    and h2: \"x3 + e3 = c\"\n    and h3: \"x1 + x2 + x3 = d\"\n  shows \"e1 = a - x1 \\<and> e2 = b - x2 \\<and> e3 = c - x3\"\nproof -\n  have e1_eq: \"e1 = a - x1\" using h0 by (auto simp: field_simps)\n  have e2_eq: \"e2 = b - x2\" using h1 by (auto simp: field_simps)\n  have e3_eq: \"e3 = c - x3\" using h2 by (auto simp: field_simps)\n  show ?thesis using e1_eq e2_eq e3_eq by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "algebra_nvar_linear_eq": {"skill_name": "algebra_nvar_linear_eq", "marker": "theorem algebra_nvar_linear_eq:\n  fixes x1 x2 e1 e2 :: complex\n  assumes h0 : \"x1 + e1 = a\"\n    and h1 : \"b * x1 + e2 = c\"\n  shows \"e1 = a - x1 \\<and> e2 = c - b * x1\"\nproof -\n  have e1_eq: \"e1 = a - x1\" using h0 by (auto simp: field_simps)\n  have e2_eq: \"e2 = c - b * x1\" using h1 by (auto simp: field_simps)\n  show ?thesis using e1_eq e2_eq by auto\nqed", "description": "-", "full_code": "theorem algebra_nvar_linear_eq:\n  fixes x1 x2 e1 e2 :: complex\n  assumes h0 : \"x1 + e1 = a\"\n    and h1 : \"b * x1 + e2 = c\"\n  shows \"e1 = a - x1 \\<and> e2 = c - b * x1\"\nproof -\n  have e1_eq: \"e1 = a - x1\" using h0 by (auto simp: field_simps)\n  have e2_eq: \"e2 = c - b * x1\" using h1 by (auto simp: field_simps)\n  show ?thesis using e1_eq e2_eq by auto\nqed", "origin": "algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4", "update_count": 0}, "sum_terms_count_extendedV3": {"skill_name": "sum_terms_count_extendedV3", "marker": "lemma sum_terms_count_extended:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"card {19::nat..<19+n} = n\"\nproof -\n  have \"card {19::nat..<19+n} = n\" by auto\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma sum_terms_count_extended:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"card {19::nat..<19+n} = n\"\nproof -\n  have \"card {19::nat..<19+n} = n\" by auto\n  thus ?thesis .\nqed", "origin": "sum_terms_count", "update_count": 0}, "mod_10_cycle": {"skill_name": "mod_10_cycle", "marker": "lemma mod_10_cycle:\n  fixes a :: nat\n  shows \"a mod 10 = 0 \\<or> a mod 10 = 1 \\<or> a mod 10 = 2 \\<or> a mod 10 = 3 \\<or> a mod 10 = 4 \\<or> a mod 10 = 5 \\<or> a mod 10 = 6 \\<or> a mod 10 = 7 \\<or> a mod 10 = 8 \\<or> a mod 10 = 9\"\nproof -\n  have \"a mod 10 < 10\" by auto\n  then show ?thesis\n    by (cases \"a mod 10\") auto\nqed", "description": "-", "full_code": "lemma mod_10_cycle:\n  fixes a :: nat\n  shows \"a mod 10 = 0 \\<or> a mod 10 = 1 \\<or> a mod 10 = 2 \\<or> a mod 10 = 3 \\<or> a mod 10 = 4 \\<or> a mod 10 = 5 \\<or> a mod 10 = 6 \\<or> a mod 10 = 7 \\<or> a mod 10 = 8 \\<or> a mod 10 = 9\"\nproof -\n  have \"a mod 10 < 10\" by auto\n  then show ?thesis\n    by (cases \"a mod 10\") auto\nqed", "origin": "do_request", "update_count": 0}, "limit_sqrt_general": {"skill_name": "limit_sqrt_general", "marker": "lemma limit_sqrt_general:\n  fixes x :: real\n  assumes \"x >= 0\" and \"k >= 0\"\n  shows \"sqrt x = k \\<longleftrightarrow> x = k^2\"\nproof -\n  have \"sqrt x = k \\<longleftrightarrow> x = k^2\" \n    by (metis assms(1) assms(2) real_sqrt_pow2_iff real_sqrt_unique)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma limit_sqrt_general:\n  fixes x :: real\n  assumes \"x >= 0\" and \"k >= 0\"\n  shows \"sqrt x = k \\<longleftrightarrow> x = k^2\"\nproof -\n  have \"sqrt x = k \\<longleftrightarrow> x = k^2\" \n    by (metis assms(1) assms(2) real_sqrt_pow2_iff real_sqrt_unique)\n  thus ?thesis by simp\nqed", "origin": "limit_sqrt", "update_count": 0}, "limit_sqrt_ndim": {"skill_name": "limit_sqrt_ndim", "marker": "lemma limit_sqrt_ndim:\n  fixes x :: \"real list\"\n  assumes \"all_nonneg x\"\n  shows \"sqrt (sum_list x) = 9 \\<longleftrightarrow> sum_list x = 81\"\nproof -\n  have \"sqrt (sum_list x) = 9 \\<longleftrightarrow> sum_list x = 9^2\"\n    by (metis real_sqrt_ge_0_iff real_sqrt_pow2 real_sqrt_unique zero_le_numeral)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma limit_sqrt_ndim:\n  fixes x :: \"real list\"\n  assumes \"all_nonneg x\"\n  shows \"sqrt (sum_list x) = 9 \\<longleftrightarrow> sum_list x = 81\"\nproof -\n  have \"sqrt (sum_list x) = 9 \\<longleftrightarrow> sum_list x = 9^2\"\n    by (metis real_sqrt_ge_0_iff real_sqrt_pow2 real_sqrt_unique zero_le_numeral)\n  thus ?thesis by simp\nqed", "origin": "limit_sqrt", "update_count": 0}, "mod_n_casesV14": {"skill_name": "mod_n_casesV14", "marker": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. a mod n = r \\<and> r < n\"\nproof -\n  obtain r where \"a mod n = r\" using mod_less by blast\n  moreover have \"r < n\" using assms by (metis Euclidean_Division.pos_mod_bound calculation int_ops(1) of_nat_less_iff)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_n_cases:\n  fixes a :: int and n :: nat\n  assumes \"n > 0\"\n  shows \"\\<exists>r. a mod n = r \\<and> r < n\"\nproof -\n  obtain r where \"a mod n = r\" using mod_less by blast\n  moreover have \"r < n\" using assms by (metis Euclidean_Division.pos_mod_bound calculation int_ops(1) of_nat_less_iff)\n  ultimately show ?thesis by auto\nqed", "origin": "mod4_cases", "update_count": 0}, "expression_nonneg_with_inequality": {"skill_name": "expression_nonneg_with_inequality", "marker": "lemma expression_nonneg_with_inequality:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" using assms by (simp add: mult_nonneg_nonneg)\n  have \"x^2 >= 0\" using assms by simp\n  have \"y^2 >= 0\" using assms by simp\n  have \"?E >= 1\" using `x^2 * y^2 >= 0` `x^2 >= 0` `y^2 >= 0` by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma expression_nonneg_with_inequality:\n  fixes x y :: real\n  assumes \"x >= 0\" \"y >= 0\"\n  shows \"((x * y) - 1)^2 + (x + y)^2 >= 1\"\nproof -\n  let ?E = \"((x * y) - 1)^2 + (x + y)^2\"\n  have \"((x * y) - 1)^2 = (x^2 * y^2 - 2 * x * y + 1)\" by sos\n  have \"(x + y)^2 = x^2 + 2 * x * y + y^2\" by sos\n  have \"?E = (x^2 * y^2 - 2 * x * y + 1) + (x^2 + 2 * x * y + y^2)\"\n    by sos\n  have \"?E = x^2 * y^2 + x^2 + y^2 + 1\" by sos\n  have \"x^2 * y^2 >= 0\" using assms by (simp add: mult_nonneg_nonneg)\n  have \"x^2 >= 0\" using assms by simp\n  have \"y^2 >= 0\" using assms by simp\n  have \"?E >= 1\" using `x^2 * y^2 >= 0` `x^2 >= 0` `y^2 >= 0` by sos\n  thus ?thesis by simp\nqed", "origin": "expression_nonneg", "update_count": 0}, "sqrt_eq_generalizedV5": {"skill_name": "sqrt_eq_generalizedV5", "marker": "lemma sqrt_eq_generalized:\n  fixes x :: real\n  assumes \"sqrt (x + c) = d\" \"c > 0\" \"d > 0\"\n  shows \"x = d^2 - c\"\nproof -\n  have \"x + c = d^2\" using assms(1) by (smt (verit) assms(3) less_eq_real_def real_sqrt_le_iff real_sqrt_pow2_iff real_sqrt_zero)\n  then show \"x = d^2 - c\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq_generalized:\n  fixes x :: real\n  assumes \"sqrt (x + c) = d\" \"c > 0\" \"d > 0\"\n  shows \"x = d^2 - c\"\nproof -\n  have \"x + c = d^2\" using assms(1) by (smt (verit) assms(3) less_eq_real_def real_sqrt_le_iff real_sqrt_pow2_iff real_sqrt_zero)\n  then show \"x = d^2 - c\" by simp\nqed", "origin": "sqrt_eq", "update_count": 0}, "square_root_propertiesV2": {"skill_name": "square_root_propertiesV2", "marker": "lemma square_root_properties:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  have \"sqrt a = sqrt (b)\" \n    using assms(1) by (simp add: sqrt_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_root_properties:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  have \"sqrt a = sqrt (b)\" \n    using assms(1) by (simp add: sqrt_def)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_root_propertiesV3": {"skill_name": "square_root_propertiesV3", "marker": "lemma square_root_properties:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  from assms(1) have \"sqrt a = sqrt a\" by simp\n  thus ?thesis by (simp add: assms(1))\nqed", "description": "-", "full_code": "lemma square_root_properties:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  from assms(1) have \"sqrt a = sqrt a\" by simp\n  thus ?thesis by (simp add: assms(1))\nqed", "origin": "do_request", "update_count": 0}, "square_root_propertiesV4": {"skill_name": "square_root_propertiesV4", "marker": "lemma square_root_properties:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  have \"sqrt a = sqrt b\" using assms(1) by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_root_properties:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  have \"sqrt a = sqrt b\" using assms(1) by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "nonnegativity_of_squares": {"skill_name": "nonnegativity_of_squares", "marker": "lemma nonnegativity_of_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"a^2 >= 0\" by auto\n  have \"b^2 = b * b\" by sos\n  then show \"b^2 >= 0\" by auto\nqed", "description": "-", "full_code": "lemma nonnegativity_of_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"a^2 >= 0\" by auto\n  have \"b^2 = b * b\" by sos\n  then show \"b^2 >= 0\" by auto\nqed", "origin": "expression_nonneg", "update_count": 0}, "sum_of_squares_nonnegV2": {"skill_name": "sum_of_squares_nonnegV2", "marker": "lemma sum_of_squares_nonneg:\n  fixes x y :: real\n  shows \"x^2 + y^2 >= 0\"\nproof -\n  have \"x^2 >= 0\" and \"y^2 >= 0\" by (simp_all add: nonnegativity_of_squares)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma nonnegativity_of_squares:\n  fixes a b :: real\n  shows \"a^2 >= 0\" and \"b^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"a^2 >= 0\" by auto\n  have \"b^2 = b * b\" by sos\n  then show \"b^2 >= 0\" by auto\nqed\n\nlemma sum_of_squares_nonneg:\n  fixes x y :: real\n  shows \"x^2 + y^2 >= 0\"\nproof -\n  have \"x^2 >= 0\" and \"y^2 >= 0\" by (simp_all add: nonnegativity_of_squares)\n  then show ?thesis by simp\nqed", "origin": "expression_nonneg", "update_count": 0}, "sqrt_propertiesV4": {"skill_name": "sqrt_propertiesV4", "marker": "lemma sqrt_properties:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x) + sqrt(y) = sqrt(x + y + 2*sqrt(x*y))\"\nproof -\n  have \"sqrt(x) + sqrt(y) \\<ge> 0\" using assms by auto\n  then have \"(sqrt(x) + sqrt(y))^2 = x + y + 2*sqrt(x)*sqrt(y)\"\n    by (smt (verit) assms(1) assms(2) power2_sum real_sqrt_pow2)\n  also have \"... = x + y + 2*sqrt(x*y)\" \n    by (metis calculation is_num_normalize(1) mult.commute mult.left_commute real_sqrt_mult)\n  finally have \"sqrt(x + y + 2*sqrt(x*y)) = sqrt((sqrt(x) + sqrt(y))^2)\"\n    by auto\n  then show ?thesis \n    using `sqrt(x) + sqrt(y) \\<ge> 0` by auto\nqed", "description": "-", "full_code": "lemma sqrt_properties:\n  fixes x y :: real\n  assumes \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"sqrt(x) + sqrt(y) = sqrt(x + y + 2*sqrt(x*y))\"\nproof -\n  have \"sqrt(x) + sqrt(y) \\<ge> 0\" using assms by auto\n  then have \"(sqrt(x) + sqrt(y))^2 = x + y + 2*sqrt(x)*sqrt(y)\"\n    by (smt (verit) assms(1) assms(2) power2_sum real_sqrt_pow2)\n  also have \"... = x + y + 2*sqrt(x*y)\" \n    by (metis calculation is_num_normalize(1) mult.commute mult.left_commute real_sqrt_mult)\n  finally have \"sqrt(x + y + 2*sqrt(x*y)) = sqrt((sqrt(x) + sqrt(y))^2)\"\n    by auto\n  then show ?thesis \n    using `sqrt(x) + sqrt(y) \\<ge> 0` by auto\nqed", "origin": "do_request", "update_count": 0}, "amc12a_2013_p8_evolvedV2": {"skill_name": "amc12a_2013_p8_evolvedV2", "marker": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (2 * (x - y)) / (x * y)\"\n    using rearranged by sos\n  have factored: \"x - y \\<noteq> 0\" using h2 by simp\n  have \"1 = 2 / (x * y)\"\n    using common_den factored by sos\n  hence \"x * y = 2\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_evolved:\n  fixes x y :: real\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: field_simps)\n  have common_den: \"x - y = (2 * (x - y)) / (x * y)\"\n    using rearranged by sos\n  have factored: \"x - y \\<noteq> 0\" using h2 by simp\n  have \"1 = 2 / (x * y)\"\n    using common_den factored by sos\n  hence \"x * y = 2\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "power_mod_generalized": {"skill_name": "power_mod_generalized", "marker": "lemma power_mod_generalized:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a > 0\" \"b > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then show ?case by (metis power_mod)\nqed", "description": "-", "full_code": "lemma power_mod_generalized:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"a > 0\" \"b > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then show ?case by (metis power_mod)\nqed", "origin": "power_mod", "update_count": 0}, "power_mod_general": {"skill_name": "power_mod_general", "marker": "lemma power_mod_general:\n  fixes a :: nat and b :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then show ?case \n  proof -\n    have \"a^(Suc b) = a * a^b\" by simp\n    then have \"a^(Suc b) mod m = (a * a^b) mod m\"\n      by simp\n    also have \"... = (a mod m * a^b mod m) mod m\" using assms by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod m) * ((a mod m)^b) mod m) mod m\" by (metis Suc \\<open>a * a ^ b mod m = a mod m * a ^ b mod m mod m\\<close> \\<open>a ^ Suc b = a * a ^ b\\<close> \\<open>a ^ Suc b mod m = a * a ^ b mod m\\<close> mod_mod_trivial mod_mult_cong mod_mult_left_eq)\n    finally show ?case by simp\n  qed\nqed", "description": "-", "full_code": "lemma power_mod_general:\n  fixes a :: nat and b :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then show ?case \n  proof -\n    have \"a^(Suc b) = a * a^b\" by simp\n    then have \"a^(Suc b) mod m = (a * a^b) mod m\"\n      by simp\n    also have \"... = (a mod m * a^b mod m) mod m\" using assms by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod m) * ((a mod m)^b) mod m) mod m\" by (metis Suc \\<open>a * a ^ b mod m = a mod m * a ^ b mod m mod m\\<close> \\<open>a ^ Suc b = a * a ^ b\\<close> \\<open>a ^ Suc b mod m = a * a ^ b mod m\\<close> mod_mod_trivial mod_mult_cong mod_mult_left_eq)\n    finally show ?case by simp\n  qed\nqed", "origin": "power_mod", "update_count": 0}, "power_mod_generalV2": {"skill_name": "power_mod_generalV2", "marker": "lemma power_mod_general:\n  fixes a :: nat and b :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then have \"a^(Suc b) = a * a^b\" by simp\n  then show ?case \n    by (metis power_mod)\nqed", "description": "-", "full_code": "lemma power_mod_general:\n  fixes a :: nat and b :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then have \"a^(Suc b) = a * a^b\" by simp\n  then show ?case \n    by (metis power_mod)\nqed", "origin": "power_mod", "update_count": 0}, "power_mod_with_exponent": {"skill_name": "power_mod_with_exponent", "marker": "lemma power_mod_with_exponent:\n  fixes a b c m :: nat\n  assumes \"m > 0\" \"c > 0\"\n  shows \"a^(b*c) mod m = ((a mod m)^(b*c)) mod m\"\nproof -\n  have \"a^(b*c) mod m = (a^b)^(c) mod m\" by (metis power_mult)\n  also have \"... = (((a mod m)^b) mod m)^(c) mod m\"\n    using power_mod_general[of a b m] assms by (metis power_mod)\n  also have \"... = ((a mod m)^(b*c)) mod m\" by (metis calculation power_mod)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma power_mod_general:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then show ?case by (metis power_mod)\nqed\n\nlemma power_mod_with_exponent:\n  fixes a b c m :: nat\n  assumes \"m > 0\" \"c > 0\"\n  shows \"a^(b*c) mod m = ((a mod m)^(b*c)) mod m\"\nproof -\n  have \"a^(b*c) mod m = (a^b)^(c) mod m\" by (metis power_mult)\n  also have \"... = (((a mod m)^b) mod m)^(c) mod m\"\n    using power_mod_general[of a b m] assms by (metis power_mod)\n  also have \"... = ((a mod m)^(b*c)) mod m\" by (metis calculation power_mod)\n  finally show ?thesis by simp\nqed", "origin": "power_mod", "update_count": 0}, "power_mod_generalV3": {"skill_name": "power_mod_generalV3", "marker": "lemma power_mod_general:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"b > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then show ?case \n  proof -\n    have \"a^(Suc b) mod m = (a * (a^b)) mod m\"\n      by simp\n    also have \"... = (a * ((a mod m)^b) mod m) mod m\"\n      using Suc.IH by (metis calculation mod_mod_trivial mod_mult_cong)\n    also have \"... = ((a mod m) * ((a mod m)^b) mod m) mod m\"\n      by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod m)^(Suc b)) mod m\"\n      by simp\n    finally show ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma power_mod_general:\n  fixes a b m :: nat\n  assumes \"m > 0\" \"b > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then show ?case \n  proof -\n    have \"a^(Suc b) mod m = (a * (a^b)) mod m\"\n      by simp\n    also have \"... = (a * ((a mod m)^b) mod m) mod m\"\n      using Suc.IH by (metis calculation mod_mod_trivial mod_mult_cong)\n    also have \"... = ((a mod m) * ((a mod m)^b) mod m) mod m\"\n      by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod m)^(Suc b)) mod m\"\n      by simp\n    finally show ?thesis by simp\n  qed\nqed", "origin": "power_mod", "update_count": 0}, "power_mod_with_base": {"skill_name": "power_mod_with_base", "marker": "lemma power_mod_with_base:\n  fixes a b c m :: nat\n  assumes \"m > 0\"\n  shows \"((a + c)^b) mod m = (((a mod m) + (c mod m))^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  have \"((a + c)^(Suc b)) mod m = ((a + c)*(a + c)^b) mod m\" by simp\n  also have \"... = ((a + c) mod m * (a + c)^b mod m) mod m\"\n    by (metis mod_mod_trivial mod_mult_left_eq)\n  also have \"... = (((a mod m) + (c mod m)) * ((a + c)^b mod m)) mod m\"\n    using Suc.IH by (metis \\<open>(a + c) * (a + c) ^ b mod m = (a + c) mod m * (a + c) ^ b mod m mod m\\<close> \\<open>(a + c) ^ Suc b mod m = (a + c) * (a + c) ^ b mod m\\<close> mod_add_eq mod_mult_cong mod_mult_right_eq mult.commute power_commutes)\n  also have \"... = (((a mod m) + (c mod m)) * (((a mod m) + (c mod m))^b) mod m) mod m\"\n    by (smt (verit) Suc \\<open>(a + c) * (a + c) ^ b mod m = (a + c) mod m * (a + c) ^ b mod m mod m\\<close> \\<open>(a + c) mod m * (a + c) ^ b mod m mod m = (a mod m + c mod m) * ((a + c) ^ b mod m) mod m\\<close> assms mod_add_eq mod_less mod_less_divisor mod_mult_eq)\n  finally show ?case by simp\nqed", "description": "-", "full_code": "lemma power_mod_with_base:\n  fixes a b c m :: nat\n  assumes \"m > 0\"\n  shows \"((a + c)^b) mod m = (((a mod m) + (c mod m))^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  have \"((a + c)^(Suc b)) mod m = ((a + c)*(a + c)^b) mod m\" by simp\n  also have \"... = ((a + c) mod m * (a + c)^b mod m) mod m\"\n    by (metis mod_mod_trivial mod_mult_left_eq)\n  also have \"... = (((a mod m) + (c mod m)) * ((a + c)^b mod m)) mod m\"\n    using Suc.IH by (metis \\<open>(a + c) * (a + c) ^ b mod m = (a + c) mod m * (a + c) ^ b mod m mod m\\<close> \\<open>(a + c) ^ Suc b mod m = (a + c) * (a + c) ^ b mod m\\<close> mod_add_eq mod_mult_cong mod_mult_right_eq mult.commute power_commutes)\n  also have \"... = (((a mod m) + (c mod m)) * (((a mod m) + (c mod m))^b) mod m) mod m\"\n    by (smt (verit) Suc \\<open>(a + c) * (a + c) ^ b mod m = (a + c) mod m * (a + c) ^ b mod m mod m\\<close> \\<open>(a + c) mod m * (a + c) ^ b mod m mod m = (a mod m + c mod m) * ((a + c) ^ b mod m) mod m\\<close> assms mod_add_eq mod_less mod_less_divisor mod_mult_eq)\n  finally show ?case by simp\nqed", "origin": "power_mod", "update_count": 0}, "power_mod_multi": {"skill_name": "power_mod_multi", "marker": "lemma power_mod_multi:\n  fixes a :: nat and b :: nat and m :: nat and d :: nat\n  assumes \"m > 0\" and \"d > 0\"\n  shows \"(a^b * d) mod m = ((a mod m)^b * d) mod m\"\nproof -\n  have \"a^b mod m = ((a mod m)^b) mod m\" by (metis power_mod assms(1))\n  then show ?thesis by (metis mod_mult_left_eq)\nqed", "description": "-", "full_code": "lemma power_mod:\n  fixes a :: nat and b :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"a^b mod m = ((a mod m)^b) mod m\"\nproof (induction b)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc b)\n  then show ?case by (metis mod_mult_left_eq power_mod)\nqed\n\nlemma power_mod_multi:\n  fixes a :: nat and b :: nat and m :: nat and d :: nat\n  assumes \"m > 0\" and \"d > 0\"\n  shows \"(a^b * d) mod m = ((a mod m)^b * d) mod m\"\nproof -\n  have \"a^b mod m = ((a mod m)^b) mod m\" by (metis power_mod assms(1))\n  then show ?thesis by (metis mod_mult_left_eq)\nqed", "origin": "power_mod", "update_count": 0}, "mod_10_calculation": {"skill_name": "mod_10_calculation", "marker": "lemma mod_10_calculation:\n  fixes a :: nat\n  assumes \"a mod 10 = 8\"\n  shows \"a^2 mod 10 = 4\"\nproof -\n  have \"a = 10 * (a div 10) + 8\" using assms by presburger\n  then have \"a^2 = (10 * (a div 10) + 8)^2\" by simp\n  also have \"... = (10 * (a div 10))^2 + 2 * (10 * (a div 10)) * 8 + 8^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (a div 10)^2 + 160 * (a div 10) + 64\" \n    by (simp add: power2_eq_square)\n  finally have \"a^2 = 100 * (a div 10)^2 + 160 * (a div 10) + 64\" .\n  then show \"a^2 mod 10 = 4\" \n  proof -\n    have \"a^2 mod 10 = (100 * (a div 10)^2 + 160 * (a div 10) + 64) mod 10\" by (metis \\<open>a\\<^sup>2 = 100 * (a div 10)\\<^sup>2 + 160 * (a div 10) + 64\\<close> eval_mod_exp(4) mod_exp_code semiring_norm(3))\n    also have \"... = (0 + 0 + 64) mod 10\" \n      using mod_mult_self1 mod_mult_self2 by presburger\n    finally show \"a^2 mod 10 = 4\" \n      by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_10_calculation:\n  fixes a :: nat\n  assumes \"a mod 10 = 8\"\n  shows \"a^2 mod 10 = 4\"\nproof -\n  have \"a = 10 * (a div 10) + 8\" using assms by presburger\n  then have \"a^2 = (10 * (a div 10) + 8)^2\" by simp\n  also have \"... = (10 * (a div 10))^2 + 2 * (10 * (a div 10)) * 8 + 8^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (a div 10)^2 + 160 * (a div 10) + 64\" \n    by (simp add: power2_eq_square)\n  finally have \"a^2 = 100 * (a div 10)^2 + 160 * (a div 10) + 64\" .\n  then show \"a^2 mod 10 = 4\" \n  proof -\n    have \"a^2 mod 10 = (100 * (a div 10)^2 + 160 * (a div 10) + 64) mod 10\" by (metis \\<open>a\\<^sup>2 = 100 * (a div 10)\\<^sup>2 + 160 * (a div 10) + 64\\<close> eval_mod_exp(4) mod_exp_code semiring_norm(3))\n    also have \"... = (0 + 0 + 64) mod 10\" \n      using mod_mult_self1 mod_mult_self2 by presburger\n    finally show \"a^2 mod 10 = 4\" \n      by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}}
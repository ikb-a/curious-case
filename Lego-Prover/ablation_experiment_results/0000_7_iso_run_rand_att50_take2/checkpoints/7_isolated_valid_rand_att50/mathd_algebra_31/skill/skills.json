{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "nonzero_times_inverse_multi": {"skill_name": "nonzero_times_inverse_multi", "marker": "lemma nonzero_times_inverse_multi:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"(a * (1 / a)) * (b * (1 / b)) = 1\"\n  by (simp add: assms)", "description": "-", "full_code": "lemma nonzero_times_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  by (simp add: assms)\n\nlemma nonzero_times_inverse_multi:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\" and \"b \\<noteq> 0\"\n  shows \"(a * (1 / a)) * (b * (1 / b)) = 1\"\n  by (simp add: assms)", "origin": "a_times_vera", "update_count": 0}, "non_zero_multiplicative_inverse": {"skill_name": "non_zero_multiplicative_inverse", "marker": "lemma non_zero_multiplicative_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"(1 / a) * a = 1\" using assms by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_zero_multiplicative_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"(1 / a) * a = 1\" using assms by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "a_times_vera", "update_count": 0}, "mod_add_power_with_variables": {"skill_name": "mod_add_power_with_variables", "marker": "lemma mod_add_power_with_variables:\n  fixes x n b c a :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_generalized[of x n b c a] by (smt (verit) assms(1) assms(2) assms(3) assms(4) mod_add_power_generalized)", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n b c a :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_with_variables:\n  fixes x n b c a :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_generalized[of x n b c a] by (smt (verit) assms(1) assms(2) assms(3) assms(4) mod_add_power_generalized)", "origin": "mod_add_power", "update_count": 0}, "sqrt_positive": {"skill_name": "sqrt_positive", "marker": "lemma sqrt_positive:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\n  by (simp add: assms)", "description": "", "full_code": "lemma sqrt_positive:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\n  by (simp add: assms)", "origin": "data/full_data/debug/valid_rand/mathd_algebra_31.json_v1", "update_count": -1}, "cancel_div_general": {"skill_name": "cancel_div_general", "marker": "lemma cancel_div_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + b = c * x\" \n    using assms(1) by (simp add: distrib_left)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma cancel_div_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + b = c * x\" \n    using assms(1) by (simp add: distrib_left)\n  thus ?thesis by sos\nqed", "origin": "cancle_div", "update_count": 0}, "cancle_div_general": {"skill_name": "cancle_div_general", "marker": "lemma cancle_div_general:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c + d / x\"\n  shows \"a * x + b = (c + d / x) * x\"\nproof -\n  have \"x * (a + b / x) = x * (c + d / x)\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = x * c + x * (d / x)\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma cancle_div_general:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c + d / x\"\n  shows \"a * x + b = (c + d / x) * x\"\nproof -\n  have \"x * (a + b / x) = x * (c + d / x)\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = x * c + x * (d / x)\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (auto simp: field_simps)\nqed", "origin": "cancle_div", "update_count": 0}, "sqrt_nonneg": {"skill_name": "sqrt_nonneg", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  shows \"a \\<ge> 0 \\<Longrightarrow> sqrt a \\<ge> 0\"\nproof -\n  assume \"a \\<ge> 0\"\n  then show \"sqrt a \\<ge> 0\" by (cases \"a = 0\") (simp_all add: sqrt_def)\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  shows \"a \\<ge> 0 \\<Longrightarrow> sqrt a \\<ge> 0\"\nproof -\n  assume \"a \\<ge> 0\"\n  then show \"sqrt a \\<ge> 0\" by (cases \"a = 0\") (simp_all add: sqrt_def)\nqed", "origin": "sqrt_positive", "update_count": 0}, "algebraic_rearrangement": {"skill_name": "algebraic_rearrangement", "marker": "lemma algebraic_rearrangement:\n  fixes a b c :: real\n  shows \"a + b = c \\<Longrightarrow> c - b = a\"\nproof -\n  assume \"a + b = c\"\n  hence \"c - b = a\"\n    by auto  \n  then show \"c - b = a\" by simp\nqed", "description": "-", "full_code": "lemma algebraic_rearrangement:\n  fixes a b c :: real\n  shows \"a + b = c \\<Longrightarrow> c - b = a\"\nproof -\n  assume \"a + b = c\"\n  hence \"c - b = a\"\n    by auto  \n  then show \"c - b = a\" by simp\nqed", "origin": "do_request", "update_count": 0}, "solve_for_x": {"skill_name": "solve_for_x", "marker": "lemma solve_for_x:\n  fixes x :: real\n  shows \"9 = sqrt(x + 9) \\<Longrightarrow> x = 72\"\nproof -\n  assume \"9 = sqrt(x + 9)\"\n  then have \"9^2 = x + 9\" \n    by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" \n    by simp\n  then show \"x = 72\" \n    by simp\nqed", "description": "-", "full_code": "lemma solve_for_x:\n  fixes x :: real\n  shows \"9 = sqrt(x + 9) \\<Longrightarrow> x = 72\"\nproof -\n  assume \"9 = sqrt(x + 9)\"\n  then have \"9^2 = x + 9\" \n    by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" \n    by simp\n  then show \"x = 72\" \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "solve_for_xV2": {"skill_name": "solve_for_xV2", "marker": "lemma solve_for_x:\n  fixes x :: real\n  shows \"9 = sqrt(x + 9) \\<Longrightarrow> x = 72\"\nproof -\n  assume \"9 = sqrt(x + 9)\"\n  then have \"9^2 = x + 9\" \n    by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  moreover have \"81 = x + 9\" \n    by (metis abs_numeral add.commute add.left_commute add_One_commute calculation num_double numeral_Bit0 numeral_Bit1 numeral_times_numeral power2_eq_square real_sqrt_abs2 real_sqrt_mult_self semiring_norm(3) semiring_norm(6) sqr.simps(2) sqr.simps(3) sqr_conv_mult)\n  ultimately have \"x = 81 - 9\" \n    by simp\n  thus \"x = 72\" \n    by simp\nqed", "description": "-", "full_code": "lemma solve_for_x:\n  fixes x :: real\n  shows \"9 = sqrt(x + 9) \\<Longrightarrow> x = 72\"\nproof -\n  assume \"9 = sqrt(x + 9)\"\n  then have \"9^2 = x + 9\" \n    by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  moreover have \"81 = x + 9\" \n    by (metis abs_numeral add.commute add.left_commute add_One_commute calculation num_double numeral_Bit0 numeral_Bit1 numeral_times_numeral power2_eq_square real_sqrt_abs2 real_sqrt_mult_self semiring_norm(3) semiring_norm(6) sqr.simps(2) sqr.simps(3) sqr_conv_mult)\n  ultimately have \"x = 81 - 9\" \n    by simp\n  thus \"x = 72\" \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_nonnegV2": {"skill_name": "sqrt_nonnegV2", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max a 0)\" \n    by (metis assms max.absorb_iff2 max.commute)\n  then show ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max a 0)\" \n    by (metis assms max.absorb_iff2 max.commute)\n  then show ?thesis using assms by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegV3": {"skill_name": "sqrt_nonnegV3", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a = 0 \\<longrightarrow> a = 0\" by auto\n  moreover have \"sqrt a > 0 \\<longrightarrow> a > 0\" by auto\n  ultimately show ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a = 0 \\<longrightarrow> a = 0\" by auto\n  moreover have \"sqrt a > 0 \\<longrightarrow> a > 0\" by auto\n  ultimately show ?thesis using assms by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "isolate_x": {"skill_name": "isolate_x", "marker": "lemma isolate_x:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"x = 72\"\nproof -\n  have \"x = 81 - 9\" \n    using assms by simp\n  thus ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma isolate_x:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"x = 72\"\nproof -\n  have \"x = 81 - 9\" \n    using assms by simp\n  thus ?thesis \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "rearrangement": {"skill_name": "rearrangement", "marker": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"b = a - c\" \n    using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"b = a - c\" \n    using assms by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "rearrangementV2": {"skill_name": "rearrangementV2", "marker": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"b + c = a\" using assms by auto\n  then have \"b = a - c\" \n    by (simp add: algebra_simps)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"b + c = a\" using assms by auto\n  then have \"b = a - c\" \n    by (simp add: algebra_simps)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_nonnegV4": {"skill_name": "sqrt_nonnegV4", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  shows \"a \\<ge> 0 \\<Longrightarrow> sqrt a \\<ge> 0\"\n  by auto", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  shows \"a \\<ge> 0 \\<Longrightarrow> sqrt a \\<ge> 0\"\n  by auto", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_and_nonnegative": {"skill_name": "sqrt_positive_and_nonnegative", "marker": "lemma sqrt_positive_and_nonnegative:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"a > 0 \\<Longrightarrow> sqrt a > 0\" using assms by (simp)\n  moreover have \"a = 0 \\<Longrightarrow> sqrt a = 0\" by simp\n  ultimately show \"sqrt a \\<ge> 0\" by (metis assms real_sqrt_ge_zero)\nqed", "description": "-", "full_code": "lemma sqrt_positive_and_nonnegative:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"a > 0 \\<Longrightarrow> sqrt a > 0\" using assms by (simp)\n  moreover have \"a = 0 \\<Longrightarrow> sqrt a = 0\" by simp\n  ultimately show \"sqrt a \\<ge> 0\" by (metis assms real_sqrt_ge_zero)\nqed", "origin": "sqrt_positive", "update_count": 0}, "rearrangementV3": {"skill_name": "rearrangementV3", "marker": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" \n    using assms by simp\n  then show \"b = a - c\" \n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" \n    using assms by simp\n  then show \"b = a - c\" \n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "rearrangementV4": {"skill_name": "rearrangementV4", "marker": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  obtain x where \"a = b + c\" using assms by auto\n  hence \"a - c = b\" by auto\n  thus \"b = a - c\" by simp\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  obtain x where \"a = b + c\" using assms by auto\n  hence \"a - c = b\" by auto\n  thus \"b = a - c\" by simp\nqed", "origin": "do_request", "update_count": 0}, "square_root_equation": {"skill_name": "square_root_equation", "marker": "lemma square_root_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9\" using assms by simp\n  then have \"9^2 = x + 9\" \n    by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" \n    by simp\n  then show \"x = 72\" \n    by simp\nqed", "description": "-", "full_code": "lemma square_root_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"sqrt (x + 9) = 9\" using assms by simp\n  then have \"9^2 = x + 9\" \n    by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" \n    by simp\n  then show \"x = 72\" \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "square_root_equationV2": {"skill_name": "square_root_equationV2", "marker": "lemma square_root_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" \n    using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" \n    by simp\n  then show \"x = 72\" \n    by simp\nqed", "description": "-", "full_code": "lemma square_root_equation:\n  fixes x :: real\n  assumes \"sqrt (x + 9) = 9\"\n  shows \"x = 72\"\nproof -\n  have \"9^2 = x + 9\" \n    using assms by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" \n    by simp\n  then show \"x = 72\" \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "non_negative_square": {"skill_name": "non_negative_square", "marker": "lemma non_negative_square:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"a^2 >= 0\" \n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a > 0\" using assms by linarith\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  qed\nqed", "description": "-", "full_code": "lemma non_negative_square:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  then show \"a^2 >= 0\" \n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a > 0\" using assms by linarith\n    then show ?thesis by (simp add: mult_nonneg_nonneg)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "non_negative_squareV2": {"skill_name": "non_negative_squareV2", "marker": "lemma non_negative_square:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"a * a >= 0\" using assms by (metis mult_nonneg_nonneg)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma non_negative_square:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"a * a >= 0\" using assms by (metis mult_nonneg_nonneg)\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_sum_nonnegative": {"skill_name": "sqrt_sum_nonnegative", "marker": "lemma sqrt_sum_nonnegative:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a + b) \\<ge> 0\"\n  by (metis add_nonneg_nonneg assms(1) assms(2) sqrt_nonnegative)", "description": "-", "full_code": "lemma sqrt_nonnegative:\n  fixes a :: real\n  shows \"a \\<ge> 0 \\<Longrightarrow> sqrt a \\<ge> 0\"\n  by auto\n\nlemma sqrt_sum_nonnegative:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a + b) \\<ge> 0\"\n  by (metis add_nonneg_nonneg assms(1) assms(2) sqrt_nonnegative)", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegative": {"skill_name": "sqrt_nonnegative", "marker": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\n  by (metis assms real_sqrt_ge_zero)", "description": "-", "full_code": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\n  by (metis assms real_sqrt_ge_zero)", "origin": "sqrt_positive", "update_count": 0}, "non_negative_squareV3": {"skill_name": "non_negative_squareV3", "marker": "lemma non_negative_square:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  then have \"a * a >= 0\" using assms by (metis mult_nonneg_nonneg)\n  thus \"a^2 >= 0\" by simp\nqed", "description": "-", "full_code": "lemma non_negative_square:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"a^2 >= 0\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  then have \"a * a >= 0\" using assms by (metis mult_nonneg_nonneg)\n  thus \"a^2 >= 0\" by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positive_general": {"skill_name": "sqrt_positive_general", "marker": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a = sqrt a\" by simp\n  then show \"sqrt a > 0\" using assms by (simp add: real_sqrt_gt_0_iff)\nqed", "description": "-", "full_code": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a = sqrt a\" by simp\n  then show \"sqrt a > 0\" using assms by (simp add: real_sqrt_gt_0_iff)\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegV5": {"skill_name": "sqrt_nonnegV5", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt a\" by simp\n  thus ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt a\" by simp\n  thus ?thesis using assms by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegV6": {"skill_name": "sqrt_nonnegV6", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<or> sqrt a > 0\" by (metis assms order.strict_iff_order real_sqrt_gt_zero real_sqrt_zero)\n  then show ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<or> sqrt a > 0\" by (metis assms order.strict_iff_order real_sqrt_gt_zero real_sqrt_zero)\n  then show ?thesis using assms by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_eq": {"skill_name": "sqrt_eq", "marker": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms(1) by auto\n  moreover have \"sqrt b ^ 2 = b\" using assms(2) by auto\n  moreover have \"sqrt a ^ 2 = sqrt b ^ 2\" using assms(3) by simp\n  ultimately show \"a = b\" by (metis power2_eq_iff)\nqed", "description": "-", "full_code": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms(1) by auto\n  moreover have \"sqrt b ^ 2 = b\" using assms(2) by auto\n  moreover have \"sqrt a ^ 2 = sqrt b ^ 2\" using assms(3) by simp\n  ultimately show \"a = b\" by (metis power2_eq_iff)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_eqV2": {"skill_name": "sqrt_eqV2", "marker": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"a = (sqrt a) ^ 2\" using assms(1) by auto\n  moreover have \"b = (sqrt b) ^ 2\" using assms(2) by auto\n  ultimately show \"a = b\" using assms(3) by auto\nqed", "description": "-", "full_code": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"a = (sqrt a) ^ 2\" using assms(1) by auto\n  moreover have \"b = (sqrt b) ^ 2\" using assms(2) by auto\n  ultimately show \"a = b\" using assms(3) by auto\nqed", "origin": "do_request", "update_count": 0}, "properties_of_sqrt": {"skill_name": "properties_of_sqrt", "marker": "lemma properties_of_sqrt:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a >= 0\" using assms by (metis real_sqrt_ge_zero)\n  thus \"sqrt a >= 0\" by simp\nqed", "description": "-", "full_code": "lemma properties_of_sqrt:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a >= 0\" using assms by (metis real_sqrt_ge_zero)\n  thus \"sqrt a >= 0\" by simp\nqed", "origin": "do_request", "update_count": 0}, "properties_of_sqrtV2": {"skill_name": "properties_of_sqrtV2", "marker": "lemma properties_of_sqrt:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  obtain b where \"b = sqrt a\" by auto\n  then have \"b \\<ge> 0\" using assms by (metis real_sqrt_ge_zero)\n  thus \"sqrt a \\<ge> 0\" by (metis assms real_sqrt_ge_zero)\nqed", "description": "-", "full_code": "lemma properties_of_sqrt:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  obtain b where \"b = sqrt a\" by auto\n  then have \"b \\<ge> 0\" using assms by (metis real_sqrt_ge_zero)\n  thus \"sqrt a \\<ge> 0\" by (metis assms real_sqrt_ge_zero)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_eqV3": {"skill_name": "sqrt_eqV3", "marker": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = sqrt b * sqrt b\" using assms(3) by auto\n  then have \"a = b\" using assms(1) assms(2) by (simp add: power2_eq_iff)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a * sqrt a = sqrt b * sqrt b\" using assms(3) by auto\n  then have \"a = b\" using assms(1) assms(2) by (simp add: power2_eq_iff)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_eqV4": {"skill_name": "sqrt_eqV4", "marker": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms(1) by auto\n  have \"sqrt b ^ 2 = b\" using assms(2) by auto\n  from assms(3) have \"sqrt a ^ 2 = sqrt b ^ 2\" by simp\n  then show ?thesis using `sqrt a ^ 2 = a` `sqrt b ^ 2 = b` by auto\nqed", "description": "-", "full_code": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms(1) by auto\n  have \"sqrt b ^ 2 = b\" using assms(2) by auto\n  from assms(3) have \"sqrt a ^ 2 = sqrt b ^ 2\" by simp\n  then show ?thesis using `sqrt a ^ 2 = a` `sqrt b ^ 2 = b` by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positive_generalV2": {"skill_name": "sqrt_positive_generalV2", "marker": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a = sqrt a - 0\" by simp\n  also have \"... > 0 - 0\" using assms by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a = sqrt a - 0\" by simp\n  also have \"... > 0 - 0\" using assms by auto\n  finally show ?thesis by simp\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_and_nonneg": {"skill_name": "sqrt_positive_and_nonneg", "marker": "lemma sqrt_positive_and_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  thus \"sqrt a >= 0\" using assms by simp\nqed", "description": "-", "full_code": "lemma sqrt_positive_and_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  thus \"sqrt a >= 0\" using assms by simp\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonneg_and_pos": {"skill_name": "sqrt_nonneg_and_pos", "marker": "lemma sqrt_nonneg_and_pos:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\" \n  and \"a > 0 \\<longrightarrow> sqrt a > 0\"\nproof -\n  show \"sqrt a \\<ge> 0\" using assms by simp\n  show \"a > 0 \\<longrightarrow> sqrt a > 0\" \n    using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg_and_pos:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\" \n  and \"a > 0 \\<longrightarrow> sqrt a > 0\"\nproof -\n  show \"sqrt a \\<ge> 0\" using assms by simp\n  show \"a > 0 \\<longrightarrow> sqrt a > 0\" \n    using assms by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_iff": {"skill_name": "sqrt_positive_iff", "marker": "lemma sqrt_positive_iff:\n  fixes a :: real\n  shows \"sqrt a > 0 \\<longleftrightarrow> a > 0\"\nproof -\n  have \"sqrt a > 0 \\<Longrightarrow> a > 0\"\n    by auto\n  moreover have \"a > 0 \\<Longrightarrow> sqrt a > 0\"\n    by auto\n  ultimately show ?thesis by blast\nqed", "description": "-", "full_code": "lemma sqrt_positive_iff:\n  fixes a :: real\n  shows \"sqrt a > 0 \\<longleftrightarrow> a > 0\"\nproof -\n  have \"sqrt a > 0 \\<Longrightarrow> a > 0\"\n    by auto\n  moreover have \"a > 0 \\<Longrightarrow> sqrt a > 0\"\n    by auto\n  ultimately show ?thesis by blast\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonneg_diff": {"skill_name": "sqrt_nonneg_diff", "marker": "lemma sqrt_nonneg_diff:\n  fixes a b :: real\n  assumes \"a \\<ge> b\" \"b \\<ge> 0\"\n  shows \"sqrt (a - b) \\<ge> 0\"\n  using assms by auto", "description": "-", "full_code": "lemma sqrt_nonneg_diff:\n  fixes a b :: real\n  assumes \"a \\<ge> b\" \"b \\<ge> 0\"\n  shows \"sqrt (a - b) \\<ge> 0\"\n  using assms by auto", "origin": "sqrt_positive", "update_count": 0}, "square_root_equationV3": {"skill_name": "square_root_equationV3", "marker": "lemma square_root_equation:\n  fixes x :: real\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof\n  assume \"sqrt (x + 9) = 9\"\n  then have \"9^2 = x + 9\" \n    by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" \n    by simp\n  thus \"x = 72\"\n    by simp\nnext\n  assume \"x = 72\"\n  then have \"x + 9 = 72 + 9\" \n    by simp\n  then have \"x + 9 = 81\" \n    by simp\n  thus \"sqrt (x + 9) = 9\"\n    by auto\nqed", "description": "-", "full_code": "lemma square_root_equation:\n  fixes x :: real\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof\n  assume \"sqrt (x + 9) = 9\"\n  then have \"9^2 = x + 9\" \n    by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n  then have \"81 = x + 9\" \n    by simp\n  thus \"x = 72\"\n    by simp\nnext\n  assume \"x = 72\"\n  then have \"x + 9 = 72 + 9\" \n    by simp\n  then have \"x + 9 = 81\" \n    by simp\n  thus \"sqrt (x + 9) = 9\"\n    by auto\nqed", "origin": "do_request", "update_count": 0}, "square_root_equationV4": {"skill_name": "square_root_equationV4", "marker": "lemma square_root_equation:\n  fixes x :: real\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof\n  show \"sqrt (x + 9) = 9 \\<Longrightarrow> x = 72\"\n  proof -\n    assume \"sqrt (x + 9) = 9\"\n    then have \"9^2 = x + 9\" \n      by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n    hence \"81 = x + 9\" \n      by simp\n    thus \"x = 72\" \n      by simp\n  qed\n  show \"x = 72 \\<Longrightarrow> sqrt (x + 9) = 9\"\n  proof -\n    assume \"x = 72\"\n    hence \"x + 9 = 72 + 9\" \n      by simp\n    thus \"sqrt (x + 9) = 9\" \n      by (simp add: sqrt_def)\n  qed\nqed", "description": "-", "full_code": "lemma square_root_equation:\n  fixes x :: real\n  shows \"sqrt (x + 9) = 9 \\<longleftrightarrow> x = 72\"\nproof\n  show \"sqrt (x + 9) = 9 \\<Longrightarrow> x = 72\"\n  proof -\n    assume \"sqrt (x + 9) = 9\"\n    then have \"9^2 = x + 9\" \n      by (metis real_sqrt_eq_iff real_sqrt_unique zero_le_numeral)\n    hence \"81 = x + 9\" \n      by simp\n    thus \"x = 72\" \n      by simp\n  qed\n  show \"x = 72 \\<Longrightarrow> sqrt (x + 9) = 9\"\n  proof -\n    assume \"x = 72\"\n    hence \"x + 9 = 72 + 9\" \n      by simp\n    thus \"sqrt (x + 9) = 9\" \n      by (simp add: sqrt_def)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sqrt_limit": {"skill_name": "sqrt_limit", "marker": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x = 9 \\<longleftrightarrow> x = 81\"\nproof\n  assume \"sqrt x = 9\"\n  then have \"9^2 = x\" \n    by (metis assms real_sqrt_pow2)\n  thus \"x = 81\"\n    by simp\nnext\n  assume \"x = 81\"\n  then have \"sqrt x = sqrt 81\" \n    by simp\n  then show \"sqrt x = 9\"\n    by simp\nqed", "description": "-", "full_code": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x = 9 \\<longleftrightarrow> x = 81\"\nproof\n  assume \"sqrt x = 9\"\n  then have \"9^2 = x\" \n    by (metis assms real_sqrt_pow2)\n  thus \"x = 81\"\n    by simp\nnext\n  assume \"x = 81\"\n  then have \"sqrt x = sqrt 81\" \n    by simp\n  then show \"sqrt x = 9\"\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_limitV2": {"skill_name": "sqrt_limitV2", "marker": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x = 9 \\<longleftrightarrow> x = 81\"\nproof\n  show \"sqrt x = 9 \\<Longrightarrow> x = 81\"\n  proof -\n    assume \"sqrt x = 9\"\n    then have \"9^2 = x\" \n      by (metis assms real_sqrt_pow2)\n    thus \"x = 81\"\n      by simp\n  qed\n  show \"x = 81 \\<Longrightarrow> sqrt x = 9\"\n  proof -\n    assume \"x = 81\"\n    then have \"sqrt x = sqrt 81\" \n      by simp\n    thus \"sqrt x = 9\"\n      by simp\n  qed\nqed", "description": "-", "full_code": "lemma sqrt_limit:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x = 9 \\<longleftrightarrow> x = 81\"\nproof\n  show \"sqrt x = 9 \\<Longrightarrow> x = 81\"\n  proof -\n    assume \"sqrt x = 9\"\n    then have \"9^2 = x\" \n      by (metis assms real_sqrt_pow2)\n    thus \"x = 81\"\n      by simp\n  qed\n  show \"x = 81 \\<Longrightarrow> sqrt x = 9\"\n  proof -\n    assume \"x = 81\"\n    then have \"sqrt x = sqrt 81\" \n      by simp\n    thus \"sqrt x = 9\"\n      by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sqrt_nonnegV7": {"skill_name": "sqrt_nonnegV7", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max 0 a)\" using assms by (simp)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max 0 a)\" using assms by (simp)\n  then show ?thesis by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegativeV2": {"skill_name": "sqrt_nonnegativeV2", "marker": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\n  using assms by simp", "description": "-", "full_code": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\n  using assms by simp", "origin": "sqrt_positive", "update_count": 0}, "properties_of_sqrtV3": {"skill_name": "properties_of_sqrtV3", "marker": "lemma properties_of_sqrt:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by (simp add: real_sqrt_zero)\n  then show \"sqrt a >= 0\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    with assms have \"a > 0\" by auto\n    hence \"sqrt a > 0\" by auto\n    then show ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma properties_of_sqrt:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by (simp add: real_sqrt_zero)\n  then show \"sqrt a >= 0\"\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    with assms have \"a > 0\" by auto\n    hence \"sqrt a > 0\" by auto\n    then show ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "properties_of_sqrtV4": {"skill_name": "properties_of_sqrtV4", "marker": "lemma properties_of_sqrt:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  then have \"sqrt a >= 0\" using assms by (metis real_sqrt_ge_zero)\n  thus \"sqrt a >= 0\" by simp\nqed", "description": "-", "full_code": "lemma properties_of_sqrt:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  then have \"sqrt a >= 0\" using assms by (metis real_sqrt_ge_zero)\n  thus \"sqrt a >= 0\" by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_non_negative": {"skill_name": "sqrt_non_negative", "marker": "lemma sqrt_non_negative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  obtain b where \"a = b^2\" using assms by (metis order_less_le pos2 realpow_pos_nth_unique zero_power2)\n  then show ?thesis by (simp add: sqrt_def)\nqed", "description": "-", "full_code": "lemma sqrt_non_negative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  obtain b where \"a = b^2\" using assms by (metis order_less_le pos2 realpow_pos_nth_unique zero_power2)\n  then show ?thesis by (simp add: sqrt_def)\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_non_negativeV2": {"skill_name": "sqrt_non_negativeV2", "marker": "lemma sqrt_non_negative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  thus ?thesis using assms by (cases \"a = 0\") auto\nqed", "description": "-", "full_code": "lemma sqrt_non_negative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  thus ?thesis using assms by (cases \"a = 0\") auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_non_negativeV3": {"skill_name": "sqrt_non_negativeV3", "marker": "lemma sqrt_non_negative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0\" if \"a = 0\" using that by simp\n  moreover have \"sqrt a > 0\" if \"a > 0\" using that by (simp add: assms)\n  ultimately show ?thesis by (metis assms real_sqrt_ge_zero)\nqed", "description": "-", "full_code": "lemma sqrt_non_negative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0\" if \"a = 0\" using that by simp\n  moreover have \"sqrt a > 0\" if \"a > 0\" using that by (simp add: assms)\n  ultimately show ?thesis by (metis assms real_sqrt_ge_zero)\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_condition": {"skill_name": "sqrt_positive_condition", "marker": "lemma sqrt_positive_condition:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  then have \"sqrt a * sqrt a > 0\" using assms by (simp add: mult_pos_pos)\n  thus ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive_condition:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a * sqrt a = a\" using assms by auto\n  then have \"sqrt a * sqrt a > 0\" using assms by (simp add: mult_pos_pos)\n  thus ?thesis using assms by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_imp_nonneg": {"skill_name": "sqrt_positive_imp_nonneg", "marker": "lemma sqrt_positive_imp_nonneg:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\n  using assms by (simp add: sqrt_nonneg)", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  shows \"a \\<ge> 0 \\<Longrightarrow> sqrt a \\<ge> 0\"\n  by auto\n\nlemma sqrt_positive_imp_nonneg:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\n  using assms by (simp add: sqrt_nonneg)", "origin": "sqrt_positive", "update_count": 0}, "sqrt_non_negativeV4": {"skill_name": "sqrt_non_negativeV4", "marker": "lemma sqrt_non_negative:\n  fixes a :: real\n  shows \"a >= 0 \\<Longrightarrow> sqrt a >= 0\"\nproof -\n  assume \"a >= 0\"\n  then show \"sqrt a >= 0\" by auto\nqed", "description": "-", "full_code": "lemma sqrt_non_negative:\n  fixes a :: real\n  shows \"a >= 0 \\<Longrightarrow> sqrt a >= 0\"\nproof -\n  assume \"a >= 0\"\n  then show \"sqrt a >= 0\" by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_contradiction": {"skill_name": "sqrt_positive_contradiction", "marker": "lemma sqrt_positive_contradiction:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a = 0 \\<Longrightarrow> a < 0\" using assms by auto\n  thus ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive_contradiction:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a = 0 \\<Longrightarrow> a < 0\" using assms by auto\n  thus ?thesis using assms by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "square_nonneg": {"skill_name": "square_nonneg", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by simp\n  then have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"... = b * b\" by (metis assms(1) power2_eq_square)\n  finally show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by simp\n  then have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"... = b * b\" by (metis assms(1) power2_eq_square)\n  finally show ?thesis by sos\nqed", "origin": "do_request", "update_count": 0}, "square_nonnegV2": {"skill_name": "square_nonnegV2", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"b^2 = b * b\" by sos\n  moreover have \"a = b\" by (rule assms(1))\n  ultimately show ?thesis \n    using assms(1) by (metis mult_eq_0_iff)\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"b^2 = b * b\" by sos\n  moreover have \"a = b\" by (rule assms(1))\n  ultimately show ?thesis \n    using assms(1) by (metis mult_eq_0_iff)\nqed", "origin": "do_request", "update_count": 0}, "square_nonnegV3": {"skill_name": "square_nonnegV3", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"b^2 = b * b\" by sos\n  moreover have \"a * a = b * b\" using assms(1) by (metis assms(1) power2_eq_square)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by sos\n  moreover have \"b^2 = b * b\" by sos\n  moreover have \"a * a = b * b\" using assms(1) by (metis assms(1) power2_eq_square)\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_nonnegV4": {"skill_name": "square_nonnegV4", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by simp\n  then show \"a^2 = b^2\"\n  proof -\n    have \"a^2 = a * a\" by (simp add: power2_eq_square)\n    also have \"... = b * b\" using `b = a` by (simp add: power2_eq_square)\n    finally show ?thesis by sos\n  qed\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by simp\n  then show \"a^2 = b^2\"\n  proof -\n    have \"a^2 = a * a\" by (simp add: power2_eq_square)\n    also have \"... = b * b\" using `b = a` by (simp add: power2_eq_square)\n    finally show ?thesis by sos\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_nonnegV5": {"skill_name": "square_nonnegV5", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  moreover have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  moreover have \"a = b\" using assms(1) by simp\n  ultimately show ?thesis \n    using assms(1) by (metis mult_eq_0_iff)\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  moreover have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  moreover have \"a = b\" using assms(1) by simp\n  ultimately show ?thesis \n    using assms(1) by (metis mult_eq_0_iff)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_sum_positive": {"skill_name": "sqrt_sum_positive", "marker": "lemma sqrt_sum_positive:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt (a + b) > 0\"\nproof -\n  have \"a + b > 0\" using assms by auto\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_sum_positive:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt (a + b) > 0\"\nproof -\n  have \"a + b > 0\" using assms by auto\n  then show ?thesis by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_if_positive": {"skill_name": "sqrt_positive_if_positive", "marker": "lemma sqrt_positive_if_positive:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\n  using assms sqrt_positive_and_non_neg by simp", "description": "-", "full_code": "lemma sqrt_positive_and_non_neg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  thus ?thesis using assms by auto\nqed\n\nlemma sqrt_positive_if_positive:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\n  using assms sqrt_positive_and_non_neg by simp", "origin": "sqrt_positive", "update_count": 0}, "square_nonnegV6": {"skill_name": "square_nonnegV6", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"a * a = b * b\" using assms(1) by (simp add: power2_eq_square)\n  also have \"b * b = b^2\" by (simp add: power2_eq_square)\n  finally show \"a^2 = b^2\" by simp\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"a * a = b * b\" using assms(1) by (simp add: power2_eq_square)\n  also have \"b * b = b^2\" by (simp add: power2_eq_square)\n  finally show \"a^2 = b^2\" by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positive_implies_greater_than_zero": {"skill_name": "sqrt_positive_implies_greater_than_zero", "marker": "lemma sqrt_positive_implies_greater_than_zero:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  from assms have \"a > 0\" by simp\n  then show \"sqrt a > 0\" by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive_implies_greater_than_zero:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  from assms have \"a > 0\" by simp\n  then show \"sqrt a > 0\" by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonneg_sqrt_positive": {"skill_name": "sqrt_nonneg_sqrt_positive", "marker": "lemma sqrt_nonneg_sqrt_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a = 0 \\<longleftrightarrow> a = 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\"\n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_nonneg_sqrt_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a = 0 \\<longleftrightarrow> a = 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\"\n    by auto\n  thus ?thesis by simp\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegativeV3": {"skill_name": "sqrt_nonnegativeV3", "marker": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  from assms show \"sqrt a >= 0\" by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  from assms show \"sqrt a >= 0\" by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "rearrangementV5": {"skill_name": "rearrangementV5", "marker": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" \n    using assms by simp\n  also have \"... = b\" \n    by (simp add: algebra_simps)\n  finally show \"b = a - c\" by simp\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" \n    using assms by simp\n  also have \"... = b\" \n    by (simp add: algebra_simps)\n  finally show \"b = a - c\" by simp\nqed", "origin": "do_request", "update_count": 0}, "rearrangementV6": {"skill_name": "rearrangementV6", "marker": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" \n    using assms by simp\n  then have \"a - c = b + (c - c)\"\n    by simp\n  then have \"a - c = b + 0\" \n    by simp\n  then show \"b = a - c\" \n    by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes a b c :: real\n  assumes \"a = b + c\"\n  shows \"b = a - c\"\nproof -\n  have \"a - c = (b + c) - c\" \n    using assms by simp\n  then have \"a - c = b + (c - c)\"\n    by simp\n  then have \"a - c = b + 0\" \n    by simp\n  then show \"b = a - c\" \n    by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_of_pos_sum_of_squares": {"skill_name": "sqrt_of_pos_sum_of_squares", "marker": "lemma sqrt_of_pos_sum_of_squares:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt (a^2 + b^2) > 0\"\n  by (metis assms(1) less_numeral_extra(3) real_less_rsqrt sum_power2_gt_zero_iff zero_eq_power2)", "description": "-", "full_code": "lemma sqrt_of_pos_sum_of_squares:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"sqrt (a^2 + b^2) > 0\"\n  by (metis assms(1) less_numeral_extra(3) real_less_rsqrt sum_power2_gt_zero_iff zero_eq_power2)", "origin": "sqrt_positive", "update_count": 0}, "sqrt_of_sum_of_squares": {"skill_name": "sqrt_of_sum_of_squares", "marker": "lemma sqrt_of_sum_of_squares:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a^2 + b^2) >= 0\"\n  by (simp add: assms)", "description": "-", "full_code": "lemma sqrt_of_sum_of_squares:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt (a^2 + b^2) >= 0\"\n  by (simp add: assms)", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegV8": {"skill_name": "sqrt_nonnegV8", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof (cases \"a = 0\")\n  case True\n  then show ?thesis by simp\nnext\n  case False\n  then show ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof (cases \"a = 0\")\n  case True\n  then show ?thesis by simp\nnext\n  case False\n  then show ?thesis using assms by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegativeV4": {"skill_name": "sqrt_nonnegativeV4", "marker": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a = 0 \\<or> sqrt a > 0\" by (metis assms order.strict_iff_order real_sqrt_gt_zero real_sqrt_zero)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a = 0 \\<or> sqrt a > 0\" by (metis assms order.strict_iff_order real_sqrt_gt_zero real_sqrt_zero)\n  thus ?thesis by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_eqV5": {"skill_name": "sqrt_eqV5", "marker": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms(1) by (simp add: power2_eq_iff)\n  moreover have \"sqrt b ^ 2 = b\" using assms(2) by (simp add: power2_eq_iff)\n  moreover have \"sqrt a ^ 2 = sqrt b ^ 2\" using assms(3) by simp\n  ultimately show \"a = b\" using power2_eq_iff by presburger\nqed", "description": "-", "full_code": "lemma sqrt_eq:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\" \"sqrt a = sqrt b\"\n  shows \"a = b\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms(1) by (simp add: power2_eq_iff)\n  moreover have \"sqrt b ^ 2 = b\" using assms(2) by (simp add: power2_eq_iff)\n  moreover have \"sqrt a ^ 2 = sqrt b ^ 2\" using assms(3) by simp\n  ultimately show \"a = b\" using power2_eq_iff by presburger\nqed", "origin": "do_request", "update_count": 0}, "sqrt_diff_inequality": {"skill_name": "sqrt_diff_inequality", "marker": "lemma sqrt_diff_inequality:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a + b) \\<le> sqrt a + sqrt b\"\nproof -\n  have \"sqrt (a + b) = sqrt (sqrt a^2 + sqrt b^2)\"\n    by (metis abs_of_nonneg assms(1) assms(2) one_add_one power2_eq_square real_sqrt_mult_self)\n  also have \"... \\<le> sqrt a + sqrt b\" by (metis assms(1) assms(2) calculation sqrt_add_le_add_sqrt)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma sqrt_diff_inequality:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt (a + b) \\<le> sqrt a + sqrt b\"\nproof -\n  have \"sqrt (a + b) = sqrt (sqrt a^2 + sqrt b^2)\"\n    by (metis abs_of_nonneg assms(1) assms(2) one_add_one power2_eq_square real_sqrt_mult_self)\n  also have \"... \\<le> sqrt a + sqrt b\" by (metis assms(1) assms(2) calculation sqrt_add_le_add_sqrt)\n  finally show ?thesis .\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegV9": {"skill_name": "sqrt_nonnegV9", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0\" if \"a = 0\" using that by simp\n  moreover have \"sqrt a > 0\" if \"a > 0\" using that by simp\n  ultimately show ?thesis by (metis assms real_sqrt_ge_zero)\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0\" if \"a = 0\" using that by simp\n  moreover have \"sqrt a > 0\" if \"a > 0\" using that by simp\n  ultimately show ?thesis by (metis assms real_sqrt_ge_zero)\nqed", "origin": "sqrt_positive", "update_count": 0}, "square_equivalence": {"skill_name": "square_equivalence", "marker": "lemma square_equivalence:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"... = b * b\" using assms by (simp add: power2_eq_square)\n  finally show ?thesis by sos\nqed", "description": "-", "full_code": "lemma square_equivalence:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"... = b * b\" using assms by (simp add: power2_eq_square)\n  finally show ?thesis by sos\nqed", "origin": "do_request", "update_count": 0}, "square_equivalenceV2": {"skill_name": "square_equivalenceV2", "marker": "lemma square_equivalence:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  moreover have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  moreover have \"a * a = b * b\" using assms by (metis assms power2_eq_square)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_equivalence:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  moreover have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  moreover have \"a * a = b * b\" using assms by (metis assms power2_eq_square)\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_equivalenceV3": {"skill_name": "square_equivalenceV3", "marker": "lemma square_equivalence:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"a * a = b * b\" using assms by (simp add: power2_eq_square)\n  also have \"b * b = b^2\" by (simp add: power2_eq_square)\n  finally show \"a^2 = b^2\" by simp\nqed", "description": "-", "full_code": "lemma square_equivalence:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  also have \"a * a = b * b\" using assms by (simp add: power2_eq_square)\n  also have \"b * b = b^2\" by (simp add: power2_eq_square)\n  finally show \"a^2 = b^2\" by simp\nqed", "origin": "do_request", "update_count": 0}, "square_equivalenceV4": {"skill_name": "square_equivalenceV4", "marker": "lemma square_equivalence:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms have \"a = b\" by simp\n  then show \"a^2 = b^2\" \n    by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_equivalence:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms have \"a = b\" by simp\n  then show \"a^2 = b^2\" \n    by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "isolate_xV2": {"skill_name": "isolate_xV2", "marker": "lemma isolate_x:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 81\" using assms by simp\n  then have \"x = 81 - 9\" \n    by (simp add: algebra_simps)\n  then show \"x = 72\" \n    by simp\nqed", "description": "-", "full_code": "lemma isolate_x:\n  fixes x :: real\n  assumes \"x + 9 = 81\"\n  shows \"x = 72\"\nproof -\n  have \"x + 9 = 81\" using assms by simp\n  then have \"x = 81 - 9\" \n    by (simp add: algebra_simps)\n  then show \"x = 72\" \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_square": {"skill_name": "sqrt_square", "marker": "lemma sqrt_square:\n  fixes a :: real\n  assumes \"0 \\<le> a\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms by auto\n  thus ?thesis by (simp only: power2_eq_square)\nqed", "description": "-", "full_code": "lemma sqrt_square:\n  fixes a :: real\n  assumes \"0 \\<le> a\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a ^ 2 = a\" using assms by auto\n  thus ?thesis by (simp only: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_squareV2": {"skill_name": "sqrt_squareV2", "marker": "lemma sqrt_square:\n  fixes a :: real\n  assumes \"0 \\<le> a\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a \\<ge> 0\" using assms by auto\n  then have \"sqrt a * sqrt a = a\" using assms by (simp add: power2_eq_iff)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_square:\n  fixes a :: real\n  assumes \"0 \\<le> a\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a \\<ge> 0\" using assms by auto\n  then have \"sqrt a * sqrt a = a\" using assms by (simp add: power2_eq_iff)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_squareV3": {"skill_name": "sqrt_squareV3", "marker": "lemma sqrt_square:\n  fixes a :: real\n  assumes \"0 \\<le> a\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a \\<ge> 0\" using assms by auto\n  then have \"sqrt a * sqrt a = (sqrt a) ^ 2\" by simp\n  also have \"... = a\" using assms by (simp add: sqrt_def)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_square:\n  fixes a :: real\n  assumes \"0 \\<le> a\"\n  shows \"sqrt a * sqrt a = a\"\nproof -\n  have \"sqrt a \\<ge> 0\" using assms by auto\n  then have \"sqrt a * sqrt a = (sqrt a) ^ 2\" by simp\n  also have \"... = a\" using assms by (simp add: sqrt_def)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_nonnegV7": {"skill_name": "square_nonnegV7", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  moreover have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  moreover have \"a * a = b * b\" using assms(1) by (simp add: assms(1))\n  ultimately show ?thesis by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  have \"a^2 = a * a\" by (simp add: power2_eq_square)\n  moreover have \"b^2 = b * b\" by (simp add: power2_eq_square)\n  moreover have \"a * a = b * b\" using assms(1) by (simp add: assms(1))\n  ultimately show ?thesis by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "square_nonnegV8": {"skill_name": "square_nonnegV8", "marker": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by simp\n  hence \"b^2 = a^2\" by (simp add: power2_eq_square)\n  thus ?thesis by (simp add: assms(1))\nqed", "description": "-", "full_code": "lemma square_nonneg:\n  fixes a b :: real\n  assumes \"a = b\" and \"a >= 0\" and \"b >= 0\"\n  shows \"a^2 = b^2\"\nproof -\n  from assms(1) have \"b = a\" by simp\n  hence \"b^2 = a^2\" by (simp add: power2_eq_square)\n  thus ?thesis by (simp add: assms(1))\nqed", "origin": "do_request", "update_count": 0}, "sqrt_nonnegV10": {"skill_name": "sqrt_nonnegV10", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0\" if \"a = 0\" for a\n    by (metis real_sqrt_zero that)\n  then show \"sqrt a >= 0\" \n    using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0\" if \"a = 0\" for a\n    by (metis real_sqrt_zero that)\n  then show \"sqrt a >= 0\" \n    using assms by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "real_square_root_positive": {"skill_name": "real_square_root_positive", "marker": "lemma real_square_root_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  moreover have \"a = 0 \\<longrightarrow> sqrt a = 0\" by (simp add: assms)\n  ultimately show ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma real_square_root_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  moreover have \"a = 0 \\<longrightarrow> sqrt a = 0\" by (simp add: assms)\n  ultimately show ?thesis using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "real_square_root_positiveV2": {"skill_name": "real_square_root_positiveV2", "marker": "lemma real_square_root_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  thus ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a > 0\" using assms by linarith\n    thus ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma real_square_root_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  thus ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a > 0\" using assms by linarith\n    thus ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "square_both_sides": {"skill_name": "square_both_sides", "marker": "lemma square_both_sides:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  have \"sqrt a = sqrt b\" using assms by (simp)\n  thus ?thesis by (simp)\nqed", "description": "-", "full_code": "lemma square_both_sides:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  have \"sqrt a = sqrt b\" using assms by (simp)\n  thus ?thesis by (simp)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positiveV2": {"skill_name": "sqrt_positiveV2", "marker": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = 0 \\<longleftrightarrow> x = 0\" by auto\n  then show \"sqrt x >= 0\" using assms\n  proof (cases \"x = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    with assms show ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma sqrt_positive:\n  fixes x :: real\n  assumes \"x >= 0\"\n  shows \"sqrt x >= 0\"\nproof -\n  have \"sqrt x = 0 \\<longleftrightarrow> x = 0\" by auto\n  then show \"sqrt x >= 0\" using assms\n  proof (cases \"x = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    with assms show ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positive_extended": {"skill_name": "sqrt_positive_extended", "marker": "lemma sqrt_positive_extended:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a = sqrt (abs a)\" using assms by auto\n  moreover have \"sqrt (abs a) > 0\" using assms by auto\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_positive_extended:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a = sqrt (abs a)\" using assms by auto\n  moreover have \"sqrt (abs a) > 0\" using assms by auto\n  ultimately show ?thesis by simp\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegativeV5": {"skill_name": "sqrt_nonnegativeV5", "marker": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"0 \\<le> a\"\n  shows \"sqrt a * sqrt a = a\"\n  using assms by auto", "description": "-", "full_code": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"0 \\<le> a\"\n  shows \"sqrt a * sqrt a = a\"\n  using assms by auto", "origin": "sqrt_positive", "update_count": 0}, "sqrt_add_nonneg": {"skill_name": "sqrt_add_nonneg", "marker": "lemma sqrt_add_nonneg:\n  fixes a b :: real\n  assumes \"0 \\<le> a\" \"0 \\<le> b\"\n  shows \"sqrt (a + b) \\<ge> 0\"\nproof -\n  have \"a + b \\<ge> 0\" using assms by simp\n  then show ?thesis by (simp add: sqrt_nonneg)\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"0 \\<le> a\"\n  shows \"sqrt a \\<ge> 0\"\n  by (simp add: assms)\n\nlemma sqrt_add_nonneg:\n  fixes a b :: real\n  assumes \"0 \\<le> a\" \"0 \\<le> b\"\n  shows \"sqrt (a + b) \\<ge> 0\"\nproof -\n  have \"a + b \\<ge> 0\" using assms by simp\n  then show ?thesis by (simp add: sqrt_nonneg)\nqed", "origin": "sqrt_positive", "update_count": 0}, "square_both_sidesV2": {"skill_name": "square_both_sidesV2", "marker": "lemma square_both_sides:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  from assms have \"a = b\" by assumption\n  hence \"sqrt a = sqrt b\" by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_both_sides:\n  fixes a b :: real\n  assumes \"a = b\"\n  shows \"sqrt a = sqrt b\"\nproof -\n  from assms have \"a = b\" by assumption\n  hence \"sqrt a = sqrt b\" by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "real_square_root_positiveV3": {"skill_name": "real_square_root_positiveV3", "marker": "lemma real_square_root_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  moreover have \"a = 0 \\<longrightarrow> sqrt a = 0\" using assms by simp\n  moreover have \"a > 0 \\<longrightarrow> sqrt a > 0\" by auto\n  ultimately show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a > 0\" using assms by auto \n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma real_square_root_positive:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  moreover have \"a = 0 \\<longrightarrow> sqrt a = 0\" using assms by simp\n  moreover have \"a > 0 \\<longrightarrow> sqrt a > 0\" by auto\n  ultimately show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"a > 0\" using assms by auto \n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positive_parametrized": {"skill_name": "sqrt_positive_parametrized", "marker": "lemma sqrt_positive_parametrized:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt (a) > 0\"\n  using sqrt_positive_general[of a] assms by simp", "description": "-", "full_code": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\n  by (simp add: assms)\n\nlemma sqrt_positive_parametrized:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt (a) > 0\"\n  using sqrt_positive_general[of a] assms by simp", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_generalV3": {"skill_name": "sqrt_positive_generalV3", "marker": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  from assms have \"a >= 0\" by simp\n  thus ?thesis by (metis assms real_sqrt_gt_zero)\nqed", "description": "-", "full_code": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  from assms have \"a >= 0\" by simp\n  thus ?thesis by (metis assms real_sqrt_gt_zero)\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_generalV4": {"skill_name": "sqrt_positive_generalV4", "marker": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\" and \"n > 0\"\n  shows \"sqrt a > 0 \\<Longrightarrow> sqrt (a + n) > 0\"\nproof -\n  have \"a + n > 0\" using assms by simp\n  then show \"sqrt (a + n) > 0\" by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\" and \"n > 0\"\n  shows \"sqrt a > 0 \\<Longrightarrow> sqrt (a + n) > 0\"\nproof -\n  have \"a + n > 0\" using assms by simp\n  then show \"sqrt (a + n) > 0\" by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegativeV6": {"skill_name": "sqrt_nonnegativeV6", "marker": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max 0 a)\" by (metis assms max.absorb_iff2)\n  then show ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma sqrt_nonnegative:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = sqrt (max 0 a)\" by (metis assms max.absorb_iff2)\n  then show ?thesis using assms by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_generalV5": {"skill_name": "sqrt_positive_generalV5", "marker": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a ^ 2 = a\" by (metis assms nle_le real_sqrt_pow2 verit_comp_simplify1(3))\n  then have \"sqrt a > 0\" using assms by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a ^ 2 = a\" by (metis assms nle_le real_sqrt_pow2 verit_comp_simplify1(3))\n  then have \"sqrt a > 0\" using assms by auto\n  then show ?thesis by simp\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegV11": {"skill_name": "sqrt_nonnegV11", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  then show ?thesis\n    using assms by (cases \"a = 0\") auto\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  then show ?thesis\n    using assms by (cases \"a = 0\") auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_generalV6": {"skill_name": "sqrt_positive_generalV6", "marker": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  then have \"sqrt a > 0\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_positive_general:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" by auto\n  then have \"sqrt a > 0\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_nonnegV12": {"skill_name": "sqrt_nonnegV12", "marker": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" using assms by auto \n  thus \"sqrt a >= 0\" by (metis assms real_sqrt_ge_zero)\nqed", "description": "-", "full_code": "lemma sqrt_nonneg:\n  fixes a :: real\n  assumes \"a >= 0\"\n  shows \"sqrt a >= 0\"\nproof -\n  have \"sqrt a = 0 \\<longleftrightarrow> a = 0\" using assms by auto \n  thus \"sqrt a >= 0\" by (metis assms real_sqrt_ge_zero)\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_nonneg_eq": {"skill_name": "sqrt_positive_nonneg_eq", "marker": "lemma sqrt_positive_nonneg_eq:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a > 0 \\<longleftrightarrow> a > 0\"\nproof -\n  have \"sqrt a > 0 \\<longleftrightarrow> a > 0\" \n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_positive_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a = sqrt (max a 0)\" by (simp add: assms)\n  thus \"sqrt a \\<ge> 0\" by auto\nqed\n\nlemma sqrt_positive_nonneg_eq:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a > 0 \\<longleftrightarrow> a > 0\"\nproof -\n  have \"sqrt a > 0 \\<longleftrightarrow> a > 0\" \n    by auto\n  thus ?thesis by simp\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_positive_nonneg": {"skill_name": "sqrt_positive_nonneg", "marker": "lemma sqrt_positive_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a = sqrt (max a 0)\" by (simp add: assms)\n  thus \"sqrt a \\<ge> 0\" by auto\nqed", "description": "-", "full_code": "lemma sqrt_positive_nonneg:\n  fixes a :: real\n  assumes \"a \\<ge> 0\"\n  shows \"sqrt a \\<ge> 0\"\nproof -\n  have \"sqrt a = sqrt (max a 0)\" by (simp add: assms)\n  thus \"sqrt a \\<ge> 0\" by auto\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_sum_nonneg": {"skill_name": "sqrt_sum_nonneg", "marker": "lemma sqrt_sum_nonneg:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt(a + b) > 0 \\<longleftrightarrow> (a + b) > 0\"\nproof -\n  have \"sqrt (a + b) > 0 \\<longleftrightarrow> a + b > 0\"\n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sqrt_sum_nonneg:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"sqrt(a + b) > 0 \\<longleftrightarrow> (a + b) > 0\"\nproof -\n  have \"sqrt (a + b) > 0 \\<longleftrightarrow> a + b > 0\"\n    by auto\n  thus ?thesis by simp\nqed", "origin": "sqrt_positive", "update_count": 0}, "square_root_positive": {"skill_name": "square_root_positive", "marker": "lemma square_root_positive:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt a + sqrt b = sqrt (a + b + 2 * sqrt (a * b))\"\nproof -\n  have \"sqrt a + sqrt b = sqrt (sqrt a ^ 2) + sqrt (sqrt b ^ 2)\" by (metis abs_of_nonneg assms(1) assms(2) one_add_one power2_eq_square real_sqrt_abs2 real_sqrt_mult_self)\n  also have \"... = sqrt (sqrt a ^ 2 + sqrt b ^ 2 + 2 * sqrt a * sqrt b)\" \n    by (metis add_nonneg_nonneg assms(1) assms(2) calculation power2_sum real_sqrt_ge_zero real_sqrt_unique)\n  finally have \"sqrt a + sqrt b = sqrt ((sqrt a + sqrt b) ^ 2)\" by (metis abs_of_nonneg add_nonneg_nonneg assms(1) assms(2) real_sqrt_abs real_sqrt_ge_zero)\n  then have \"sqrt a + sqrt b = sqrt (a + b + 2 * sqrt (a * b))\" \n    using assms by (metis \\<open>sqrt ((sqrt a)\\<^sup>2) + sqrt ((sqrt b)\\<^sup>2) = sqrt ((sqrt a)\\<^sup>2 + (sqrt b)\\<^sup>2 + 2 * sqrt a * sqrt b)\\<close> \\<open>sqrt a + sqrt b = sqrt ((sqrt a)\\<^sup>2) + sqrt ((sqrt b)\\<^sup>2)\\<close> add.commute add.left_commute add_left_cancel add_right_cancel is_num_normalize(1) mult.commute mult.left_commute power2_eq_square real_sqrt_eq_iff real_sqrt_mult real_sqrt_pow2_iff real_sqrt_power)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_root_positive:\n  fixes a b :: real\n  assumes \"a \\<ge> 0\" \"b \\<ge> 0\"\n  shows \"sqrt a + sqrt b = sqrt (a + b + 2 * sqrt (a * b))\"\nproof -\n  have \"sqrt a + sqrt b = sqrt (sqrt a ^ 2) + sqrt (sqrt b ^ 2)\" by (metis abs_of_nonneg assms(1) assms(2) one_add_one power2_eq_square real_sqrt_abs2 real_sqrt_mult_self)\n  also have \"... = sqrt (sqrt a ^ 2 + sqrt b ^ 2 + 2 * sqrt a * sqrt b)\" \n    by (metis add_nonneg_nonneg assms(1) assms(2) calculation power2_sum real_sqrt_ge_zero real_sqrt_unique)\n  finally have \"sqrt a + sqrt b = sqrt ((sqrt a + sqrt b) ^ 2)\" by (metis abs_of_nonneg add_nonneg_nonneg assms(1) assms(2) real_sqrt_abs real_sqrt_ge_zero)\n  then have \"sqrt a + sqrt b = sqrt (a + b + 2 * sqrt (a * b))\" \n    using assms by (metis \\<open>sqrt ((sqrt a)\\<^sup>2) + sqrt ((sqrt b)\\<^sup>2) = sqrt ((sqrt a)\\<^sup>2 + (sqrt b)\\<^sup>2 + 2 * sqrt a * sqrt b)\\<close> \\<open>sqrt a + sqrt b = sqrt ((sqrt a)\\<^sup>2) + sqrt ((sqrt b)\\<^sup>2)\\<close> add.commute add.left_commute add_left_cancel add_right_cancel is_num_normalize(1) mult.commute mult.left_commute power2_eq_square real_sqrt_eq_iff real_sqrt_mult real_sqrt_pow2_iff real_sqrt_power)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sqrt_property": {"skill_name": "sqrt_property", "marker": "lemma sqrt_property:\n  fixes a b :: real\n  assumes \"0 \\<le> a\" \"0 \\<le> b\" \"sqrt a = b\"\n  shows \"a = b^2\"\nproof -\n  have \"a = (sqrt a) ^ 2\" using assms(1) by auto\n  moreover have \"b = sqrt a\" using assms(3) by auto\n  ultimately show \"a = b^2\" using power2_eq_square by auto\nqed", "description": "-", "full_code": "lemma sqrt_property:\n  fixes a b :: real\n  assumes \"0 \\<le> a\" \"0 \\<le> b\" \"sqrt a = b\"\n  shows \"a = b^2\"\nproof -\n  have \"a = (sqrt a) ^ 2\" using assms(1) by auto\n  moreover have \"b = sqrt a\" using assms(3) by auto\n  ultimately show \"a = b^2\" using power2_eq_square by auto\nqed", "origin": "do_request", "update_count": 0}, "sqrt_propertyV2": {"skill_name": "sqrt_propertyV2", "marker": "lemma sqrt_property:\n  fixes a b :: real\n  assumes \"0 \\<le> a\" \"0 \\<le> b\" \"sqrt a = b\"\n  shows \"a = b^2\"\nproof -\n  have \"a = (sqrt a) ^ 2\" using assms(1) by auto\n  thus ?thesis using assms(3) by (simp only: power2_eq_square)\nqed", "description": "-", "full_code": "lemma sqrt_property:\n  fixes a b :: real\n  assumes \"0 \\<le> a\" \"0 \\<le> b\" \"sqrt a = b\"\n  shows \"a = b^2\"\nproof -\n  have \"a = (sqrt a) ^ 2\" using assms(1) by auto\n  thus ?thesis using assms(3) by (simp only: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "sqrt_positive_extendedV2": {"skill_name": "sqrt_positive_extendedV2", "marker": "lemma sqrt_positive_extended:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\" and \"sqrt a \\<noteq> 0\"\nproof -\n  have \"sqrt a > 0\" using assms by (simp add: assms)\n  thus \"sqrt a > 0\" by simp\nnext\n  have \"sqrt a \\<noteq> 0\" using assms by auto\n  thus \"sqrt a \\<noteq> 0\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_positive_extended:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"sqrt a > 0\" and \"sqrt a \\<noteq> 0\"\nproof -\n  have \"sqrt a > 0\" using assms by (simp add: assms)\n  thus \"sqrt a > 0\" by simp\nnext\n  have \"sqrt a \\<noteq> 0\" using assms by auto\n  thus \"sqrt a \\<noteq> 0\" by simp\nqed", "origin": "sqrt_positive", "update_count": 0}, "sqrt_propertyV3": {"skill_name": "sqrt_propertyV3", "marker": "lemma sqrt_property:\n  fixes a b :: real\n  assumes \"0 \\<le> a\" \"0 \\<le> b\" \"sqrt a = b\"\n  shows \"a = b^2\"\nproof -\n  have \"a = (sqrt a) ^ 2\" using assms(1) by auto\n  also have \"... = b^2\" using assms(3) by (simp add: power2_eq_square)\n  finally show \"a = b^2\" by simp\nqed", "description": "-", "full_code": "lemma sqrt_property:\n  fixes a b :: real\n  assumes \"0 \\<le> a\" \"0 \\<le> b\" \"sqrt a = b\"\n  shows \"a = b^2\"\nproof -\n  have \"a = (sqrt a) ^ 2\" using assms(1) by auto\n  also have \"... = b^2\" using assms(3) by (simp add: power2_eq_square)\n  finally show \"a = b^2\" by simp\nqed", "origin": "do_request", "update_count": 0}}
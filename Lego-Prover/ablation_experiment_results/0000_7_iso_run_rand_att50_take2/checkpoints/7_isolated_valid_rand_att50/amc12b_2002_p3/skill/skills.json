{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "cancel_div_multi": {"skill_name": "cancel_div_multi", "marker": "lemma cancel_div_multi:\n  fixes x :: real\n  fixes a b c :: \"real list\"\n  assumes \"x > 0\" \"length a = length b\" \"length a = length c\"\n  shows \"(\\<forall>i. a!i + b!i / x = c!i) \\<Longrightarrow> (\\<forall>i. a!i * x + b!i = c!i * x)\"\nproof -\n  assume \"(\\<forall>i. a!i + b!i / x = c!i)\"\n  hence \"\\<forall>i. x * (a!i + b!i / x) = c!i * x\" by (simp add: assms(1))\n  hence \"\\<forall>i. x * a!i + x * (b!i / x) = c!i * x\" by (simp add: distrib_left)\n  thus ?thesis by (smt (verit) \\<open>\\<forall>i. a ! i + b ! i / x = c ! i\\<close> add_divide_eq_iff assms(1) nonzero_eq_divide_eq of_nat_0 of_nat_less_0_iff)\nqed", "description": "-", "full_code": "lemma cancel_div_multi:\n  fixes x :: real\n  fixes a b c :: \"real list\"\n  assumes \"x > 0\" \"length a = length b\" \"length a = length c\"\n  shows \"(\\<forall>i. a!i + b!i / x = c!i) \\<Longrightarrow> (\\<forall>i. a!i * x + b!i = c!i * x)\"\nproof -\n  assume \"(\\<forall>i. a!i + b!i / x = c!i)\"\n  hence \"\\<forall>i. x * (a!i + b!i / x) = c!i * x\" by (simp add: assms(1))\n  hence \"\\<forall>i. x * a!i + x * (b!i / x) = c!i * x\" by (simp add: distrib_left)\n  thus ?thesis by (smt (verit) \\<open>\\<forall>i. a ! i + b ! i / x = c ! i\\<close> add_divide_eq_iff assms(1) nonzero_eq_divide_eq of_nat_0 of_nat_less_0_iff)\nqed", "origin": "cancle_div", "update_count": 0}, "cancel_div_multiV2": {"skill_name": "cancel_div_multiV2", "marker": "lemma cancel_div_multi:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"c + d / x = e\"\n  shows \"a * x + b = c * x\" and \"c * x + d = e * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  thus \"a * x + b = c * x\" using assms(1) by (simp add: mult.commute)\n  have \"x * (c + d / x) = e * x\"\n    using assms(3) by auto\n  then have \"x * c + x * (d / x) = e * x\"\n    by (simp add: distrib_left)\n  thus \"c * x + d = e * x\" using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancel_div_multi:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"c + d / x = e\"\n  shows \"a * x + b = c * x\" and \"c * x + d = e * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  thus \"a * x + b = c * x\" using assms(1) by (simp add: mult.commute)\n  have \"x * (c + d / x) = e * x\"\n    using assms(3) by auto\n  then have \"x * c + x * (d / x) = e * x\"\n    by (simp add: distrib_left)\n  thus \"c * x + d = e * x\" using assms(1) by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "multi_distrib_complex_n": {"skill_name": "multi_distrib_complex_n", "marker": "lemma multi_distrib_complex_n:\n  fixes a b :: complex\n    and c d :: \"complex list\"\n  shows \"(a + b) * (\\<Sum>i\\<in>set c. i) = a * (\\<Sum>i\\<in>set c. i) + b * (\\<Sum>i\\<in>set c. i)\"\n  by (auto simp: field_simps)", "description": "-", "full_code": "lemma multi_distrib_complex_n:\n  fixes a b :: complex\n    and c d :: \"complex list\"\n  shows \"(a + b) * (\\<Sum>i\\<in>set c. i) = a * (\\<Sum>i\\<in>set c. i) + b * (\\<Sum>i\\<in>set c. i)\"\n  by (auto simp: field_simps)", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib_complex_nV2": {"skill_name": "multi_distrib_complex_nV2", "marker": "lemma multi_distrib_complex_n:\n  fixes a b :: \"complex list\" and c d :: \"complex list\"\n  shows \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j)\"\nproof -\n  have \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>i < length a. a ! i * (\\<Sum>j < length d. d ! j))\" \n    by (metis sum_distrib_right)\n  then show ?thesis by (simp add: sum_distrib_right)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_n:\n  fixes a b :: \"complex list\" and c d :: \"complex list\"\n  shows \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j)\"\nproof -\n  have \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>i < length a. a ! i * (\\<Sum>j < length d. d ! j))\" \n    by (metis sum_distrib_right)\n  then show ?thesis by (simp add: sum_distrib_right)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "generalize_cancellation": {"skill_name": "generalize_cancellation", "marker": "lemma generalize_cancellation:\n  fixes x a b c d :: real\n  assumes \"x \\<noteq> 0\" \"c \\<noteq> 0\" \"a + b / x = c\"\n  shows \"(a + b / x) * d = c * d\"\nproof -\n  have \"(a + b / x) * d = c * d\" using assms(3) by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma generalize_cancellation:\n  fixes x a b c d :: real\n  assumes \"x \\<noteq> 0\" \"c \\<noteq> 0\" \"a + b / x = c\"\n  shows \"(a + b / x) * d = c * d\"\nproof -\n  have \"(a + b / x) * d = c * d\" using assms(3) by auto\n  thus ?thesis by simp\nqed", "origin": "cancle_div", "update_count": 0}, "cancel_divide_with_negativity": {"skill_name": "cancel_divide_with_negativity", "marker": "lemma cancel_divide_with_negativity:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"b < 0\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(2) mult.commute nonzero_eq_divide_eq)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancel_divide_with_negativity:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"b < 0\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(2) mult.commute nonzero_eq_divide_eq)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "cancel_divide_with_condition": {"skill_name": "cancel_divide_with_condition", "marker": "lemma cancel_divide_with_condition:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"b > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(3) by auto\n  then have \"x * a + b = c * x\" by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(3) mult.commute nonzero_eq_divide_eq order_less_imp_not_eq2)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancel_divide_with_condition:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"b > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(3) by auto\n  then have \"x * a + b = c * x\" by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(3) mult.commute nonzero_eq_divide_eq order_less_imp_not_eq2)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "inequality_from_division": {"skill_name": "inequality_from_division", "marker": "lemma inequality_from_division:\n  fixes a b c :: real\n  assumes \"c > 0\" \"a / c < b\"\n  shows \"a < b * c\"\nproof -\n  have \"a < b * c\" using assms by (simp add: field_split_simps)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma inequality_from_division:\n  fixes a b c :: real\n  assumes \"c > 0\" \"a / c < b\"\n  shows \"a < b * c\"\nproof -\n  have \"a < b * c\" using assms by (simp add: field_split_simps)\n  thus ?thesis by auto\nqed", "origin": "cancel_divide_with_condition", "update_count": 0}, "add_and_multiply": {"skill_name": "add_and_multiply", "marker": "lemma add_and_multiply:\n  fixes x y z :: real\n  assumes \"x > 0\" \"y > 0\"\n  shows \"z + (x * y) = z + x * y\"\nproof -\n  have \"z + (x * y) = z + x * y\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma add_and_multiply:\n  fixes x y z :: real\n  assumes \"x > 0\" \"y > 0\"\n  shows \"z + (x * y) = z + x * y\"\nproof -\n  have \"z + (x * y) = z + x * y\" by simp\n  thus ?thesis by simp\nqed", "origin": "cancel_divide_with_condition", "update_count": 0}, "inequality_from_division_extended": {"skill_name": "inequality_from_division_extended", "marker": "lemma inequality_from_division_extended:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\" \"a / c < b / d\"\n  shows \"a * d < b * c\"\nproof -\n  have \"a / c < b / d\" using assms(2) by (metis assms(3))\n  then have \"a * d < b * (c / d * d)\" using assms(1) by (metis assms(2) divide_less_eq mult.commute mult.left_commute mult_less_cancel_left_pos times_divide_eq_left times_divide_eq_right)\n  thus ?thesis using assms(1) by (metis assms(2) assms(3) mult.commute pos_divide_less_eq pos_less_divide_eq times_divide_eq_left)\nqed", "description": "-", "full_code": "lemma inequality_from_division_extended:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\" \"a / c < b / d\"\n  shows \"a * d < b * c\"\nproof -\n  have \"a / c < b / d\" using assms(2) by (metis assms(3))\n  then have \"a * d < b * (c / d * d)\" using assms(1) by (metis assms(2) divide_less_eq mult.commute mult.left_commute mult_less_cancel_left_pos times_divide_eq_left times_divide_eq_right)\n  thus ?thesis using assms(1) by (metis assms(2) assms(3) mult.commute pos_divide_less_eq pos_less_divide_eq times_divide_eq_left)\nqed", "origin": "inequality_from_division", "update_count": 0}, "mod_add_power_special": {"skill_name": "mod_add_power_special", "marker": "lemma mod_add_power_special:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"((x + b) ^ 2) mod n = ((a + b) ^ 2) mod n\"\n  using mod_add_power_general[of x n a b 2] by (smt (verit) assms(1) assms(2) assms(3) mod_add_power_general pos2)", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_special:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"((x + b) ^ 2) mod n = ((a + b) ^ 2) mod n\"\n  using mod_add_power_general[of x n a b 2] by (smt (verit) assms(1) assms(2) assms(3) mod_add_power_general pos2)", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_extended": {"skill_name": "mod_add_power_extended", "marker": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c + d) mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c + d) mod n\"\n    using assms(5) by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c + d) mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c + d) mod n\"\n    using assms(5) by auto\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_generalized": {"skill_name": "mod_add_power_generalized", "marker": "lemma mod_add_power_generalized:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \"d > 0\"\n  shows \"((x + b)^c + d) mod n = (((a + b)^c) + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c + d) mod n\"\n    using assms(4) by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c + d) mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \"d > 0\"\n  shows \"((x + b)^c + d) mod n = (((a + b)^c) + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c + d) mod n\"\n    using assms(4) by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c + d) mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "multi_distrib_complex_general": {"skill_name": "multi_distrib_complex_general", "marker": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) * (e + f) = a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f\"\nproof -\n  have \"(a + b) * (c + d) * (e + f) = ((a + b) * (c + d)) * (e + f)\" by simp\n  also have \"... = (a * c + b * c + a * d + b * d) * (e + f)\" by (auto simp: field_simps)\n  also have \"... = (a * c * e + a * c * f + b * c * e + b * c * f + a * d * e + a * d * f + b * d * e + b * d * f)\"\n    by (auto simp: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) * (e + f) = a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f\"\nproof -\n  have \"(a + b) * (c + d) * (e + f) = ((a + b) * (c + d)) * (e + f)\" by simp\n  also have \"... = (a * c + b * c + a * d + b * d) * (e + f)\" by (auto simp: field_simps)\n  also have \"... = (a * c * e + a * c * f + b * c * e + b * c * f + a * d * e + a * d * f + b * d * e + b * d * f)\"\n    by (auto simp: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "inequality_from_subtraction": {"skill_name": "inequality_from_subtraction", "marker": "lemma inequality_from_subtraction:\n  fixes a b c :: real\n  assumes \"c > 0\" \"a < b * c\"\n  shows \"a / c < b\"\nproof -\n  have \"a < b * c\" using assms by simp\n  then have \"a / c < b * c / c\" using assms by (simp add: field_split_simps)\n  thus ?thesis by (metis assms(1) assms(2) mult_imp_div_pos_less)\nqed", "description": "-", "full_code": "lemma inequality_from_subtraction:\n  fixes a b c :: real\n  assumes \"c > 0\" \"a < b * c\"\n  shows \"a / c < b\"\nproof -\n  have \"a < b * c\" using assms by simp\n  then have \"a / c < b * c / c\" using assms by (simp add: field_split_simps)\n  thus ?thesis by (metis assms(1) assms(2) mult_imp_div_pos_less)\nqed", "origin": "inequality_from_division", "update_count": 0}, "inequality_from_division_extendedV2": {"skill_name": "inequality_from_division_extendedV2", "marker": "lemma inequality_from_division_extended:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\" \"a / c < b / d\"\n  shows \"a * d < b * c\"\nproof -\n  have \"a / c < b / d\" using assms(1) assms(2) by (metis assms(3))\n  hence \"a * d < b * c\" using assms(1) assms(2) \n    by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma inequality_from_division_extended:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\" \"a / c < b / d\"\n  shows \"a * d < b * c\"\nproof -\n  have \"a / c < b / d\" using assms(1) assms(2) by (metis assms(3))\n  hence \"a * d < b * c\" using assms(1) assms(2) \n    by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "origin": "inequality_from_division", "update_count": 0}, "logarithmic_identity": {"skill_name": "logarithmic_identity", "marker": "lemma logarithmic_identity:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nproof -\n  have \"c = log a b\" by (simp add: assms(4))\n  then show ?thesis using assms by (metis powr_log_cancel powr_realpow)\nqed", "description": "-", "full_code": "lemma logarithmic_identity:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nproof -\n  have \"c = log a b\" by (simp add: assms(4))\n  then show ?thesis using assms by (metis powr_log_cancel powr_realpow)\nqed", "origin": "cal_log_value", "update_count": 0}, "logarithm_property": {"skill_name": "logarithm_property", "marker": "lemma logarithm_property:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\n  using assms by (metis powr_log_cancel powr_realpow)", "description": "-", "full_code": "lemma logarithm_property:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\n  using assms by (metis powr_log_cancel powr_realpow)", "origin": "cal_log_value", "update_count": 0}, "multi_distrib_complexV2": {"skill_name": "multi_distrib_complexV2", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by (simp add: distrib_right)\n  also have \"... = a * c + a * d + b * c + b * d\" by (auto simp: field_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by (simp add: distrib_right)\n  also have \"... = a * c + a * d + b * c + b * d\" by (auto simp: field_simps)\n  finally show ?thesis by simp\nqed", "origin": "multi_distrib_complex_general", "update_count": 0}, "multi_distrib_complex_special": {"skill_name": "multi_distrib_complex_special", "marker": "lemma multi_distrib_complex_special:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a + b) * c + (a + b) * d\" by (auto simp: field_simps)\n  also have \"... = a * c + b * c + a * d + b * d\" by (simp add: distrib_right)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_special:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"(a + b) * (c + d) = (a + b) * c + (a + b) * d\" by (auto simp: field_simps)\n  also have \"... = a * c + b * c + a * d + b * d\" by (simp add: distrib_right)\n  finally show ?thesis by simp\nqed", "origin": "multi_distrib_complex_general", "update_count": 0}, "inequality_from_subtraction_multi": {"skill_name": "inequality_from_subtraction_multi", "marker": "lemma inequality_from_subtraction_multi:\n  fixes a b c :: real\n  assumes \"c > 0\" \"finite A\" \"\\<forall>x \\<in> A. a < b * c\"\n  shows \"\\<forall>x \\<in> A. a / c < b\"\nproof -\n  have \"\\<forall>x \\<in> A. a < b * c\" using assms(2) assms(3) by auto\n  then have \"\\<forall>x \\<in> A. a / c < b * c / c\" using assms(1) by (simp add: field_split_simps)\n  thus ?thesis by (metis assms(1) assms(3) mult_imp_div_pos_less)\nqed", "description": "-", "full_code": "lemma inequality_from_subtraction_multi:\n  fixes a b c :: real\n  assumes \"c > 0\" \"finite A\" \"\\<forall>x \\<in> A. a < b * c\"\n  shows \"\\<forall>x \\<in> A. a / c < b\"\nproof -\n  have \"\\<forall>x \\<in> A. a < b * c\" using assms(2) assms(3) by auto\n  then have \"\\<forall>x \\<in> A. a / c < b * c / c\" using assms(1) by (simp add: field_split_simps)\n  thus ?thesis by (metis assms(1) assms(3) mult_imp_div_pos_less)\nqed", "origin": "inequality_from_subtraction", "update_count": 0}, "logarithmic_identity_multiple": {"skill_name": "logarithmic_identity_multiple", "marker": "lemma logarithmic_identity_multiple:\n  fixes a :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b * c) = log a b + log a c\"\nproof -\n  have \"log a (b * c) = log a b + log a c\" using assms\n    by (metis log_mult)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithmic_identity_multiple:\n  fixes a :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b * c) = log a b + log a c\"\nproof -\n  have \"log a (b * c) = log a b + log a c\" using assms\n    by (metis log_mult)\n  then show ?thesis by simp\nqed", "origin": "logarithmic_identity", "update_count": 0}, "logarithmic_identity_multipleV2": {"skill_name": "logarithmic_identity_multipleV2", "marker": "lemma logarithmic_identity_multiple:\n  fixes a :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"log a b = x\" and \"log a c = y\"\n  shows \"b * c = a ^ (x + y)\"\nproof -\n  have \"x = log a b\" by (simp add: assms(5))\n  have \"y = log a c\" by (simp add: assms(6))\n  then show ?thesis using assms(1) by (smt (verit) assms(2) assms(3) assms(4) assms(5) assms(6) power_add powr_log_cancel powr_realpow)\nqed", "description": "-", "full_code": "lemma logarithmic_identity_multiple:\n  fixes a :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"log a b = x\" and \"log a c = y\"\n  shows \"b * c = a ^ (x + y)\"\nproof -\n  have \"x = log a b\" by (simp add: assms(5))\n  have \"y = log a c\" by (simp add: assms(6))\n  then show ?thesis using assms(1) by (smt (verit) assms(2) assms(3) assms(4) assms(5) assms(6) power_add powr_log_cancel powr_realpow)\nqed", "origin": "logarithmic_identity", "update_count": 0}, "logarithmic_identity_higher_dimensions": {"skill_name": "logarithmic_identity_higher_dimensions", "marker": "lemma logarithmic_identity_higher_dimensions:\n  fixes a b :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\n  using logarithmic_identity_multi_dimensional[of a b c] by (metis assms(1) assms(2) assms(3) assms(4))", "description": "-", "full_code": "lemma logarithmic_identity_multi_dimensional:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nproof -\n  have \"c = log a b\" by (simp add: assms(4))\n  then show ?thesis using assms by (metis powr_log_cancel powr_realpow)\nqed\n\nlemma logarithmic_identity_higher_dimensions:\n  fixes a b :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\n  using logarithmic_identity_multi_dimensional[of a b c] by (metis assms(1) assms(2) assms(3) assms(4))", "origin": "logarithmic_identity", "update_count": 0}, "product_of_integers": {"skill_name": "product_of_integers", "marker": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"\\<exists>x y. (x = a \\<and> y = b) \\<or> (x = b \\<and> y = a)\"\nproof -\n  have \"a > 0 \\<or> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis\n      using assms(1) by auto\n  qed\n  then show ?thesis\n  proof (cases \"a > 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"\\<exists>x y. (x = a \\<and> y = b) \\<or> (x = b \\<and> y = a)\"\nproof -\n  have \"a > 0 \\<or> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis\n      using assms(1) by auto\n  qed\n  then show ?thesis\n  proof (cases \"a > 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sum_product_distributivity": {"skill_name": "sum_product_distributivity", "marker": "lemma sum_product_distributivity:\n  fixes a b :: \"complex list\" and c d :: \"complex list\"\n  shows \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>i < length a. a ! i * (\\<Sum>j < length d. d ! j))\"\nproof -\n  have \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j)\" \n    by (metis sum_distrib_right)\n  thus ?thesis by (simp add: sum_distrib_right)\nqed", "description": "-", "full_code": "lemma sum_product_distributivity:\n  fixes a b :: \"complex list\" and c d :: \"complex list\"\n  shows \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>i < length a. a ! i * (\\<Sum>j < length d. d ! j))\"\nproof -\n  have \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j)\" \n    by (metis sum_distrib_right)\n  thus ?thesis by (simp add: sum_distrib_right)\nqed", "origin": "multi_distrib_complex_nV2", "update_count": 0}, "logarithm_properties": {"skill_name": "logarithm_properties", "marker": "lemma logarithm_properties:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b / c) = log a b - log a c\"\nproof -\n  have \"log a (b / c) = log a b + log a (1/c)\" using assms\n    by (smt (verit) log_divide log_one)\n  also have \"log a (1/c) = -log a c\" using assms\n    by (smt (verit) calculation log_divide)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_properties:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b / c) = log a b - log a c\"\nproof -\n  have \"log a (b / c) = log a b + log a (1/c)\" using assms\n    by (smt (verit) log_divide log_one)\n  also have \"log a (1/c) = -log a c\" using assms\n    by (smt (verit) calculation log_divide)\n  finally show ?thesis by simp\nqed", "origin": "logarithmic_identity_multiple", "update_count": 0}, "multi_distrib_complex_n_dim": {"skill_name": "multi_distrib_complex_n_dim", "marker": "lemma multi_distrib_complex_n_dim:\n  fixes a b :: \"complex list\" and c d :: \"complex list\"\n  assumes \"length a = length c\" \"length b = length d\"\n  shows \"(\\<Sum>i=0..<length a. (a!i + b!i) * (c!i + d!i)) = \n         (\\<Sum>i=0..<length a. (a!i * c!i + a!i * d!i + b!i * c!i + b!i * d!i))\"\nproof -\n  have \"(\\<Sum>i=0..<length a. (a!i + b!i) * (c!i + d!i)) = \n        (\\<Sum>i=0..<length a. (a!i * c!i + a!i * d!i + b!i * c!i + b!i * d!i))\"\n    by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_n_dim:\n  fixes a b :: \"complex list\" and c d :: \"complex list\"\n  assumes \"length a = length c\" \"length b = length d\"\n  shows \"(\\<Sum>i=0..<length a. (a!i + b!i) * (c!i + d!i)) = \n         (\\<Sum>i=0..<length a. (a!i * c!i + a!i * d!i + b!i * c!i + b!i * d!i))\"\nproof -\n  have \"(\\<Sum>i=0..<length a. (a!i + b!i) * (c!i + d!i)) = \n        (\\<Sum>i=0..<length a. (a!i * c!i + a!i * d!i + b!i * c!i + b!i * d!i))\"\n    by (auto simp: field_simps)\n  thus ?thesis by simp\nqed", "origin": "multi_distrib_complex_special", "update_count": 0}, "multi_distrib_complex_special_general": {"skill_name": "multi_distrib_complex_special_general", "marker": "lemma multi_distrib_complex_special_general:\n  fixes a b c d :: complex\n  assumes \"finite A\" and \"finite B\"\n  shows \"(\\<Sum>i\\<in>A. (a + b) * (c + d)) = (\\<Sum>i\\<in>A. (a * c + a * d + b * c + b * d))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. (a + b) * (c + d)) = (\\<Sum>i\\<in>A. (a * c + a * d + b * c + b * d))\"\n    by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_special_general:\n  fixes a b c d :: complex\n  assumes \"finite A\" and \"finite B\"\n  shows \"(\\<Sum>i\\<in>A. (a + b) * (c + d)) = (\\<Sum>i\\<in>A. (a * c + a * d + b * c + b * d))\"\nproof -\n  have \"(\\<Sum>i\\<in>A. (a + b) * (c + d)) = (\\<Sum>i\\<in>A. (a * c + a * d + b * c + b * d))\"\n    by (auto simp: field_simps)\n  then show ?thesis by simp\nqed", "origin": "multi_distrib_complex_special", "update_count": 0}, "logarithm_properties_for_x": {"skill_name": "logarithm_properties_for_x", "marker": "lemma logarithm_properties_for_x:\n  fixes a b c x :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"x > 0\"\n  shows \"log a (x * b / c) = log a x + log a (b / c)\"\nproof -\n  have \"log a (x * b / c) = log a (x) + log a (b / c)\" using assms\n    by (smt (verit) divide_pos_pos log_add_eq_powr powr_log_cancel times_divide_eq_right)\n  also have \"log a (b / c) = log a b - log a c\" using logarithm_properties_generalized[of a b c] assms\n    by simp\n  finally show ?thesis by (metis \\<open>log a (x * b / c) = log a x + log a (b / c)\\<close>)\nqed", "description": "-", "full_code": "lemma logarithm_properties_generalized:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b / c) = log a b - log a c\"\nproof -\n  have \"log a (b / c) = log a b + log a (1/c)\" using assms\n    by (smt (verit) log_divide log_one)\n  also have \"log a (1 / c) = -log a c\" using assms\n    by (smt (verit) calculation log_divide)\n  finally show ?thesis by simp\nqed\n\nlemma logarithm_properties_for_x:\n  fixes a b c x :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"x > 0\"\n  shows \"log a (x * b / c) = log a x + log a (b / c)\"\nproof -\n  have \"log a (x * b / c) = log a (x) + log a (b / c)\" using assms\n    by (smt (verit) divide_pos_pos log_add_eq_powr powr_log_cancel times_divide_eq_right)\n  also have \"log a (b / c) = log a b - log a c\" using logarithm_properties_generalized[of a b c] assms\n    by simp\n  finally show ?thesis by (metis \\<open>log a (x * b / c) = log a x + log a (b / c)\\<close>)\nqed", "origin": "logarithm_properties", "update_count": 0}, "logarithm_properties_for_any_base": {"skill_name": "logarithm_properties_for_any_base", "marker": "lemma logarithm_properties_for_any_base:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b / c) = log a b - log a c\"\n  and \"log a (b * c) = log a b + log a c\"\nproof -\n  have \"log a (b / c) = log a b + log a (1/c)\" using assms\n    by (smt (verit) log_divide log_one)\n  also have \"log a (1/c) = -log a c\" using assms\n    by (smt (verit) calculation log_divide)\n  then have \"log a (b / c) = log a b - log a c\" by (metis assms(1) assms(2) assms(3) assms(4) logarithm_properties_generalized uminus_add_conv_diff)\n  then show \"log a (b / c) = log a b - log a c\" by simp\n  have \"log a (b * c) = log a b + log a c\" using assms\n    by (metis log_mult)\n  then show \"log a (b * c) = log a b + log a c\" by simp\nqed", "description": "-", "full_code": "lemma logarithm_properties_generalized:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b / c) = log a b - log a c\"\nproof -\n  have \"log a (b / c) = log a b + log a (1/c)\" using assms\n    by (smt (verit) log_divide log_one)\n  also have \"log a (1/c) = -log a c\" using assms\n    by (smt (verit) calculation log_divide)\n  finally show ?thesis by simp\nqed\n\nlemma logarithm_properties_for_any_base:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b / c) = log a b - log a c\"\n  and \"log a (b * c) = log a b + log a c\"\nproof -\n  have \"log a (b / c) = log a b + log a (1/c)\" using assms\n    by (smt (verit) log_divide log_one)\n  also have \"log a (1/c) = -log a c\" using assms\n    by (smt (verit) calculation log_divide)\n  then have \"log a (b / c) = log a b - log a c\" by (metis assms(1) assms(2) assms(3) assms(4) logarithm_properties_generalized uminus_add_conv_diff)\n  then show \"log a (b / c) = log a b - log a c\" by simp\n  have \"log a (b * c) = log a b + log a c\" using assms\n    by (metis log_mult)\n  then show \"log a (b * c) = log a b + log a c\" by simp\nqed", "origin": "logarithm_properties", "update_count": 0}, "product_of_integersV2": {"skill_name": "product_of_integersV2", "marker": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"\\<exists>x y. (x = a \\<and> y = b) \\<or> (x = b \\<and> y = a)\"\nproof -\n  have \"a > 0 \\<or> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a > 0\" using assms(1) by auto\n    then show ?thesis by auto\n  qed\n  then show ?thesis\n  proof (cases \"a > 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"\\<exists>x y. (x = a \\<and> y = b) \\<or> (x = b \\<and> y = a)\"\nproof -\n  have \"a > 0 \\<or> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a > 0\" using assms(1) by auto\n    then show ?thesis by auto\n  qed\n  then show ?thesis\n  proof (cases \"a > 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_of_integersV3": {"skill_name": "product_of_integersV3", "marker": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"\\<exists>x y. (x = a \\<and> y = b) \\<or> (x = b \\<and> y = a)\"\nproof -\n  have \"a > 0 \\<or> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a > 0\" using assms(1) by (simp add: mult_nonneg_nonneg)\n    then show ?thesis by auto\n  qed\n  obtain x y where \"x = a\" and \"y = b\" using assms(1) by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"\\<exists>x y. (x = a \\<and> y = b) \\<or> (x = b \\<and> y = a)\"\nproof -\n  have \"a > 0 \\<or> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a > 0\" using assms(1) by (simp add: mult_nonneg_nonneg)\n    then show ?thesis by auto\n  qed\n  obtain x y where \"x = a\" and \"y = b\" using assms(1) by auto\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "cancel_divide_with_negativity_specialized": {"skill_name": "cancel_divide_with_negativity_specialized", "marker": "lemma cancel_divide_with_negativity_specialized:\n  fixes x :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"b < 0\"\n  shows \"a * x + b = c * x\"\n  using cancel_divide_with_negativity_generalized[of x a b c] assms by simp", "description": "-", "full_code": "lemma cancel_divide_with_negativity_generalized:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\" \"b < 0\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(2) mult.commute nonzero_eq_divide_eq)\n  thus ?thesis using assms(1) by (simp add: mult.commute)\nqed\n\nlemma cancel_divide_with_negativity_specialized:\n  fixes x :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"b < 0\"\n  shows \"a * x + b = c * x\"\n  using cancel_divide_with_negativity_generalized[of x a b c] assms by simp", "origin": "cancel_divide_with_negativity", "update_count": 0}, "cancel_divide_with_negativity_special": {"skill_name": "cancel_divide_with_negativity_special", "marker": "lemma cancel_divide_with_negativity_special:\n  fixes a b c :: real\n  assumes \"a + b / d = c\" \"b < 0\" \"d > 0\"\n  shows \"a * d + b = c * d\"\nproof -\n  have \"d * (a + b / d) = c * d\" using assms(1) by auto\n  then have \"d * a + b = c * d\" by (smt (verit) add_divide_eq_if_simps(1) assms(2) assms(3) mult.commute nonzero_eq_divide_eq)\n  thus ?thesis using assms(3) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancel_divide_with_negativity_special:\n  fixes a b c :: real\n  assumes \"a + b / d = c\" \"b < 0\" \"d > 0\"\n  shows \"a * d + b = c * d\"\nproof -\n  have \"d * (a + b / d) = c * d\" using assms(1) by auto\n  then have \"d * a + b = c * d\" by (smt (verit) add_divide_eq_if_simps(1) assms(2) assms(3) mult.commute nonzero_eq_divide_eq)\n  thus ?thesis using assms(3) by (simp add: mult.commute)\nqed", "origin": "cancel_divide_with_negativity", "update_count": 0}, "mod_add_powerV2": {"skill_name": "mod_add_powerV2", "marker": "lemma mod_add_power:\n  fixes x b c n a d :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = (((x + b)^c mod n))\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c) mod n\"\n    using assms(3) by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c) mod n\"\n    using assms(1) by (metis add.commute assms(3))\n  finally show ?thesis by (metis \\<open>(x + b) ^ c mod n = (x mod n + b) ^ c mod n\\<close> add.commute assms(3))\nqed", "description": "-", "full_code": "lemma mod_add_power:\n  fixes x b c n a d :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = (((x + b)^c mod n))\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c) mod n\"\n    using assms(3) by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c) mod n\"\n    using assms(1) by (metis add.commute assms(3))\n  finally show ?thesis by (metis \\<open>(x + b) ^ c mod n = (x mod n + b) ^ c mod n\\<close> add.commute assms(3))\nqed", "origin": "mod_add_power_extended", "update_count": 0}, "mod_add_powerV3": {"skill_name": "mod_add_powerV3", "marker": "lemma mod_add_power:\n  fixes x a b c n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = (((x + b)^c mod n) + 0) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c) mod n\"\n    using assms(3) by (smt (verit) calculation mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c) mod n\"\n    by (metis add.commute assms(3))\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power:\n  fixes x a b c n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = (((x + b)^c mod n) + 0) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c) mod n\"\n    using assms(3) by (smt (verit) calculation mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c) mod n\"\n    by (metis add.commute assms(3))\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power_extended", "update_count": 0}, "mod_add_power_general": {"skill_name": "mod_add_power_general", "marker": "lemma mod_add_power_general:\n  fixes x b c n a :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\" \"c > 0\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = (((x + b)^c mod n))\" by presburger\n  also have \"... = (((x mod n) + b)^c) mod n\" using assms(4) by (metis mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c) mod n\" using assms(3) by auto\n  finally show ?thesis by (metis \\<open>(x + b) ^ c mod n = (x mod n + b) ^ c mod n\\<close> add.commute assms(3))\nqed", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x b c n a :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\" \"c > 0\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = (((x + b)^c mod n))\" by presburger\n  also have \"... = (((x mod n) + b)^c) mod n\" using assms(4) by (metis mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c) mod n\" using assms(3) by auto\n  finally show ?thesis by (metis \\<open>(x + b) ^ c mod n = (x mod n + b) ^ c mod n\\<close> add.commute assms(3))\nqed", "origin": "mod_add_power_extended", "update_count": 0}, "product_nonzero": {"skill_name": "product_nonzero", "marker": "lemma product_nonzero:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"a > 0 \\<and> b > 0\"\nproof -\n  have \"a > 0 \\<or> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a > 0\" using assms(1) by (simp add: mult_nonneg_nonneg)\n    then show ?thesis by auto\n  qed\n  then show \"a > 0 \\<and> b > 0\" using assms(1) assms(2) by auto\nqed", "description": "-", "full_code": "lemma product_nonzero:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"a > 0 \\<and> b > 0\"\nproof -\n  have \"a > 0 \\<or> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a > 0\" using assms(1) by (simp add: mult_nonneg_nonneg)\n    then show ?thesis by auto\n  qed\n  then show \"a > 0 \\<and> b > 0\" using assms(1) assms(2) by auto\nqed", "origin": "product_of_integersV3", "update_count": 0}, "prime_factorization": {"skill_name": "prime_factorization", "marker": "lemma prime_factorization:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a = 1 \\<or> b = 1\" using assms(2) prime_product assms(1) by (metis)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma prime_factorization:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a = 1 \\<or> b = 1\" using assms(2) prime_product assms(1) by (metis)\n  thus ?thesis by auto\nqed", "origin": "product_of_integersV3", "update_count": 0}, "product_prime_condition": {"skill_name": "product_prime_condition", "marker": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"\\<exists>p. (a = 1 \\<and> b = p) \\<or> (a = p \\<and> b = 1)\"\nproof -\n  have \"a * b > 1\" using assms(3) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<or> b > 1\"\n  proof (cases \"a = 1\")\n    case True\n    then have \"b > 1\" using assms(3) by (metis \\<open>1 < a * b\\<close> assms(2) less_numeral_extra(4) nat_1_eq_mult_iff nat_dvd_not_less nat_neq_iff one_dvd)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a > 1\" using assms(1) by auto\n    then have \"b = 1 \\<or> b > 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\n    thus ?thesis by (metis \\<open>1 < a\\<close>)\n  qed\n  then show ?thesis\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(3) by (metis less_not_refl3 prime_product)\n    then show ?thesis by (metis True)\n  next\n    case False\n    then have \"a = 1\" using assms(1) by auto\n    then have \"b > 1\" using assms(3) by (metis False \\<open>1 < a \\<or> 1 < b\\<close>)\n    then show ?thesis by (metis \\<open>a = 1\\<close>)\n  qed\nqed", "description": "-", "full_code": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"\\<exists>p. (a = 1 \\<and> b = p) \\<or> (a = p \\<and> b = 1)\"\nproof -\n  have \"a * b > 1\" using assms(3) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<or> b > 1\"\n  proof (cases \"a = 1\")\n    case True\n    then have \"b > 1\" using assms(3) by (metis \\<open>1 < a * b\\<close> assms(2) less_numeral_extra(4) nat_1_eq_mult_iff nat_dvd_not_less nat_neq_iff one_dvd)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a > 1\" using assms(1) by auto\n    then have \"b = 1 \\<or> b > 1\" by (metis \\<open>1 < a * b\\<close> less_one mult_is_0 nat_neq_iff not_one_less_zero)\n    thus ?thesis by (metis \\<open>1 < a\\<close>)\n  qed\n  then show ?thesis\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(3) by (metis less_not_refl3 prime_product)\n    then show ?thesis by (metis True)\n  next\n    case False\n    then have \"a = 1\" using assms(1) by auto\n    then have \"b > 1\" using assms(3) by (metis False \\<open>1 < a \\<or> 1 < b\\<close>)\n    then show ?thesis by (metis \\<open>a = 1\\<close>)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "even_odd_product": {"skill_name": "even_odd_product", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m\" by auto\n  from assms(2) obtain n where \"b = 2 * n + 1\" by (cases b) auto\n  then have \"a * b = (2 * m) * (2 * n + 1)\" by (simp add: `a = 2 * m`)\n  also have \"... = 2 * m * (2 * n + 1)\" by (simp add: algebra_simps)\n  then have \"a * b = 2 * (m * (2 * n + 1))\" by (smt (verit) \\<open>a = 2 * m\\<close> \\<open>b = 2 * n + 1\\<close> ab_semigroup_mult_class.mult_ac(1))\n  hence \"even (a * b)\" by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m\" by auto\n  from assms(2) obtain n where \"b = 2 * n + 1\" by (cases b) auto\n  then have \"a * b = (2 * m) * (2 * n + 1)\" by (simp add: `a = 2 * m`)\n  also have \"... = 2 * m * (2 * n + 1)\" by (simp add: algebra_simps)\n  then have \"a * b = 2 * (m * (2 * n + 1))\" by (smt (verit) \\<open>a = 2 * m\\<close> \\<open>b = 2 * n + 1\\<close> ab_semigroup_mult_class.mult_ac(1))\n  hence \"even (a * b)\" by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "nonzero_times_inverse": {"skill_name": "nonzero_times_inverse", "marker": "lemma nonzero_times_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"a * (1 / a) = (a / a)\" using assms by (simp add: field_simps)\n  then show ?thesis by (metis assms divide_self)\nqed", "description": "-", "full_code": "lemma nonzero_times_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"a * (1 / a) = (a / a)\" using assms by (simp add: field_simps)\n  then show ?thesis by (metis assms divide_self)\nqed", "origin": "a_times_vera", "update_count": 0}, "general_non_zero_times_inverse": {"skill_name": "general_non_zero_times_inverse", "marker": "lemma general_non_zero_times_inverse:\n  fixes x :: real\n  assumes \"x \\<noteq> 0\"\n  shows \"x * (1 / x) = 1\"\n  by (simp add: assms)", "description": "-", "full_code": "lemma non_zero_times_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  by (simp add: assms)\n\nlemma general_non_zero_times_inverse:\n  fixes x :: real\n  assumes \"x \\<noteq> 0\"\n  shows \"x * (1 / x) = 1\"\n  by (simp add: assms)", "origin": "a_times_vera", "update_count": 0}, "even_odd_productV2": {"skill_name": "even_odd_productV2", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  then have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by simp\n  then have \"a * b = 2 * (k * (2 * m + 1))\" by (metis mult.assoc)\n  thus \"even (a * b)\" by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  then have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by simp\n  then have \"a * b = 2 * (k * (2 * m + 1))\" by (metis mult.assoc)\n  thus \"even (a * b)\" by auto\nqed", "origin": "do_request", "update_count": 0}, "even_odd_productV3": {"skill_name": "even_odd_productV3", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  hence \"a * b = (2 * k) * (2 * m + 1)\" by (simp add: `a = 2 * k` `b = 2 * m + 1`)\n  thus \"even (a * b)\" \n  proof -\n    have \"a * b = 2 * k * (2 * m + 1)\" by (metis \\<open>a * b = 2 * k * (2 * m + 1)\\<close>)\n    also have \"... = 2 * (k * (2 * m + 1))\" by (simp add: ac_simps)\n    finally show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  hence \"a * b = (2 * k) * (2 * m + 1)\" by (simp add: `a = 2 * k` `b = 2 * m + 1`)\n  thus \"even (a * b)\" \n  proof -\n    have \"a * b = 2 * k * (2 * m + 1)\" by (metis \\<open>a * b = 2 * k * (2 * m + 1)\\<close>)\n    also have \"... = 2 * (k * (2 * m + 1))\" by (simp add: ac_simps)\n    finally show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_even_odd": {"skill_name": "product_even_odd", "marker": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"a * b mod 2 = 0\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by simp\n  hence \"a * b = 2 * (k * (2 * m + 1))\" by (metis mult.assoc)\n  thus \"a * b mod 2 = 0\" by auto\nqed", "description": "-", "full_code": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"a * b mod 2 = 0\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  then have \"a * b = 2 * k * (2 * m + 1)\" by simp\n  hence \"a * b = 2 * (k * (2 * m + 1))\" by (metis mult.assoc)\n  thus \"a * b mod 2 = 0\" by auto\nqed", "origin": "do_request", "update_count": 0}, "product_even_oddV2": {"skill_name": "product_even_oddV2", "marker": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"a * b mod 2 = 0\"\nproof -\n  obtain m where \"a = 2 * m\" using assms(1) by auto\n  obtain n where \"b = 2 * n + 1\" using assms(2) by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  then have \"a * b = (2 * m) * (2 * n + 1)\" by (simp add: `a = 2 * m`)\n  also have \"... = 2 * m * (2 * n + 1)\" by (simp add: algebra_simps)\n  then have \"a * b = 2 * (m * (2 * n + 1))\" by (metis \\<open>a = 2 * m\\<close> \\<open>b = 2 * n + 1\\<close> mult.commute mult.left_commute)\n  hence \"a * b mod 2 = 0\" by (simp add: mod_0)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"a * b mod 2 = 0\"\nproof -\n  obtain m where \"a = 2 * m\" using assms(1) by auto\n  obtain n where \"b = 2 * n + 1\" using assms(2) by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  then have \"a * b = (2 * m) * (2 * n + 1)\" by (simp add: `a = 2 * m`)\n  also have \"... = 2 * m * (2 * n + 1)\" by (simp add: algebra_simps)\n  then have \"a * b = 2 * (m * (2 * n + 1))\" by (metis \\<open>a = 2 * m\\<close> \\<open>b = 2 * n + 1\\<close> mult.commute mult.left_commute)\n  hence \"a * b mod 2 = 0\" by (simp add: mod_0)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "product_of_two_integers_is_prime": {"skill_name": "product_of_two_integers_is_prime", "marker": "lemma product_of_two_integers_is_prime:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  from assms(3) have \"a * b > 1\" by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" using assms(1) assms(2) by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` by (metis Primes.prime_nat_def assms(3) less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(3) by (metis less_not_refl3 prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) by auto\n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma product_of_two_integers_is_prime:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  from assms(3) have \"a * b > 1\" by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" using assms(1) assms(2) by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` by (metis Primes.prime_nat_def assms(3) less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(3) by (metis less_not_refl3 prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) by auto\n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_of_two_integers_is_primeV2": {"skill_name": "product_of_two_integers_is_primeV2", "marker": "lemma product_of_two_integers_is_prime:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(3) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<or> b > 1\"\n  proof (cases \"a = 1\")\n    case True\n    then show ?thesis by (metis \\<open>1 < a * b\\<close> assms(2) less_numeral_extra(3) less_numeral_extra(4) less_one nat_mult_eq_1_iff nat_neq_iff)\n  next\n    case False\n    then have \"b = 1 \\<or> b > 1\" using assms(2) by auto\n    thus ?thesis by (metis assms(3) mult.right_neutral prime_gt_1_nat)\n  qed\n  then show ?thesis\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(3) by (metis less_not_refl3 prime_product)\n    then show ?thesis by (metis True)\n  next\n    case False\n    then have \"a = 1\" using assms(1) by auto\n    then show ?thesis by (metis \\<open>1 < a * b\\<close> assms(2) less_one mult_is_0)\n  qed\nqed", "description": "-", "full_code": "lemma product_of_two_integers_is_prime:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(3) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<or> b > 1\"\n  proof (cases \"a = 1\")\n    case True\n    then show ?thesis by (metis \\<open>1 < a * b\\<close> assms(2) less_numeral_extra(3) less_numeral_extra(4) less_one nat_mult_eq_1_iff nat_neq_iff)\n  next\n    case False\n    then have \"b = 1 \\<or> b > 1\" using assms(2) by auto\n    thus ?thesis by (metis assms(3) mult.right_neutral prime_gt_1_nat)\n  qed\n  then show ?thesis\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(3) by (metis less_not_refl3 prime_product)\n    then show ?thesis by (metis True)\n  next\n    case False\n    then have \"a = 1\" using assms(1) by auto\n    then show ?thesis by (metis \\<open>1 < a * b\\<close> assms(2) less_one mult_is_0)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_of_two_integers_is_primeV3": {"skill_name": "product_of_two_integers_is_primeV3", "marker": "lemma product_of_two_integers_is_prime:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(3) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<or> b > 1\"\n  proof (cases \"a = 1\")\n    case True\n    then show ?thesis by (metis \\<open>1 < a * b\\<close> assms(2) less_numeral_extra(3) less_numeral_extra(4) less_one nat_mult_eq_1_iff nat_neq_iff)\n  next\n    case False\n    then have \"a > 1\" using assms(1) by auto\n    have \"b = 1 \\<or> b > 1\"\n    proof (cases \"b = 1\")\n      case True\n      then show ?thesis by auto\n    next\n      case False\n      then have \"b > 1\" using assms(2) by auto\n      thus ?thesis by auto\n    qed\n    thus ?thesis by (metis \\<open>1 < a\\<close>)\n  qed\n  then show ?thesis\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(3) by (metis less_not_refl3 prime_product)\n    then show ?thesis by (metis True)\n  next\n    case False\n    then have \"a = 1\" using assms(1) by auto\n    then have \"b > 1\" using assms(3) by (metis False \\<open>1 < a \\<or> 1 < b\\<close>)\n    thus ?thesis by (metis \\<open>a = 1\\<close>)\n  qed\nqed", "description": "-", "full_code": "lemma product_of_two_integers_is_prime:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(3) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<or> b > 1\"\n  proof (cases \"a = 1\")\n    case True\n    then show ?thesis by (metis \\<open>1 < a * b\\<close> assms(2) less_numeral_extra(3) less_numeral_extra(4) less_one nat_mult_eq_1_iff nat_neq_iff)\n  next\n    case False\n    then have \"a > 1\" using assms(1) by auto\n    have \"b = 1 \\<or> b > 1\"\n    proof (cases \"b = 1\")\n      case True\n      then show ?thesis by auto\n    next\n      case False\n      then have \"b > 1\" using assms(2) by auto\n      thus ?thesis by auto\n    qed\n    thus ?thesis by (metis \\<open>1 < a\\<close>)\n  qed\n  then show ?thesis\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(3) by (metis less_not_refl3 prime_product)\n    then show ?thesis by (metis True)\n  next\n    case False\n    then have \"a = 1\" using assms(1) by auto\n    then have \"b > 1\" using assms(3) by (metis False \\<open>1 < a \\<or> 1 < b\\<close>)\n    thus ?thesis by (metis \\<open>a = 1\\<close>)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "prime_even_product": {"skill_name": "prime_even_product", "marker": "lemma prime_even_product:\n  fixes a b :: nat\n  assumes \"a * b = 2\" and \"a > 0\" and \"b > 0\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms(1) by auto\n  have \"a > 0\" using assms(2) by auto\n  have \"b > 0\" using assms(3) by auto\n  then have \"a = 1 \\<or> a = 2\" using `a * b = 2` by (metis Suc_1 Suc_lessI assms(2) less_antisym less_zeroE linorder_neqE_nat mult_cancel_right mult_delta_right mult_left_cancel mult_numeral_1 n_not_Suc_n nat_mult_1_right nat_mult_eq_1_iff nat_mult_eq_cancel1 nat_mult_less_cancel1 numeral_1_eq_Suc_0 one_eq_numeral_iff)\n  then show ?thesis\n  proof (cases \"a = 1\")\n    case True\n    then have \"b = 2\" using `a * b = 2` by auto\n    then show ?thesis by (metis True)\n  next\n    case False\n    then have \"a = 2\" using `a * b = 2` by (metis \\<open>a = 1 \\<or> a = 2\\<close>)\n    then have \"b = 1\" using `a * b = 2` by auto\n    then show ?thesis by (metis \\<open>a = 2\\<close>)\n  qed\nqed", "description": "-", "full_code": "lemma prime_even_product:\n  fixes a b :: nat\n  assumes \"a * b = 2\" and \"a > 0\" and \"b > 0\"\n  shows \"a = 1 \\<and> b = 2 \\<or> a = 2 \\<and> b = 1\"\nproof -\n  have \"a * b = 2\" using assms(1) by auto\n  have \"a > 0\" using assms(2) by auto\n  have \"b > 0\" using assms(3) by auto\n  then have \"a = 1 \\<or> a = 2\" using `a * b = 2` by (metis Suc_1 Suc_lessI assms(2) less_antisym less_zeroE linorder_neqE_nat mult_cancel_right mult_delta_right mult_left_cancel mult_numeral_1 n_not_Suc_n nat_mult_1_right nat_mult_eq_1_iff nat_mult_eq_cancel1 nat_mult_less_cancel1 numeral_1_eq_Suc_0 one_eq_numeral_iff)\n  then show ?thesis\n  proof (cases \"a = 1\")\n    case True\n    then have \"b = 2\" using `a * b = 2` by auto\n    then show ?thesis by (metis True)\n  next\n    case False\n    then have \"a = 2\" using `a * b = 2` by (metis \\<open>a = 1 \\<or> a = 2\\<close>)\n    then have \"b = 1\" using `a * b = 2` by auto\n    then show ?thesis by (metis \\<open>a = 2\\<close>)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_prime_conditionV2": {"skill_name": "product_prime_conditionV2", "marker": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` by (metis Primes.prime_nat_def assms less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms by (metis less_not_refl3 prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) by (metis dvdI prime_nat_iff)\n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` by (metis Primes.prime_nat_def assms less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms by (metis less_not_refl3 prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) by (metis dvdI prime_nat_iff)\n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_prime_conditionV3": {"skill_name": "product_prime_conditionV3", "marker": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" \n    using assms by (metis less_not_refl less_numeral_extra(4) prime_product)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms by (metis less_not_refl3 prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) by (metis dvdI prime_nat_iff)\n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" \n    using assms by (metis less_not_refl less_numeral_extra(4) prime_product)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms by (metis less_not_refl3 prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) by (metis dvdI prime_nat_iff)\n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "even_product": {"skill_name": "even_product", "marker": "lemma even_product:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a mod 2 = 0) \\<or> (b mod 2 = 0) \\<Longrightarrow> (a * b mod 2 = 0)\"\nproof -\n  assume \"a mod 2 = 0 \\<or> b mod 2 = 0\"\n  have \"a mod 2 = 0 \\<Longrightarrow> a * b mod 2 = 0\" \n  proof -\n    assume \"a mod 2 = 0\"\n    then obtain k where \"a = 2 * k\" by auto \n    have \"a * b = (2 * k) * b\" by (metis `a = 2 * k`)\n    thus \"a * b mod 2 = 0\" by auto\n  qed\n  moreover have \"b mod 2 = 0 \\<Longrightarrow> a * b mod 2 = 0\"\n  proof -\n    assume \"b mod 2 = 0\"\n    then obtain m where \"b = 2 * m\" by auto\n    have \"a * b = a * (2 * m)\" by (metis `b = 2 * m`)\n    thus \"a * b mod 2 = 0\" by auto\n  qed\n  ultimately show \"a * b mod 2 = 0\" using `a mod 2 = 0 \\<or> b mod 2 = 0` by (metis)\nqed", "description": "-", "full_code": "lemma even_product:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(a mod 2 = 0) \\<or> (b mod 2 = 0) \\<Longrightarrow> (a * b mod 2 = 0)\"\nproof -\n  assume \"a mod 2 = 0 \\<or> b mod 2 = 0\"\n  have \"a mod 2 = 0 \\<Longrightarrow> a * b mod 2 = 0\" \n  proof -\n    assume \"a mod 2 = 0\"\n    then obtain k where \"a = 2 * k\" by auto \n    have \"a * b = (2 * k) * b\" by (metis `a = 2 * k`)\n    thus \"a * b mod 2 = 0\" by auto\n  qed\n  moreover have \"b mod 2 = 0 \\<Longrightarrow> a * b mod 2 = 0\"\n  proof -\n    assume \"b mod 2 = 0\"\n    then obtain m where \"b = 2 * m\" by auto\n    have \"a * b = a * (2 * m)\" by (metis `b = 2 * m`)\n    thus \"a * b mod 2 = 0\" by auto\n  qed\n  ultimately show \"a * b mod 2 = 0\" using `a mod 2 = 0 \\<or> b mod 2 = 0` by (metis)\nqed", "origin": "do_request", "update_count": 0}, "even_productV2": {"skill_name": "even_productV2", "marker": "lemma even_product:\n  fixes x y :: nat\n  assumes \"even x\" and \"even y\"\n  shows \"even (x * y)\"\nproof -\n  from assms(1) obtain m where \"x = 2 * m\" by auto\n  from assms(2) obtain n where \"y = 2 * n\" by auto\n  then have \"x * y = (2 * m) * (2 * n)\" by (simp add: `x = 2 * m`)\n  also have \"... = 4 * (m * n)\" by (simp add: algebra_simps)\n  hence \"even (x * y)\" by (metis assms(1) even_mult_iff)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma even_product:\n  fixes x y :: nat\n  assumes \"even x\" and \"even y\"\n  shows \"even (x * y)\"\nproof -\n  from assms(1) obtain m where \"x = 2 * m\" by auto\n  from assms(2) obtain n where \"y = 2 * n\" by auto\n  then have \"x * y = (2 * m) * (2 * n)\" by (simp add: `x = 2 * m`)\n  also have \"... = 4 * (m * n)\" by (simp add: algebra_simps)\n  hence \"even (x * y)\" by (metis assms(1) even_mult_iff)\n  thus ?thesis by simp\nqed", "origin": "even_odd_product", "update_count": 0}, "odd_even_sum": {"skill_name": "odd_even_sum", "marker": "lemma odd_even_sum:\n  fixes x y :: nat\n  assumes \"odd x\" and \"even y\"\n  shows \"odd (x + y)\"\nproof -\n  from assms(1) obtain m where \"x = 2 * m + 1\" by (cases x) auto\n  from assms(2) obtain n where \"y = 2 * n\" by auto\n  then have \"x + y = (2 * m + 1) + (2 * n)\" by (simp add: `x = 2 * m + 1`)\n  also have \"... = 2 * (m + n) + 1\" by (simp add: algebra_simps)\n  hence \"odd (x + y)\" by (metis assms(1) assms(2) odd_add)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma odd_even_sum:\n  fixes x y :: nat\n  assumes \"odd x\" and \"even y\"\n  shows \"odd (x + y)\"\nproof -\n  from assms(1) obtain m where \"x = 2 * m + 1\" by (cases x) auto\n  from assms(2) obtain n where \"y = 2 * n\" by auto\n  then have \"x + y = (2 * m + 1) + (2 * n)\" by (simp add: `x = 2 * m + 1`)\n  also have \"... = 2 * (m + n) + 1\" by (simp add: algebra_simps)\n  hence \"odd (x + y)\" by (metis assms(1) assms(2) odd_add)\n  thus ?thesis by simp\nqed", "origin": "even_odd_product", "update_count": 0}, "odd_even_product": {"skill_name": "odd_even_product", "marker": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"odd a\" and \"even b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m + 1\" by (cases a) auto\n  from assms(2) obtain n where \"b = 2 * n\" by auto\n  then have \"a * b = (2 * m + 1) * (2 * n)\" by (metis \\<open>a = 2 * m + 1\\<close>)\n  also have \"... = 2 * (m * (2 * n) + n)\" by (simp add: algebra_simps)\n  hence \"even (a * b)\" by (metis assms(2) even_mult_iff)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"odd a\" and \"even b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m + 1\" by (cases a) auto\n  from assms(2) obtain n where \"b = 2 * n\" by auto\n  then have \"a * b = (2 * m + 1) * (2 * n)\" by (metis \\<open>a = 2 * m + 1\\<close>)\n  also have \"... = 2 * (m * (2 * n) + n)\" by (simp add: algebra_simps)\n  hence \"even (a * b)\" by (metis assms(2) even_mult_iff)\n  thus ?thesis by simp\nqed", "origin": "even_odd_product", "update_count": 0}, "sum_product_distributivityV2": {"skill_name": "sum_product_distributivityV2", "marker": "lemma sum_product_distributivity:\n  fixes a b :: \"complex list\" and c d :: \"complex list\"\n  shows \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>i < length a. a ! i * (\\<Sum>j < length d. d ! j))\"\nproof -\n  have \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>j < length d. d ! j) * (\\<Sum>i < length a. a ! i)\"\n    by auto\n  thus ?thesis by (metis sum_distrib_right)\nqed", "description": "-", "full_code": "lemma sum_product_distributivity:\n  fixes a b :: \"complex list\" and c d :: \"complex list\"\n  shows \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>i < length a. a ! i * (\\<Sum>j < length d. d ! j))\"\nproof -\n  have \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>j < length d. d ! j) * (\\<Sum>i < length a. a ! i)\"\n    by auto\n  thus ?thesis by (metis sum_distrib_right)\nqed", "origin": "sum_product_distributivity", "update_count": 0}, "sum_product_over_lists": {"skill_name": "sum_product_over_lists", "marker": "lemma sum_product_over_lists:\n  fixes a b :: \"complex list\" and c d :: \"complex list\"\n  shows \"(\\<Sum>i < length a. a ! i * (\\<Sum>j < length b. b ! j)) = \n         (\\<Sum>j < length b. b ! j) * (\\<Sum>i < length a. a ! i)\"\nproof -\n  have \"(\\<Sum>i < length a. a ! i * (\\<Sum>j < length b. b ! j)) = \n         (\\<Sum>j < length b. b ! j) * (\\<Sum>i < length a. a ! i)\"\n    by (metis mult.commute sum_product_distributivity)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_product_distributivity:\n  fixes a b :: \"complex list\" and c d :: \"complex list\"\n  shows \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>i < length a. a ! i * (\\<Sum>j < length d. d ! j))\"\nproof -\n  have \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length d. d ! j) = \n         (\\<Sum>j < length d. d ! j) * (\\<Sum>i < length a. a ! i)\"\n    by auto\n  thus ?thesis by (metis sum_distrib_right)\nqed\n\nlemma sum_product_over_lists:\n  fixes a b :: \"complex list\" and c d :: \"complex list\"\n  shows \"(\\<Sum>i < length a. a ! i * (\\<Sum>j < length b. b ! j)) = \n         (\\<Sum>j < length b. b ! j) * (\\<Sum>i < length a. a ! i)\"\nproof -\n  have \"(\\<Sum>i < length a. a ! i * (\\<Sum>j < length b. b ! j)) = \n         (\\<Sum>j < length b. b ! j) * (\\<Sum>i < length a. a ! i)\"\n    by (metis mult.commute sum_product_distributivity)\n  thus ?thesis by simp\nqed", "origin": "sum_product_distributivity", "update_count": 0}, "mod_add_power_generalV2": {"skill_name": "mod_add_power_generalV2", "marker": "lemma mod_add_power_general:\n  fixes x a b c n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\" \"c > 0\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_multi[of x a b c n] by (smt (verit) assms(1) assms(2) assms(3) assms(4) mod_add_power_multi)", "description": "-", "full_code": "lemma mod_add_power_multi:\n  fixes x a b c n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\" \"c > 0\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = (((x + b)^c mod n) + 0) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c) mod n\"\n    using assms(3) by (smt (verit) calculation mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c) mod n\"\n    by (metis add.commute assms(3))\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_general:\n  fixes x a b c n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\" \"c > 0\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_multi[of x a b c n] by (smt (verit) assms(1) assms(2) assms(3) assms(4) mod_add_power_multi)", "origin": "mod_add_powerV3", "update_count": 0}, "mod_add_power_generalV3": {"skill_name": "mod_add_power_generalV3", "marker": "lemma mod_add_power_general:\n  fixes x a b c d n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\" \"c > 0\" \"d > 0\"\n  shows \"((x + b)^c * (x + d)^c) mod n = ((a + b)^c * (a + d)^c) mod n\"\nproof -\n  have \"((x + b)^c * (x + d)^c) mod n = (((x + b)^c mod n) * ((x + d)^c mod n)) mod n\"\n    by (metis mod_mult_eq)\n  also have \"... = (((x mod n) + b)^c * ((x mod n) + d)^c) mod n\"\n    using assms(3) by (smt (verit) assms(1) assms(2) assms(4) assms(5) mod_add_power_multi mod_mult_eq)\n  also have \"... = ((a + b)^c * (a + d)^c) mod n\"\n    by (metis add.commute assms(3))\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_multi:\n  fixes x a b c n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\" \"c > 0\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = (((x + b)^c mod n) + 0) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c) mod n\"\n    using assms(3) by (smt (verit) calculation mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c) mod n\"\n    by (metis add.commute assms(3))\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_general:\n  fixes x a b c d n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\" \"c > 0\" \"d > 0\"\n  shows \"((x + b)^c * (x + d)^c) mod n = ((a + b)^c * (a + d)^c) mod n\"\nproof -\n  have \"((x + b)^c * (x + d)^c) mod n = (((x + b)^c mod n) * ((x + d)^c mod n)) mod n\"\n    by (metis mod_mult_eq)\n  also have \"... = (((x mod n) + b)^c * ((x mod n) + d)^c) mod n\"\n    using assms(3) by (smt (verit) assms(1) assms(2) assms(4) assms(5) mod_add_power_multi mod_mult_eq)\n  also have \"... = ((a + b)^c * (a + d)^c) mod n\"\n    by (metis add.commute assms(3))\n  finally show ?thesis by auto\nqed", "origin": "mod_add_powerV3", "update_count": 0}, "unique_factorization_property": {"skill_name": "unique_factorization_property", "marker": "lemma unique_factorization_property:\n  fixes a b c :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"a > 0 \\<and> b > 0\"\nproof -\n  have \"c > 0\" using assms(2) by simp\n  then have \"a > 0 \\<or> b > 0\" using assms(1) by auto\n  then show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis using True by (metis assms(1) assms(2) mult_zero_left not_less_zero)\n  next\n    case False\n    then have \"a > 0\" using assms(1) by auto\n    then show ?thesis using assms(1) by (metis assms(2) gr_zeroI less_numeral_extra(3) mult_0_right)\n  qed\nqed", "description": "-", "full_code": "lemma unique_factorization_property:\n  fixes a b c :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"a > 0 \\<and> b > 0\"\nproof -\n  have \"c > 0\" using assms(2) by simp\n  then have \"a > 0 \\<or> b > 0\" using assms(1) by auto\n  then show ?thesis\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis using True by (metis assms(1) assms(2) mult_zero_left not_less_zero)\n  next\n    case False\n    then have \"a > 0\" using assms(1) by auto\n    then show ?thesis using assms(1) by (metis assms(2) gr_zeroI less_numeral_extra(3) mult_0_right)\n  qed\nqed", "origin": "product_of_integersV2", "update_count": 0}, "product_of_integersV4": {"skill_name": "product_of_integersV4", "marker": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"a > 0 \\<and> b > 0\"\nproof -\n  have \"a > 0 \\<or> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a > 0\" using assms(1) by auto\n    then show ?thesis by auto\n  qed\n  then show ?thesis\n  proof (cases \"a > 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by (metis True)\n  next\n    case False\n    then show ?thesis by (metis assms(1) assms(2) gr0I mult_zero_left not_less0)\n  qed\nqed", "description": "-", "full_code": "lemma product_of_integers:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"a > 0 \\<and> b > 0\"\nproof -\n  have \"a > 0 \\<or> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a > 0\" using assms(1) by auto\n    then show ?thesis by auto\n  qed\n  then show ?thesis\n  proof (cases \"a > 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by (metis True)\n  next\n    case False\n    then show ?thesis by (metis assms(1) assms(2) gr0I mult_zero_left not_less0)\n  qed\nqed", "origin": "product_of_integersV2", "update_count": 0}, "logarithmic_identity_base_change": {"skill_name": "logarithmic_identity_base_change", "marker": "lemma logarithmic_identity_base_change:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b * c) = log a b + log a c\"\nproof -\n  have \"log a (b * c) = log a b + log a c\" \n    by (simp add: log_mult assms(1) assms(2) assms(3) assms(4))\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithmic_identity_base_change:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b * c) = log a b + log a c\"\nproof -\n  have \"log a (b * c) = log a b + log a c\" \n    by (simp add: log_mult assms(1) assms(2) assms(3) assms(4))\n  then show ?thesis by simp\nqed", "origin": "logarithmic_identity_multipleV2", "update_count": 0}, "mod_add_power_extendedV2": {"skill_name": "mod_add_power_extendedV2", "marker": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by (metis mod_add_left_eq)\n  also have \"... = (((a + b)^c mod n) + d) mod n\"\n    by (smt (verit) assms(5) mod_add_cong mod_add_left_eq power_mod)\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by (metis mod_add_left_eq)\n  also have \"... = (((a + b)^c mod n) + d) mod n\"\n    by (smt (verit) assms(5) mod_add_cong mod_add_left_eq power_mod)\n  finally show ?thesis by presburger\nqed", "origin": "mod_add_power", "update_count": 0}, "vector_add": {"skill_name": "vector_add", "marker": "fun vector_add :: \"nat list \\<Rightarrow> nat list \\<Rightarrow> nat list\" where\n  \"vector_add [] ys = ys\" |\n  \"vector_add (x # xs) ys = (x + hd ys) # vector_add xs (tl ys)\"", "description": "-", "full_code": "fun vector_add :: \"nat list \\<Rightarrow> nat list \\<Rightarrow> nat list\" where\n  \"vector_add [] ys = ys\" |\n  \"vector_add (x # xs) ys = (x + hd ys) # vector_add xs (tl ys)\"", "origin": "mod_add_power", "update_count": 0}, "even_odd_productV4": {"skill_name": "even_odd_productV4", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m\" by auto\n  from assms(2) obtain n where \"b = 2 * n + 1\" by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * m) * (2 * n + 1)\" by (simp add: `a = 2 * m` `b = 2 * n + 1`)\n  also have \"... = 2 * m * (2 * n + 1)\" by (simp add: algebra_simps)\n  also have \"... = 2 * (m * (2 * n + 1))\" by (metis (no_types) `a = 2 * m` `b = 2 * n + 1` mult.commute mult.left_commute)\n  hence \"even (a * b)\" by (metis assms(1) even_mult_iff)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m\" by auto\n  from assms(2) obtain n where \"b = 2 * n + 1\" by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * m) * (2 * n + 1)\" by (simp add: `a = 2 * m` `b = 2 * n + 1`)\n  also have \"... = 2 * m * (2 * n + 1)\" by (simp add: algebra_simps)\n  also have \"... = 2 * (m * (2 * n + 1))\" by (metis (no_types) `a = 2 * m` `b = 2 * n + 1` mult.commute mult.left_commute)\n  hence \"even (a * b)\" by (metis assms(1) even_mult_iff)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "even_odd_productV5": {"skill_name": "even_odd_productV5", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain m where \"a = 2 * m\" using assms(1) by auto\n  obtain n where \"b = 2 * n + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * m) * (2 * n + 1)\" by (simp add: `a = 2 * m` `b = 2 * n + 1`)\n  also have \"... = 2 * m * (2 * n + 1)\" by (simp add: algebra_simps)\n  finally have \"a * b = 2 * (m * (2 * n + 1))\" by (smt (verit) \\<open>a = 2 * m\\<close> \\<open>b = 2 * n + 1\\<close> ab_semigroup_mult_class.mult_ac(1))\n  thus \"even (a * b)\" by auto\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  obtain m where \"a = 2 * m\" using assms(1) by auto\n  obtain n where \"b = 2 * n + 1\" using assms(2) by (metis odd_two_times_div_two_succ)\n  have \"a * b = (2 * m) * (2 * n + 1)\" by (simp add: `a = 2 * m` `b = 2 * n + 1`)\n  also have \"... = 2 * m * (2 * n + 1)\" by (simp add: algebra_simps)\n  finally have \"a * b = 2 * (m * (2 * n + 1))\" by (smt (verit) \\<open>a = 2 * m\\<close> \\<open>b = 2 * n + 1\\<close> ab_semigroup_mult_class.mult_ac(1))\n  thus \"even (a * b)\" by auto\nqed", "origin": "do_request", "update_count": 0}, "product_equals_prime": {"skill_name": "product_equals_prime", "marker": "lemma product_equals_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(2) by (metis assms(1) prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" \n    using assms(1) by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms(1) assms(2) less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(2) by (smt (verit) assms(1) less_numeral_extra(4) prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) by (metis assms(2) mult.comm_neutral mult.commute mult_delta_right prime_gt_1_nat prime_product)\n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma product_equals_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"a * b > 1\" using assms(2) by (metis assms(1) prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" \n    using assms(1) by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms(1) assms(2) less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(2) by (smt (verit) assms(1) less_numeral_extra(4) prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) by (metis assms(2) mult.comm_neutral mult.commute mult_delta_right prime_gt_1_nat prime_product)\n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_of_two_positive_integers": {"skill_name": "product_of_two_positive_integers", "marker": "lemma product_of_two_positive_integers:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"a * b = c\" and \"c > 0\"\n  shows \"\\<exists>x y. (x = a \\<and> y = b) \\<or> (x = b \\<and> y = a)\"\nproof -\n  have \"a > 0 \\<and> b > 0\" using assms(1) assms(2) by auto\n  then show ?thesis\n    using assms(3) assms(4) product_of_integers(1) by blast\nqed", "description": "-", "full_code": "lemma product_of_integers:\n  fixes a b c :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"\\<exists>x y. (x = a \\<and> y = b) \\<or> (x = b \\<and> y = a)\"\nproof -\n  have \"a > 0 \\<or> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis\n      using assms(1) by auto\n  qed\n  then show ?thesis\n  proof (cases \"a > 0\")\n    case True\n    then have \"b > 0\" using assms(1) assms(2) by auto\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis by auto\n  qed\nqed\n\nlemma product_of_two_positive_integers:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"a * b = c\" and \"c > 0\"\n  shows \"\\<exists>x y. (x = a \\<and> y = b) \\<or> (x = b \\<and> y = a)\"\nproof -\n  have \"a > 0 \\<and> b > 0\" using assms(1) assms(2) by auto\n  then show ?thesis\n    using assms(3) assms(4) product_of_integers(1) by blast\nqed", "origin": "product_of_integers", "update_count": 0}, "logarithm_difference_properties": {"skill_name": "logarithm_difference_properties", "marker": "lemma logarithm_difference_properties:\n  fixes a b c d :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"d > 0\"\n  shows \"log a (b * c / d) = log a b + log a c - log a d\"\nproof -\n  have \"log a (b * c / d) = log a (b * c) - log a d\" using assms\n    by (simp add: log_divide)\n  also have \"log a (b * c) = log a b + log a c\" using assms\n    by (metis log_mult)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_difference_properties:\n  fixes a b c d :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"d > 0\"\n  shows \"log a (b * c / d) = log a b + log a c - log a d\"\nproof -\n  have \"log a (b * c / d) = log a (b * c) - log a d\" using assms\n    by (simp add: log_divide)\n  also have \"log a (b * c) = log a b + log a c\" using assms\n    by (metis log_mult)\n  finally show ?thesis by simp\nqed", "origin": "logarithm_properties", "update_count": 0}, "generalized_inequality_from_division_with_param": {"skill_name": "generalized_inequality_from_division_with_param", "marker": "lemma generalized_inequality_from_division_with_param:\n  fixes a b c d :: real\n  assumes \"d > 0\" \"a / d < b\"\n  shows \"a < b * d\"\nproof -\n  have \"a < b * d\" using assms by (simp add: field_split_simps)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma generalized_inequality_from_division:\n  fixes a b c :: real\n  assumes \"c > 0\" \"a / c < b\"\n  shows \"a < b * c\"\nproof -\n  have \"a < b * c\" using assms by (simp add: field_split_simps)\n  thus ?thesis by auto\nqed\n\nlemma generalized_inequality_from_division_with_param:\n  fixes a b c d :: real\n  assumes \"d > 0\" \"a / d < b\"\n  shows \"a < b * d\"\nproof -\n  have \"a < b * d\" using assms by (simp add: field_split_simps)\n  thus ?thesis by auto\nqed", "origin": "inequality_from_division", "update_count": 0}, "cancel_div_multiV3": {"skill_name": "cancel_div_multiV3", "marker": "lemma cancel_div_multi:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"c + d / x = e\"\n  shows \"a * x + b = c * x\" and \"c * x + d = e * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + b = c * x\" using assms(1) by (simp add: distrib_left)\n  thus \"a * x + b = c * x\" by sos\n  have \"x * (c + d / x) = e * x\"\n    using assms(3) by auto\n  then have \"c * x + d = e * x\" using assms(1) by sos\n  thus \"c * x + d = e * x\" by simp\nqed", "description": "-", "full_code": "lemma cancel_div_multi:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"c + d / x = e\"\n  shows \"a * x + b = c * x\" and \"c * x + d = e * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + b = c * x\" using assms(1) by (simp add: distrib_left)\n  thus \"a * x + b = c * x\" by sos\n  have \"x * (c + d / x) = e * x\"\n    using assms(3) by auto\n  then have \"c * x + d = e * x\" using assms(1) by sos\n  thus \"c * x + d = e * x\" by simp\nqed", "origin": "cancel_div_multiV2", "update_count": 0}, "add_eq_cancel": {"skill_name": "add_eq_cancel", "marker": "lemma add_eq_cancel:\n  fixes x a b :: real\n  assumes \"x > 0\" \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"a = c - b\" using assms by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma add_eq_cancel:\n  fixes x a b :: real\n  assumes \"x > 0\" \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"a = c - b\" using assms by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "cancel_div_multiV2", "update_count": 0}, "mod_add_power_natural": {"skill_name": "mod_add_power_natural", "marker": "lemma mod_add_power_natural:\n  fixes x a b c n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_general assms by blast", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x a b c n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b)^c) mod n = (((x + b)^c mod n) + 0) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c) mod n\"\n    using assms(3) by (smt (verit) calculation mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c) mod n\"\n    by (metis add.commute assms(3))\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_natural:\n  fixes x a b c n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  using mod_add_power_general assms by blast", "origin": "mod_add_powerV3", "update_count": 0}, "mod_add_power_for_any_m": {"skill_name": "mod_add_power_for_any_m", "marker": "lemma mod_add_power_for_any_m:\n  fixes x a b c m n :: nat\n  assumes \"n > 0\" \"b > 0\" \"m > 0\" \"x mod n = a\"\n  shows \"((x + m*b)^c) mod n = ((a + m*b)^c) mod n\"\nproof -\n  have \"((x + m*b)^c) mod n = (((x + m*b)^c mod n) + 0) mod n\" by presburger\n  also have \"... = (((x mod n) + m*b)^c) mod n\" using assms(4) \n    by (smt (verit) calculation mod_add_left_eq power_mod)\n  also have \"... = ((a + m*b)^c) mod n\" \n    by (metis add.commute assms(4) mult.commute)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_for_any_m:\n  fixes x a b c m n :: nat\n  assumes \"n > 0\" \"b > 0\" \"m > 0\" \"x mod n = a\"\n  shows \"((x + m*b)^c) mod n = ((a + m*b)^c) mod n\"\nproof -\n  have \"((x + m*b)^c) mod n = (((x + m*b)^c mod n) + 0) mod n\" by presburger\n  also have \"... = (((x mod n) + m*b)^c) mod n\" using assms(4) \n    by (smt (verit) calculation mod_add_left_eq power_mod)\n  also have \"... = ((a + m*b)^c) mod n\" \n    by (metis add.commute assms(4) mult.commute)\n  finally show ?thesis by auto\nqed", "origin": "mod_add_powerV3", "update_count": 0}, "product_even_any_odd": {"skill_name": "product_even_any_odd", "marker": "lemma product_even_any_odd:\n  fixes a :: nat\n  fixes b :: nat\n  assumes \"a mod 2 = 0\"\n  shows \"a * b mod 2 = 0\"\nproof -\n  obtain m where \"a = 2 * m\" using assms by auto\n  then have \"a * b = 2 * m * b\" by (simp add: `a = 2 * m`)\n  hence \"a * b mod 2 = 0\" by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma product_even_any_odd:\n  fixes a :: nat\n  fixes b :: nat\n  assumes \"a mod 2 = 0\"\n  shows \"a * b mod 2 = 0\"\nproof -\n  obtain m where \"a = 2 * m\" using assms by auto\n  then have \"a * b = 2 * m * b\" by (simp add: `a = 2 * m`)\n  hence \"a * b mod 2 = 0\" by auto\n  thus ?thesis by simp\nqed", "origin": "product_even_oddV2", "update_count": 0}, "positive_integer_product": {"skill_name": "positive_integer_product", "marker": "lemma positive_integer_product:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"a > 0 \\<and> b > 0\"\nproof -\n  have \"c > 0\" using assms(2) by simp\n  have \"a * b > 0\" using assms(1) by (metis assms(2))\n  then show \"a > 0 \\<and> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) by (metis \\<open>0 < a * b\\<close> less_numeral_extra(3) mult_eq_0_iff zero_less_iff_neq_zero)\n    then show ?thesis by (metis True assms(1) assms(2) mult_zero_left not_less_zero)\n  next\n    case False\n    then have \"a > 0\" using assms(1) by auto\n    then show ?thesis by (metis \\<open>0 < a * b\\<close> less_numeral_extra(3) mult_eq_0_iff zero_less_iff_neq_zero)\n  qed\nqed", "description": "-", "full_code": "lemma positive_integer_product:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"a > 0 \\<and> b > 0\"\nproof -\n  have \"c > 0\" using assms(2) by simp\n  have \"a * b > 0\" using assms(1) by (metis assms(2))\n  then show \"a > 0 \\<and> b > 0\"\n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) by (metis \\<open>0 < a * b\\<close> less_numeral_extra(3) mult_eq_0_iff zero_less_iff_neq_zero)\n    then show ?thesis by (metis True assms(1) assms(2) mult_zero_left not_less_zero)\n  next\n    case False\n    then have \"a > 0\" using assms(1) by auto\n    then show ?thesis by (metis \\<open>0 < a * b\\<close> less_numeral_extra(3) mult_eq_0_iff zero_less_iff_neq_zero)\n  qed\nqed", "origin": "product_of_integersV2", "update_count": 0}, "product_of_integers_positive": {"skill_name": "product_of_integers_positive", "marker": "lemma product_of_integers_positive:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"a > 0 \\<and> b > 0\"\nproof -\n  have \"c > 0\" using assms(2) by simp\n  then show ?thesis \n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) by (metis assms(2) less_numeral_extra(3) mult_eq_0_iff zero_less_iff_neq_zero)\n    then show ?thesis by (metis True assms(1) assms(2) mult_zero_left not_less0)\n  next\n    case False\n    then have \"a > 0\" using assms(1) by auto\n    then show ?thesis by (metis assms(1) assms(2) less_numeral_extra(3) mult_eq_0_iff zero_less_iff_neq_zero)\n  qed\nqed", "description": "-", "full_code": "lemma product_of_integers_positive:\n  fixes a b :: nat\n  assumes \"a * b = c\" and \"c > 0\"\n  shows \"a > 0 \\<and> b > 0\"\nproof -\n  have \"c > 0\" using assms(2) by simp\n  then show ?thesis \n  proof (cases \"a = 0\")\n    case True\n    then have \"b > 0\" using assms(1) by (metis assms(2) less_numeral_extra(3) mult_eq_0_iff zero_less_iff_neq_zero)\n    then show ?thesis by (metis True assms(1) assms(2) mult_zero_left not_less0)\n  next\n    case False\n    then have \"a > 0\" using assms(1) by auto\n    then show ?thesis by (metis assms(1) assms(2) less_numeral_extra(3) mult_eq_0_iff zero_less_iff_neq_zero)\n  qed\nqed", "origin": "product_of_integersV2", "update_count": 0}, "product_even_oddV3": {"skill_name": "product_even_oddV3", "marker": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"a * b mod 2 = 0\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  also have \"... = 2 * k * (2 * m + 1)\" by simp\n  hence \"a * b = 2 * (k * (2 * m + 1))\" by (metis \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> mult.commute mult.left_commute)\n  thus \"a * b mod 2 = 0\" by auto\nqed", "description": "-", "full_code": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"a * b mod 2 = 0\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  also have \"... = 2 * k * (2 * m + 1)\" by simp\n  hence \"a * b = 2 * (k * (2 * m + 1))\" by (metis \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> mult.commute mult.left_commute)\n  thus \"a * b mod 2 = 0\" by auto\nqed", "origin": "do_request", "update_count": 0}, "parity_of_consecutive_integers": {"skill_name": "parity_of_consecutive_integers", "marker": "lemma parity_of_consecutive_integers:\n  fixes n :: nat\n  shows \"even n \\<or> odd n\"\nproof -\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  thus ?thesis\n  proof (cases \"n mod 2 = 0\")\n    case True\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma parity_of_consecutive_integers:\n  fixes n :: nat\n  shows \"even n \\<or> odd n\"\nproof -\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  thus ?thesis\n  proof (cases \"n mod 2 = 0\")\n    case True\n    then show ?thesis by auto\n  next\n    case False\n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "parity_of_consecutive_integersV2": {"skill_name": "parity_of_consecutive_integersV2", "marker": "lemma parity_of_consecutive_integers:\n  fixes n :: nat\n  shows \"even n \\<or> odd n\"\nproof -\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  thus ?thesis\n  proof\n    assume \"n mod 2 = 0\"\n    hence \"even n\" by auto\n    thus \"even n \\<or> odd n\" by (simp)\n  next\n    assume \"n mod 2 = 1\"\n    hence \"odd n\" by auto\n    thus \"even n \\<or> odd n\" by (simp)\n  qed\nqed", "description": "-", "full_code": "lemma parity_of_consecutive_integers:\n  fixes n :: nat\n  shows \"even n \\<or> odd n\"\nproof -\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  thus ?thesis\n  proof\n    assume \"n mod 2 = 0\"\n    hence \"even n\" by auto\n    thus \"even n \\<or> odd n\" by (simp)\n  next\n    assume \"n mod 2 = 1\"\n    hence \"odd n\" by auto\n    thus \"even n \\<or> odd n\" by (simp)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "parity_of_consecutive_integersV3": {"skill_name": "parity_of_consecutive_integersV3", "marker": "lemma parity_of_consecutive_integers:\n  fixes n :: nat\n  shows \"even n \\<or> odd n\"\nproof -\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  then show ?thesis\n  proof (cases \"n mod 2 = 0\")\n    case True\n    then have \"even n\" by auto\n    thus ?thesis by (simp add: True)\n  next\n    case False\n    then have \"odd n\" by auto\n    thus ?thesis by (simp add: False)\n  qed\nqed", "description": "-", "full_code": "lemma parity_of_consecutive_integers:\n  fixes n :: nat\n  shows \"even n \\<or> odd n\"\nproof -\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  then show ?thesis\n  proof (cases \"n mod 2 = 0\")\n    case True\n    then have \"even n\" by auto\n    thus ?thesis by (simp add: True)\n  next\n    case False\n    then have \"odd n\" by auto\n    thus ?thesis by (simp add: False)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "parity_of_consecutive_integersV4": {"skill_name": "parity_of_consecutive_integersV4", "marker": "lemma parity_of_consecutive_integers:\n  fixes n :: nat\n  shows \"even n \\<or> odd n\"\nproof -\n  have \"n = 2 * (n div 2) + (n mod 2)\" by auto\n  then show \"even n \\<or> odd n\"\n  proof (cases \"n mod 2 = 0\")\n    case True\n    then have \"even n\" by auto\n    thus ?thesis by (simp add: True)\n  next\n    case False\n    then have \"odd n\" by auto\n    thus ?thesis by (simp add: False)\n  qed\nqed", "description": "-", "full_code": "lemma parity_of_consecutive_integers:\n  fixes n :: nat\n  shows \"even n \\<or> odd n\"\nproof -\n  have \"n = 2 * (n div 2) + (n mod 2)\" by auto\n  then show \"even n \\<or> odd n\"\n  proof (cases \"n mod 2 = 0\")\n    case True\n    then have \"even n\" by auto\n    thus ?thesis by (simp add: True)\n  next\n    case False\n    then have \"odd n\" by auto\n    thus ?thesis by (simp add: False)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_odd_any_even": {"skill_name": "product_odd_any_even", "marker": "lemma product_odd_any_even:\n  fixes a :: nat\n  fixes b :: nat\n  assumes \"b mod 2 = 0\"  \n  shows \"a * b mod 2 = 0\" \nproof -\n  obtain n where \"b = 2 * n\" using assms by auto\n  hence \"a * b = a * (2 * n)\" by simp\n  thus \"a * b mod 2 = 0\" by auto\nqed", "description": "-", "full_code": "lemma product_odd_any_even:\n  fixes a :: nat\n  fixes b :: nat\n  assumes \"b mod 2 = 0\"  \n  shows \"a * b mod 2 = 0\" \nproof -\n  obtain n where \"b = 2 * n\" using assms by auto\n  hence \"a * b = a * (2 * n)\" by simp\n  thus \"a * b mod 2 = 0\" by auto\nqed", "origin": "product_even_any_odd", "update_count": 0}, "product_even_oddV4": {"skill_name": "product_even_oddV4", "marker": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"a * b mod 2 = 0\"\nproof -\n  obtain m where \"a = 2 * m\" using assms(1) by auto\n  then have \"a * b = (2 * m) * b\" by (simp add: `a = 2 * m`)\n  hence \"a * b mod 2 = 0\" by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma product_even_odd:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"a * b mod 2 = 0\"\nproof -\n  obtain m where \"a = 2 * m\" using assms(1) by auto\n  then have \"a * b = (2 * m) * b\" by (simp add: `a = 2 * m`)\n  hence \"a * b mod 2 = 0\" by auto\n  thus ?thesis by simp\nqed", "origin": "product_even_any_odd", "update_count": 0}, "prime_product_condition": {"skill_name": "prime_product_condition", "marker": "lemma prime_product_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\" \"a > 1\" \"b > 1\"\n  shows \"False\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms(1) div_eq_dividend_iff div_less int_ops(1) int_ops(2) less_numeral_extra(1) prime_product zero_neq_one)\n  thus \"False\" by (metis assms(2) assms(3))\nqed", "description": "-", "full_code": "lemma prime_product_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\" \"a > 1\" \"b > 1\"\n  shows \"False\"\nproof -\n  have \"a * b > 1\" using assms by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms(1) div_eq_dividend_iff div_less int_ops(1) int_ops(2) less_numeral_extra(1) prime_product zero_neq_one)\n  thus \"False\" by (metis assms(2) assms(3))\nqed", "origin": "product_prime_conditionV2", "update_count": 0}, "odd_even_productV2": {"skill_name": "odd_even_productV2", "marker": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"odd a\" and \"even b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(2) obtain n where \"b = 2 * n\" by auto\n  then have \"a * b = a * (2 * n)\" by (simp add: `b = 2 * n`)\n  thus \"even (a * b)\" by auto\nqed", "description": "-", "full_code": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"odd a\" and \"even b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(2) obtain n where \"b = 2 * n\" by auto\n  then have \"a * b = a * (2 * n)\" by (simp add: `b = 2 * n`)\n  thus \"even (a * b)\" by auto\nqed", "origin": "odd_even_sum", "update_count": 0}, "sum_of_odd_even": {"skill_name": "sum_of_odd_even", "marker": "lemma sum_of_odd_even:\n  fixes a b :: nat\n  assumes \"odd a\" and \"even b\"\n  shows \"odd (a + b) \\<and> even (a + b + 1)\"\nproof -\n  have \"odd (a + b)\" using odd_even_sum assms by auto\n  have \"a + b + 1 = (a + b) + 1\" by simp\n  then have \"even (a + b + 1)\" using assms(2) by (metis \\<open>odd (a + b)\\<close> add.commute odd_even_add odd_one)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma odd_even_sum:\n  fixes x y :: nat\n  assumes \"odd x\" and \"even y\"\n  shows \"odd (x + y)\"\nproof -\n  from assms(1) obtain m where \"x = 2 * m + 1\" by (cases x) auto\n  from assms(2) obtain n where \"y = 2 * n\" by auto\n  then have \"x + y = (2 * m + 1) + (2 * n)\" by (simp add: `x = 2 * m + 1`)\n  also have \"... = 2 * (m + n) + 1\" by (simp add: algebra_simps)\n  hence \"odd (x + y)\" by (metis assms(1) assms(2) odd_add)\n  thus ?thesis by simp\nqed\n\nlemma sum_of_odd_even:\n  fixes a b :: nat\n  assumes \"odd a\" and \"even b\"\n  shows \"odd (a + b) \\<and> even (a + b + 1)\"\nproof -\n  have \"odd (a + b)\" using odd_even_sum assms by auto\n  have \"a + b + 1 = (a + b) + 1\" by simp\n  then have \"even (a + b + 1)\" using assms(2) by (metis \\<open>odd (a + b)\\<close> add.commute odd_even_add odd_one)\n  thus ?thesis by auto\nqed", "origin": "odd_even_sum", "update_count": 0}, "parity_of_odd_sum": {"skill_name": "parity_of_odd_sum", "marker": "lemma parity_of_odd_sum:\n  fixes x y :: nat\n  assumes \"odd x\" and \"odd y\"\n  shows \"even (x + y)\"\nproof -\n  from assms(1) obtain m where \"x = 2 * m + 1\" by (cases x) auto\n  from assms(2) obtain n where \"y = 2 * n + 1\" by (cases y) auto\n  hence \"x + y = (2 * m + 1) + (2 * n + 1)\" by (metis \\<open>x = 2 * m + 1\\<close>)\n  also have \"... = 2 * (m + n + 1)\" by (simp add: algebra_simps)\n  thus ?thesis by (metis assms(1) assms(2) odd_even_add)\nqed", "description": "-", "full_code": "lemma parity_of_odd_sum:\n  fixes x y :: nat\n  assumes \"odd x\" and \"odd y\"\n  shows \"even (x + y)\"\nproof -\n  from assms(1) obtain m where \"x = 2 * m + 1\" by (cases x) auto\n  from assms(2) obtain n where \"y = 2 * n + 1\" by (cases y) auto\n  hence \"x + y = (2 * m + 1) + (2 * n + 1)\" by (metis \\<open>x = 2 * m + 1\\<close>)\n  also have \"... = 2 * (m + n + 1)\" by (simp add: algebra_simps)\n  thus ?thesis by (metis assms(1) assms(2) odd_even_add)\nqed", "origin": "odd_even_sum", "update_count": 0}, "parity_of_sum": {"skill_name": "parity_of_sum", "marker": "lemma parity_of_sum:\n  fixes a b :: nat\n  assumes \"even a\" and \"even b\"\n  shows \"even (a + b)\"\n  using assms\n  by auto", "description": "-", "full_code": "lemma parity_of_sum:\n  fixes a b :: nat\n  assumes \"even a\" and \"even b\"\n  shows \"even (a + b)\"\n  using assms\n  by auto", "origin": "odd_even_sum", "update_count": 0}, "consecutive_integers_parity": {"skill_name": "consecutive_integers_parity", "marker": "lemma consecutive_integers_parity:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"even (n - 1) \\<or> even (n - 2)\"\nproof -\n  have \"n = 1 + (n - 1)\" by (metis Suc_diff_1 assms plus_1_eq_Suc)\n  then have \"n mod 2 = (1 + (n - 1) mod 2) mod 2\" by presburger\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  then show ?thesis\n  proof (cases \"n mod 2 = 0\")\n    case True\n    then have \"even n\" by auto\n    then show ?thesis\n    proof -\n      have \"n - 1 = n - 2 + 1\" by (smt (verit) Nat.diff_add_assoc Nat.diff_cancel \\<open>even n\\<close> add.commute assms dvd_imp_le nat_1_add_1)\n      then have \"even (n - 2) \\<or> odd (n - 2)\" by (metis even_add odd_add)\n      thus ?thesis by (auto simp add: True)\n    qed\n  next\n    case False\n    then have \"odd n\" by auto\n    then show ?thesis\n    proof -\n      have \"even (n - 1) \\<or> odd (n - 1)\" by (metis even_add odd_add)\n      thus ?thesis using False by auto\n    qed\n  qed\nqed", "description": "-", "full_code": "lemma consecutive_integers_parity:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"even (n - 1) \\<or> even (n - 2)\"\nproof -\n  have \"n = 1 + (n - 1)\" by (metis Suc_diff_1 assms plus_1_eq_Suc)\n  then have \"n mod 2 = (1 + (n - 1) mod 2) mod 2\" by presburger\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  then show ?thesis\n  proof (cases \"n mod 2 = 0\")\n    case True\n    then have \"even n\" by auto\n    then show ?thesis\n    proof -\n      have \"n - 1 = n - 2 + 1\" by (smt (verit) Nat.diff_add_assoc Nat.diff_cancel \\<open>even n\\<close> add.commute assms dvd_imp_le nat_1_add_1)\n      then have \"even (n - 2) \\<or> odd (n - 2)\" by (metis even_add odd_add)\n      thus ?thesis by (auto simp add: True)\n    qed\n  next\n    case False\n    then have \"odd n\" by auto\n    then show ?thesis\n    proof -\n      have \"even (n - 1) \\<or> odd (n - 1)\" by (metis even_add odd_add)\n      thus ?thesis using False by auto\n    qed\n  qed\nqed", "origin": "do_request", "update_count": 0}, "logarithm_properties_for_xV2": {"skill_name": "logarithm_properties_for_xV2", "marker": "lemma logarithm_properties_for_x:\n  fixes a b c x :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"x > 0\"\n  shows \"log a (x * b / c) = log a x + log a b - log a c\"\nproof -\n  have \"log a (x * b / c) = log a (x) + log a (b / c)\" using assms\n    by (smt (verit) divide_pos_pos log_add_eq_powr powr_log_cancel times_divide_eq_right)\n  also have \"log a (b / c) = log a b - log a c\" using logarithm_properties_generalized[of a b c] assms\n    by simp\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma logarithm_properties_generalized:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b / c) = log a b - log a c\"\nproof -\n  have \"log a (b / c) = log a b + log a (1 / c)\" using assms\n    by (smt (verit) log_divide log_one)\n  also have \"log a (1 / c) = - log a c\" using assms\n    by (smt (verit) calculation log_divide)\n  finally show ?thesis by simp\nqed\n\nlemma logarithm_properties_for_x:\n  fixes a b c x :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"x > 0\"\n  shows \"log a (x * b / c) = log a x + log a b - log a c\"\nproof -\n  have \"log a (x * b / c) = log a (x) + log a (b / c)\" using assms\n    by (smt (verit) divide_pos_pos log_add_eq_powr powr_log_cancel times_divide_eq_right)\n  also have \"log a (b / c) = log a b - log a c\" using logarithm_properties_generalized[of a b c] assms\n    by simp\n  finally show ?thesis by auto\nqed", "origin": "logarithm_properties_for_x", "update_count": 0}, "logarithm_addition": {"skill_name": "logarithm_addition", "marker": "lemma logarithm_addition:\n  fixes a b c x y :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"x > 0\" and \"y > 0\"\n  shows \"log a (x * y) = log a x + log a y\"\nproof -\n  have \"log a (x * y) = log a x + log a (y / 1)\" using assms\n    by (metis div_by_1 log_mult)\n  also have \"log a (y / 1) = log a y\" by (simp add: assms(6) log_one)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_addition:\n  fixes a b c x y :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"x > 0\" and \"y > 0\"\n  shows \"log a (x * y) = log a x + log a y\"\nproof -\n  have \"log a (x * y) = log a x + log a (y / 1)\" using assms\n    by (metis div_by_1 log_mult)\n  also have \"log a (y / 1) = log a y\" by (simp add: assms(6) log_one)\n  finally show ?thesis by simp\nqed", "origin": "logarithm_properties_for_x", "update_count": 0}, "logarithm_combination": {"skill_name": "logarithm_combination", "marker": "lemma logarithm_combination:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b * c) = log a b + log a c\"\nproof -\n  have \"log a (b * c) = log a b + log a c\" \n    using assms by (simp add: log_mult)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_combination:\n  fixes a b c :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\"\n  shows \"log a (b * c) = log a b + log a c\"\nproof -\n  have \"log a (b * c) = log a b + log a c\" \n    using assms by (simp add: log_mult)\n  thus ?thesis by simp\nqed", "origin": "logarithm_properties_for_x", "update_count": 0}, "logarithm_product": {"skill_name": "logarithm_product", "marker": "lemma logarithm_product:\n  fixes a b :: real\n  assumes \"a > 0\" and \"b > 0\" and \"a \\<noteq> 1\"\n  shows \"log a (a * b) = log a a + log a b\"\nproof -\n  have \"log a (a * b) = log a a + log a b\" \n    using assms by (simp add: log_mult)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_product:\n  fixes a b :: real\n  assumes \"a > 0\" and \"b > 0\" and \"a \\<noteq> 1\"\n  shows \"log a (a * b) = log a a + log a b\"\nproof -\n  have \"log a (a * b) = log a a + log a b\" \n    using assms by (simp add: log_mult)\n  thus ?thesis by simp\nqed", "origin": "logarithm_properties_for_x", "update_count": 0}, "product_prime_conditionV4": {"skill_name": "product_prime_conditionV4", "marker": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  from assms have \"a * b > 1\" using prime_gt_1_nat by auto\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" \n    by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms \n      by (metis less_not_refl3 prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) \n      by (metis dvdI prime_nat_iff)\n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma product_prime_condition:\n  fixes a b :: nat\n  assumes \"prime (a * b)\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  from assms have \"a * b > 1\" using prime_gt_1_nat by auto\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" \n    by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms \n      by (metis less_not_refl3 prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) \n      by (metis dvdI prime_nat_iff)\n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_equals_primeV2": {"skill_name": "product_equals_primeV2", "marker": "lemma product_equals_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  have \"a * b = p\" using assms(1) by simp\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\"\n    by (metis \\<open>1 < p\\<close> assms(1) less_eq_nat.simps(2) mult_pos_pos)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `p > 1` \n    by (metis Primes.prime_nat_def assms(1) assms(2) less_irrefl_nat less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms \n      by (metis less_not_refl3 prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) \n      by (metis assms(2) mult.comm_neutral mult.commute mult_delta_right prime_gt_1_nat prime_product)\n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma product_equals_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  have \"a * b = p\" using assms(1) by simp\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\"\n    by (metis \\<open>1 < p\\<close> assms(1) less_eq_nat.simps(2) mult_pos_pos)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `p > 1` \n    by (metis Primes.prime_nat_def assms(1) assms(2) less_irrefl_nat less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms \n      by (metis less_not_refl3 prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) \n      by (metis assms(2) mult.comm_neutral mult.commute mult_delta_right prime_gt_1_nat prime_product)\n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_equals_primeV3": {"skill_name": "product_equals_primeV3", "marker": "lemma product_equals_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  have \"a * b > 1\" using assms(1) by (metis \\<open>1 < p\\<close>)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" \n    by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms(1) assms(2) less_irrefl_nat less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(1) \n      by (metis assms(2) less_irrefl_nat mult.commute mult_delta_right prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) by (metis assms(2) mult.commute mult_delta_right nat_mult_1_right prime_gt_1_nat prime_product)\n    then show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma product_equals_prime:\n  fixes a b :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<or> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  have \"a * b > 1\" using assms(1) by (metis \\<open>1 < p\\<close>)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" \n    by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms(1) assms(2) less_irrefl_nat less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<or> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(1) \n      by (metis assms(2) less_irrefl_nat mult.commute mult_delta_right prime_product)\n    then show ?thesis by auto\n  next\n    case False\n    then have \"a = 1\" using assms(1) by (metis assms(2) mult.commute mult_delta_right nat_mult_1_right prime_gt_1_nat prime_product)\n    then show ?thesis by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "even_odd_productV6": {"skill_name": "even_odd_productV6", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m\" by auto\n  from assms(2) obtain n where \"b = 2 * n + 1\" by (cases b) auto\n  then have \"a * b = (2 * m) * (2 * n + 1)\" by (metis \\<open>a = 2 * m\\<close>)\n  also have \"... = 2 * (m * (2 * n + 1))\" by (simp add: algebra_simps)\n  hence \"even (a * b)\" by (metis assms(1) even_mult_iff)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m\" by auto\n  from assms(2) obtain n where \"b = 2 * n + 1\" by (cases b) auto\n  then have \"a * b = (2 * m) * (2 * n + 1)\" by (metis \\<open>a = 2 * m\\<close>)\n  also have \"... = 2 * (m * (2 * n + 1))\" by (simp add: algebra_simps)\n  hence \"even (a * b)\" by (metis assms(1) even_mult_iff)\n  thus ?thesis by simp\nqed", "origin": "odd_even_product", "update_count": 0}, "product_of_odd_even": {"skill_name": "product_of_odd_even", "marker": "lemma product_of_odd_even:\n  fixes x y :: nat\n  assumes \"odd x\" and \"even y\"\n  shows \"odd (x * y) = False\"\nproof -\n  have \"even (x * y)\" using odd_even_product assms by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma odd_even_product:\n  fixes a b :: nat\n  assumes \"odd a\" and \"even b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m + 1\" by (cases a) auto\n  from assms(2) obtain n where \"b = 2 * n\" by auto\n  then have \"a * b = (2 * m + 1) * (2 * n)\" by (metis \\<open>a = 2 * m + 1\\<close>)\n  also have \"... = 2 * (m * (2 * n) + n)\" by (simp add: algebra_simps)\n  hence \"even (a * b)\" by (metis assms(2) even_mult_iff)\n  thus ?thesis by simp\nqed\n\nlemma product_of_odd_even:\n  fixes x y :: nat\n  assumes \"odd x\" and \"even y\"\n  shows \"odd (x * y) = False\"\nproof -\n  have \"even (x * y)\" using odd_even_product assms by simp\n  thus ?thesis by auto\nqed", "origin": "odd_even_product", "update_count": 0}, "manipulate_division": {"skill_name": "manipulate_division", "marker": "lemma manipulate_division:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \n      and \"a + b / x = c\" \n      and \"c + d / x = e\"\n  shows \"b = (c - a) * x\" \n     and \"d = (e - c) * x\"\nproof -\n  have \"b = (c - a) * x\" \n    using assms(2) by (smt (verit) assms(1) diff_add_eq nonzero_eq_divide_eq order_less_imp_not_eq)\n  thus \"b = (c - a) * x\" by simp\n  have \"d = (e - c) * x\" \n    using assms(3) by (smt (verit) assms(1) diff_add_eq nonzero_eq_divide_eq order_less_imp_not_eq)\n  thus \"d = (e - c) * x\" by simp\nqed", "description": "-", "full_code": "lemma manipulate_division:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \n      and \"a + b / x = c\" \n      and \"c + d / x = e\"\n  shows \"b = (c - a) * x\" \n     and \"d = (e - c) * x\"\nproof -\n  have \"b = (c - a) * x\" \n    using assms(2) by (smt (verit) assms(1) diff_add_eq nonzero_eq_divide_eq order_less_imp_not_eq)\n  thus \"b = (c - a) * x\" by simp\n  have \"d = (e - c) * x\" \n    using assms(3) by (smt (verit) assms(1) diff_add_eq nonzero_eq_divide_eq order_less_imp_not_eq)\n  thus \"d = (e - c) * x\" by simp\nqed", "origin": "cancel_div_multiV3", "update_count": 0}, "non_negative_sum": {"skill_name": "non_negative_sum", "marker": "lemma non_negative_sum:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  from assms show ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_negative_sum:\n  fixes a b :: real\n  assumes \"a >= 0\" \"b >= 0\"\n  shows \"a + b >= 0\"\nproof -\n  from assms show ?thesis by simp\nqed", "origin": "cancel_div_multiV3", "update_count": 0}, "logarithm_difference_extended_properties": {"skill_name": "logarithm_difference_extended_properties", "marker": "lemma logarithm_difference_extended_properties:\n  fixes a b c d e f :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"d > 0\" and \"e > 0\" and \"f > 0\"\n  shows \"log a (b * c / (d * e)) = log a b + log a c - log a d - log a e\"\nproof -\n  have \"log a (b * c / (d * e)) = log a (b * c) - log a (d * e)\" using assms\n    by (simp add: log_divide)\n  also have \"log a (b * c) = log a b + log a c\" using assms\n    by (metis log_mult)\n  also have \"log a (d * e) = log a d + log a e\" using assms\n    by (metis log_mult)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_difference_extended_properties:\n  fixes a b c d e f :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"d > 0\" and \"e > 0\" and \"f > 0\"\n  shows \"log a (b * c / (d * e)) = log a b + log a c - log a d - log a e\"\nproof -\n  have \"log a (b * c / (d * e)) = log a (b * c) - log a (d * e)\" using assms\n    by (simp add: log_divide)\n  also have \"log a (b * c) = log a b + log a c\" using assms\n    by (metis log_mult)\n  also have \"log a (d * e) = log a d + log a e\" using assms\n    by (metis log_mult)\n  finally show ?thesis by simp\nqed", "origin": "logarithm_difference_properties", "update_count": 0}, "even_odd_productV7": {"skill_name": "even_odd_productV7", "marker": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m\" by auto\n  from assms(2) obtain n where \"b = 2 * n + 1\" by (cases b) auto\n  have \"a * b = (2 * m) * (2 * n + 1)\" by (metis `a = 2 * m` `b = 2 * n + 1`)\n  also have \"... = 2 * m * (2 * n + 1)\" by (simp add: algebra_simps)\n  also have \"... = 2 * (m * (2 * n + 1))\" by (simp add: algebra_simps)\n  thus \"even (a * b)\" by (metis assms(1) even_mult_iff)\nqed", "description": "-", "full_code": "lemma even_odd_product:\n  fixes a b :: nat\n  assumes \"even a\" and \"odd b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m\" by auto\n  from assms(2) obtain n where \"b = 2 * n + 1\" by (cases b) auto\n  have \"a * b = (2 * m) * (2 * n + 1)\" by (metis `a = 2 * m` `b = 2 * n + 1`)\n  also have \"... = 2 * m * (2 * n + 1)\" by (simp add: algebra_simps)\n  also have \"... = 2 * (m * (2 * n + 1))\" by (simp add: algebra_simps)\n  thus \"even (a * b)\" by (metis assms(1) even_mult_iff)\nqed", "origin": "do_request", "update_count": 0}, "prime_product": {"skill_name": "prime_product", "marker": "lemma prime_product:\n  fixes a b :: nat\n  assumes \"prime (a * b)\" \"a > 1\" \"b > 1\"\n  shows \"False\"\nproof -\n  have \"a * b > 1\" using assms(1) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms(1) less_not_refl less_numeral_extra(4) prime_product)\n  thus \"False\" using assms(2) assms(3) by auto\nqed", "description": "-", "full_code": "lemma prime_product:\n  fixes a b :: nat\n  assumes \"prime (a * b)\" \"a > 1\" \"b > 1\"\n  shows \"False\"\nproof -\n  have \"a * b > 1\" using assms(1) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` \n    by (metis Primes.prime_nat_def assms(1) less_not_refl less_numeral_extra(4) prime_product)\n  thus \"False\" using assms(2) assms(3) by auto\nqed", "origin": "do_request", "update_count": 0}, "prime_productV2": {"skill_name": "prime_productV2", "marker": "lemma prime_product:\n  fixes a b :: nat\n  assumes \"prime (a * b)\" \"a > 1\" \"b > 1\"\n  shows \"False\"\nproof -\n  have \"a * b > 1\" using assms(1) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` by (metis assms(1) less_not_refl less_numeral_extra(4) prime_product)\n  thus \"False\" \n    using assms(2) assms(3) by auto\nqed", "description": "-", "full_code": "lemma prime_product:\n  fixes a b :: nat\n  assumes \"prime (a * b)\" \"a > 1\" \"b > 1\"\n  shows \"False\"\nproof -\n  have \"a * b > 1\" using assms(1) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" by (metis \\<open>1 < a * b\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `a * b > 1` by (metis assms(1) less_not_refl less_numeral_extra(4) prime_product)\n  thus \"False\" \n    using assms(2) assms(3) by auto\nqed", "origin": "do_request", "update_count": 0}, "product_even_any": {"skill_name": "product_even_any", "marker": "lemma product_even_any:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = c\"\n  shows \"a * b mod 2 = 0\"\n  using product_even_odd_general[of a b] assms(1) assms(2) by auto", "description": "-", "full_code": "lemma product_even_odd_general:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = 1\"\n  shows \"a * b mod 2 = 0\"\nproof -\n  obtain k where \"a = 2 * k\" using assms(1) by auto\n  obtain m where \"b = 2 * m + 1\" using assms(2) by (metis add.commute bits_mod_0 less_one mod_eq_nat1E one_mod_two_eq_one verit_comp_simplify1(3) zero_neq_one)\n  have \"a * b = (2 * k) * (2 * m + 1)\" by (metis `a = 2 * k` `b = 2 * m + 1`)\n  also have \"... = 2 * k * (2 * m + 1)\" by simp\n  hence \"a * b = 2 * (k * (2 * m + 1))\" by (metis \\<open>a = 2 * k\\<close> \\<open>b = 2 * m + 1\\<close> mult.commute mult.left_commute)\n  thus \"a * b mod 2 = 0\" by auto\nqed\n\nlemma product_even_any:\n  fixes a b :: nat\n  assumes \"a mod 2 = 0\" and \"b mod 2 = c\"\n  shows \"a * b mod 2 = 0\"\n  using product_even_odd_general[of a b] assms(1) assms(2) by auto", "origin": "product_even_oddV3", "update_count": 0}, "check_prime": {"skill_name": "check_prime", "marker": "lemma check_prime:\n  fixes n :: nat\n  assumes \"n = 3\"\n  shows \"prime (n^2 - 3*n + 2)\"\nproof -\n  have \"n^2 - 3*n + 2 = (n - 1) * (n - 2)\"\n    by (smt (verit) One_nat_def Suc_1 Suc_diff_le Suc_nat_number_of_add add.commute add_diff_cancel_left' assms diff_add_0 diff_numeral_Suc diff_self_eq_0 le_numeral_extra(4) mult_numeral_1_right numerals(1) plus_1_eq_Suc power2_eq_square pred_numeral_simps(3) semiring_norm(2))\n  then have \"n^2 - 3*n + 2 = (3 - 1) * (3 - 2)\" \n    using assms by auto\n  then have \"n^2 - 3*n + 2 = 2 * 1\" by auto\n  thus \"prime (n^2 - 3*n + 2)\" \n    by (metis Suc_1 add.commute add_2_eq_Suc assms diff_self_eq_0 mult.commute nat_power_eq_Suc_0_iff power2_eq_square power_one two_is_prime_nat)\nqed", "description": "-", "full_code": "lemma check_prime:\n  fixes n :: nat\n  assumes \"n = 3\"\n  shows \"prime (n^2 - 3*n + 2)\"\nproof -\n  have \"n^2 - 3*n + 2 = (n - 1) * (n - 2)\"\n    by (smt (verit) One_nat_def Suc_1 Suc_diff_le Suc_nat_number_of_add add.commute add_diff_cancel_left' assms diff_add_0 diff_numeral_Suc diff_self_eq_0 le_numeral_extra(4) mult_numeral_1_right numerals(1) plus_1_eq_Suc power2_eq_square pred_numeral_simps(3) semiring_norm(2))\n  then have \"n^2 - 3*n + 2 = (3 - 1) * (3 - 2)\" \n    using assms by auto\n  then have \"n^2 - 3*n + 2 = 2 * 1\" by auto\n  thus \"prime (n^2 - 3*n + 2)\" \n    by (metis Suc_1 add.commute add_2_eq_Suc assms diff_self_eq_0 mult.commute nat_power_eq_Suc_0_iff power2_eq_square power_one two_is_prime_nat)\nqed", "origin": "do_request", "update_count": 0}, "check_primeV2": {"skill_name": "check_primeV2", "marker": "lemma check_prime:\n  fixes n :: nat\n  assumes \"n = 3\"\n  shows \"prime (n^2 - 3*n + 2)\"\nproof -\n  have \"n^2 - 3*n + 2 = 3^2 - 3*3 + 2\" using assms by auto\n  then have \"n^2 - 3*n + 2 = 9 - 9 + 2\" by simp\n  then have \"n^2 - 3*n + 2 = 2\" by simp\n  thus \"prime (n^2 - 3*n + 2)\" by (metis Suc_le_D Suc_n_not_le_n add.commute add_2_eq_Suc add_Suc_shift add_cancel_left_left add_diff_cancel_right' add_leE assms diff_Suc_Suc diff_diff_cancel diff_mult_distrib diff_self_eq_0 full_nat_induct le_add_diff_inverse2 le_zero_eq minus_nat.diff_0 mult.commute mult_eq_0_iff nat_arith.suc1 nat_le_linear not_less_eq_eq not_prime_0 numeral_2_eq_2 numeral_3_eq_3 power2_eq_square two_is_prime_nat)\nqed", "description": "-", "full_code": "lemma check_prime:\n  fixes n :: nat\n  assumes \"n = 3\"\n  shows \"prime (n^2 - 3*n + 2)\"\nproof -\n  have \"n^2 - 3*n + 2 = 3^2 - 3*3 + 2\" using assms by auto\n  then have \"n^2 - 3*n + 2 = 9 - 9 + 2\" by simp\n  then have \"n^2 - 3*n + 2 = 2\" by simp\n  thus \"prime (n^2 - 3*n + 2)\" by (metis Suc_le_D Suc_n_not_le_n add.commute add_2_eq_Suc add_Suc_shift add_cancel_left_left add_diff_cancel_right' add_leE assms diff_Suc_Suc diff_diff_cancel diff_mult_distrib diff_self_eq_0 full_nat_induct le_add_diff_inverse2 le_zero_eq minus_nat.diff_0 mult.commute mult_eq_0_iff nat_arith.suc1 nat_le_linear not_less_eq_eq not_prime_0 numeral_2_eq_2 numeral_3_eq_3 power2_eq_square two_is_prime_nat)\nqed", "origin": "do_request", "update_count": 0}, "even_product_consecutive": {"skill_name": "even_product_consecutive", "marker": "lemma even_product_consecutive:\n  fixes n :: nat\n  shows \"even (n * (n + 1))\"\nproof -\n  have \"n * (n + 1) = n^2 + n\" by (metis add.commute add_cancel_right_left add_left_imp_eq add_mult_distrib comm_monoid_mult_class.mult_1 diff_zero group_cancel.add2 linordered_nonzero_semiring_class.zero_le_one mult.commute mult_1 mult_eq_0_iff nat_eq_add_iff1 power2_eq_square)\n  have \"n^2 + n = n * (n + 1)\" by (metis \\<open>n * (n + 1) = n\\<^sup>2 + n\\<close>)\n  have \"even n \\<or> even (n + 1)\" by auto\n  moreover {\n    assume \"even n\"\n    then have \"even (n * (n + 1))\" by (metis even_mult_iff)\n  }\n  moreover {\n    assume \"even (n + 1)\"\n    then have \"even (n * (n + 1))\" by (metis even_mult_iff)\n  }\n  ultimately show \"even (n * (n + 1))\" by auto\nqed", "description": "-", "full_code": "lemma even_product_consecutive:\n  fixes n :: nat\n  shows \"even (n * (n + 1))\"\nproof -\n  have \"n * (n + 1) = n^2 + n\" by (metis add.commute add_cancel_right_left add_left_imp_eq add_mult_distrib comm_monoid_mult_class.mult_1 diff_zero group_cancel.add2 linordered_nonzero_semiring_class.zero_le_one mult.commute mult_1 mult_eq_0_iff nat_eq_add_iff1 power2_eq_square)\n  have \"n^2 + n = n * (n + 1)\" by (metis \\<open>n * (n + 1) = n\\<^sup>2 + n\\<close>)\n  have \"even n \\<or> even (n + 1)\" by auto\n  moreover {\n    assume \"even n\"\n    then have \"even (n * (n + 1))\" by (metis even_mult_iff)\n  }\n  moreover {\n    assume \"even (n + 1)\"\n    then have \"even (n * (n + 1))\" by (metis even_mult_iff)\n  }\n  ultimately show \"even (n * (n + 1))\" by auto\nqed", "origin": "do_request", "update_count": 0}, "even_product_consecutiveV2": {"skill_name": "even_product_consecutiveV2", "marker": "lemma even_product_consecutive:\n  fixes n :: nat\n  shows \"even (n * (n + 1))\"\nproof -\n  have \"n * (n + 1) = n^2 + n\" by (metis add.commute add_cancel_right_left add_left_imp_eq add_mult_distrib comm_monoid_mult_class.mult_1 diff_zero group_cancel.add2 linordered_nonzero_semiring_class.zero_le_one mult.commute mult_1 mult_eq_0_iff nat_eq_add_iff1 power2_eq_square)\n  also have \"... = 2 * (n div 2) * (n + 1) + (n mod 2) * (n + 1)\" by (smt (verit) add_is_0 calculation comm_semiring_class.distrib div_mult_self1 div_mult_self3 div_mult_self_is_m less_one mod_mult_div_eq trans_less_add2 zero_neq_one)\n  then have \"n * (n + 1) = 2 * (n div 2 * (n + 1)) + (n mod 2) * (n + 1)\" by (metis add.commute add.left_commute add_0 add_cancel_left_right add_left_imp_eq comm_semiring_class.distrib distrib_left mod_mult_div_eq mult.commute mult.left_commute mult_is_0 one_add_one)\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  moreover {\n    assume \"n mod 2 = 0\"\n    then have \"even (n * (n + 1))\" using `n mod 2 = 0` by simp\n  }\n  moreover {\n    assume \"n mod 2 = 1\"\n    then have \"n + 1 = 2 * ((n + 1) div 2)\" by presburger\n    hence \"n * (n + 1) = n * (2 * ((n + 1) div 2))\" by simp\n    then have \"even (n * (n + 1))\" by auto\n  }\n  ultimately show \"even (n * (n + 1))\" by auto\nqed", "description": "-", "full_code": "lemma even_product_consecutive:\n  fixes n :: nat\n  shows \"even (n * (n + 1))\"\nproof -\n  have \"n * (n + 1) = n^2 + n\" by (metis add.commute add_cancel_right_left add_left_imp_eq add_mult_distrib comm_monoid_mult_class.mult_1 diff_zero group_cancel.add2 linordered_nonzero_semiring_class.zero_le_one mult.commute mult_1 mult_eq_0_iff nat_eq_add_iff1 power2_eq_square)\n  also have \"... = 2 * (n div 2) * (n + 1) + (n mod 2) * (n + 1)\" by (smt (verit) add_is_0 calculation comm_semiring_class.distrib div_mult_self1 div_mult_self3 div_mult_self_is_m less_one mod_mult_div_eq trans_less_add2 zero_neq_one)\n  then have \"n * (n + 1) = 2 * (n div 2 * (n + 1)) + (n mod 2) * (n + 1)\" by (metis add.commute add.left_commute add_0 add_cancel_left_right add_left_imp_eq comm_semiring_class.distrib distrib_left mod_mult_div_eq mult.commute mult.left_commute mult_is_0 one_add_one)\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  moreover {\n    assume \"n mod 2 = 0\"\n    then have \"even (n * (n + 1))\" using `n mod 2 = 0` by simp\n  }\n  moreover {\n    assume \"n mod 2 = 1\"\n    then have \"n + 1 = 2 * ((n + 1) div 2)\" by presburger\n    hence \"n * (n + 1) = n * (2 * ((n + 1) div 2))\" by simp\n    then have \"even (n * (n + 1))\" by auto\n  }\n  ultimately show \"even (n * (n + 1))\" by auto\nqed", "origin": "do_request", "update_count": 0}, "vector_addV2": {"skill_name": "vector_addV2", "marker": "fun vector_add :: \"nat list \\<Rightarrow> nat list \\<Rightarrow> nat list\" where\n  \"vector_add [] ys = ys\" |\n  \"vector_add xs [] = xs\" |  (* Handle the case where the second list is empty *)\n  \"vector_add (x # xs) (y # ys) = (x + y) # vector_add xs ys\"", "description": "-", "full_code": "fun vector_add :: \"nat list \\<Rightarrow> nat list \\<Rightarrow> nat list\" where\n  \"vector_add [] ys = ys\" |\n  \"vector_add xs [] = xs\" |  (* Handle the case where the second list is empty *)\n  \"vector_add (x # xs) (y # ys) = (x + y) # vector_add xs ys\"", "origin": "vector_add", "update_count": 0}, "vector_addV3": {"skill_name": "vector_addV3", "marker": "fun vector_add :: \"nat list \\<Rightarrow> nat list \\<Rightarrow> nat list\" where\n  \"vector_add [] ys = ys\" |\n  \"vector_add xs [] = xs\" |  (* Allows addition with empty list *)\n  \"vector_add (x # xs) (y # ys) = (x + y) # vector_add xs ys\"\n (* Element-wise addition *)", "description": "-", "full_code": "fun vector_add :: \"nat list \\<Rightarrow> nat list \\<Rightarrow> nat list\" where\n  \"vector_add [] ys = ys\" |\n  \"vector_add xs [] = xs\" |  (* Allows addition with empty list *)\n  \"vector_add (x # xs) (y # ys) = (x + y) # vector_add xs ys\"\n (* Element-wise addition *)", "origin": "vector_add", "update_count": 0}, "even_product_of_two": {"skill_name": "even_product_of_two", "marker": "lemma even_product_of_two:\n  fixes a b :: nat\n  assumes \"even a\" and \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k1 where \"a = 2 * k1\" using assms(1) by auto\n  obtain k2 where \"b = 2 * k2\" using assms(2) by auto\n  hence \"a * b = (2 * k1) * (2 * k2)\" by (simp add: `a = 2 * k1` `b = 2 * k2`)\n  thus \"even (a * b)\" \n  proof -\n    have \"a * b = 2 * k1 * 2 * k2\" by (smt (verit) \\<open>a = 2 * k1\\<close> \\<open>b = 2 * k2\\<close> mult.assoc)\n    also have \"... = 2 * (k1 * k2 * 2)\" by (simp add: ac_simps)\n    finally show ?thesis by auto\n  qed\nqed", "description": "-", "full_code": "lemma even_product_of_two:\n  fixes a b :: nat\n  assumes \"even a\" and \"even b\"\n  shows \"even (a * b)\"\nproof -\n  obtain k1 where \"a = 2 * k1\" using assms(1) by auto\n  obtain k2 where \"b = 2 * k2\" using assms(2) by auto\n  hence \"a * b = (2 * k1) * (2 * k2)\" by (simp add: `a = 2 * k1` `b = 2 * k2`)\n  thus \"even (a * b)\" \n  proof -\n    have \"a * b = 2 * k1 * 2 * k2\" by (smt (verit) \\<open>a = 2 * k1\\<close> \\<open>b = 2 * k2\\<close> mult.assoc)\n    also have \"... = 2 * (k1 * k2 * 2)\" by (simp add: ac_simps)\n    finally show ?thesis by auto\n  qed\nqed", "origin": "even_odd_productV3", "update_count": 0}, "odd_even_product_any": {"skill_name": "odd_even_product_any", "marker": "lemma odd_even_product_any:\n  fixes a b :: nat\n  assumes \"odd a\" and \"even b\"\n  shows \"even (a * b)\"\n  using odd_even_product_generalized[of a b] assms by simp", "description": "-", "full_code": "lemma odd_even_product_generalized:\n  fixes a b :: nat\n  assumes \"odd a\" and \"even b\"\n  shows \"even (a * b)\"\nproof -\n  from assms(1) obtain m where \"a = 2 * m + 1\" by (cases a) auto\n  from assms(2) obtain n where \"b = 2 * n\" by auto\n  then have \"a * b = (2 * m + 1) * (2 * n)\" by (metis \\<open>a = 2 * m + 1\\<close>)\n  also have \"... = 2 * (m * (2 * n) + n)\" by (simp add: algebra_simps)\n  hence \"even (a * b)\" by (metis assms(2) even_mult_iff)\n  thus ?thesis by simp\nqed\n\nlemma odd_even_product_any:\n  fixes a b :: nat\n  assumes \"odd a\" and \"even b\"\n  shows \"even (a * b)\"\n  using odd_even_product_generalized[of a b] assms by simp", "origin": "odd_even_product", "update_count": 0}, "sum_product_distributivity_multi": {"skill_name": "sum_product_distributivity_multi", "marker": "lemma sum_product_distributivity_multi:\n  fixes a :: \"complex list\" and b :: \"complex list\" and c :: \"complex list\" and d :: \"complex list\"\n  shows \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length b. b ! j) * (\\<Sum>k < length c. c ! k) * (\\<Sum>l < length d. d ! l) = \n         (\\<Sum>i < length a. a ! i) * (\\<Sum>j < length b. b ! j) * (\\<Sum>k < length c. c ! k) * (\\<Sum>l < length d. d ! l)\"\nproof -\n  have \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length b. b ! j) * (\\<Sum>k < length c. c ! k) * (\\<Sum>l < length d. d ! l) = \n         (\\<Sum>i < length a. a ! i) * (\\<Sum>j < length b. b ! j) * (\\<Sum>k < length c. c ! k) * (\\<Sum>l < length d. d ! l)\" \n    by (metis sum_distrib_right)\n  thus ?thesis by (simp add: sum_distrib_right)\nqed", "description": "-", "full_code": "lemma sum_product_distributivity_multi:\n  fixes a :: \"complex list\" and b :: \"complex list\" and c :: \"complex list\" and d :: \"complex list\"\n  shows \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length b. b ! j) * (\\<Sum>k < length c. c ! k) * (\\<Sum>l < length d. d ! l) = \n         (\\<Sum>i < length a. a ! i) * (\\<Sum>j < length b. b ! j) * (\\<Sum>k < length c. c ! k) * (\\<Sum>l < length d. d ! l)\"\nproof -\n  have \"(\\<Sum>i < length a. a ! i) * (\\<Sum>j < length b. b ! j) * (\\<Sum>k < length c. c ! k) * (\\<Sum>l < length d. d ! l) = \n         (\\<Sum>i < length a. a ! i) * (\\<Sum>j < length b. b ! j) * (\\<Sum>k < length c. c ! k) * (\\<Sum>l < length d. d ! l)\" \n    by (metis sum_distrib_right)\n  thus ?thesis by (simp add: sum_distrib_right)\nqed", "origin": "sum_product_distributivity", "update_count": 0}, "sum_product_distributivity_extended": {"skill_name": "sum_product_distributivity_extended", "marker": "lemma sum_product_distributivity_extended:\n  fixes a b :: \"complex list\" and c d :: \"complex list\" and n :: nat\n  assumes \"length a = n\" \"length b = n\" \"length c = n\" \"length d = n\"\n  shows \"(\\<Sum>i < n. a ! i) * (\\<Sum>j < n. b ! j) * (\\<Sum>k < n. c ! k) * (\\<Sum>l < n. d ! l) =\n         (\\<Sum>i < n. a ! i * (\\<Sum>j < n. b ! j) * (\\<Sum>k < n. c ! k) * (\\<Sum>l < n. d ! l))\"\nproof -\n  have \"(\\<Sum>i < n. a ! i) * (\\<Sum>j < n. b ! j) = \n         (\\<Sum>i < n. a ! i) * (\\<Sum>j < n. b ! j)\" \n    by (metis sum_distrib_right)\n  thus ?thesis by (simp add: sum_distrib_right)\nqed", "description": "-", "full_code": "lemma sum_product_distributivity_extended:\n  fixes a b :: \"complex list\" and c d :: \"complex list\" and n :: nat\n  assumes \"length a = n\" \"length b = n\" \"length c = n\" \"length d = n\"\n  shows \"(\\<Sum>i < n. a ! i) * (\\<Sum>j < n. b ! j) * (\\<Sum>k < n. c ! k) * (\\<Sum>l < n. d ! l) =\n         (\\<Sum>i < n. a ! i * (\\<Sum>j < n. b ! j) * (\\<Sum>k < n. c ! k) * (\\<Sum>l < n. d ! l))\"\nproof -\n  have \"(\\<Sum>i < n. a ! i) * (\\<Sum>j < n. b ! j) = \n         (\\<Sum>i < n. a ! i) * (\\<Sum>j < n. b ! j)\" \n    by (metis sum_distrib_right)\n  thus ?thesis by (simp add: sum_distrib_right)\nqed", "origin": "sum_product_distributivity", "update_count": 0}, "even_product_consecutiveV3": {"skill_name": "even_product_consecutiveV3", "marker": "lemma even_product_consecutive:\n  fixes n :: nat\n  shows \"even (n * (n + 1))\"\nproof -\n  have \"n * (n + 1) = n^2 + n\" by (metis add.commute add_cancel_right_left add_left_imp_eq add_mult_distrib comm_monoid_mult_class.mult_1 diff_zero group_cancel.add2 linordered_nonzero_semiring_class.zero_le_one mult.commute mult_1 mult_eq_0_iff nat_eq_add_iff1 power2_eq_square)\n  have \"n * (n + 1) = 2 * (n div 2) * (n + 1) + (n mod 2) * (n + 1)\" by (smt (verit) add_mult_distrib mult_div_mod_eq)\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  moreover {\n    assume \"n mod 2 = 0\"\n    then have \"even (n * (n + 1))\" using `n * (n + 1) = 2 * (n div 2) * (n + 1) + (n mod 2) * (n + 1)` by auto\n  }\n  moreover {\n    assume \"n mod 2 = 1\"\n    then have \"n + 1 = 2 * ((n + 1) div 2)\" by presburger\n    hence \"n * (n + 1) = n * (2 * ((n + 1) div 2))\" by simp\n    then have \"even (n * (n + 1))\" by auto\n  }\n  ultimately show \"even (n * (n + 1))\" by auto\nqed", "description": "-", "full_code": "lemma even_product_consecutive:\n  fixes n :: nat\n  shows \"even (n * (n + 1))\"\nproof -\n  have \"n * (n + 1) = n^2 + n\" by (metis add.commute add_cancel_right_left add_left_imp_eq add_mult_distrib comm_monoid_mult_class.mult_1 diff_zero group_cancel.add2 linordered_nonzero_semiring_class.zero_le_one mult.commute mult_1 mult_eq_0_iff nat_eq_add_iff1 power2_eq_square)\n  have \"n * (n + 1) = 2 * (n div 2) * (n + 1) + (n mod 2) * (n + 1)\" by (smt (verit) add_mult_distrib mult_div_mod_eq)\n  have \"n mod 2 = 0 \\<or> n mod 2 = 1\" by auto\n  moreover {\n    assume \"n mod 2 = 0\"\n    then have \"even (n * (n + 1))\" using `n * (n + 1) = 2 * (n div 2) * (n + 1) + (n mod 2) * (n + 1)` by auto\n  }\n  moreover {\n    assume \"n mod 2 = 1\"\n    then have \"n + 1 = 2 * ((n + 1) div 2)\" by presburger\n    hence \"n * (n + 1) = n * (2 * ((n + 1) div 2))\" by simp\n    then have \"even (n * (n + 1))\" by auto\n  }\n  ultimately show \"even (n * (n + 1))\" by auto\nqed", "origin": "do_request", "update_count": 0}, "distribution_of_sum": {"skill_name": "distribution_of_sum", "marker": "lemma distribution_of_sum:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"a * (c + d) + b * (c + d) = a * c + a * d + b * c + b * d\" \n    by (auto simp: field_simps)\n  then show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma distribution_of_sum:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\nproof -\n  have \"a * (c + d) + b * (c + d) = a * c + a * d + b * c + b * d\" \n    by (auto simp: field_simps)\n  then show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex_special", "update_count": 0}, "product_prime": {"skill_name": "product_prime", "marker": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  have \"a * b = p\" using assms(1) by simp\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\"\n    by (metis \\<open>1 < p\\<close> assms(1) less_eq_nat.simps(2) mult_pos_pos)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `p > 1` \n    by (metis Primes.prime_nat_def assms(1) assms(2) less_irrefl_nat less_numeral_extra(4) prime_product)\n  show \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(2)\n      by (smt (verit) assms(1) less_numeral_extra(4) prime_product)\n    then show ?thesis by (metis One_nat_def add_scale_eq_noteq assms(1) mult.commute n_not_Suc_n nat_mult_1)\n  next\n    case False\n    then have \"a = 1\" using assms(1)\n      by (smt (verit) \\<open>1 < p\\<close> assms(2) mult.comm_neutral prime_product)\n    then show ?thesis by (metis One_nat_def add_scale_eq_noteq assms(1) mult.commute mult.right_neutral n_not_Suc_n)\n  qed\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  have \"a * b = p\" using assms(1) by simp\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\"\n    by (metis \\<open>1 < p\\<close> assms(1) less_eq_nat.simps(2) mult_pos_pos)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `p > 1` \n    by (metis Primes.prime_nat_def assms(1) assms(2) less_irrefl_nat less_numeral_extra(4) prime_product)\n  show \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(2)\n      by (smt (verit) assms(1) less_numeral_extra(4) prime_product)\n    then show ?thesis by (metis One_nat_def add_scale_eq_noteq assms(1) mult.commute n_not_Suc_n nat_mult_1)\n  next\n    case False\n    then have \"a = 1\" using assms(1)\n      by (smt (verit) \\<open>1 < p\\<close> assms(2) mult.comm_neutral prime_product)\n    then show ?thesis by (metis One_nat_def add_scale_eq_noteq assms(1) mult.commute mult.right_neutral n_not_Suc_n)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "product_primeV2": {"skill_name": "product_primeV2", "marker": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" \n    using assms(1) by (metis \\<open>1 < p\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `p > 1` \n    by (metis Primes.prime_nat_def assms(1) assms(2) less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(2) \n      by (smt (verit) assms(1) less_numeral_extra(4) prime_product)\n    then show ?thesis by (metis One_nat_def add_scale_eq_noteq assms(1) mult.commute n_not_Suc_n nat_mult_1)\n  next\n    case False\n    then have \"a = 1\" using assms(1) by (smt (verit) \\<open>1 < p\\<close> assms(2) mult.comm_neutral prime_product)\n    then show ?thesis by (metis One_nat_def add_scale_eq_noteq assms(1) mult.commute mult.right_neutral n_not_Suc_n)\n  qed\nqed", "description": "-", "full_code": "lemma product_prime:\n  fixes a b p :: nat\n  assumes \"a * b = p\" and \"prime p\"\n  shows \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\nproof -\n  have \"p > 1\" using assms(2) by (metis prime_gt_1_nat)\n  have \"a > 1 \\<and> b > 1 \\<longrightarrow> a * b > 1\" \n    using assms(1) by (metis \\<open>1 < p\\<close>)\n  hence \"\\<not> (a > 1 \\<and> b > 1)\" using `p > 1` \n    by (metis Primes.prime_nat_def assms(1) assms(2) less_not_refl less_numeral_extra(4) prime_product)\n  thus \"a = 1 \\<and> b = p \\<or> a = p \\<and> b = 1\"\n  proof (cases \"a > 1\")\n    case True\n    then have \"b = 1\" using assms(2) \n      by (smt (verit) assms(1) less_numeral_extra(4) prime_product)\n    then show ?thesis by (metis One_nat_def add_scale_eq_noteq assms(1) mult.commute n_not_Suc_n nat_mult_1)\n  next\n    case False\n    then have \"a = 1\" using assms(1) by (smt (verit) \\<open>1 < p\\<close> assms(2) mult.comm_neutral prime_product)\n    then show ?thesis by (metis One_nat_def add_scale_eq_noteq assms(1) mult.commute mult.right_neutral n_not_Suc_n)\n  qed\nqed", "origin": "do_request", "update_count": 0}}
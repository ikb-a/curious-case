{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "non_zero_division_property": {"skill_name": "non_zero_division_property", "marker": "lemma non_zero_division_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" and \"b * (1 / b) = 1\"\n  by (simp_all add: assms)", "description": "-", "full_code": "lemma non_zero_division_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" and \"b * (1 / b) = 1\"\n  by (simp_all add: assms)", "origin": "a_times_vera", "update_count": 0}, "non_zero_sum_property": {"skill_name": "non_zero_sum_property", "marker": "lemma non_zero_sum_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) + b * (1 / b) = 2\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by simp\n  hence \"b * (1 / b) = 1\" using assms(2) by simp\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close> one_add_one)\nqed", "description": "-", "full_code": "lemma non_zero_sum_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) + b * (1 / b) = 2\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by simp\n  hence \"b * (1 / b) = 1\" using assms(2) by simp\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close> one_add_one)\nqed", "origin": "a_times_vera", "update_count": 0}, "scalar_multiplication_inverse": {"skill_name": "scalar_multiplication_inverse", "marker": "lemma scalar_multiplication_inverse:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: field_simps)\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma scalar_multiplication_inverse:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: field_simps)\n  thus ?thesis .\nqed", "origin": "a_times_vera", "update_count": 0}, "nonzero_division_property": {"skill_name": "nonzero_division_property", "marker": "lemma nonzero_division_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a)\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma nonzero_division_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a)\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed", "origin": "a_times_vera", "update_count": 0}, "division_by_nonzero": {"skill_name": "division_by_nonzero", "marker": "lemma division_by_nonzero:\n  fixes x :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"x / a = x * (1 / a)\"\n  using nonzero_division_property[of a x] assms by simp", "description": "-", "full_code": "lemma nonzero_division_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a)\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed\n\nlemma division_by_nonzero:\n  fixes x :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"x / a = x * (1 / a)\"\n  using nonzero_division_property[of a x] assms by simp", "origin": "a_times_vera", "update_count": 0}, "division_properties_nonzero": {"skill_name": "division_properties_nonzero", "marker": "lemma division_properties_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" \n    and \"b * (1 / b) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: field_simps)\n  moreover have \"b * (1 / b) = 1\" using assms(2) by (simp add: field_simps)\n  ultimately show \"a * (1 / a) = 1\" and \"b * (1 / b) = 1\" by auto\nqed", "description": "-", "full_code": "lemma division_properties_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" \n    and \"b * (1 / b) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: field_simps)\n  moreover have \"b * (1 / b) = 1\" using assms(2) by (simp add: field_simps)\n  ultimately show \"a * (1 / a) = 1\" and \"b * (1 / b) = 1\" by auto\nqed", "origin": "a_times_vera", "update_count": 0}, "nonzero_product_nonzero": {"skill_name": "nonzero_product_nonzero", "marker": "lemma nonzero_product_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * b \\<noteq> 0\"\nproof -\n  have \"a * b \\<noteq> 0\" using assms by (simp add: field_simps)\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma nonzero_product_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * b \\<noteq> 0\"\nproof -\n  have \"a * b \\<noteq> 0\" using assms by (simp add: field_simps)\n  thus ?thesis .\nqed", "origin": "a_times_vera", "update_count": 0}, "general_non_zero_division_property": {"skill_name": "general_non_zero_division_property", "marker": "lemma general_non_zero_division_property:\n  fixes a :: \"'a::field\"\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "-", "full_code": "lemma non_zero_division_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" and \"b * (1 / b) = 1\"\n  by (simp_all add: assms)\n\nlemma general_non_zero_division_property:\n  fixes a :: \"'a::field\"\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "non_zero_division_property", "update_count": 0}, "division_property_generalized": {"skill_name": "division_property_generalized", "marker": "lemma division_property_generalized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / (a * c) = (b / a) * (1 / c)\"\nproof -\n  have \"b / (a * c) = b * (1 / (a * c))\" by (simp add: divide_simps)\n  also have \"... = b * (1 / a) * (1 / c)\" using assms by (simp add: divide_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma division_property_generalized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / (a * c) = (b / a) * (1 / c)\"\nproof -\n  have \"b / (a * c) = b * (1 / (a * c))\" by (simp add: divide_simps)\n  also have \"... = b * (1 / a) * (1 / c)\" using assms by (simp add: divide_simps)\n  finally show ?thesis by simp\nqed", "origin": "nonzero_division_property", "update_count": 0}, "multiplication_property_generalized": {"skill_name": "multiplication_property_generalized", "marker": "lemma multiplication_property_generalized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (b / c) = (a * b) / c\"\nproof -\n  have \"a * (b / c) = a * (b * (1 / c))\" by (simp add: divide_simps)\n  also have \"... = (a * b) * (1 / c)\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma multiplication_property_generalized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (b / c) = (a * b) / c\"\nproof -\n  have \"a * (b / c) = a * (b * (1 / c))\" by (simp add: divide_simps)\n  also have \"... = (a * b) * (1 / c)\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "origin": "division_property_generalized", "update_count": 0}, "division_property": {"skill_name": "division_property", "marker": "lemma division_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"1 / (a * b) = (1 / a) * (1 / b)\"\nproof -\n  have \"1 / (a * b) = 1 * (1 / (a * b))\" by (simp add: divide_simps)\n  also have \"... = (1 / a) * (1 / b)\" using assms by (simp add: divide_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma division_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"1 / (a * b) = (1 / a) * (1 / b)\"\nproof -\n  have \"1 / (a * b) = 1 * (1 / (a * b))\" by (simp add: divide_simps)\n  also have \"... = (1 / a) * (1 / b)\" using assms by (simp add: divide_simps)\n  finally show ?thesis by simp\nqed", "origin": "division_property_generalized", "update_count": 0}, "express_congruence": {"skill_name": "express_congruence", "marker": "lemma express_congruence:\n  fixes n m a :: nat\n  assumes \"n mod m = a\"\n  shows \"\\<exists>k. n = m * k + a\"\nproof -\n  from assms have \"n mod m = a\" by simp\n  then have \"n = m * (n div m) + (n mod m)\"\n    by auto\n  then show \"\\<exists>k. n = m * k + a\" \n    by (metis assms div_mult_mod_eq mult.commute)\nqed", "description": "-", "full_code": "lemma express_congruence:\n  fixes n m a :: nat\n  assumes \"n mod m = a\"\n  shows \"\\<exists>k. n = m * k + a\"\nproof -\n  from assms have \"n mod m = a\" by simp\n  then have \"n = m * (n div m) + (n mod m)\"\n    by auto\n  then show \"\\<exists>k. n = m * k + a\" \n    by (metis assms div_mult_mod_eq mult.commute)\nqed", "origin": "do_request", "update_count": 0}, "division_identity": {"skill_name": "division_identity", "marker": "lemma division_identity:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b * c) / a = (b / a) * c\"\n  using division_property[of a b] assms\n  by (simp add: algebra_simps)", "description": "-", "full_code": "lemma division_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a)\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed\n\nlemma division_identity:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b * c) / a = (b / a) * c\"\n  using division_property[of a b] assms\n  by (simp add: algebra_simps)", "origin": "division_by_nonzero", "update_count": 0}, "division_and_nonzero": {"skill_name": "division_and_nonzero", "marker": "lemma division_and_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a)\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma division_and_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a)\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed", "origin": "division_by_nonzero", "update_count": 0}, "ratio_equivalence": {"skill_name": "ratio_equivalence", "marker": "lemma ratio_equivalence:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a / b = (a * (1 / b))\"\n  using division_and_nonzero[of b a] assms by simp", "description": "-", "full_code": "lemma division_and_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a)\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed\n\nlemma ratio_equivalence:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a / b = (a * (1 / b))\"\n  using division_and_nonzero[of b a] assms by simp", "origin": "division_by_nonzero", "update_count": 0}, "nonzero_division_reciprocal": {"skill_name": "nonzero_division_reciprocal", "marker": "lemma nonzero_division_reciprocal:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a) \\<and> (1 / a) * a = 1\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  then have \"b / a = b * (1 / a)\" by simp\n  moreover have \"(1 / a) * a = 1\" using assms by (simp add: divide_simps)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma nonzero_division_reciprocal:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a) \\<and> (1 / a) * a = 1\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  then have \"b / a = b * (1 / a)\" by simp\n  moreover have \"(1 / a) * a = 1\" using assms by (simp add: divide_simps)\n  ultimately show ?thesis by auto\nqed", "origin": "division_by_nonzero", "update_count": 0}, "lcm_properties": {"skill_name": "lcm_properties", "marker": "lemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\"\n    by auto\n  then have \"lcm a b = (a * b) div gcd a b\"\n    by (metis lcm_nat_def)\n  thus ?thesis\n    using gcd_lcm by auto\nqed", "description": "-", "full_code": "lemma lcm_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"lcm a b * gcd a b = a * b\"\n    by auto\n  then have \"lcm a b = (a * b) div gcd a b\"\n    by (metis lcm_nat_def)\n  thus ?thesis\n    using gcd_lcm by auto\nqed", "origin": "do_request", "update_count": 0}, "multiplication_property_generalized_v2": {"skill_name": "multiplication_property_generalized_v2", "marker": "lemma multiplication_property_generalized_v2:\n  fixes a b c d :: real\n  assumes \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a * b) / (c * d) = (a / c) * (b / d)\"\nproof -\n  have \"(a * b) / (c * d) = (a * b) * (1 / (c * d))\" by (simp add: divide_simps)\n  also have \"... = (a * (1 / c)) * (b * (1 / d))\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma multiplication_property_generalized_v2:\n  fixes a b c d :: real\n  assumes \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a * b) / (c * d) = (a / c) * (b / d)\"\nproof -\n  have \"(a * b) / (c * d) = (a * b) * (1 / (c * d))\" by (simp add: divide_simps)\n  also have \"... = (a * (1 / c)) * (b * (1 / d))\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "origin": "multiplication_property_generalized", "update_count": 0}, "non_zero_division_property_extended": {"skill_name": "non_zero_division_property_extended", "marker": "lemma non_zero_division_property_extended:\n  fixes a b :: real and c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" and \"b * (1 / b) = 1\" and \"c * (1 / c) = 1\"\n  by (simp_all add: assms)", "description": "-", "full_code": "lemma non_zero_division_property_extended:\n  fixes a b :: real and c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" and \"b * (1 / b) = 1\" and \"c * (1 / c) = 1\"\n  by (simp_all add: assms)", "origin": "non_zero_division_property", "update_count": 0}, "non_zero_division_property_general": {"skill_name": "non_zero_division_property_general", "marker": "lemma non_zero_division_property_general:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" and \"b * (1 / b) = 1\"\nproof -\n  show \"a * (1 / a) = 1\" using assms by simp\n  show \"b * (1 / b) = 1\" using assms by simp\nqed", "description": "-", "full_code": "lemma non_zero_division_property_general:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" and \"b * (1 / b) = 1\"\nproof -\n  show \"a * (1 / a) = 1\" using assms by simp\n  show \"b * (1 / b) = 1\" using assms by simp\nqed", "origin": "non_zero_division_property", "update_count": 0}, "congruence_manipulation": {"skill_name": "congruence_manipulation", "marker": "lemma congruence_manipulation:\n  fixes k :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"\\<exists>q. k = m * q + a\"\nproof -\n  from assms(1) have \"k mod m = a\" by simp\n  then have \"k = m * (k div m) + (k mod m)\"\n    by auto\n  then show \"\\<exists>q. k = m * q + a\" \n    by (metis assms(1) div_mult_mod_eq mult.commute)\nqed", "description": "-", "full_code": "lemma congruence_manipulation:\n  fixes k :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"\\<exists>q. k = m * q + a\"\nproof -\n  from assms(1) have \"k mod m = a\" by simp\n  then have \"k = m * (k div m) + (k mod m)\"\n    by auto\n  then show \"\\<exists>q. k = m * q + a\" \n    by (metis assms(1) div_mult_mod_eq mult.commute)\nqed", "origin": "do_request", "update_count": 0}, "congruence_manipulationV2": {"skill_name": "congruence_manipulationV2", "marker": "lemma congruence_manipulation:\n  fixes k m n a b :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"\\<exists>q. k = m * q + a\"\nproof -\n  have \"k = m * (k div m) + (k mod m)\"\n    by auto\n  then show \"\\<exists>q. k = m * q + a\" \n    using assms(1) by auto\nqed", "description": "-", "full_code": "lemma congruence_manipulation:\n  fixes k m n a b :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"\\<exists>q. k = m * q + a\"\nproof -\n  have \"k = m * (k div m) + (k mod m)\"\n    by auto\n  then show \"\\<exists>q. k = m * q + a\" \n    using assms(1) by auto\nqed", "origin": "do_request", "update_count": 0}, "non_zero_sum_property_extended": {"skill_name": "non_zero_sum_property_extended", "marker": "lemma non_zero_sum_property_extended:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"x * (1 / x) + y * (1 / y) = 2\"\nproof -\n  have \"x * (1 / x) = 1\" using assms(1) by simp\n  hence \"y * (1 / y) = 1\" using assms(2) by simp\n  thus ?thesis by (metis \\<open>x * (1 / x) = 1\\<close> one_add_one)\nqed", "description": "-", "full_code": "lemma non_zero_sum_property_extended:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"x * (1 / x) + y * (1 / y) = 2\"\nproof -\n  have \"x * (1 / x) = 1\" using assms(1) by simp\n  hence \"y * (1 / y) = 1\" using assms(2) by simp\n  thus ?thesis by (metis \\<open>x * (1 / x) = 1\\<close> one_add_one)\nqed", "origin": "non_zero_sum_property", "update_count": 0}, "sum_of_inverses": {"skill_name": "sum_of_inverses", "marker": "lemma sum_of_inverses:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"1 / x + 1 / y = (x + y) / (x * y)\"\nproof -\n  have \"1 / x + 1 / y = y / (x * y) + x / (x * y)\" using assms by simp\n  thus ?thesis by (smt (verit) add.commute add_divide_distrib)\nqed", "description": "-", "full_code": "lemma sum_of_inverses:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"1 / x + 1 / y = (x + y) / (x * y)\"\nproof -\n  have \"1 / x + 1 / y = y / (x * y) + x / (x * y)\" using assms by simp\n  thus ?thesis by (smt (verit) add.commute add_divide_distrib)\nqed", "origin": "non_zero_sum_property", "update_count": 0}, "sum_of_reciprocals": {"skill_name": "sum_of_reciprocals", "marker": "lemma sum_of_reciprocals:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1/a + 1/b = (a + b) / (a*b)\"\nproof -\n  have \"1/a + 1/b = b/(a*b) + a/(a*b)\" using assms by simp\n  thus ?thesis by (smt (verit) add.commute add_divide_distrib)\nqed", "description": "-", "full_code": "lemma sum_of_reciprocals:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1/a + 1/b = (a + b) / (a*b)\"\nproof -\n  have \"1/a + 1/b = b/(a*b) + a/(a*b)\" using assms by simp\n  thus ?thesis by (smt (verit) add.commute add_divide_distrib)\nqed", "origin": "non_zero_sum_property", "update_count": 0}, "multi_distrib_complex_n": {"skill_name": "multi_distrib_complex_n", "marker": "lemma multi_distrib_complex_n:\n  fixes a b :: complex\n  fixes xs ys :: \"complex list\"\n  shows \"(a + b) * (complex_sum xs + complex_sum ys) = a * complex_sum xs + b * complex_sum xs + a * complex_sum ys + b * complex_sum ys\"\nproof (induction xs)\n  case Nil\n  then show ?case \n    by (auto simp: field_simps)\nnext\n  case (Cons x xs)\n  then show ?case \n    by (auto simp: algebra_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_n:\n  fixes a b :: complex\n  fixes xs ys :: \"complex list\"\n  shows \"(a + b) * (complex_sum xs + complex_sum ys) = a * complex_sum xs + b * complex_sum xs + a * complex_sum ys + b * complex_sum ys\"\nproof (induction xs)\n  case Nil\n  then show ?case \n    by (auto simp: field_simps)\nnext\n  case (Cons x xs)\n  then show ?case \n    by (auto simp: algebra_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib_complex_nV2": {"skill_name": "multi_distrib_complex_nV2", "marker": "lemma multi_distrib_complex_n:\n  fixes a b :: complex\n  fixes cs :: \"complex list\"\n  shows \"(a + b) * complex_sum cs = a * complex_sum cs + b * complex_sum cs\"\nproof (induction cs)\n  case Nil\n  then show ?case \n    by (auto simp: field_simps)\nnext\n  case (Cons c cs)\n  then show ?case \n    by (auto simp: algebra_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_n:\n  fixes a b :: complex\n  fixes cs :: \"complex list\"\n  shows \"(a + b) * complex_sum cs = a * complex_sum cs + b * complex_sum cs\"\nproof (induction cs)\n  case Nil\n  then show ?case \n    by (auto simp: field_simps)\nnext\n  case (Cons c cs)\n  then show ?case \n    by (auto simp: algebra_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "scalar_multiplication_inverse_nonzero": {"skill_name": "scalar_multiplication_inverse_nonzero", "marker": "lemma scalar_multiplication_inverse_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1 \\<and> b * (1 / b) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: field_simps)\n  have \"b * (1 / b) = 1\" using assms(2) by (simp add: field_simps)\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close>)\nqed", "description": "-", "full_code": "lemma scalar_multiplication_inverse_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1 \\<and> b * (1 / b) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: field_simps)\n  have \"b * (1 / b) = 1\" using assms(2) by (simp add: field_simps)\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close>)\nqed", "origin": "scalar_multiplication_inverse", "update_count": 0}, "scalar_multiplication_inverse_generalized": {"skill_name": "scalar_multiplication_inverse_generalized", "marker": "lemma scalar_multiplication_inverse_generalized:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  using assms by (simp add: field_simps)", "description": "-", "full_code": "lemma scalar_multiplication_inverse_generalized:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  using assms by (simp add: field_simps)", "origin": "scalar_multiplication_inverse", "update_count": 0}, "scalar_multiplication_inverse_generalizedV2": {"skill_name": "scalar_multiplication_inverse_generalizedV2", "marker": "lemma scalar_multiplication_inverse_generalized:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: field_simps)\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma scalar_multiplication_inverse_generalized:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: field_simps)\n  thus ?thesis .\nqed", "origin": "scalar_multiplication_inverse", "update_count": 0}, "mod_linear_combination_generalized": {"skill_name": "mod_linear_combination_generalized", "marker": "lemma mod_linear_combination_generalized:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  have \"(a + c) mod m = (b + d) mod m\"\n    using assms by (metis mod_add_cong mod_add_eq)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_linear_combination_generalized:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  have \"(a + c) mod m = (b + d) mod m\"\n    using assms by (metis mod_add_cong mod_add_eq)\n  thus ?thesis by simp\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_linear_combination_general": {"skill_name": "mod_linear_combination_general", "marker": "lemma mod_linear_combination_general:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  have \"(a + c) mod m = ((a mod m) + (c mod m)) mod m\"\n    by presburger\n  also have \"... = (b + d) mod m\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_linear_combination_general:\n  fixes a b c d m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + c) mod m = (b + d) mod m\"\nproof -\n  have \"(a + c) mod m = ((a mod m) + (c mod m)) mod m\"\n    by presburger\n  also have \"... = (b + d) mod m\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "origin": "mod_add_power", "update_count": 0}, "division_property_extended": {"skill_name": "division_property_extended", "marker": "lemma division_property_extended:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a * c = (b * c) / a\"\nproof -\n  have \"b / a * c = (b * (1 / a)) * c\" using assms by (simp add: divide_simps)\n  also have \"... = (b * c) * (1 / a)\" by (simp add: algebra_simps)\n  finally show ?thesis using assms by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma division_property_extended:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a * c = (b * c) / a\"\nproof -\n  have \"b / a * c = (b * (1 / a)) * c\" using assms by (simp add: divide_simps)\n  also have \"... = (b * c) * (1 / a)\" by (simp add: algebra_simps)\n  finally show ?thesis using assms by (simp add: divide_simps)\nqed", "origin": "division_identity", "update_count": 0}, "division_identity_extended": {"skill_name": "division_identity_extended", "marker": "lemma division_identity_extended:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b * c) / a = (b / a) * c\"\n  by (metis division_property_extended[of a b c] assms)", "description": "-", "full_code": "lemma division_property_extended:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a * c = (b * c) / a\"\nproof -\n  have \"b / a * c = (b * (1 / a)) * c\" using assms by (simp add: divide_simps)\n  also have \"... = (b * c) * (1 / a)\" by (simp add: algebra_simps)\n  finally show ?thesis using assms by (simp add: divide_simps)\nqed\n\nlemma division_identity_extended:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b * c) / a = (b / a) * c\"\n  by (metis division_property_extended[of a b c] assms)", "origin": "division_identity", "update_count": 0}, "distributive_division": {"skill_name": "distributive_division", "marker": "lemma distributive_division:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b + c) / a = (b / a) + (c / a)\"\nproof -\n  have \"(b + c) * (1 / a) = (b * (1 / a)) + (c * (1 / a))\" using assms by (simp add: field_simps)\n  thus ?thesis by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma distributive_division:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b + c) / a = (b / a) + (c / a)\"\nproof -\n  have \"(b + c) * (1 / a) = (b * (1 / a)) + (c * (1 / a))\" using assms by (simp add: field_simps)\n  thus ?thesis by (simp add: divide_simps)\nqed", "origin": "division_identity", "update_count": 0}, "sum_of_reciprocals_generalized": {"skill_name": "sum_of_reciprocals_generalized", "marker": "lemma sum_of_reciprocals_generalized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c > 0\"\n  shows \"1/(a*c) + 1/(b*c) = (1/a + 1/b) / c\"\nproof -\n  have \"1/(a*c) + 1/(b*c) = (b + a) / (a*b*c)\" using assms by (auto simp: field_simps)\n  also have \"... = (1/a + 1/b) / c\" by (smt (verit) add_divide_distrib calculation divide_divide_eq_left)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma sum_of_reciprocals_generalized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c > 0\"\n  shows \"1/(a*c) + 1/(b*c) = (1/a + 1/b) / c\"\nproof -\n  have \"1/(a*c) + 1/(b*c) = (b + a) / (a*b*c)\" using assms by (auto simp: field_simps)\n  also have \"... = (1/a + 1/b) / c\" by (smt (verit) add_divide_distrib calculation divide_divide_eq_left)\n  finally show ?thesis .\nqed", "origin": "sum_of_reciprocals", "update_count": 0}, "multiplication_property_generalized_extended": {"skill_name": "multiplication_property_generalized_extended", "marker": "lemma multiplication_property_generalized_extended:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a * (b / c)) * d = (a * b * d) / c\"\nproof -\n  have \"a * (b / c) * d = a * (b * (1 / c)) * d\" by (simp add: divide_simps)\n  also have \"... = (a * b) * (1 / c) * d\" by (simp add: algebra_simps)\n  also have \"... = (a * b * d) * (1 / c)\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma multiplication_property_generalized_extended:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a * (b / c)) * d = (a * b * d) / c\"\nproof -\n  have \"a * (b / c) * d = a * (b * (1 / c)) * d\" by (simp add: divide_simps)\n  also have \"... = (a * b) * (1 / c) * d\" by (simp add: algebra_simps)\n  also have \"... = (a * b * d) * (1 / c)\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "origin": "multiplication_property_generalized", "update_count": 0}, "extended_congruence_relation": {"skill_name": "extended_congruence_relation", "marker": "lemma extended_congruence_relation:\n  fixes k m n a b :: nat\n  assumes \"k mod m = a\" \"k mod n = b\" \"m > 0\" \"n > 0\"\n  shows \"\\<exists>q1 q2. k = m * q1 + a \\<and> k = n * q2 + b\"\nproof -\n  obtain q1 where \"k = m * q1 + a\" using assms(1) by (metis div_mult_mod_eq mult.commute)\n  obtain q2 where \"k = n * q2 + b\" using assms(2) by (metis mod_div_decomp mult.commute)\n  thus ?thesis by (metis \\<open>\\<And>thesis. (\\<And>q1. k = m * q1 + a \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close> \\<open>\\<And>thesis. (\\<And>q2. k = n * q2 + b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>)\nqed", "description": "-", "full_code": "lemma extended_congruence_relation:\n  fixes k m n a b :: nat\n  assumes \"k mod m = a\" \"k mod n = b\" \"m > 0\" \"n > 0\"\n  shows \"\\<exists>q1 q2. k = m * q1 + a \\<and> k = n * q2 + b\"\nproof -\n  obtain q1 where \"k = m * q1 + a\" using assms(1) by (metis div_mult_mod_eq mult.commute)\n  obtain q2 where \"k = n * q2 + b\" using assms(2) by (metis mod_div_decomp mult.commute)\n  thus ?thesis by (metis \\<open>\\<And>thesis. (\\<And>q1. k = m * q1 + a \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close> \\<open>\\<And>thesis. (\\<And>q2. k = n * q2 + b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>)\nqed", "origin": "congruence_manipulationV2", "update_count": 0}, "scalar_multiplication_inverse_extended": {"skill_name": "scalar_multiplication_inverse_extended", "marker": "lemma scalar_multiplication_inverse_extended:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a * (1 / a)) * (b * (1 / b)) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: field_simps)\n  have \"b * (1 / b) = 1\" using assms(2) by (simp add: field_simps)\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close> comm_monoid_mult_class.mult_1)\nqed", "description": "-", "full_code": "lemma scalar_multiplication_inverse_extended:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a * (1 / a)) * (b * (1 / b)) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: field_simps)\n  have \"b * (1 / b) = 1\" using assms(2) by (simp add: field_simps)\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close> comm_monoid_mult_class.mult_1)\nqed", "origin": "scalar_multiplication_inverse_generalized", "update_count": 0}, "scalar_multiplication_inverse_properties": {"skill_name": "scalar_multiplication_inverse_properties", "marker": "lemma scalar_multiplication_inverse_properties:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" and \"b * (1 / b) = 1\"\n  using assms by (simp_all add: field_simps)", "description": "-", "full_code": "lemma scalar_multiplication_inverse_properties:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\" and \"b * (1 / b) = 1\"\n  using assms by (simp_all add: field_simps)", "origin": "scalar_multiplication_inverse_generalized", "update_count": 0}, "integer_divisibility": {"skill_name": "integer_divisibility", "marker": "lemma integer_divisibility:\n  fixes n d :: nat\n  assumes \"n mod d = 0\"\n  shows \"\\<exists>k. n = k * d\"\nproof -\n  have \"n = d * (n div d) + (n mod d)\"\n    by auto\n  moreover have \"n mod d = 0\" using assms by simp\n  ultimately have \"n = d * (n div d) + 0\" by auto\n  thus \"\\<exists>k. n = k * d\" \n    by (auto simp: field_simps) \nqed", "description": "-", "full_code": "lemma integer_divisibility:\n  fixes n d :: nat\n  assumes \"n mod d = 0\"\n  shows \"\\<exists>k. n = k * d\"\nproof -\n  have \"n = d * (n div d) + (n mod d)\"\n    by auto\n  moreover have \"n mod d = 0\" using assms by simp\n  ultimately have \"n = d * (n div d) + 0\" by auto\n  thus \"\\<exists>k. n = k * d\" \n    by (auto simp: field_simps) \nqed", "origin": "do_request", "update_count": 0}, "integer_divisibilityV2": {"skill_name": "integer_divisibilityV2", "marker": "lemma integer_divisibility:\n  fixes n d :: nat\n  assumes \"n mod d = 0\"\n  shows \"\\<exists>k. n = k * d\"\nproof -\n  have \"n = d * (n div d) + (n mod d)\"\n    by auto\n  then show \"\\<exists>k. n = k * d\" \n    using assms by auto\nqed", "description": "-", "full_code": "lemma integer_divisibility:\n  fixes n d :: nat\n  assumes \"n mod d = 0\"\n  shows \"\\<exists>k. n = k * d\"\nproof -\n  have \"n = d * (n div d) + (n mod d)\"\n    by auto\n  then show \"\\<exists>k. n = k * d\" \n    using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "integer_divisibilityV3": {"skill_name": "integer_divisibilityV3", "marker": "lemma integer_divisibility:\n  fixes n d :: nat\n  assumes \"n mod d = 0\"\n  shows \"\\<exists>k. n = k * d\"\nproof -\n  have \"n mod d = 0\" using assms by simp\n  then have \"n = d * (n div d) + (n mod d)\" \n    by auto\n  then show \"\\<exists>k. n = k * d\" \n    by (smt (verit) Nat.diff_add_assoc assms diff_add_inverse2 diff_is_0_eq' le_numeral_extra(3) mult.commute)\nqed", "description": "-", "full_code": "lemma integer_divisibility:\n  fixes n d :: nat\n  assumes \"n mod d = 0\"\n  shows \"\\<exists>k. n = k * d\"\nproof -\n  have \"n mod d = 0\" using assms by simp\n  then have \"n = d * (n div d) + (n mod d)\" \n    by auto\n  then show \"\\<exists>k. n = k * d\" \n    by (smt (verit) Nat.diff_add_assoc assms diff_add_inverse2 diff_is_0_eq' le_numeral_extra(3) mult.commute)\nqed", "origin": "do_request", "update_count": 0}, "mod_linear_combination_generalized_multiple": {"skill_name": "mod_linear_combination_generalized_multiple", "marker": "lemma mod_linear_combination_generalized_multiple:\n  fixes a b c d m n :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + n * c) mod m = (b + n * d) mod m\"\nproof -\n  have \"(a + n * c) mod m = ((a mod m) + (n * (c mod m))) mod m\"\n    by (smt (verit) mod_add_cong mod_mod_trivial mod_mult_right_eq)\n  also have \"... = (b + n * d) mod m\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_linear_combination_generalized_multiple:\n  fixes a b c d m n :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + n * c) mod m = (b + n * d) mod m\"\nproof -\n  have \"(a + n * c) mod m = ((a mod m) + (n * (c mod m))) mod m\"\n    by (smt (verit) mod_add_cong mod_mod_trivial mod_mult_right_eq)\n  also have \"... = (b + n * d) mod m\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "origin": "mod_linear_combination_generalized", "update_count": 0}, "mod_linear_combination_extended": {"skill_name": "mod_linear_combination_extended", "marker": "lemma mod_linear_combination_extended:\n  fixes a b c d e f m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\" \"e mod m = f\"\n  shows \"(a + c + e) mod m = (b + d + f) mod m\"\nproof -\n  have \"(a + c + e) mod m = ((a + c) mod m + e) mod m\"\n    by presburger\n  also have \"... = ((b + d) mod m + f) mod m\"\n    using assms by (smt (verit) mod_add_left_eq mod_add_right_eq)\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_linear_combination_extended:\n  fixes a b c d e f m :: nat\n  assumes \"a mod m = b\" \"c mod m = d\" \"e mod m = f\"\n  shows \"(a + c + e) mod m = (b + d + f) mod m\"\nproof -\n  have \"(a + c + e) mod m = ((a + c) mod m + e) mod m\"\n    by presburger\n  also have \"... = ((b + d) mod m + f) mod m\"\n    using assms by (smt (verit) mod_add_left_eq mod_add_right_eq)\n  finally show ?thesis by presburger\nqed", "origin": "mod_linear_combination_generalized", "update_count": 0}, "mod_add": {"skill_name": "mod_add", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof (induction a)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc a)\n  then have \"((Suc a) + b) mod m = (a + b + 1) mod m\" by simp\n  also have \"... = ((a + b) mod m + 1) mod m\"\n    by presburger\n  also have \"... = ((a mod m) + (b mod m) + 1) mod m\"\n    using Suc.IH by (metis Suc_eq_plus1_left \\<open>(Suc a + b) mod m = (a + b + 1) mod m\\<close> \\<open>(a + b + 1) mod m = ((a + b) mod m + 1) mod m\\<close> add.commute add_Suc_shift group_cancel.add1 group_cancel.add2 mod_Suc mod_add_left_eq mod_add_right_eq nat_arith.suc1)\n  finally show ?case by (metis mod_add_eq)\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof (induction a)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc a)\n  then have \"((Suc a) + b) mod m = (a + b + 1) mod m\" by simp\n  also have \"... = ((a + b) mod m + 1) mod m\"\n    by presburger\n  also have \"... = ((a mod m) + (b mod m) + 1) mod m\"\n    using Suc.IH by (metis Suc_eq_plus1_left \\<open>(Suc a + b) mod m = (a + b + 1) mod m\\<close> \\<open>(a + b + 1) mod m = ((a + b) mod m + 1) mod m\\<close> add.commute add_Suc_shift group_cancel.add1 group_cancel.add2 mod_Suc mod_add_left_eq mod_add_right_eq nat_arith.suc1)\n  finally show ?case by (metis mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "non_zero_division_propertyV2": {"skill_name": "non_zero_division_propertyV2", "marker": "lemma non_zero_division_property:\n  fixes x :: real\n  assumes \"x \\<noteq> 0\"\n  shows \"x * (1 / x) = 1\"\n  using assms by simp", "description": "-", "full_code": "lemma non_zero_division_property:\n  fixes x :: real\n  assumes \"x \\<noteq> 0\"\n  shows \"x * (1 / x) = 1\"\n  using assms by simp", "origin": "non_zero_division_property_extended", "update_count": 0}, "mod_addV2": {"skill_name": "mod_addV2", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"(a + b) mod m = ((a mod m) + (b mod m) + (a div m + b div m) * m) mod m\"\n    by presburger\n  also have \"... = ((a mod m) + (b mod m)) mod m\"\n    by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"(a + b) mod m = ((a mod m) + (b mod m) + (a div m + b div m) * m) mod m\"\n    by presburger\n  also have \"... = ((a mod m) + (b mod m)) mod m\"\n    by auto\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_congruence": {"skill_name": "mod_congruence", "marker": "lemma mod_congruence:\n  fixes a b m c :: nat\n  assumes \"a mod m = b\"\n  shows \"((c * a) mod m) = ((c * b) mod m)\"\nproof -\n  have \"c * a = c * (b + m * (a div m))\"\n    using assms by auto\n  then have \"c * a mod m = (c * b + c * m * (a div m)) mod m\"\n    by (auto simp: field_simps)\n  also have \"... = (c * b) mod m\"\n    using mod_mult_right_eq by (metis add_cancel_left_right mod_add_cong mod_mult_self1_is_0 mult.assoc mult.commute mult_delta_right)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_congruence:\n  fixes a b m c :: nat\n  assumes \"a mod m = b\"\n  shows \"((c * a) mod m) = ((c * b) mod m)\"\nproof -\n  have \"c * a = c * (b + m * (a div m))\"\n    using assms by auto\n  then have \"c * a mod m = (c * b + c * m * (a div m)) mod m\"\n    by (auto simp: field_simps)\n  also have \"... = (c * b) mod m\"\n    using mod_mult_right_eq by (metis add_cancel_left_right mod_add_cong mod_mult_self1_is_0 mult.assoc mult.commute mult_delta_right)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_add_generalized": {"skill_name": "mod_add_generalized", "marker": "lemma mod_add_generalized:\n  fixes a b m d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = ((a mod d) + (b mod d)) mod d\"\nproof -\n  have \"(a + b) mod d = ((a mod d) + (b mod d) + (a div d + b div d) * d) mod d\"\n    by presburger\n  also have \"... = ((a mod d) + (b mod d)) mod d\"\n    by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_generalized:\n  fixes a b m d :: nat\n  assumes \"d > 0\"\n  shows \"(a + b) mod d = ((a mod d) + (b mod d)) mod d\"\nproof -\n  have \"(a + b) mod d = ((a mod d) + (b mod d) + (a div d + b div d) * d) mod d\"\n    by presburger\n  also have \"... = ((a mod d) + (b mod d)) mod d\"\n    by auto\n  finally show ?thesis by auto\nqed", "origin": "mod_addV2", "update_count": 0}, "mod_add_multiple": {"skill_name": "mod_add_multiple", "marker": "lemma mod_add_multiple:\n  fixes a b m n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b + n) mod m = ((a mod m) + (b mod m) + (n mod m)) mod m\"\nproof -\n  have \"(a + b + n) mod m = ((a + b) mod m + n) mod m\" by presburger\n  also have \"... = (((a mod m) + (b mod m)) mod m + n) mod m\" by presburger\n  also have \"... = ((a mod m) + (b mod m) + (n mod m)) mod m\" by (metis mod_add_left_eq mod_add_right_eq)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_multiple:\n  fixes a b m n :: nat\n  assumes \"n > 0\"\n  shows \"(a + b + n) mod m = ((a mod m) + (b mod m) + (n mod m)) mod m\"\nproof -\n  have \"(a + b + n) mod m = ((a + b) mod m + n) mod m\" by presburger\n  also have \"... = (((a mod m) + (b mod m)) mod m + n) mod m\" by presburger\n  also have \"... = ((a mod m) + (b mod m) + (n mod m)) mod m\" by (metis mod_add_left_eq mod_add_right_eq)\n  finally show ?thesis by auto\nqed", "origin": "mod_addV2", "update_count": 0}, "lcm_and_gcd_properties": {"skill_name": "lcm_and_gcd_properties", "marker": "lemma lcm_and_gcd_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\n    and \"gcd a b * lcm a b = a * b\"\nproof -\n  have lcm_def: \"lcm a b * gcd a b = a * b\" by (simp add: gcd_lcm)\n  thus \"lcm a b = (a * b) div gcd a b\" by (simp add: lcm_nat_def)\n  thus \"gcd a b * lcm a b = a * b\" by auto\nqed", "description": "-", "full_code": "lemma lcm_and_gcd_properties:\n  fixes a b :: nat\n  shows \"lcm a b = (a * b) div gcd a b\"\n    and \"gcd a b * lcm a b = a * b\"\nproof -\n  have lcm_def: \"lcm a b * gcd a b = a * b\" by (simp add: gcd_lcm)\n  thus \"lcm a b = (a * b) div gcd a b\" by (simp add: lcm_nat_def)\n  thus \"gcd a b * lcm a b = a * b\" by auto\nqed", "origin": "lcm_properties", "update_count": 0}, "gcd_lcm_commutativity": {"skill_name": "gcd_lcm_commutativity", "marker": "lemma gcd_lcm_commutativity:\n  fixes a b :: nat\n  shows \"gcd a b = gcd b a\" and \"lcm a b = lcm b a\"\nproof -\n  have \"gcd a b = gcd b a\" by (metis gcd.commute)\n  thus \"gcd a b = gcd b a\" by auto\n  have \"lcm a b = lcm b a\" by (metis lcm.commute)\n  thus \"lcm a b = lcm b a\" by auto\nqed", "description": "-", "full_code": "lemma gcd_lcm_commutativity:\n  fixes a b :: nat\n  shows \"gcd a b = gcd b a\" and \"lcm a b = lcm b a\"\nproof -\n  have \"gcd a b = gcd b a\" by (metis gcd.commute)\n  thus \"gcd a b = gcd b a\" by auto\n  have \"lcm a b = lcm b a\" by (metis lcm.commute)\n  thus \"lcm a b = lcm b a\" by auto\nqed", "origin": "lcm_properties", "update_count": 0}, "congruence_manipulationV3": {"skill_name": "congruence_manipulationV3", "marker": "lemma congruence_manipulation:\n  fixes k :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"\\<exists>q. k = m * q + a\"\nproof -\n  obtain q where \"k = m * q + a\" using assms(1) by (metis div_mult_mod_eq mult.commute) \n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma congruence_manipulation:\n  fixes k :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"\\<exists>q. k = m * q + a\"\nproof -\n  obtain q where \"k = m * q + a\" using assms(1) by (metis div_mult_mod_eq mult.commute) \n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "generalized_multiplication_property": {"skill_name": "generalized_multiplication_property", "marker": "lemma generalized_multiplication_property:\n  fixes x y z w :: real\n  assumes \"z \\<noteq> 0\" \"w \\<noteq> 0\"\n  shows \"(x * y) / (z * w) = (x / z) * (y / w)\"\nproof -\n  have \"(x * y) / (z * w) = (x * y) * (1 / (z * w))\" by (simp add: divide_simps)\n  also have \"... = (x * (1 / z)) * (y * (1 / w))\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma generalized_multiplication_property:\n  fixes x y z w :: real\n  assumes \"z \\<noteq> 0\" \"w \\<noteq> 0\"\n  shows \"(x * y) / (z * w) = (x / z) * (y / w)\"\nproof -\n  have \"(x * y) / (z * w) = (x * y) * (1 / (z * w))\" by (simp add: divide_simps)\n  also have \"... = (x * (1 / z)) * (y * (1 / w))\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "origin": "multiplication_property_generalized_v2", "update_count": 0}, "multiplication_property_with_vars": {"skill_name": "multiplication_property_with_vars", "marker": "lemma multiplication_property_with_vars:\n  fixes a b c d e f g h :: real\n  assumes \"e \\<noteq> 0\" \"f \\<noteq> 0\" \"g \\<noteq> 0\" \"h \\<noteq> 0\"\n  shows \"(a * b) / (e * f) = (a / e) * (b / f) \\<and> (c * d) / (g * h) = (c / g) * (d / h)\"\nproof -\n  have \"(a * b) / (e * f) = (a * b) * (1 / (e * f))\" by (simp add: divide_simps)\n  also have \"... = (a * (1 / e)) * (b * (1 / f))\" by (simp add: algebra_simps)\n  finally have first_eq: \"(a * b) / (e * f) = (a / e) * (b / f)\" by (simp add: divide_simps)\n  have \"(c * d) / (g * h) = (c * d) * (1 / (g * h))\" by (simp add: divide_simps)\n  also have \"... = (c * (1 / g)) * (d * (1 / h))\" by (simp add: algebra_simps)\n  finally have second_eq: \"(c * d) / (g * h) = (c / g) * (d / h)\" by (simp add: divide_simps)\n  show ?thesis using first_eq second_eq by auto\nqed", "description": "-", "full_code": "lemma multiplication_property_with_vars:\n  fixes a b c d e f g h :: real\n  assumes \"e \\<noteq> 0\" \"f \\<noteq> 0\" \"g \\<noteq> 0\" \"h \\<noteq> 0\"\n  shows \"(a * b) / (e * f) = (a / e) * (b / f) \\<and> (c * d) / (g * h) = (c / g) * (d / h)\"\nproof -\n  have \"(a * b) / (e * f) = (a * b) * (1 / (e * f))\" by (simp add: divide_simps)\n  also have \"... = (a * (1 / e)) * (b * (1 / f))\" by (simp add: algebra_simps)\n  finally have first_eq: \"(a * b) / (e * f) = (a / e) * (b / f)\" by (simp add: divide_simps)\n  have \"(c * d) / (g * h) = (c * d) * (1 / (g * h))\" by (simp add: divide_simps)\n  also have \"... = (c * (1 / g)) * (d * (1 / h))\" by (simp add: algebra_simps)\n  finally have second_eq: \"(c * d) / (g * h) = (c / g) * (d / h)\" by (simp add: divide_simps)\n  show ?thesis using first_eq second_eq by auto\nqed", "origin": "multiplication_property_generalized_v2", "update_count": 0}, "mod_properties": {"skill_name": "mod_properties", "marker": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c > 0\"\n  shows \"(a + b) mod c = (a mod c + b mod c) mod c\"\nproof -\n  have \"(a + b) mod c = (a mod c + (b + (a div c) * c)) mod c\"\n    by auto\n  also have \"... = (a mod c + b mod c) mod c\"\n    by (metis calculation mod_add_eq)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c > 0\"\n  shows \"(a + b) mod c = (a mod c + b mod c) mod c\"\nproof -\n  have \"(a + b) mod c = (a mod c + (b + (a div c) * c)) mod c\"\n    by auto\n  also have \"... = (a mod c + b mod c) mod c\"\n    by (metis calculation mod_add_eq)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_propertiesV2": {"skill_name": "mod_propertiesV2", "marker": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c > 0\"\n  shows \"(a + b) mod c = (a mod c + b mod c) mod c\"\nproof -\n  have \"a + b = (a mod c) + (b mod c) + (a div c + b div c) * c\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + (a div c + b div c) * c) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c > 0\"\n  shows \"(a + b) mod c = (a mod c + b mod c) mod c\"\nproof -\n  have \"a + b = (a mod c) + (b mod c) + (a div c + b div c) * c\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + (a div c + b div c) * c) mod c\"\n    by simp\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_propertiesV3": {"skill_name": "mod_propertiesV3", "marker": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c > 0\"\n  shows \"(a + b) mod c = (a mod c + b mod c) mod c\"\nproof -\n  have \"(a + b) mod c = ((a mod c) + (b mod c) + (a div c + b div c) * c) mod c\"\n    by presburger\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by (simp add: add.commute)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_properties:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c > 0\"\n  shows \"(a + b) mod c = (a mod c + b mod c) mod c\"\nproof -\n  have \"(a + b) mod c = ((a mod c) + (b mod c) + (a div c + b div c) * c) mod c\"\n    by presburger\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by (simp add: add.commute)\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "divisibility_properties": {"skill_name": "divisibility_properties", "marker": "lemma divisibility_properties:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  from assms(1) have \"a mod m = b\" by simp\n  then have \"a = m * (a div m) + (a mod m)\"\n    by auto\n  then show \"\\<exists>k. a = k * m + b\" \n    using assms(1) by (metis div_mult_mod_eq)\nqed", "description": "-", "full_code": "lemma divisibility_properties:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  from assms(1) have \"a mod m = b\" by simp\n  then have \"a = m * (a div m) + (a mod m)\"\n    by auto\n  then show \"\\<exists>k. a = k * m + b\" \n    using assms(1) by (metis div_mult_mod_eq)\nqed", "origin": "do_request", "update_count": 0}, "divisibility_propertiesV2": {"skill_name": "divisibility_propertiesV2", "marker": "lemma divisibility_properties:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  from assms(1) have \"a mod m = b\" by simp\n  then have \"a = m * (a div m) + (a mod m)\"\n    by auto\n  moreover have \"a mod m = b\" by (simp add: assms(1))\n  hence \"a = m * (a div m) + b\" by auto\n  ultimately show \"\\<exists>k. a = k * m + b\" \n    by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma divisibility_properties:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  from assms(1) have \"a mod m = b\" by simp\n  then have \"a = m * (a div m) + (a mod m)\"\n    by auto\n  moreover have \"a mod m = b\" by (simp add: assms(1))\n  hence \"a = m * (a div m) + b\" by auto\n  ultimately show \"\\<exists>k. a = k * m + b\" \n    by (auto simp: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "divisibility_propertiesV3": {"skill_name": "divisibility_propertiesV3", "marker": "lemma divisibility_properties:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  from assms(1) have \"a mod m = b\" by simp\n  then obtain q where \"a = m * q + b\" \n    using div_mult_mod_eq by (metis div_mod_decomp mult.commute)\n  moreover have \"q = a div m\" \n    by (smt (verit) Euclidean_Division.div_eq_0_iff add_cancel_left_left add_eq_self_zero add_right_imp_eq assms(2) bits_div_by_0 calculation div_add1_eq div_mult2_eq div_mult_self4 mod_mult_self4 mult_not_zero nonzero_mult_div_cancel_left nonzero_mult_div_cancel_right not_add_less1)\n  ultimately show \"\\<exists>k. a = k * m + b\" \n    by fastforce\nqed", "description": "-", "full_code": "lemma divisibility_properties:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"\\<exists>k. a = k * m + b\"\nproof -\n  from assms(1) have \"a mod m = b\" by simp\n  then obtain q where \"a = m * q + b\" \n    using div_mult_mod_eq by (metis div_mod_decomp mult.commute)\n  moreover have \"q = a div m\" \n    by (smt (verit) Euclidean_Division.div_eq_0_iff add_cancel_left_left add_eq_self_zero add_right_imp_eq assms(2) bits_div_by_0 calculation div_add1_eq div_mult2_eq div_mult_self4 mod_mult_self4 mult_not_zero nonzero_mult_div_cancel_left nonzero_mult_div_cancel_right not_add_less1)\n  ultimately show \"\\<exists>k. a = k * m + b\" \n    by fastforce\nqed", "origin": "do_request", "update_count": 0}, "generalized_mod_properties": {"skill_name": "generalized_mod_properties", "marker": "lemma generalized_mod_properties:\n  fixes a b c d :: nat\n  assumes \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"(a + b + d) mod c = ((a mod c + b mod c + d mod c) mod c)\"\nproof -\n  have \"(a + b + d) mod c = ((a + b) + d) mod c\"\n    by simp\n  also have \"... = ((a mod c + b mod c) + d) mod c\"\n    by (metis mod_add_eq)\n  also have \"... = ((a mod c + b mod c + d mod c) mod c)\"\n    by (metis mod_add_right_eq)\n  finally show ?thesis by (metis group_cancel.add1 mod_add_cong mod_add_eq mod_mod_trivial)\nqed", "description": "-", "full_code": "lemma generalized_mod_properties:\n  fixes a b c d :: nat\n  assumes \"b > 0\" \"c > 0\" \"d > 0\"\n  shows \"(a + b + d) mod c = ((a mod c + b mod c + d mod c) mod c)\"\nproof -\n  have \"(a + b + d) mod c = ((a + b) + d) mod c\"\n    by simp\n  also have \"... = ((a mod c + b mod c) + d) mod c\"\n    by (metis mod_add_eq)\n  also have \"... = ((a mod c + b mod c + d mod c) mod c)\"\n    by (metis mod_add_right_eq)\n  finally show ?thesis by (metis group_cancel.add1 mod_add_cong mod_add_eq mod_mod_trivial)\nqed", "origin": "mod_properties", "update_count": 0}, "division_property_n_dimensions": {"skill_name": "division_property_n_dimensions", "marker": "lemma division_property_n_dimensions:\n  fixes a b :: \"real set\"\n  assumes \"finite a\" and \"finite b\" and \"(\\<forall>x\\<in>a. x \\<noteq> 0)\" and \"(\\<forall>y\\<in>b. y \\<noteq> 0)\"\n  shows \"(\\<Sum>x\\<in>a. 1 / x) = (\\<Sum>x\\<in>a. (1 / x))\" \n  and \"(\\<Sum>y\\<in>b. 1 / y) = (\\<Sum>y\\<in>b. (1 / y))\"\n  using assms\nproof -\n  show \"(\\<Sum>x\\<in>a. 1 / x) = (\\<Sum>x\\<in>a. (1 / x))\"\n    by (metis sum.cong)\n  show \"(\\<Sum>y\\<in>b. 1 / y) = (\\<Sum>y\\<in>b. (1 / y))\"\n    by (metis sum.cong)\nqed", "description": "-", "full_code": "lemma division_property_n_dimensions:\n  fixes a b :: \"real set\"\n  assumes \"finite a\" and \"finite b\" and \"(\\<forall>x\\<in>a. x \\<noteq> 0)\" and \"(\\<forall>y\\<in>b. y \\<noteq> 0)\"\n  shows \"(\\<Sum>x\\<in>a. 1 / x) = (\\<Sum>x\\<in>a. (1 / x))\" \n  and \"(\\<Sum>y\\<in>b. 1 / y) = (\\<Sum>y\\<in>b. (1 / y))\"\n  using assms\nproof -\n  show \"(\\<Sum>x\\<in>a. 1 / x) = (\\<Sum>x\\<in>a. (1 / x))\"\n    by (metis sum.cong)\n  show \"(\\<Sum>y\\<in>b. 1 / y) = (\\<Sum>y\\<in>b. (1 / y))\"\n    by (metis sum.cong)\nqed", "origin": "division_property", "update_count": 0}, "division_property_n_dimensionsV2": {"skill_name": "division_property_n_dimensionsV2", "marker": "lemma division_property_n_dimensions:\n  fixes a b :: \"real set\"\n  assumes \"(\\<forall> x \\<in> a. x \\<noteq> 0) \\<and> (\\<forall> y \\<in> b. y \\<noteq> 0)\"\n  shows \"\\<forall> x \\<in> a. \\<forall> y \\<in> b. 1 / (x * y) = (1 / x) * (1 / y)\"\nproof -\n  have \"\\<forall> x \\<in> a. \\<forall> y \\<in> b. 1 / (x * y) = 1 * (1 / (x * y))\" by (simp add: divide_simps)\n  moreover have \"\\<forall> x \\<in> a. \\<forall> y \\<in> b. 1 / (x * y) = (1 / x) * (1 / y)\"\n    using assms by auto\n  ultimately show ?thesis by blast\nqed", "description": "-", "full_code": "lemma division_property_n_dimensions:\n  fixes a b :: \"real set\"\n  assumes \"(\\<forall> x \\<in> a. x \\<noteq> 0) \\<and> (\\<forall> y \\<in> b. y \\<noteq> 0)\"\n  shows \"\\<forall> x \\<in> a. \\<forall> y \\<in> b. 1 / (x * y) = (1 / x) * (1 / y)\"\nproof -\n  have \"\\<forall> x \\<in> a. \\<forall> y \\<in> b. 1 / (x * y) = 1 * (1 / (x * y))\" by (simp add: divide_simps)\n  moreover have \"\\<forall> x \\<in> a. \\<forall> y \\<in> b. 1 / (x * y) = (1 / x) * (1 / y)\"\n    using assms by auto\n  ultimately show ?thesis by blast\nqed", "origin": "division_property", "update_count": 0}, "cancel_div_generalized": {"skill_name": "cancel_div_generalized", "marker": "lemma cancel_div_generalized:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"m*a + n*b / x = p\"\n    and \"n > 0\"\n  shows \"m*a*x + n*b = p*x\"\nproof -\n  have \"x * (m*a + n*b / x) = p * x\"\n    using assms(2) by auto\n  then have \"x * m * a + x * (n * b / x) = p * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma cancel_div_generalized:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"m*a + n*b / x = p\"\n    and \"n > 0\"\n  shows \"m*a*x + n*b = p*x\"\nproof -\n  have \"x * (m*a + n*b / x) = p * x\"\n    using assms(2) by auto\n  then have \"x * m * a + x * (n * b / x) = p * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (auto simp: field_simps)\nqed", "origin": "cancle_div", "update_count": 0}, "extended_congruence_manipulation": {"skill_name": "extended_congruence_manipulation", "marker": "lemma extended_congruence_manipulation:\n  fixes k :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"\\<exists>q. k = m * q + a\" \n  and \"\\<exists>r. k = n * r + b\"\nproof -\n  from assms(1) have \"k mod m = a\" by simp\n  then have \"k = m * (k div m) + (k mod m)\"\n    by auto\n  then show \"\\<exists>q. k = m * q + a\" \n    by (metis assms(1) div_mult_mod_eq mult.commute)\n  from assms(2) have \"k mod n = b\" by simp\n  then have \"k = n * (k div n) + (k mod n)\"\n    by auto\n  then show \"\\<exists>r. k = n * r + b\" \n    by (metis assms(2) div_mult_mod_eq mult.commute)\nqed", "description": "-", "full_code": "lemma extended_congruence_manipulation:\n  fixes k :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"\\<exists>q. k = m * q + a\" \n  and \"\\<exists>r. k = n * r + b\"\nproof -\n  from assms(1) have \"k mod m = a\" by simp\n  then have \"k = m * (k div m) + (k mod m)\"\n    by auto\n  then show \"\\<exists>q. k = m * q + a\" \n    by (metis assms(1) div_mult_mod_eq mult.commute)\n  from assms(2) have \"k mod n = b\" by simp\n  then have \"k = n * (k div n) + (k mod n)\"\n    by auto\n  then show \"\\<exists>r. k = n * r + b\" \n    by (metis assms(2) div_mult_mod_eq mult.commute)\nqed", "origin": "congruence_manipulation", "update_count": 0}, "gcd_lcm_associativity": {"skill_name": "gcd_lcm_associativity", "marker": "lemma gcd_lcm_associativity:\n  fixes a b c :: nat\n  shows \"gcd a (gcd b c) = gcd (gcd a b) c\" and \"lcm a (lcm b c) = lcm (lcm a b) c\"\nproof -\n  have \"gcd a (gcd b c) = gcd (gcd a b) c\" by (metis gcd.assoc)\n  thus \"gcd a (gcd b c) = gcd (gcd a b) c\" by auto\n  have \"lcm a (lcm b c) = lcm (lcm a b) c\" by (metis lcm.assoc)\n  thus \"lcm a (lcm b c) = lcm (lcm a b) c\" by auto\nqed", "description": "-", "full_code": "lemma gcd_lcm_associativity:\n  fixes a b c :: nat\n  shows \"gcd a (gcd b c) = gcd (gcd a b) c\" and \"lcm a (lcm b c) = lcm (lcm a b) c\"\nproof -\n  have \"gcd a (gcd b c) = gcd (gcd a b) c\" by (metis gcd.assoc)\n  thus \"gcd a (gcd b c) = gcd (gcd a b) c\" by auto\n  have \"lcm a (lcm b c) = lcm (lcm a b) c\" by (metis lcm.assoc)\n  thus \"lcm a (lcm b c) = lcm (lcm a b) c\" by auto\nqed", "origin": "gcd_lcm_commutativity", "update_count": 0}, "mod_linear_combination": {"skill_name": "mod_linear_combination", "marker": "lemma mod_linear_combination:\n  fixes a b c d m n :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + k * c) mod m = (b + k * d) mod m\"\nproof -\n  have \"(a + k * c) mod m = ((a mod m) + (k * (c mod m))) mod m\"\n    by (smt (verit) mod_add_cong mod_mod_trivial mod_mult_right_eq)\n  also have \"... = (b + k * d) mod m\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_linear_combination:\n  fixes a b c d m n :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + k * c) mod m = (b + k * d) mod m\"\nproof -\n  have \"(a + k * c) mod m = ((a mod m) + (k * (c mod m))) mod m\"\n    by (smt (verit) mod_add_cong mod_mod_trivial mod_mult_right_eq)\n  also have \"... = (b + k * d) mod m\"\n    using assms by auto\n  finally show ?thesis by simp\nqed", "origin": "mod_linear_combination_generalized_multiple", "update_count": 0}, "mod_congruence_multiple": {"skill_name": "mod_congruence_multiple", "marker": "lemma mod_congruence_multiple:\n  fixes a b m n :: nat\n  assumes \"a mod m = b mod m\"\n  shows \"(c * a) mod m = (c * b) mod m\" \n  using assms\n  by (metis mod_mult_cong mult.commute)", "description": "-", "full_code": "lemma mod_congruence_multiple:\n  fixes a b m n :: nat\n  assumes \"a mod m = b mod m\"\n  shows \"(c * a) mod m = (c * b) mod m\" \n  using assms\n  by (metis mod_mult_cong mult.commute)", "origin": "generalized_mod_properties", "update_count": 0}, "generalized_mod_sum_properties": {"skill_name": "generalized_mod_sum_properties", "marker": "lemma generalized_mod_sum_properties:\n  fixes a b c :: nat\n  assumes \"a < c\" \"b < c\"\n  shows \"(a + b) mod c = (a mod c + b mod c) mod c\"\nproof -\n  have \"a mod c = a\" and \"b mod c = b\" using assms by simp_all\n  then have \"(a + b) mod c = (a + b) mod c\" by simp\n  thus ?thesis by presburger\nqed", "description": "-", "full_code": "lemma generalized_mod_sum_properties:\n  fixes a b c :: nat\n  assumes \"a < c\" \"b < c\"\n  shows \"(a + b) mod c = (a mod c + b mod c) mod c\"\nproof -\n  have \"a mod c = a\" and \"b mod c = b\" using assms by simp_all\n  then have \"(a + b) mod c = (a + b) mod c\" by simp\n  thus ?thesis by presburger\nqed", "origin": "generalized_mod_properties", "update_count": 0}, "mod_propertiesV4": {"skill_name": "mod_propertiesV4", "marker": "lemma mod_properties:\n  fixes a b c d :: nat\n  assumes \"a mod d = b\" \"c mod d = 0\"\n  shows \"(a + c) mod d = b\"\nproof -\n  have \"a = b + (a div d) * d\" using assms(1) by auto\n  have \"c = (c div d) * d\" using assms(2) by auto\n  then have \"a + c = (b + (a div d) * d) + ((c div d) * d)\" by (metis \\<open>a = b + a div d * d\\<close>)\n  also have \"... = b + ((a div d) + (c div d)) * d\" by (auto simp: field_simps)\n  finally have \"a + c = b + ((a div d) + (c div d)) * d\" .\n  then have \"(a + c) mod d = (b + ((a div d) + (c div d)) * d) mod d\" by (simp)\n  also have \"... = b mod d\" by auto\n  finally show ?thesis using assms(1) by auto\nqed", "description": "-", "full_code": "lemma mod_properties:\n  fixes a b c d :: nat\n  assumes \"a mod d = b\" \"c mod d = 0\"\n  shows \"(a + c) mod d = b\"\nproof -\n  have \"a = b + (a div d) * d\" using assms(1) by auto\n  have \"c = (c div d) * d\" using assms(2) by auto\n  then have \"a + c = (b + (a div d) * d) + ((c div d) * d)\" by (metis \\<open>a = b + a div d * d\\<close>)\n  also have \"... = b + ((a div d) + (c div d)) * d\" by (auto simp: field_simps)\n  finally have \"a + c = b + ((a div d) + (c div d)) * d\" .\n  then have \"(a + c) mod d = (b + ((a div d) + (c div d)) * d) mod d\" by (simp)\n  also have \"... = b mod d\" by auto\n  finally show ?thesis using assms(1) by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_propertiesV5": {"skill_name": "mod_propertiesV5", "marker": "lemma mod_properties:\n  fixes a b c d :: nat\n  assumes \"a mod d = b\" \"c mod d = 0\"\n  shows \"(a + c) mod d = b\"\nproof -\n  have \"a = b + (a div d) * d\" using assms(1) by auto\n  moreover have \"c = 0 + (c div d) * d\" using assms(2) by auto\n  ultimately have \"a + c = (b + (a div d) * d) + ((c div d) * d)\"\n    by (simp add: add.commute)\n  then have \"(a + c) mod d = ((b + (a div d) * d + (c div d) * d) mod d)\"\n    by simp\n  moreover have \"((a div d) * d + (c div d) * d) mod d = 0\"\n    by auto\n  ultimately have \"(a + c) mod d = (b + 0) mod d\"\n    by simp\n  thus ?thesis by (metis add_0_iff assms(1) assms(2) mod_0 mod_add_cong)\nqed", "description": "-", "full_code": "lemma mod_properties:\n  fixes a b c d :: nat\n  assumes \"a mod d = b\" \"c mod d = 0\"\n  shows \"(a + c) mod d = b\"\nproof -\n  have \"a = b + (a div d) * d\" using assms(1) by auto\n  moreover have \"c = 0 + (c div d) * d\" using assms(2) by auto\n  ultimately have \"a + c = (b + (a div d) * d) + ((c div d) * d)\"\n    by (simp add: add.commute)\n  then have \"(a + c) mod d = ((b + (a div d) * d + (c div d) * d) mod d)\"\n    by simp\n  moreover have \"((a div d) * d + (c div d) * d) mod d = 0\"\n    by auto\n  ultimately have \"(a + c) mod d = (b + 0) mod d\"\n    by simp\n  thus ?thesis by (metis add_0_iff assms(1) assms(2) mod_0 mod_add_cong)\nqed", "origin": "do_request", "update_count": 0}, "chinese_remainder_theorem": {"skill_name": "chinese_remainder_theorem", "marker": "lemma chinese_remainder_theorem:\n  fixes a b c d x :: nat\n  assumes \"a > 0\" \"b < a\" \"c > 0\" \"d < c\"\n    and \"x mod a = b\" \"x mod c = d\"\n  shows \"\\<exists>k. x = b + a * k\"\nproof -\n  obtain k1 where \"x = b + a * k1\" using assms(5) by (metis mod_div_mult_eq mult.commute)\n  thus \"\\<exists>k. x = b + a * k\" by auto\nqed", "description": "-", "full_code": "lemma chinese_remainder_theorem:\n  fixes a b c d x :: nat\n  assumes \"a > 0\" \"b < a\" \"c > 0\" \"d < c\"\n    and \"x mod a = b\" \"x mod c = d\"\n  shows \"\\<exists>k. x = b + a * k\"\nproof -\n  obtain k1 where \"x = b + a * k1\" using assms(5) by (metis mod_div_mult_eq mult.commute)\n  thus \"\\<exists>k. x = b + a * k\" by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_bound": {"skill_name": "mod_bound", "marker": "lemma mod_bound:\n  fixes n :: nat\n  assumes \"n < k\" \"n mod m = r\"\n  shows \"\\<exists>x. x < k \\<and> x mod m = r\"\nproof -\n  from assms(2) have \"n mod m = r\" by simp\n  then have \"n = m * (n div m) + r\" by auto\n  let ?x = \"n\"\n  have \"?x mod m = r\" by (metis assms(2))\n  moreover have \"?x < k\" using assms(1) by simp\n  ultimately show \"\\<exists>x. x < k \\<and> x mod m = r\" \n    by auto\nqed", "description": "-", "full_code": "lemma mod_bound:\n  fixes n :: nat\n  assumes \"n < k\" \"n mod m = r\"\n  shows \"\\<exists>x. x < k \\<and> x mod m = r\"\nproof -\n  from assms(2) have \"n mod m = r\" by simp\n  then have \"n = m * (n div m) + r\" by auto\n  let ?x = \"n\"\n  have \"?x mod m = r\" by (metis assms(2))\n  moreover have \"?x < k\" using assms(1) by simp\n  ultimately show \"\\<exists>x. x < k \\<and> x mod m = r\" \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "multiplication_property": {"skill_name": "multiplication_property", "marker": "lemma multiplication_property:\n  fixes x y z :: real\n  assumes \"z \\<noteq> 0\"\n  shows \"(x * y) / z = (x / z) * y\"\nproof -\n  have \"(x * y) / z = (x * y) * (1 / z)\" by (simp add: divide_simps)\n  also have \"... = (x * (1 / z)) * y\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma multiplication_property:\n  fixes x y z :: real\n  assumes \"z \\<noteq> 0\"\n  shows \"(x * y) / z = (x / z) * y\"\nproof -\n  have \"(x * y) / z = (x * y) * (1 / z)\" by (simp add: divide_simps)\n  also have \"... = (x * (1 / z)) * y\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "origin": "generalized_multiplication_property", "update_count": 0}, "division_propertyV2": {"skill_name": "division_propertyV2", "marker": "lemma division_property:\n  fixes x y z :: real\n  assumes \"z \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"(x / z) * y = x * (y / z)\"\nproof -\n  have \"(x / z) * y = (x * (1 / z)) * y\" by (simp add: divide_simps)\n  also have \"... = x * (y * (1 / z))\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma division_property:\n  fixes x y z :: real\n  assumes \"z \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"(x / z) * y = x * (y / z)\"\nproof -\n  have \"(x / z) * y = (x * (1 / z)) * y\" by (simp add: divide_simps)\n  also have \"... = x * (y * (1 / z))\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed", "origin": "generalized_multiplication_property", "update_count": 0}, "reciprocal_properties": {"skill_name": "reciprocal_properties", "marker": "lemma reciprocal_properties:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a) \\<and> (1 / a) * a = 1 \\<and> (1 / a) \\<noteq> 0\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  then have \"b / a = b * (1 / a)\" by simp\n  moreover have \"(1 / a) * a = 1\" using assms by (simp add: divide_simps)\n  moreover have \"(1 / a) \\<noteq> 0\" using assms by (simp add: divide_simps)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma reciprocal_properties:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a) \\<and> (1 / a) * a = 1 \\<and> (1 / a) \\<noteq> 0\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  then have \"b / a = b * (1 / a)\" by simp\n  moreover have \"(1 / a) * a = 1\" using assms by (simp add: divide_simps)\n  moreover have \"(1 / a) \\<noteq> 0\" using assms by (simp add: divide_simps)\n  ultimately show ?thesis by auto\nqed", "origin": "nonzero_division_reciprocal", "update_count": 0}, "ratio_equivalence_multi": {"skill_name": "ratio_equivalence_multi", "marker": "lemma ratio_equivalence_multi:\n  fixes a :: real\n  assumes \"b1 \\<noteq> 0\" \"b2 \\<noteq> 0\"\n  shows \"a / (b1 * b2) = (a * (1 / b1)) * (1 / b2)\"\nproof -\n  have \"a / (b1 * b2) = a * (1 / (b1 * b2))\" using assms by auto\n  also have \"... = (a * (1 / b1)) * (1 / b2)\" by (simp add: divide_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma division_and_nonzero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a = b * (1 / a)\"\nproof -\n  have \"b / a = b * (1 / a)\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed\n\nlemma ratio_equivalence:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a / b = (a * (1 / b))\"\n  using division_and_nonzero[of b a] assms by simp\n\nlemma ratio_equivalence_multi:\n  fixes a :: real\n  assumes \"b1 \\<noteq> 0\" \"b2 \\<noteq> 0\"\n  shows \"a / (b1 * b2) = (a * (1 / b1)) * (1 / b2)\"\nproof -\n  have \"a / (b1 * b2) = a * (1 / (b1 * b2))\" using assms by auto\n  also have \"... = (a * (1 / b1)) * (1 / b2)\" by (simp add: divide_simps)\n  finally show ?thesis .\nqed", "origin": "ratio_equivalence", "update_count": 0}, "division_and_nonzero_multi": {"skill_name": "division_and_nonzero_multi", "marker": "lemma division_and_nonzero_multi:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\" \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. b / a) = (\\<Sum>i\\<in>A. b) * (1 / a)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b / a) = (\\<Sum>i\\<in>A. b * (1 / a))\" \n    by (simp add: sum.cong assms(1))\n  also have \"(\\<Sum>i\\<in>A. b * (1 / a)) = (\\<Sum>i\\<in>A. b) * (1 / a)\" \n    by auto\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma division_and_nonzero_multi:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\" \"finite A\"\n  shows \"(\\<Sum>i\\<in>A. b / a) = (\\<Sum>i\\<in>A. b) * (1 / a)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. b / a) = (\\<Sum>i\\<in>A. b * (1 / a))\" \n    by (simp add: sum.cong assms(1))\n  also have \"(\\<Sum>i\\<in>A. b * (1 / a)) = (\\<Sum>i\\<in>A. b) * (1 / a)\" \n    by auto\n  finally show ?thesis .\nqed", "origin": "ratio_equivalence", "update_count": 0}, "positive_division": {"skill_name": "positive_division", "marker": "lemma positive_division:\n  fixes a b :: real\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"a / b > 0\"\nproof -\n  have \"a / b = a * (1 / b)\" by (simp add: field_simps)\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma positive_division:\n  fixes a b :: real\n  assumes \"a > 0\" and \"b > 0\"\n  shows \"a / b > 0\"\nproof -\n  have \"a / b = a * (1 / b)\" by (simp add: field_simps)\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "origin": "scalar_multiplication_inverse_generalizedV2", "update_count": 0}, "linear_congruence_solution": {"skill_name": "linear_congruence_solution", "marker": "lemma linear_congruence_solution:\n  fixes a b c :: nat\n  assumes \"c > 0\" and \"a mod c = b\"\n  shows \"\\<exists>k. a = b + k * c\"\nproof -\n  obtain k where \"a = b + k * c\" \n    using assms(2) by (metis mod_div_mult_eq)\n  thus \"\\<exists>k. a = b + k * c\" by auto\nqed", "description": "-", "full_code": "lemma linear_congruence_solution:\n  fixes a b c :: nat\n  assumes \"c > 0\" and \"a mod c = b\"\n  shows \"\\<exists>k. a = b + k * c\"\nproof -\n  obtain k where \"a = b + k * c\" \n    using assms(2) by (metis mod_div_mult_eq)\n  thus \"\\<exists>k. a = b + k * c\" by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_linear_combination_specific": {"skill_name": "mod_linear_combination_specific", "marker": "lemma mod_linear_combination_specific:\n  fixes a b c d :: nat\n  assumes \"a mod m = b\" \"c mod m = d\" \"n > 0\"\n  shows \"(a + n * c) mod m = (b + n * d) mod m\"\n  using mod_linear_combination_generalized[of a b c d m n] by (smt (verit) assms(1) assms(2) mod_linear_combination_generalized)", "description": "-", "full_code": "lemma mod_linear_combination_generalized:\n  fixes a b c d m n :: nat\n  assumes \"a mod m = b\" \"c mod m = d\"\n  shows \"(a + n * c) mod m = (b + n * d) mod m\"\nproof -\n  have \"(a + n * c) mod m = ((a mod m) + (n * (c mod m))) mod m\"\n    by (smt (verit) mod_add_cong mod_mod_trivial mod_mult_right_eq)\n  also have \"... = (b + n * d) mod m\"\n    using assms by auto\n  finally show ?thesis by simp\nqed\n\nlemma mod_linear_combination_specific:\n  fixes a b c d :: nat\n  assumes \"a mod m = b\" \"c mod m = d\" \"n > 0\"\n  shows \"(a + n * c) mod m = (b + n * d) mod m\"\n  using mod_linear_combination_generalized[of a b c d m n] by (smt (verit) assms(1) assms(2) mod_linear_combination_generalized)", "origin": "mod_linear_combination_generalized_multiple", "update_count": 0}, "mod_linear_combination_special_case": {"skill_name": "mod_linear_combination_special_case", "marker": "lemma mod_linear_combination_special_case:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\" \"c mod m = 0\"\n  shows \"(a + c) mod m = b mod m\"\nproof -\n  have \"(a + c) mod m = (a mod m + c mod m) mod m\" \n    by presburger\n  also have \"... = (b + 0) mod m\" \n    using assms by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_linear_combination_special_case:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\" \"c mod m = 0\"\n  shows \"(a + c) mod m = b mod m\"\nproof -\n  have \"(a + c) mod m = (a mod m + c mod m) mod m\" \n    by presburger\n  also have \"... = (b + 0) mod m\" \n    using assms by simp\n  finally show ?thesis by simp\nqed", "origin": "mod_linear_combination_generalized_multiple", "update_count": 0}, "mod_linear_combination_specialized": {"skill_name": "mod_linear_combination_specialized", "marker": "lemma mod_linear_combination_specialized:\n  fixes a b c m n :: nat\n  assumes \"a mod m = b\" \"c mod m = 0\"\n  shows \"(a + n * c) mod m = b mod m\"\nproof -\n  have \"c mod m = 0\" using assms(2) by simp\n  then have \"(a + n * c) mod m = (a + n * 0) mod m\" by (metis add_0_iff assms(1) mod_add_cong mod_mult_left_eq mult.commute mult_delta_left mult_delta_right)\n  thus ?thesis using assms(1) by auto\nqed", "description": "-", "full_code": "lemma mod_linear_combination_specialized:\n  fixes a b c m n :: nat\n  assumes \"a mod m = b\" \"c mod m = 0\"\n  shows \"(a + n * c) mod m = b mod m\"\nproof -\n  have \"c mod m = 0\" using assms(2) by simp\n  then have \"(a + n * c) mod m = (a + n * 0) mod m\" by (metis add_0_iff assms(1) mod_add_cong mod_mult_left_eq mult.commute mult_delta_left mult_delta_right)\n  thus ?thesis using assms(1) by auto\nqed", "origin": "mod_linear_combination_generalized_multiple", "update_count": 0}, "scalar_multiplication_inverse_for_positive_numbers": {"skill_name": "scalar_multiplication_inverse_for_positive_numbers", "marker": "lemma scalar_multiplication_inverse_for_positive_numbers:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"(1 / a) * a = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: field_simps)\n  thus ?thesis by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma scalar_multiplication_inverse_for_positive_numbers:\n  fixes a :: real\n  assumes \"a > 0\"\n  shows \"(1 / a) * a = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: field_simps)\n  thus ?thesis by (simp add: mult.commute)\nqed", "origin": "scalar_multiplication_inverse_generalizedV2", "update_count": 0}, "mod_congruence_addition": {"skill_name": "mod_congruence_addition", "marker": "lemma mod_congruence_addition:\n  fixes n m a b :: nat\n  assumes \"n mod m = a\" \"n mod m = b\"\n  shows \"a = b\"\nproof -\n  have \"n mod m = a\" by (simp add: assms(1))\n  then have \"n mod m = b\" by (simp add: assms(2))\n  thus ?thesis by (metis assms(1))\nqed", "description": "-", "full_code": "lemma mod_congruence_addition:\n  fixes n m a b :: nat\n  assumes \"n mod m = a\" \"n mod m = b\"\n  shows \"a = b\"\nproof -\n  have \"n mod m = a\" by (simp add: assms(1))\n  then have \"n mod m = b\" by (simp add: assms(2))\n  thus ?thesis by (metis assms(1))\nqed", "origin": "express_congruence", "update_count": 0}, "multiplicative_inverse_property": {"skill_name": "multiplicative_inverse_property", "marker": "lemma multiplicative_inverse_property:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma multiplicative_inverse_property:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed", "origin": "division_by_nonzero", "update_count": 0}, "inequality_bounds": {"skill_name": "inequality_bounds", "marker": "lemma inequality_bounds:\n  fixes x :: nat\n  assumes \"x < a\" \"x < b\"\n  shows \"x < min a b\"\nproof -\n  from assms(1) have \"x < a\" by simp\n  from assms(2) have \"x < b\" by simp\n  then show \"x < min a b\" \n    by (metis assms(1) min_less_iff_conj)\nqed", "description": "-", "full_code": "lemma inequality_bounds:\n  fixes x :: nat\n  assumes \"x < a\" \"x < b\"\n  shows \"x < min a b\"\nproof -\n  from assms(1) have \"x < a\" by simp\n  from assms(2) have \"x < b\" by simp\n  then show \"x < min a b\" \n    by (metis assms(1) min_less_iff_conj)\nqed", "origin": "do_request", "update_count": 0}, "inequality_boundsV2": {"skill_name": "inequality_boundsV2", "marker": "lemma inequality_bounds:\n  fixes x :: nat\n  assumes \"x < a\" \"x < b\"\n  shows \"x < min a b\"\nproof -\n  have \"min a b = (if a < b then a else b)\" by (simp add: min_def)\n  moreover {\n    assume \"a < b\"\n    then have \"min a b = a\" by (simp add: min_def)\n    hence \"x < min a b\" using assms(1) by simp\n  }\n  moreover {\n    assume \"b \\<le> a\"\n    then have \"min a b = b\" by (simp add: min_def)\n    hence \"x < min a b\" using assms(2) by simp\n  }\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma inequality_bounds:\n  fixes x :: nat\n  assumes \"x < a\" \"x < b\"\n  shows \"x < min a b\"\nproof -\n  have \"min a b = (if a < b then a else b)\" by (simp add: min_def)\n  moreover {\n    assume \"a < b\"\n    then have \"min a b = a\" by (simp add: min_def)\n    hence \"x < min a b\" using assms(1) by simp\n  }\n  moreover {\n    assume \"b \\<le> a\"\n    then have \"min a b = b\" by (simp add: min_def)\n    hence \"x < min a b\" using assms(2) by simp\n  }\n  ultimately show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_congruence_extended": {"skill_name": "mod_congruence_extended", "marker": "lemma mod_congruence_extended:\n  fixes a b m k :: nat\n  assumes \"a mod m = b mod m\" \"k > 0\"\n  shows \"(k * a) mod m = (k * b) mod m\" \n  using assms mod_congruence_multiple_general by blast", "description": "-", "full_code": "lemma mod_congruence_multiple_general:\n  fixes a b c m n :: nat\n  assumes \"a mod m = b mod m\"\n  shows \"(c * a) mod m = (c * b) mod m\" \n  by (metis assms mod_mult_cong mult.commute)\n\nlemma mod_congruence_extended:\n  fixes a b m k :: nat\n  assumes \"a mod m = b mod m\" \"k > 0\"\n  shows \"(k * a) mod m = (k * b) mod m\" \n  using assms mod_congruence_multiple_general by blast", "origin": "mod_congruence_multiple", "update_count": 0}, "mod_congruence_multiple_additive": {"skill_name": "mod_congruence_multiple_additive", "marker": "lemma mod_congruence_multiple_additive:\n  fixes a b c m :: nat\n  assumes \"a mod m = b mod m\"\n  shows \"((a + c) mod m) = ((b + c) mod m)\"\nproof -\n  have \"a mod m = b mod m\" \n    using assms by auto\n  then have \"(a + c) mod m = (b + c) mod m\" \n    using assms by (metis mod_add_cong)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_congruence_multiple_additive:\n  fixes a b c m :: nat\n  assumes \"a mod m = b mod m\"\n  shows \"((a + c) mod m) = ((b + c) mod m)\"\nproof -\n  have \"a mod m = b mod m\" \n    using assms by auto\n  then have \"(a + c) mod m = (b + c) mod m\" \n    using assms by (metis mod_add_cong)\n  thus ?thesis by auto\nqed", "origin": "mod_congruence_multiple", "update_count": 0}, "mod_congruence_multiple_general": {"skill_name": "mod_congruence_multiple_general", "marker": "lemma mod_congruence_multiple_general:\n  fixes a b c m :: nat\n  assumes \"a mod m = b mod m\" \"c > 0\"\n  shows \"(c * a) mod m = (c * b) mod m\" \nproof -\n  have \"c * a mod m = (c * (a mod m) + c * (b mod m) - c * (b mod m)) mod m\"\n    using assms by (metis add_implies_diff mod_mult_right_eq)\n  thus ?thesis using assms by (metis mod_mult_cong mult.commute)\nqed", "description": "-", "full_code": "lemma mod_congruence_multiple_general:\n  fixes a b c m :: nat\n  assumes \"a mod m = b mod m\" \"c > 0\"\n  shows \"(c * a) mod m = (c * b) mod m\" \nproof -\n  have \"c * a mod m = (c * (a mod m) + c * (b mod m) - c * (b mod m)) mod m\"\n    using assms by (metis add_implies_diff mod_mult_right_eq)\n  thus ?thesis using assms by (metis mod_mult_cong mult.commute)\nqed", "origin": "mod_congruence_multiple", "update_count": 0}, "mod_congruence_additionV2": {"skill_name": "mod_congruence_additionV2", "marker": "lemma mod_congruence_addition:\n  fixes a b c m :: nat\n  assumes \"a mod m = b mod m\"\n  shows \"(a + c) mod m = (b + c) mod m\"\n  using assms\n  by (metis mod_add_cong)", "description": "-", "full_code": "lemma mod_congruence_addition:\n  fixes a b c m :: nat\n  assumes \"a mod m = b mod m\"\n  shows \"(a + c) mod m = (b + c) mod m\"\n  using assms\n  by (metis mod_add_cong)", "origin": "mod_congruence_multiple", "update_count": 0}, "congruence_class_representation": {"skill_name": "congruence_class_representation", "marker": "lemma congruence_class_representation:\n  fixes n m :: nat\n  assumes \"n mod m = r\" and \"0 \\<le> r\" and \"r < m\"\n  shows \"\\<exists>k. n = m * k + r\"\nproof -\n  from assms(1) have \"n mod m = r\" by simp\n  then have \"n = m * (n div m) + (n mod m)\"\n    by auto\n  then have \"n = m * (n div m) + r\"\n    using assms(1) by auto\n  thus \"\\<exists>k. n = m * k + r\" \n    by (rule exI[where x=\"n div m\"])\nqed", "description": "-", "full_code": "lemma congruence_class_representation:\n  fixes n m :: nat\n  assumes \"n mod m = r\" and \"0 \\<le> r\" and \"r < m\"\n  shows \"\\<exists>k. n = m * k + r\"\nproof -\n  from assms(1) have \"n mod m = r\" by simp\n  then have \"n = m * (n div m) + (n mod m)\"\n    by auto\n  then have \"n = m * (n div m) + r\"\n    using assms(1) by auto\n  thus \"\\<exists>k. n = m * k + r\" \n    by (rule exI[where x=\"n div m\"])\nqed", "origin": "do_request", "update_count": 0}, "scalar_multiplication_inverse_parameterized": {"skill_name": "scalar_multiplication_inverse_parameterized", "marker": "lemma scalar_multiplication_inverse_parameterized:\n  fixes a b :: real\n  assumes \"a > 0\"\n  shows \"a * (1 / a) = 1\"\n  using scalar_multiplication_inverse_general[of a] assms by simp", "description": "-", "full_code": "lemma scalar_multiplication_inverse_general:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: field_simps)\n  thus ?thesis .\nqed\n\nlemma scalar_multiplication_inverse_parameterized:\n  fixes a b :: real\n  assumes \"a > 0\"\n  shows \"a * (1 / a) = 1\"\n  using scalar_multiplication_inverse_general[of a] assms by simp", "origin": "scalar_multiplication_inverse", "update_count": 0}, "sum_of_possible_n": {"skill_name": "sum_of_possible_n", "marker": "lemma sum_of_possible_N:\n  shows \"21 + 45 = 66\"\nproof -\n  have \"21 + 45 = 66\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_possible_N:\n  shows \"21 + 45 = 66\"\nproof -\n  have \"21 + 45 = 66\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "ratio_equivalence_with_c": {"skill_name": "ratio_equivalence_with_c", "marker": "lemma ratio_equivalence_with_c:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\"\n  shows \"a / (b * c) = (a / b) * (1 / c)\"\nproof -\n  have \"a / (b * c) = a * (1 / (b * c))\"\n    by simp\n  also have \"... = a * (1 / b) * (1 / c)\"\n    by (simp add: divide_simps)\n  finally show ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma ratio_equivalence_with_c:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\"\n  shows \"a / (b * c) = (a / b) * (1 / c)\"\nproof -\n  have \"a / (b * c) = a * (1 / (b * c))\"\n    by simp\n  also have \"... = a * (1 / b) * (1 / c)\"\n    by (simp add: divide_simps)\n  finally show ?thesis\n    by simp\nqed", "origin": "ratio_equivalence", "update_count": 0}, "ratio_equivalence_parametrized": {"skill_name": "ratio_equivalence_parametrized", "marker": "lemma ratio_equivalence_parametrized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\"\n  shows \"a / (b * c) = (a * (1 / (b * c)))\"\nproof -\n  have \"a / (b * c) = a * (1 / (b * c))\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma ratio_equivalence_parametrized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\"\n  shows \"a / (b * c) = (a * (1 / (b * c)))\"\nproof -\n  have \"a / (b * c) = a * (1 / (b * c))\" using assms by (simp add: divide_simps)\n  thus ?thesis .\nqed", "origin": "ratio_equivalence", "update_count": 0}, "non_zero_sum_property_arbitrary": {"skill_name": "non_zero_sum_property_arbitrary", "marker": "lemma non_zero_sum_property_arbitrary:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"k > 0\"\n  shows \"k * (1 / a) + k * (1 / b) = k * (1 / a + 1 / b)\"\nproof -\n  have \"k * (1 / a) + k * (1 / b) = k * ((1 / a) + (1 / b))\"\n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_zero_sum_property_arbitrary:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"k > 0\"\n  shows \"k * (1 / a) + k * (1 / b) = k * (1 / a + 1 / b)\"\nproof -\n  have \"k * (1 / a) + k * (1 / b) = k * ((1 / a) + (1 / b))\"\n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "non_zero_sum_property", "update_count": 0}, "non_zero_sum_property_with_c": {"skill_name": "non_zero_sum_property_with_c", "marker": "lemma non_zero_sum_property_with_c:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\"\n  shows \"a * (1 / a) + b * (1 / b) + c * (1 / c) = 3\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by simp\n  hence \"b * (1 / b) = 1\" using assms(2) by simp\n  hence \"c * (1 / c) = 1\" using assms(3) by simp\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close> \\<open>b * (1 / b) = 1\\<close> add.commute dbl_def dbl_simps(3) numeral_plus_one semiring_norm(3) semiring_norm(5))\nqed", "description": "-", "full_code": "lemma non_zero_sum_property_with_c:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\"\n  shows \"a * (1 / a) + b * (1 / b) + c * (1 / c) = 3\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by simp\n  hence \"b * (1 / b) = 1\" using assms(2) by simp\n  hence \"c * (1 / c) = 1\" using assms(3) by simp\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close> \\<open>b * (1 / b) = 1\\<close> add.commute dbl_def dbl_simps(3) numeral_plus_one semiring_norm(3) semiring_norm(5))\nqed", "origin": "non_zero_sum_property", "update_count": 0}, "generalized_non_zero_sum_property": {"skill_name": "generalized_non_zero_sum_property", "marker": "lemma generalized_non_zero_sum_property:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"a * (1 / a) + b * (1 / b) + c * (1 / c) + d * (1 / d) = 4\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by simp\n  hence \"b * (1 / b) = 1\" using assms(2) by simp\n  hence \"c * (1 / c) = 1\" using assms(3) by simp\n  hence \"d * (1 / d) = 1\" using assms(4) by simp\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close> \\<open>b * (1 / b) = 1\\<close> \\<open>c * (1 / c) = 1\\<close> add.commute add_divide_distrib div_by_1 group_cancel.add2 is_num_normalize(1) mult_cancel_right1 nonzero_eq_divide_eq numeral_Bit0 one_add_one zero_neq_one)\nqed", "description": "-", "full_code": "lemma generalized_non_zero_sum_property:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"a * (1 / a) + b * (1 / b) + c * (1 / c) + d * (1 / d) = 4\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by simp\n  hence \"b * (1 / b) = 1\" using assms(2) by simp\n  hence \"c * (1 / c) = 1\" using assms(3) by simp\n  hence \"d * (1 / d) = 1\" using assms(4) by simp\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close> \\<open>b * (1 / b) = 1\\<close> \\<open>c * (1 / c) = 1\\<close> add.commute add_divide_distrib div_by_1 group_cancel.add2 is_num_normalize(1) mult_cancel_right1 nonzero_eq_divide_eq numeral_Bit0 one_add_one zero_neq_one)\nqed", "origin": "non_zero_sum_property", "update_count": 0}, "nonzero_division": {"skill_name": "nonzero_division", "marker": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"1 / a \\<noteq> 0\" using assms by simp\n  then have \"a * (1 / a) = a * (1 / a)\" by simp\n  thus ?thesis by (smt (verit) assms divide_cancel_right nonzero_mult_div_cancel_left)\nqed", "description": "-", "full_code": "lemma nonzero_division:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\nproof -\n  have \"1 / a \\<noteq> 0\" using assms by simp\n  then have \"a * (1 / a) = a * (1 / a)\" by simp\n  thus ?thesis by (smt (verit) assms divide_cancel_right nonzero_mult_div_cancel_left)\nqed", "origin": "a_times_vera", "update_count": 0}, "chinese_remainder_theoremV2": {"skill_name": "chinese_remainder_theoremV2", "marker": "lemma chinese_remainder_theorem:\n  fixes a b c d x :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n    and \"x mod a = b\" \"x mod c = d\"\n  shows \"\\<exists>k. x = b + a * k\"\nproof -\n  have \"x = b + (x div a) * a\" using assms(5) by (metis mod_div_mult_eq)\n  thus ?thesis\n    by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma chinese_remainder_theorem:\n  fixes a b c d x :: nat\n  assumes \"a > 0\" \"b > 0\" \"c > 0\" \"d > 0\"\n    and \"x mod a = b\" \"x mod c = d\"\n  shows \"\\<exists>k. x = b + a * k\"\nproof -\n  have \"x = b + (x div a) * a\" using assms(5) by (metis mod_div_mult_eq)\n  thus ?thesis\n    by (auto simp: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "mod_arithmetic": {"skill_name": "mod_arithmetic", "marker": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c > 0\"\n  shows \"(b + c) mod a = ((b mod a) + (c mod a)) mod a\"\nproof -\n  have \"b mod a = b\" using assms(2) by simp\n  have \"c mod a < a\" using assms(3) by (metis assms(1) mod_less_divisor)\n  have \"b + c = (b mod a) + (c mod a) + (b div a + c div a) * a\"\n    by (auto simp: field_simps)\n  then have \"(b + c) mod a = ((b mod a) + (c mod a) + (b div a + c div a) * a) mod a\"\n    by simp\n  also have \"... = ((b mod a) + (c mod a)) mod a\"\n    using assms(1) assms(2) by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c > 0\"\n  shows \"(b + c) mod a = ((b mod a) + (c mod a)) mod a\"\nproof -\n  have \"b mod a = b\" using assms(2) by simp\n  have \"c mod a < a\" using assms(3) by (metis assms(1) mod_less_divisor)\n  have \"b + c = (b mod a) + (c mod a) + (b div a + c div a) * a\"\n    by (auto simp: field_simps)\n  then have \"(b + c) mod a = ((b mod a) + (c mod a) + (b div a + c div a) * a) mod a\"\n    by simp\n  also have \"... = ((b mod a) + (c mod a)) mod a\"\n    using assms(1) assms(2) by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "substitute_congruence": {"skill_name": "substitute_congruence", "marker": "lemma substitute_congruence:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 6 = 3 \\<longleftrightarrow> (2 * k + 5) mod 6 = 3\"\nproof -\n  have \"N mod 6 = (8 * k + 5) mod 6\"\n    using assms by simp\n  also have \"... = (8 * k mod 6 + 5 mod 6) mod 6\"\n    by presburger\n  also have \"... = (2 * k mod 6 + 5 mod 6) mod 6\"\n    by presburger\n  also have \"... = (2 * k + 5) mod 6\"\n    by presburger\n  finally have \"N mod 6 = (2 * k + 5) mod 6\" .\n  show \"N mod 6 = 3 \\<longleftrightarrow> (2 * k + 5) mod 6 = 3\"\n    using `N mod 6 = (2 * k + 5) mod 6` by auto\nqed", "description": "-", "full_code": "lemma substitute_congruence:\n  fixes k :: nat\n  assumes \"N = 8 * k + 5\"\n  shows \"N mod 6 = 3 \\<longleftrightarrow> (2 * k + 5) mod 6 = 3\"\nproof -\n  have \"N mod 6 = (8 * k + 5) mod 6\"\n    using assms by simp\n  also have \"... = (8 * k mod 6 + 5 mod 6) mod 6\"\n    by presburger\n  also have \"... = (2 * k mod 6 + 5 mod 6) mod 6\"\n    by presburger\n  also have \"... = (2 * k + 5) mod 6\"\n    by presburger\n  finally have \"N mod 6 = (2 * k + 5) mod 6\" .\n  show \"N mod 6 = 3 \\<longleftrightarrow> (2 * k + 5) mod 6 = 3\"\n    using `N mod 6 = (2 * k + 5) mod 6` by auto\nqed", "origin": "do_request", "update_count": 0}, "division_and_nonzero_extended": {"skill_name": "division_and_nonzero_extended", "marker": "lemma division_and_nonzero_extended:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a + c / a = (b + c) * (1 / a)\"\nproof -\n  have \"b / a + c / a = (b * (1 / a)) + (c * (1 / a))\" using assms by auto\n  also have \"... = (b + c) * (1 / a)\" by (metis distrib_right)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma division_and_nonzero_extended:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a + c / a = (b + c) * (1 / a)\"\nproof -\n  have \"b / a + c / a = (b * (1 / a)) + (c * (1 / a))\" using assms by auto\n  also have \"... = (b + c) * (1 / a)\" by (metis distrib_right)\n  finally show ?thesis .\nqed", "origin": "division_and_nonzero", "update_count": 0}, "division_with_nonzero_and_additive_property": {"skill_name": "division_with_nonzero_and_additive_property", "marker": "lemma division_with_nonzero_and_additive_property:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b + c) / a = b / a + c / a\"\nproof -\n  have \"(b + c) / a = (b + c) * (1 / a)\" using assms by (simp add: divide_simps)\n  also have \"... = (b * (1 / a)) + (c * (1 / a))\" by (metis distrib_right)\n  also have \"... = b / a + c / a\" by (simp add: divide_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma division_with_nonzero_and_additive_property:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b + c) / a = b / a + c / a\"\nproof -\n  have \"(b + c) / a = (b + c) * (1 / a)\" using assms by (simp add: divide_simps)\n  also have \"... = (b * (1 / a)) + (c * (1 / a))\" by (metis distrib_right)\n  also have \"... = b / a + c / a\" by (simp add: divide_simps)\n  finally show ?thesis .\nqed", "origin": "division_and_nonzero", "update_count": 0}, "division_property_with_nonzero": {"skill_name": "division_property_with_nonzero", "marker": "lemma division_property_with_nonzero:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"c > 0\"\n  shows \"(b / a) * c = b * (c / a)\"\nproof -\n  have \"(b / a) * c = (b * c) / a\" using assms by (simp add: divide_simps)\n  also have \"... = b * (c / a)\" using assms by (simp add: divide_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma division_property_with_nonzero:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\" \"c > 0\"\n  shows \"(b / a) * c = b * (c / a)\"\nproof -\n  have \"(b / a) * c = (b * c) / a\" using assms by (simp add: divide_simps)\n  also have \"... = b * (c / a)\" using assms by (simp add: divide_simps)\n  finally show ?thesis .\nqed", "origin": "division_and_nonzero", "update_count": 0}, "mod_addition_properties": {"skill_name": "mod_addition_properties", "marker": "lemma mod_addition_properties:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a + b = (a div c) * c + (a mod c) + (b div c) * c + (b mod c)\"\n    by auto\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + (a div c + b div c) * c) mod c\" \n    by presburger\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by (simp add: add.commute)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_addition_properties:\n  fixes a b c :: nat\n  assumes \"b > 0\" \"c > 0\"\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a + b = (a div c) * c + (a mod c) + (b div c) * c + (b mod c)\"\n    by auto\n  then have \"(a + b) mod c = ((a mod c) + (b mod c) + (a div c + b div c) * c) mod c\" \n    by presburger\n  also have \"... = ((a mod c) + (b mod c)) mod c\"\n    by (simp add: add.commute)\n  finally show ?thesis by auto\nqed", "origin": "mod_propertiesV3", "update_count": 0}, "generalized_congruence_solution": {"skill_name": "generalized_congruence_solution", "marker": "lemma generalized_congruence_solution:\n  fixes k a b m n :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"\\<exists>p q. k = m * p + a \\<and> k = n * q + b\"\nproof -\n  obtain p where p_def: \"k = m * p + a\" using assms(1) by (metis div_mult_mod_eq mult.commute)\n  obtain q where q_def: \"k = n * q + b\" using assms(2) by (metis div_mult_mod_eq mult.commute)\n  show ?thesis using p_def q_def by blast\nqed", "description": "-", "full_code": "lemma generalized_congruence_solution:\n  fixes k a b m n :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"\\<exists>p q. k = m * p + a \\<and> k = n * q + b\"\nproof -\n  obtain p where p_def: \"k = m * p + a\" using assms(1) by (metis div_mult_mod_eq mult.commute)\n  obtain q where q_def: \"k = n * q + b\" using assms(2) by (metis div_mult_mod_eq mult.commute)\n  show ?thesis using p_def q_def by blast\nqed", "origin": "congruence_manipulationV3", "update_count": 0}, "ratio_property": {"skill_name": "ratio_property", "marker": "lemma ratio_property:\n  fixes a b c :: real\n  assumes \"b \\<noteq> 0\" \"c \\<noteq> 0\"\n  shows \"a / (b * c) = (a / b) * (1 / c)\"\nproof -\n  have \"a / (b * c) = a * (1 / (b * c))\" by simp\n  also have \"... = a * (1 / b) * (1 / c)\" using assms by (simp add: divide_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma ratio_property:\n  fixes a b c :: real\n  assumes \"b \\<noteq> 0\" \"c \\<noteq> 0\"\n  shows \"a / (b * c) = (a / b) * (1 / c)\"\nproof -\n  have \"a / (b * c) = a * (1 / (b * c))\" by simp\n  also have \"... = a * (1 / b) * (1 / c)\" using assms by (simp add: divide_simps)\n  finally show ?thesis by simp\nqed", "origin": "ratio_equivalence_with_c", "update_count": 0}, "product_of_inverses": {"skill_name": "product_of_inverses", "marker": "lemma product_of_inverses:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1 / (a * b) = (1 / a) * (1 / b)\"\nproof -\n  have \"1 / (a * b) = (1 / a) * (1 / b) \\<longleftrightarrow> (1 / (a * b)) * (a * b) = 1\"\n    by (metis assms(1) assms(2) divide_divide_eq_left' divide_eq_eq divide_eq_imp mult.right_neutral nonzero_divide_eq_eq nonzero_mult_divide_mult_cancel_left times_divide_eq_left times_divide_eq_right)\n  also have \"... \\<longleftrightarrow> 1 = (1 / a) * (1 / b) * (a * b)\"\n    by (simp add: assms)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma product_of_inverses:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1 / (a * b) = (1 / a) * (1 / b)\"\nproof -\n  have \"1 / (a * b) = (1 / a) * (1 / b) \\<longleftrightarrow> (1 / (a * b)) * (a * b) = 1\"\n    by (metis assms(1) assms(2) divide_divide_eq_left' divide_eq_eq divide_eq_imp mult.right_neutral nonzero_divide_eq_eq nonzero_mult_divide_mult_cancel_left times_divide_eq_left times_divide_eq_right)\n  also have \"... \\<longleftrightarrow> 1 = (1 / a) * (1 / b) * (a * b)\"\n    by (simp add: assms)\n  finally show ?thesis by simp\nqed", "origin": "a_times_vera", "update_count": 0}, "product_of_nonzero_reals": {"skill_name": "product_of_nonzero_reals", "marker": "lemma product_of_nonzero_reals:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a * b) * (1 / (a * b)) = 1\"\nproof -\n  have \"a * b \\<noteq> 0\" using assms by auto\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma product_of_nonzero_reals:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"(a * b) * (1 / (a * b)) = 1\"\nproof -\n  have \"a * b \\<noteq> 0\" using assms by auto\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "a_times_vera", "update_count": 0}, "non_zero_division": {"skill_name": "non_zero_division", "marker": "lemma non_zero_division:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (b / a) = b\"\nproof -\n  have \"b = a * (b / a)\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_zero_division:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (b / a) = b\"\nproof -\n  have \"b = a * (b / a)\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "a_times_vera", "update_count": 0}, "inequality_bounds_extended": {"skill_name": "inequality_bounds_extended", "marker": "lemma inequality_bounds_extended:\n  fixes x :: nat\n  assumes \"x < a\" \"x < b\" \"x < c\"\n  shows \"x < min (min a b) c\"\nproof -\n  have \"x < a\" using assms(1) by simp\n  have \"x < b\" using assms(2) by simp\n  have \"x < c\" using assms(3) by simp\n  then show \"x < min (min a b) c\" \n    by (metis assms(1) assms(2) min_less_iff_conj)\nqed", "description": "-", "full_code": "lemma inequality_bounds_extended:\n  fixes x :: nat\n  assumes \"x < a\" \"x < b\" \"x < c\"\n  shows \"x < min (min a b) c\"\nproof -\n  have \"x < a\" using assms(1) by simp\n  have \"x < b\" using assms(2) by simp\n  have \"x < c\" using assms(3) by simp\n  then show \"x < min (min a b) c\" \n    by (metis assms(1) assms(2) min_less_iff_conj)\nqed", "origin": "inequality_bounds", "update_count": 0}, "mod_addV3": {"skill_name": "mod_addV3", "marker": "lemma mod_add:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a = (a div m) * m + (a mod m)\" \n    by auto\n  then have \"a = (a div m) * m + b\" \n    using assms by auto\n  hence \"a + c = (a div m) * m + b + c\" \n    by auto\n  then have \"(a + c) mod m = ((a div m) * m + b + c) mod m\" \n    by auto\n  also have \"... = (b + c) mod m\" \n  proof -\n    have \"(a div m) * m mod m = 0\" \n      by auto\n    thus ?thesis \n      by (metis \\<open>a + c = a div m * m + b + c\\<close> calculation mod_add_cong mod_mult_self3)\n  qed\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a = (a div m) * m + (a mod m)\" \n    by auto\n  then have \"a = (a div m) * m + b\" \n    using assms by auto\n  hence \"a + c = (a div m) * m + b + c\" \n    by auto\n  then have \"(a + c) mod m = ((a div m) * m + b + c) mod m\" \n    by auto\n  also have \"... = (b + c) mod m\" \n  proof -\n    have \"(a div m) * m mod m = 0\" \n      by auto\n    thus ?thesis \n      by (metis \\<open>a + c = a div m * m + b + c\\<close> calculation mod_add_cong mod_mult_self3)\n  qed\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_addV4": {"skill_name": "mod_addV4", "marker": "lemma mod_add:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a = (a div m) * m + (a mod m)\"\n    by auto\n  then have \"a = (a div m) * m + b\"\n    using assms by auto\n  then have \"a + c = ((a div m) * m + b) + c\"\n    by auto\n  then have \"(a + c) mod m = (((a div m) * m + b) + c) mod m\"\n    by auto\n  also have \"... = (b + c) mod m\"\n    by (metis \\<open>a + c = a div m * m + b + c\\<close> calculation mod_add_cong mod_mult_self3)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a = (a div m) * m + (a mod m)\"\n    by auto\n  then have \"a = (a div m) * m + b\"\n    using assms by auto\n  then have \"a + c = ((a div m) * m + b) + c\"\n    by auto\n  then have \"(a + c) mod m = (((a div m) * m + b) + c) mod m\"\n    by auto\n  also have \"... = (b + c) mod m\"\n    by (metis \\<open>a + c = a div m * m + b + c\\<close> calculation mod_add_cong mod_mult_self3)\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_addV5": {"skill_name": "mod_addV5", "marker": "lemma mod_add:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a mod m = b\" \n    using assms by auto\n  have \"(a + c) mod m = (b + c + (a div m) * m) mod m\"\n    using `a mod m = b` by fastforce\n  also have \"... = (b + c) mod m\"\n    by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b c m :: nat\n  assumes \"a mod m = b\"\n  shows \"(a + c) mod m = (b + c) mod m\"\nproof -\n  have \"a mod m = b\" \n    using assms by auto\n  have \"(a + c) mod m = (b + c + (a div m) * m) mod m\"\n    using `a mod m = b` by fastforce\n  also have \"... = (b + c) mod m\"\n    by auto\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "multiplication_property_generalized_n_dimensional": {"skill_name": "multiplication_property_generalized_n_dimensional", "marker": "lemma multiplication_property_generalized_n_dimensional:\n  fixes a b c:: \"real list\" \n  assumes \"length a = n\" \"length b = n\" \"length c = n\" \"(\\<forall>i. a ! i \\<noteq> 0) \\<and> (\\<forall>i. b ! i \\<noteq> 0) \\<and> (\\<forall>i. c ! i \\<noteq> 0)\" \n  shows \"map (\\<lambda>i. a ! i * (b ! i / (c ! i))) (if n > 0 then [0..<n] else []) = map (\\<lambda>i. (a ! i * b ! i) / (c ! i)) (if n > 0 then [0..<n] else [])\"\nproof -\n  have \"map (\\<lambda>i. a ! i * (b ! i / (c ! i))) (if n > 0 then [0..<n] else []) = \n        map (\\<lambda>i. a ! i * (b ! i * (1 / (c ! i)))) (if n > 0 then [0..<n] else [])\" by (simp add: divide_simps)\n  moreover have \"... = map (\\<lambda>i. (a ! i * b ! i) * (1 / (c ! i))) (if n > 0 then [0..<n] else [])\" \n    by (simp add: algebra_simps)\n  ultimately show ?thesis by (simp add: divide_simps)\nqed", "description": "-", "full_code": "lemma multiplication_property_generalized:\n  fixes a b c:: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"c \\<noteq> 0\"\n  shows \"a * (b / c) = (a * b) / c\"\nproof -\n  have \"a * (b / c) = a * (b * (1 / c))\" by (simp add: divide_simps)\n  also have \"... = (a * b) * (1 / c)\" by (simp add: algebra_simps)\n  finally show ?thesis by (simp add: divide_simps)\nqed\n\nlemma multiplication_property_generalized_n_dimensional:\n  fixes a b c:: \"real list\" \n  assumes \"length a = n\" \"length b = n\" \"length c = n\" \"(\\<forall>i. a ! i \\<noteq> 0) \\<and> (\\<forall>i. b ! i \\<noteq> 0) \\<and> (\\<forall>i. c ! i \\<noteq> 0)\" \n  shows \"map (\\<lambda>i. a ! i * (b ! i / (c ! i))) (if n > 0 then [0..<n] else []) = map (\\<lambda>i. (a ! i * b ! i) / (c ! i)) (if n > 0 then [0..<n] else [])\"\nproof -\n  have \"map (\\<lambda>i. a ! i * (b ! i / (c ! i))) (if n > 0 then [0..<n] else []) = \n        map (\\<lambda>i. a ! i * (b ! i * (1 / (c ! i)))) (if n > 0 then [0..<n] else [])\" by (simp add: divide_simps)\n  moreover have \"... = map (\\<lambda>i. (a ! i * b ! i) * (1 / (c ! i))) (if n > 0 then [0..<n] else [])\" \n    by (simp add: algebra_simps)\n  ultimately show ?thesis by (simp add: divide_simps)\nqed", "origin": "multiplication_property_generalized", "update_count": 0}, "congruence_manipulationV4": {"skill_name": "congruence_manipulationV4", "marker": "lemma congruence_manipulation:\n  fixes a b m n :: nat\n  assumes \"a mod m = b\" \"n > 0\"\n  shows \"(a + n) mod m = (b + n) mod m\"\nproof -\n  have \"(a + n) mod m = (a mod m + n) mod m\" by presburger\n  also have \"... = (b + n) mod m\" using assms(1) by (metis mod_add_left_eq)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma congruence_manipulation:\n  fixes a b m n :: nat\n  assumes \"a mod m = b\" \"n > 0\"\n  shows \"(a + n) mod m = (b + n) mod m\"\nproof -\n  have \"(a + n) mod m = (a mod m + n) mod m\" by presburger\n  also have \"... = (b + n) mod m\" using assms(1) by (metis mod_add_left_eq)\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "lcm_property": {"skill_name": "lcm_property", "marker": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\"\n    using assms by auto\n  then have \"lcm a b * gcd a b = a * b\"\n    by auto\n  then have \"lcm a b = (a * b) div gcd a b\"\n    using `gcd a b > 0` by (metis lcm_nat_def)\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\"\n    using assms by auto\n  then have \"lcm a b * gcd a b = a * b\"\n    by auto\n  then have \"lcm a b = (a * b) div gcd a b\"\n    using `gcd a b > 0` by (metis lcm_nat_def)\n  thus ?thesis .\nqed", "origin": "do_request", "update_count": 0}, "lcm_propertyV2": {"skill_name": "lcm_propertyV2", "marker": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  hence gcd_non_zero: \"gcd a b > 0\" by simp\n  have \"lcm a b * gcd a b = a * b\"\n    by auto\n  then have \"lcm a b = (a * b) div gcd a b\"\n    using gcd_non_zero by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"lcm a b = (a * b) div gcd a b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  hence gcd_non_zero: \"gcd a b > 0\" by simp\n  have \"lcm a b * gcd a b = a * b\"\n    by auto\n  then have \"lcm a b = (a * b) div gcd a b\"\n    using gcd_non_zero by (metis lcm_nat_def)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sum_of_possible_nV2": {"skill_name": "sum_of_possible_nV2", "marker": "lemma sum_of_possible_N:\n  fixes A B :: nat\n  shows \"A + B = A + B\"\nproof -\n  have \"A + B = A + B\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_possible_N:\n  fixes A B :: nat\n  shows \"A + B = A + B\"\nproof -\n  have \"A + B = A + B\" by simp\n  thus ?thesis by simp\nqed", "origin": "sum_of_possible_n", "update_count": 0}, "sum_of_possible_nV3": {"skill_name": "sum_of_possible_nV3", "marker": "lemma sum_of_possible_N:\n  assumes \"finite A\" \n  shows \"(\\<Sum>i\\<in>A. (21 + 45)) = card A * (21 + 45)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. (21 + 45)) = card A * (21 + 45)\" \n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_possible_N:\n  assumes \"finite A\" \n  shows \"(\\<Sum>i\\<in>A. (21 + 45)) = card A * (21 + 45)\"\nproof -\n  have \"(\\<Sum>i\\<in>A. (21 + 45)) = card A * (21 + 45)\" \n    by auto\n  thus ?thesis by simp\nqed", "origin": "sum_of_possible_n", "update_count": 0}, "multiplicative_inverse_property_generalized": {"skill_name": "multiplicative_inverse_property_generalized", "marker": "lemma multiplicative_inverse_property_generalized:\n  fixes a :: real and b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1 \\<and> b * (1 / b) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: divide_simps)\n  moreover have \"b * (1 / b) = 1\" using assms(2) by (simp add: divide_simps)\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma multiplicative_inverse_property_generalized:\n  fixes a :: real and b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) = 1 \\<and> b * (1 / b) = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: divide_simps)\n  moreover have \"b * (1 / b) = 1\" using assms(2) by (simp add: divide_simps)\n  ultimately show ?thesis by simp\nqed", "origin": "multiplicative_inverse_property", "update_count": 0}, "multiplicative_inverse_property_general": {"skill_name": "multiplicative_inverse_property_general", "marker": "lemma multiplicative_inverse_property_general:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1 \\<and> (1 / a) * a = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: divide_simps)\n  moreover have \"(1 / a) * a = 1\" using assms by (simp add: divide_simps)\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma multiplicative_inverse_property_general:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1 \\<and> (1 / a) * a = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: divide_simps)\n  moreover have \"(1 / a) * a = 1\" using assms by (simp add: divide_simps)\n  ultimately show ?thesis by auto\nqed", "origin": "multiplicative_inverse_property", "update_count": 0}, "simplify_congruence": {"skill_name": "simplify_congruence", "marker": "lemma simplify_congruence:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c < a\"\n  shows \"(b + c) mod a = (b mod a + c mod a) mod a\"\nproof -\n  have \"b mod a = b\" using assms(2) by simp\n  have \"c mod a = c\" using assms(3) by simp\n  have \"b + c = (b mod a) + (c mod a)\" \n    using assms(1) assms(2) assms(3) by auto\n  then have \"(b + c) mod a = ((b mod a) + (c mod a)) mod a\"\n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma simplify_congruence:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c < a\"\n  shows \"(b + c) mod a = (b mod a + c mod a) mod a\"\nproof -\n  have \"b mod a = b\" using assms(2) by simp\n  have \"c mod a = c\" using assms(3) by simp\n  have \"b + c = (b mod a) + (c mod a)\" \n    using assms(1) assms(2) assms(3) by auto\n  then have \"(b + c) mod a = ((b mod a) + (c mod a)) mod a\"\n    by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "nat_inequality": {"skill_name": "nat_inequality", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 \\<le> b\"\nproof -\n  have \"b > a\" using assms by simp\n  then show \"a + 1 \\<le> b\" \n  proof (cases b)\n    case 0\n    then have \"a < 0\" using assms(1) by simp\n    thus \"a + 1 \\<le> b\" by simp\n  next\n    case (Suc n)\n    then have \"b = Suc n\" and \"a \\<le> n\" using assms by auto\n    thus \"a + 1 \\<le> b\" by auto\n  qed\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 \\<le> b\"\nproof -\n  have \"b > a\" using assms by simp\n  then show \"a + 1 \\<le> b\" \n  proof (cases b)\n    case 0\n    then have \"a < 0\" using assms(1) by simp\n    thus \"a + 1 \\<le> b\" by simp\n  next\n    case (Suc n)\n    then have \"b = Suc n\" and \"a \\<le> n\" using assms by auto\n    thus \"a + 1 \\<le> b\" by auto\n  qed\nqed", "origin": "do_request", "update_count": 0}, "nat_inequalityV2": {"skill_name": "nat_inequalityV2", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 \\<le> b\"\nproof -\n  from assms have \"b > a\" by simp\n  then show \"a + 1 \\<le> b\" \n  proof (cases \"b = a + 1\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b > a + 1\" using `b > a` by auto\n    then show ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 \\<le> b\"\nproof -\n  from assms have \"b > a\" by simp\n  then show \"a + 1 \\<le> b\" \n  proof (cases \"b = a + 1\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"b > a + 1\" using `b > a` by auto\n    then show ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "nat_inequalityV3": {"skill_name": "nat_inequalityV3", "marker": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 \\<le> b\"\nproof -\n  have \"b = a + 1 + (b - (a + 1))\" by (metis add.commute add_diff_inverse_nat assms less_diff_conv2 less_le_not_le less_one linorder_le_less_linear nle_le verit_comp_simplify1(1) zero_less_diff zero_less_iff_neq_zero)\n  also have \"... \\<ge> a + 1\" by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma nat_inequality:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"a + 1 \\<le> b\"\nproof -\n  have \"b = a + 1 + (b - (a + 1))\" by (metis add.commute add_diff_inverse_nat assms less_diff_conv2 less_le_not_le less_one linorder_le_less_linear nle_le verit_comp_simplify1(1) zero_less_diff zero_less_iff_neq_zero)\n  also have \"... \\<ge> a + 1\" by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_properties_generalized": {"skill_name": "mod_properties_generalized", "marker": "lemma mod_properties_generalized:\n  fixes a b c d :: nat\n  assumes \"a mod d = b\" \"c mod d = 0\"\n  shows \"(a + c) mod d = b\"\nproof -\n  have \"c mod d = 0\" using assms(2) by simp\n  then have \"(a + c) mod d = (b + 0) mod d\" using assms(1) by auto\n  then show ?thesis by (metis add_0_iff assms(1) assms(2) mod_0 mod_add_cong)\nqed", "description": "-", "full_code": "lemma mod_properties_generalized:\n  fixes a b c d :: nat\n  assumes \"a mod d = b\" \"c mod d = 0\"\n  shows \"(a + c) mod d = b\"\nproof -\n  have \"c mod d = 0\" using assms(2) by simp\n  then have \"(a + c) mod d = (b + 0) mod d\" using assms(1) by auto\n  then show ?thesis by (metis add_0_iff assms(1) assms(2) mod_0 mod_add_cong)\nqed", "origin": "mod_add_generalized", "update_count": 0}, "gcd_lcm_property": {"skill_name": "gcd_lcm_property", "marker": "lemma gcd_lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"gcd a b * lcm a b = a * b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  then have \"gcd a b * (a * b) div gcd a b = a * b\" by (simp add: mult.commute)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma gcd_lcm_property:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"gcd a b * lcm a b = a * b\"\nproof -\n  have \"gcd a b > 0\" using assms by auto\n  then have \"gcd a b * (a * b) div gcd a b = a * b\" by (simp add: mult.commute)\n  then show ?thesis by auto\nqed", "origin": "lcm_propertyV2", "update_count": 0}, "mod_add_power_general": {"skill_name": "mod_add_power_general", "marker": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b) mod n) = ((x mod n) + (b mod n)) mod n\"\n    by presburger\n  also have \"... = (a + b) mod n\" using assms(4) by presburger\n  then show ?thesis using power_mod by (smt (verit) calculation)\nqed", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b) mod n) = ((x mod n) + (b mod n)) mod n\"\n    by presburger\n  also have \"... = (a + b) mod n\" using assms(4) by presburger\n  then show ?thesis using power_mod by (smt (verit) calculation)\nqed", "origin": "mod_add_power", "update_count": 0}, "add_div_cancel": {"skill_name": "add_div_cancel", "marker": "lemma add_div_cancel:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\" \"a + b / c = d\"\n  shows \"a * c + b = d * c\"\nproof -\n  have \"c * (a + b / c) = d * c\" using assms(3) by auto\n  then have \"c * a + c * (b / c) = d * c\" by (simp add: distrib_left)\n  then show ?thesis using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma add_div_cancel:\n  fixes a b c d :: real\n  assumes \"c > 0\" \"d > 0\" \"a + b / c = d\"\n  shows \"a * c + b = d * c\"\nproof -\n  have \"c * (a + b / c) = d * c\" using assms(3) by auto\n  then have \"c * a + c * (b / c) = d * c\" by (simp add: distrib_left)\n  then show ?thesis using assms(1) by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "division_property_extendedV2": {"skill_name": "division_property_extendedV2", "marker": "lemma division_property_extended:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b * c / a = (b / a) * c\"\n  using division_identity_generalized[of a b c] assms by simp", "description": "-", "full_code": "lemma division_property_generalized:\n  fixes a b c :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b / a * c = (b * c) / a\"\nproof -\n  have \"b / a * c = (b * (1 / a)) * c\" using assms by (simp add: divide_simps)\n  also have \"... = (b * c) * (1 / a)\" by (simp add: algebra_simps)\n  finally show ?thesis using assms by (simp add: divide_simps)\nqed\n\nlemma division_identity_generalized:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"(b * c) / a = (b / a) * c\"\n  using division_property_generalized[of a b c] assms by simp\n\nlemma division_property_extended:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"b * c / a = (b / a) * c\"\n  using division_identity_generalized[of a b c] assms by simp", "origin": "division_identity_extended", "update_count": 0}, "mod_vector_properties": {"skill_name": "mod_vector_properties", "marker": "lemma mod_vector_properties:\n  fixes a b c d :: \"nat list\" and m :: nat\n  assumes \"length a = length b\" and \"length a = length c\" \n          and \"\\<forall>i. a ! i mod m = b ! i\" \n          and \"\\<forall>i. c ! i mod m = 0\"\n  shows \"(\\<forall>i. (a ! i + c ! i) mod m = b ! i)\"\nproof -\n  have \"\\<forall>i. a ! i = b ! i + (a ! i div m) * m\" \n    using assms(3) by (metis ab_semigroup_add_class.add_ac(1) add.commute add_right_imp_eq mult.commute mult_div_mod_eq)\n  have \"\\<forall>i. c ! i = (c ! i div m) * m\" \n    using assms(4) by (metis add_cancel_right_left add_left_imp_eq mod_mult_div_eq mult.commute)\n  have \"\\<forall>i. (a ! i + c ! i) = (b ! i + (a ! i div m) * m) + ((c ! i div m) * m)\"\n    using assms(1) by (metis \\<open>\\<forall>i. a ! i = b ! i + a ! i div m * m\\<close> \\<open>\\<forall>i. c ! i = c ! i div m * m\\<close>)\n  then have \"\\<forall>i. (a ! i + c ! i) = b ! i + ((a ! i div m) + (c ! i div m)) * m\"\n    by (auto simp: field_simps)\n  then show ?thesis \n    by (metis add_cancel_left_right assms(3) assms(4) mod_0 mod_add_cong)\nqed", "description": "-", "full_code": "lemma mod_vector_properties:\n  fixes a b c d :: \"nat list\" and m :: nat\n  assumes \"length a = length b\" and \"length a = length c\" \n          and \"\\<forall>i. a ! i mod m = b ! i\" \n          and \"\\<forall>i. c ! i mod m = 0\"\n  shows \"(\\<forall>i. (a ! i + c ! i) mod m = b ! i)\"\nproof -\n  have \"\\<forall>i. a ! i = b ! i + (a ! i div m) * m\" \n    using assms(3) by (metis ab_semigroup_add_class.add_ac(1) add.commute add_right_imp_eq mult.commute mult_div_mod_eq)\n  have \"\\<forall>i. c ! i = (c ! i div m) * m\" \n    using assms(4) by (metis add_cancel_right_left add_left_imp_eq mod_mult_div_eq mult.commute)\n  have \"\\<forall>i. (a ! i + c ! i) = (b ! i + (a ! i div m) * m) + ((c ! i div m) * m)\"\n    using assms(1) by (metis \\<open>\\<forall>i. a ! i = b ! i + a ! i div m * m\\<close> \\<open>\\<forall>i. c ! i = c ! i div m * m\\<close>)\n  then have \"\\<forall>i. (a ! i + c ! i) = b ! i + ((a ! i div m) + (c ! i div m)) * m\"\n    by (auto simp: field_simps)\n  then show ?thesis \n    by (metis add_cancel_left_right assms(3) assms(4) mod_0 mod_add_cong)\nqed", "origin": "mod_propertiesV4", "update_count": 0}, "mod_properties_multidim": {"skill_name": "mod_properties_multidim", "marker": "lemma mod_properties_multidim:\n  fixes a b c d :: \"nat list\"\n  assumes \"length a = n\" \"length b = n\" \"length c = n\" \"length d = n\"\n    and \"\\<forall>i. a ! i mod (d ! i) = b ! i\" \"\\<forall>i. c ! i mod (d ! i) = 0\"\n  shows \"(\\<forall>i. (a ! i + c ! i) mod (d ! i) = b ! i)\"\nproof -\n  have \"\\<forall>i. a ! i = b ! i + (a ! i div (d ! i)) * (d ! i)\" using assms(5) by (metis add.assoc add.commute add_right_imp_eq mult.commute mult_div_mod_eq)\n  have \"\\<forall>i. c ! i = (c ! i div (d ! i)) * (d ! i)\" using assms(6) by (metis add_cancel_left_right add_right_imp_eq mult.commute mult_div_mod_eq)\n  then have \"\\<forall>i. a ! i + c ! i = (b ! i + (a ! i div (d ! i)) * (d ! i)) + ((c ! i div (d ! i)) * (d ! i))\" \n    by (metis \\<open>\\<forall>i. a ! i = b ! i + a ! i div d ! i * d ! i\\<close>)\n  then have \"\\<forall>i. a ! i + c ! i = b ! i + ((a ! i div (d ! i)) + (c ! i div (d ! i))) * (d ! i)\" \n    by (auto simp: field_simps)\n  thus ?thesis by (metis add_0_iff assms(5) assms(6) bits_mod_0 mod_add_cong)\nqed", "description": "-", "full_code": "lemma mod_properties_multidim:\n  fixes a b c d :: \"nat list\"\n  assumes \"length a = n\" \"length b = n\" \"length c = n\" \"length d = n\"\n    and \"\\<forall>i. a ! i mod (d ! i) = b ! i\" \"\\<forall>i. c ! i mod (d ! i) = 0\"\n  shows \"(\\<forall>i. (a ! i + c ! i) mod (d ! i) = b ! i)\"\nproof -\n  have \"\\<forall>i. a ! i = b ! i + (a ! i div (d ! i)) * (d ! i)\" using assms(5) by (metis add.assoc add.commute add_right_imp_eq mult.commute mult_div_mod_eq)\n  have \"\\<forall>i. c ! i = (c ! i div (d ! i)) * (d ! i)\" using assms(6) by (metis add_cancel_left_right add_right_imp_eq mult.commute mult_div_mod_eq)\n  then have \"\\<forall>i. a ! i + c ! i = (b ! i + (a ! i div (d ! i)) * (d ! i)) + ((c ! i div (d ! i)) * (d ! i))\" \n    by (metis \\<open>\\<forall>i. a ! i = b ! i + a ! i div d ! i * d ! i\\<close>)\n  then have \"\\<forall>i. a ! i + c ! i = b ! i + ((a ! i div (d ! i)) + (c ! i div (d ! i))) * (d ! i)\" \n    by (auto simp: field_simps)\n  thus ?thesis by (metis add_0_iff assms(5) assms(6) bits_mod_0 mod_add_cong)\nqed", "origin": "mod_propertiesV4", "update_count": 0}, "mod_properties_extended_multi": {"skill_name": "mod_properties_extended_multi", "marker": "lemma mod_properties_extended_multi:\n  fixes a b c d :: nat\n  assumes \"a mod d = b\" \"c mod d = 0\" \"e mod d = f\"\n  shows \"((a + c) + e) mod d = (b + f) mod d\"\nproof -\n  have \"((a + c) + e) mod d = ((b + ((a div d) + (c div d)) * d) + e) mod d\" \n    using mod_properties_extended[OF assms(1) assms(2)] by (smt (verit) assms(1) assms(2) mod_add_cong mod_add_left_eq mod_mult_self1 mod_properties_extended)\n  also have \"... = (b + f + ((a div d) + (c div d)) * d) mod d\" \n    using assms(3) by (metis add.commute group_cancel.add1 mod_add_cong mod_mod_trivial mod_mult_self1 mod_mult_self2 mult.commute)\n  also have \"... = (b + f) mod d\" by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_properties_extended:\n  fixes a b c d :: nat\n  assumes \"a mod d = b\" \"c mod d = 0\"\n  shows \"(a + c) mod d = b\"\nproof -\n  have \"a = b + (a div d) * d\" using assms(1) by auto\n  have \"c = (c div d) * d\" using assms(2) by auto\n  then have \"a + c = (b + (a div d) * d) + ((c div d) * d)\" \n    by (metis \\<open>a = b + a div d * d\\<close>)\n  also have \"... = b + ((a div d) + (c div d)) * d\" by (auto simp: field_simps)\n  finally have \"a + c = b + ((a div d) + (c div d)) * d\" .\n  then have \"(a + c) mod d = (b + ((a div d) + (c div d)) * d) mod d\" by (simp)\n  also have \"... = b mod d\" by auto\n  finally show ?thesis using assms(1) by auto\nqed\n\nlemma mod_properties_extended_multi:\n  fixes a b c d :: nat\n  assumes \"a mod d = b\" \"c mod d = 0\" \"e mod d = f\"\n  shows \"((a + c) + e) mod d = (b + f) mod d\"\nproof -\n  have \"((a + c) + e) mod d = ((b + ((a div d) + (c div d)) * d) + e) mod d\" \n    using mod_properties_extended[OF assms(1) assms(2)] by (smt (verit) assms(1) assms(2) mod_add_cong mod_add_left_eq mod_mult_self1 mod_properties_extended)\n  also have \"... = (b + f + ((a div d) + (c div d)) * d) mod d\" \n    using assms(3) by (metis add.commute group_cancel.add1 mod_add_cong mod_mod_trivial mod_mult_self1 mod_mult_self2 mult.commute)\n  also have \"... = (b + f) mod d\" by auto\n  finally show ?thesis by simp\nqed", "origin": "mod_propertiesV4", "update_count": 0}, "mod_arithmeticV2": {"skill_name": "mod_arithmeticV2", "marker": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c > 0\"\n  shows \"(b + c) mod a = ((b mod a) + (c mod a)) mod a\"\nproof -\n  let ?b_mod_a = \"b mod a\"\n  let ?c_mod_a = \"c mod a\"\n  have \"b = ?b_mod_a + (b div a) * a\" \n    by auto\n  then have \"b + c = (?b_mod_a + (b div a) * a) + c\"\n    by simp\n  have \"c = ?c_mod_a + (c div a) * a\"\n    by auto\n  then have \"b + c = (?b_mod_a + (b div a) * a) + (?c_mod_a + (c div a) * a)\"\n    by simp\n  then have \"b + c = (?b_mod_a + ?c_mod_a) + ((b div a) + (c div a)) * a\"\n    by (auto simp: field_simps)\n  hence \"(b + c) mod a = ((?b_mod_a + ?c_mod_a) + ((b div a) + (c div a)) * a) mod a\"\n    by simp\n  also have \"... = ((?b_mod_a + ?c_mod_a) mod a)\"\n    by (simp add: mod_add_eq)\n  finally show ?thesis by (simp add: add.commute)\nqed", "description": "-", "full_code": "lemma mod_arithmetic:\n  fixes a b c :: nat\n  assumes \"a > 0\" \"b < a\" \"c > 0\"\n  shows \"(b + c) mod a = ((b mod a) + (c mod a)) mod a\"\nproof -\n  let ?b_mod_a = \"b mod a\"\n  let ?c_mod_a = \"c mod a\"\n  have \"b = ?b_mod_a + (b div a) * a\" \n    by auto\n  then have \"b + c = (?b_mod_a + (b div a) * a) + c\"\n    by simp\n  have \"c = ?c_mod_a + (c div a) * a\"\n    by auto\n  then have \"b + c = (?b_mod_a + (b div a) * a) + (?c_mod_a + (c div a) * a)\"\n    by simp\n  then have \"b + c = (?b_mod_a + ?c_mod_a) + ((b div a) + (c div a)) * a\"\n    by (auto simp: field_simps)\n  hence \"(b + c) mod a = ((?b_mod_a + ?c_mod_a) + ((b div a) + (c div a)) * a) mod a\"\n    by simp\n  also have \"... = ((?b_mod_a + ?c_mod_a) mod a)\"\n    by (simp add: mod_add_eq)\n  finally show ?thesis by (simp add: add.commute)\nqed", "origin": "do_request", "update_count": 0}, "general_reciprocal_sum": {"skill_name": "general_reciprocal_sum", "marker": "lemma general_reciprocal_sum:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"x * (1 / x) + y * (1 / y) = 2\"\n  using reciprocal_sum_property[of x y] assms by simp", "description": "-", "full_code": "lemma reciprocal_sum_property:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * (1 / a) + b * (1 / b) = 2\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by simp\n  hence \"b * (1 / b) = 1\" using assms(2) by simp\n  thus ?thesis by (metis \\<open>a * (1 / a) = 1\\<close> one_add_one)\nqed\n\nlemma general_reciprocal_sum:\n  fixes x y :: real\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"x * (1 / x) + y * (1 / y) = 2\"\n  using reciprocal_sum_property[of x y] assms by simp", "origin": "non_zero_sum_property", "update_count": 0}, "mod_addition": {"skill_name": "mod_addition", "marker": "lemma mod_addition:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"(a + b) mod m = (b + b) mod m\"\nproof -\n  have \"a = b + (a div m) * m\" using assms(1) by auto\n  then have \"a + b = (b + (a div m) * m) + b\" by simp\n  also have \"... = (b + b) + (a div m) * m\" by (simp add: algebra_simps)\n  finally have \"a + b = (b + b) + (a div m) * m\" .\n  then have \"(a + b) mod m = ((b + b) + (a div m) * m) mod m\" by presburger\n  also have \"... = (b + b) mod m\" by auto\n  finally show ?thesis using assms(1) by auto\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < m\"\n  shows \"(a + b) mod m = (b + b) mod m\"\nproof -\n  have \"a = b + (a div m) * m\" using assms(1) by auto\n  then have \"a + b = (b + (a div m) * m) + b\" by simp\n  also have \"... = (b + b) + (a div m) * m\" by (simp add: algebra_simps)\n  finally have \"a + b = (b + b) + (a div m) * m\" .\n  then have \"(a + b) mod m = ((b + b) + (a div m) * m) mod m\" by presburger\n  also have \"... = (b + b) mod m\" by auto\n  finally show ?thesis using assms(1) by auto\nqed", "origin": "mod_propertiesV4", "update_count": 0}, "mod_subtract": {"skill_name": "mod_subtract", "marker": "lemma mod_subtract:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < a\" \n  shows \"(a - b) mod m = 0\"\nproof -\n  have \"a = b + (a div m) * m\" using assms(1) by auto\n  then have \"a - b = (a div m) * m\" by (simp add: assms(2))\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_subtract:\n  fixes a b m :: nat\n  assumes \"a mod m = b\" \"b < a\" \n  shows \"(a - b) mod m = 0\"\nproof -\n  have \"a = b + (a div m) * m\" using assms(1) by auto\n  then have \"a - b = (a div m) * m\" by (simp add: assms(2))\n  then show ?thesis by auto\nqed", "origin": "mod_propertiesV4", "update_count": 0}, "mod_addV6": {"skill_name": "mod_addV6", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"a = (a div m) * m + (a mod m)\" by auto\n  have \"b = (b div m) * m + (b mod m)\" by auto\n  then have \"a + b = ((a div m) + (b div m)) * m + ((a mod m) + (b mod m))\" by (auto simp: field_simps)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"a = (a div m) * m + (a mod m)\" by auto\n  have \"b = (b div m) * m + (b mod m)\" by auto\n  then have \"a + b = ((a div m) + (b div m)) * m + ((a mod m) + (b mod m))\" by (auto simp: field_simps)\n  then show ?thesis by auto\nqed", "origin": "mod_propertiesV4", "update_count": 0}, "mod_additionV2": {"skill_name": "mod_additionV2", "marker": "lemma mod_addition:\n  fixes a b m :: nat\n  assumes \"a mod m = x\" \"b mod m = y\"\n  shows \"(a + b) mod m = (x + y) mod m\"\nproof -\n  let ?q1 = \"a div m\"\n  let ?q2 = \"b div m\"\n  have \"a = x + ?q1 * m\" using assms(1) by auto\n  have \"b = y + ?q2 * m\" using assms(2) by auto\n  then have \"a + b = (x + ?q1 * m) + (y + ?q2 * m)\"\n    by (metis \\<open>a = x + a div m * m\\<close>)\n  also have \"... = (x + y) + (?q1 + ?q2) * m\" by (simp add: distrib_right)\n  finally have \"a + b = (x + y) + (?q1 + ?q2) * m\" .\n  then show ?thesis\n    by (simp)\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes a b m :: nat\n  assumes \"a mod m = x\" \"b mod m = y\"\n  shows \"(a + b) mod m = (x + y) mod m\"\nproof -\n  let ?q1 = \"a div m\"\n  let ?q2 = \"b div m\"\n  have \"a = x + ?q1 * m\" using assms(1) by auto\n  have \"b = y + ?q2 * m\" using assms(2) by auto\n  then have \"a + b = (x + ?q1 * m) + (y + ?q2 * m)\"\n    by (metis \\<open>a = x + a div m * m\\<close>)\n  also have \"... = (x + y) + (?q1 + ?q2) * m\" by (simp add: distrib_right)\n  finally have \"a + b = (x + y) + (?q1 + ?q2) * m\" .\n  then show ?thesis\n    by (simp)\nqed", "origin": "mod_propertiesV4", "update_count": 0}, "scalar_multiplication_inverse_for_positive_numbers_general": {"skill_name": "scalar_multiplication_inverse_for_positive_numbers_general", "marker": "lemma scalar_multiplication_inverse_for_positive_numbers_general:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(1 / a) * a * b = b\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: field_simps)\n  thus ?thesis by (simp add: mult.assoc)\nqed", "description": "-", "full_code": "lemma scalar_multiplication_inverse_for_positive_numbers_general:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(1 / a) * a * b = b\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: field_simps)\n  thus ?thesis by (simp add: mult.assoc)\nqed", "origin": "scalar_multiplication_inverse_for_positive_numbers", "update_count": 0}, "scalar_multiplication_inverse_for_positive_and_negative_numbers": {"skill_name": "scalar_multiplication_inverse_for_positive_and_negative_numbers", "marker": "lemma scalar_multiplication_inverse_for_positive_and_negative_numbers:\n  fixes a b :: real\n  assumes \"a > 0\" \"b < 0\"\n  shows \"(1 / a) * a = 1\" and \"(1 / b) * b = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: field_simps)\n  hence scalar_pos: \"(1 / a) * a = 1\" by (simp add: mult.commute)\n  have \"b * (1 / b) = 1\" using assms(2) by (simp add: field_simps)\n  hence scalar_neg: \"(1 / b) * b = 1\" by (simp add: mult.commute)\n  show \"(1 / a) * a = 1\" and \"(1 / b) * b = 1\"\n    using scalar_pos scalar_neg by auto\nqed", "description": "-", "full_code": "lemma scalar_multiplication_inverse_for_positive_and_negative_numbers:\n  fixes a b :: real\n  assumes \"a > 0\" \"b < 0\"\n  shows \"(1 / a) * a = 1\" and \"(1 / b) * b = 1\"\nproof -\n  have \"a * (1 / a) = 1\" using assms(1) by (simp add: field_simps)\n  hence scalar_pos: \"(1 / a) * a = 1\" by (simp add: mult.commute)\n  have \"b * (1 / b) = 1\" using assms(2) by (simp add: field_simps)\n  hence scalar_neg: \"(1 / b) * b = 1\" by (simp add: mult.commute)\n  show \"(1 / a) * a = 1\" and \"(1 / b) * b = 1\"\n    using scalar_pos scalar_neg by auto\nqed", "origin": "scalar_multiplication_inverse_for_positive_numbers", "update_count": 0}, "scalar_multiplication_inverse_for_positive_reals": {"skill_name": "scalar_multiplication_inverse_for_positive_reals", "marker": "lemma scalar_multiplication_inverse_for_positive_reals:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(1 / a) * (a * b) = b\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: field_simps)\n  then have \"b = (1 / a) * (a * b)\" by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma scalar_multiplication_inverse_for_positive_reals:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(1 / a) * (a * b) = b\"\nproof -\n  have \"a * (1 / a) = 1\" using assms by (simp add: field_simps)\n  then have \"b = (1 / a) * (a * b)\" by auto\n  thus ?thesis by simp\nqed", "origin": "scalar_multiplication_inverse_for_positive_numbers", "update_count": 0}, "scalar_multiplication_inverse_for_positive_nat": {"skill_name": "scalar_multiplication_inverse_for_positive_nat", "marker": "lemma scalar_multiplication_inverse_for_positive_nat:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(1 / (real a)) * (real a * real b) = real b\"\nproof -\n  have \"real a * (1 / real a) = 1\" using assms by (simp add: field_simps)\n  then have \"real b = (1 / real a) * (real a * real b)\" by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma scalar_multiplication_inverse_for_positive_nat:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"(1 / (real a)) * (real a * real b) = real b\"\nproof -\n  have \"real a * (1 / real a) = 1\" using assms by (simp add: field_simps)\n  then have \"real b = (1 / real a) * (real a * real b)\" by auto\n  thus ?thesis by simp\nqed", "origin": "scalar_multiplication_inverse_for_positive_numbers", "update_count": 0}, "congruence_reformulation": {"skill_name": "congruence_reformulation", "marker": "lemma congruence_reformulation:\n  fixes k m n a b :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"k = m * (k div m) + a\"\nproof -\n  have \"k = m * (k div m) + (k mod m)\" by auto\n  thus ?thesis using assms(1) by auto\nqed", "description": "-", "full_code": "lemma congruence_reformulation:\n  fixes k m n a b :: nat\n  assumes \"k mod m = a\" \"k mod n = b\"\n  shows \"k = m * (k div m) + a\"\nproof -\n  have \"k = m * (k div m) + (k mod m)\" by auto\n  thus ?thesis using assms(1) by auto\nqed", "origin": "congruence_manipulationV2", "update_count": 0}, "congruence_manipulation_multi": {"skill_name": "congruence_manipulation_multi", "marker": "lemma congruence_manipulation_multi:\n  fixes a b m n :: nat\n  assumes \"a mod m = b\" \"n > 0\" \"k > 0\"\n  shows \"(a + n*k) mod m = (b + n*k) mod m\"\nproof -\n  have \"(a + n*k) mod m = (a mod m + n*k) mod m\" by presburger\n  also have \"... = (b + n*k) mod m\" using assms(1) by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma congruence_manipulation:\n  fixes a b m n :: nat\n  assumes \"a mod m = b\" \"n > 0\"\n  shows \"(a + n) mod m = (b + n) mod m\"\nproof -\n  have \"(a + n) mod m = (a mod m + n) mod m\" by presburger\n  also have \"... = (b + n) mod m\" using assms(1) by (metis mod_add_left_eq)\n  finally show ?thesis by auto\nqed\n\nlemma congruence_manipulation_multi:\n  fixes a b m n :: nat\n  assumes \"a mod m = b\" \"n > 0\" \"k > 0\"\n  shows \"(a + n*k) mod m = (b + n*k) mod m\"\nproof -\n  have \"(a + n*k) mod m = (a mod m + n*k) mod m\" by presburger\n  also have \"... = (b + n*k) mod m\" using assms(1) by auto\n  finally show ?thesis by auto\nqed", "origin": "congruence_manipulationV4", "update_count": 0}, "nonzero_product_nonzero_complex": {"skill_name": "nonzero_product_nonzero_complex", "marker": "lemma nonzero_product_nonzero_complex:\n  fixes z1 z2 :: complex\n  assumes \"z1 \\<noteq> 0\" \"z2 \\<noteq> 0\"\n  shows \"z1 * z2 \\<noteq> 0\"\nproof -\n  have \"z1 * z2 \\<noteq> 0\" using assms by auto\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma nonzero_product_nonzero_complex:\n  fixes z1 z2 :: complex\n  assumes \"z1 \\<noteq> 0\" \"z2 \\<noteq> 0\"\n  shows \"z1 * z2 \\<noteq> 0\"\nproof -\n  have \"z1 * z2 \\<noteq> 0\" using assms by auto\n  thus ?thesis .\nqed", "origin": "nonzero_product_nonzero", "update_count": 0}, "nonzero_product_nonzero_nat": {"skill_name": "nonzero_product_nonzero_nat", "marker": "lemma nonzero_product_nonzero_nat:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"a * b > 0\"\nproof -\n  have \"a * b > 0\" using assms by auto\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma nonzero_product_nonzero_nat:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"a * b > 0\"\nproof -\n  have \"a * b > 0\" using assms by auto\n  thus ?thesis .\nqed", "origin": "nonzero_product_nonzero", "update_count": 0}}
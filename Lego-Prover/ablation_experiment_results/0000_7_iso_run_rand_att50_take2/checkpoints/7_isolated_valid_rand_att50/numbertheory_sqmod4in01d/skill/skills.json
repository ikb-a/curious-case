{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "cancel_divide_specific": {"skill_name": "cancel_divide_specific", "marker": "lemma cancel_divide_specific:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"b > 0\"\n  shows \"b = c * x - a * x\"\nproof -\n  have \"c * x = a * x + b\" using cancel_divide_general[of x a b c] assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancel_divide_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" using assms(1) by (simp add: distrib_left)\n  thus ?thesis by (simp add: mult.commute)\nqed\n\nlemma cancel_divide_specific:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"b > 0\"\n  shows \"b = c * x - a * x\"\nproof -\n  have \"c * x = a * x + b\" using cancel_divide_general[of x a b c] assms by auto\n  thus ?thesis by simp\nqed", "origin": "cancle_div", "update_count": 0}, "mod_add_power_with_properties": {"skill_name": "mod_add_power_with_properties", "marker": "lemma mod_add_power_with_properties:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"x mod n = a\" using assms(4) by assumption\n  have \"(x + b) mod n = (a + b) mod n\" using assms(1) by (smt (verit) assms(4) mod_add_left_eq)\n  then have \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n    by (metis mod_eq_0_iff_dvd power_mod)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_with_properties:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"x mod n = a\" using assms(4) by assumption\n  have \"(x + b) mod n = (a + b) mod n\" using assms(1) by (smt (verit) assms(4) mod_add_left_eq)\n  then have \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n    by (metis mod_eq_0_iff_dvd power_mod)\n  thus ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_extended": {"skill_name": "mod_add_power_extended", "marker": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"(((x + b) ^ c + d) mod n) = (((a + b) ^ c + d) mod n)\"\nproof -\n  have \"((x + b) ^ c + d) mod n = (((x + b) ^ c) mod n + d) mod n\"\n    by presburger\n  also have \"... = (((a + b) ^ c) mod n + d) mod n\"\n    using mod_add_power_generalized[of x n a b c] assms by (smt (verit) add.commute mod_add_cong mod_add_right_eq power_mod)\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma mod_add_power_generalized:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b) ^ c) mod n = ((a + b) ^ c) mod n\"\nproof -\n  have \"((x + b) ^ c) mod n = ((x mod n + b) ^ c) mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b) ^ c) mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"(((x + b) ^ c + d) mod n) = (((a + b) ^ c + d) mod n)\"\nproof -\n  have \"((x + b) ^ c + d) mod n = (((x + b) ^ c) mod n + d) mod n\"\n    by presburger\n  also have \"... = (((a + b) ^ c) mod n + d) mod n\"\n    using mod_add_power_generalized[of x n a b c] assms by (smt (verit) add.commute mod_add_cong mod_add_right_eq power_mod)\n  finally show ?thesis by presburger\nqed", "origin": "mod_add_power", "update_count": 0}, "generalized_cancel_divide": {"skill_name": "generalized_cancel_divide", "marker": "lemma generalized_cancel_divide:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c + d / x\"\n  shows \"a * x + b = c * x + d\"\nproof -\n  have \"x * (a + b / x) = x * (c + d / x)\" using assms(2) by auto\n  then have \"x * a + b = x * c + d\" using assms(1) by (simp add: distrib_left)\n  thus ?thesis by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma generalized_cancel_divide:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c + d / x\"\n  shows \"a * x + b = c * x + d\"\nproof -\n  have \"x * (a + b / x) = x * (c + d / x)\" using assms(2) by auto\n  then have \"x * a + b = x * c + d\" using assms(1) by (simp add: distrib_left)\n  thus ?thesis by (simp add: mult.commute)\nqed", "origin": "cancel_divide_specific", "update_count": 0}, "numbertheory_sqmod4in01d": {"skill_name": "numbertheory_sqmod4in01d", "marker": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\"\n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 4 = b^2 mod 4\" using c0\n    by (smt (verit) power_mod)\n  then show ?thesis\n  proof (cases \"b=0\")\n    case True\n    have \"a^2 mod 4 = 0\" using True c2 by auto\n    then show ?thesis by auto\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b=1\")\n      case True\n      have \"a^2 mod 4 = 1\" using True c2\n        by auto\n      then show ?thesis by auto\n    next\n      case False\n      have \"b = 2 \\<or> b = 3\" using c1 c3 by (smt (verit) False)\n      then show ?thesis\n      proof (cases \"b=2\")\n        case True\n        have \"a^2 mod 4 = 2^2 mod 4\" using c2 True by auto\n        also have \"... = 0\" by simp\n        finally show ?thesis by auto\n      next\n        case False\n        have \"b = 3\" using c1 c3 False by (metis \\<open>b = 2 \\<or> b = 3\\<close>)\n        hence \"a^2 mod 4 = 3^2 mod 4\" using c2 by auto\n        also have \"... = 1\" by simp\n        finally show ?thesis by auto\n      qed\n    qed\n  qed\nqed", "description": "", "full_code": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\"\n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 4 = b^2 mod 4\" using c0\n    by (smt (verit) power_mod)\n  then show ?thesis\n  proof (cases \"b=0\")\n    case True\n    have \"a^2 mod 4 = 0\" using True c2 by auto\n    then show ?thesis by auto\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b=1\")\n      case True\n      have \"a^2 mod 4 = 1\" using True c2\n        by auto\n      then show ?thesis by auto\n    next\n      case False\n      have \"b = 2 \\<or> b = 3\" using c1 c3 by (smt (verit) False)\n      then show ?thesis\n      proof (cases \"b=2\")\n        case True\n        have \"a^2 mod 4 = 2^2 mod 4\" using c2 True by auto\n        also have \"... = 0\" by simp\n        finally show ?thesis by auto\n      next\n        case False\n        have \"b = 3\" using c1 c3 False by (metis \\<open>b = 2 \\<or> b = 3\\<close>)\n        hence \"a^2 mod 4 = 3^2 mod 4\" using c2 by auto\n        also have \"... = 1\" by simp\n        finally show ?thesis by auto\n      qed\n    qed\n  qed\nqed", "origin": "data/full_data/debug/valid_rand/numbertheory_sqmod4in01d.json_v2", "update_count": -1}, "square_modulus_properties": {"skill_name": "square_modulus_properties", "marker": "lemma square_modulus_properties:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<or> (a mod 4 = 1) \\<or> (a mod 4 = 2) \\<or> (a mod 4 = 3)\"\nproof -\n  obtain b :: int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" \n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0)\n  then show ?thesis using c0 by auto\nqed", "description": "-", "full_code": "lemma square_modulus_properties:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<or> (a mod 4 = 1) \\<or> (a mod 4 = 2) \\<or> (a mod 4 = 3)\"\nproof -\n  obtain b :: int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" \n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0)\n  then show ?thesis using c0 by auto\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "square_mod_prime": {"skill_name": "square_mod_prime", "marker": "lemma square_mod_prime:\n  fixes a :: int and p :: nat\n  assumes \"p > 1\" and \"is_prime p\"\n  shows \"(a mod p)^2 mod p = (a^2 mod p)\"\nproof -\n  have \"a mod p = a - p * (a div p)\" by (auto simp: field_simps)\n  then have \"((a mod p)^2 mod p) = ((a - p * (a div p))^2 mod p)\" by simp\n  also have \"... = (a^2 - 2 * a * p * (a div p) + (p * (a div p))^2) mod p\" by (smt (verit) ab_semigroup_mult_class.mult_ac(1) diff_add_eq power2_diff)\n  also have \"... = (a^2 mod p)\" using mod_add_eq by (metis \\<open>(a - int p * (a div int p))\\<^sup>2 mod int p = (a\\<^sup>2 - 2 * a * int p * (a div int p) + (int p * (a div int p))\\<^sup>2) mod int p\\<close> add.commute add_diff_eq diff_diff_eq2 minus_mult_div_eq_mod mult.commute mult.left_commute mult_2 mult_of_nat_commute of_nat_numeral power2_eq_square power_mod right_diff_distrib')\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma square_mod_prime:\n  fixes a :: int and p :: nat\n  assumes \"p > 1\" and \"is_prime p\"\n  shows \"(a mod p)^2 mod p = (a^2 mod p)\"\nproof -\n  have \"a mod p = a - p * (a div p)\" by (auto simp: field_simps)\n  then have \"((a mod p)^2 mod p) = ((a - p * (a div p))^2 mod p)\" by simp\n  also have \"... = (a^2 - 2 * a * p * (a div p) + (p * (a div p))^2) mod p\" by (smt (verit) ab_semigroup_mult_class.mult_ac(1) diff_add_eq power2_diff)\n  also have \"... = (a^2 mod p)\" using mod_add_eq by (metis \\<open>(a - int p * (a div int p))\\<^sup>2 mod int p = (a\\<^sup>2 - 2 * a * int p * (a div int p) + (int p * (a div int p))\\<^sup>2) mod int p\\<close> add.commute add_diff_eq diff_diff_eq2 minus_mult_div_eq_mod mult.commute mult.left_commute mult_2 mult_of_nat_commute of_nat_numeral power2_eq_square power_mod right_diff_distrib')\n  finally show ?thesis by simp\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "square_mod_four": {"skill_name": "square_mod_four", "marker": "lemma square_mod_four:\n  fixes a :: int\n  shows \"(a mod 4)^2 mod 4 = (a^2 mod 4)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0)\n  have c2: \"a^2 mod 4 = b^2 mod 4\" using c0 power_mod by (metis mod_mult_cong mod_mult_eq power2_eq_square)\n  show ?thesis using c2 by (metis power_mod)\nqed", "description": "-", "full_code": "lemma square_mod_four:\n  fixes a :: int\n  shows \"(a mod 4)^2 mod 4 = (a^2 mod 4)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0)\n  have c2: \"a^2 mod 4 = b^2 mod 4\" using c0 power_mod by (metis mod_mult_cong mod_mult_eq power2_eq_square)\n  show ?thesis using c2 by (metis power_mod)\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "numbertheory_sqmod4in01d_special_case": {"skill_name": "numbertheory_sqmod4in01d_special_case", "marker": "theorem numbertheory_sqmod4in01d_special_case:\n  fixes a :: int\n  assumes \"a mod 4 = 2\"\n  shows \"a^2 mod 4 = 0\"\nproof -\n  have \"a^2 mod 4 = (2^2) mod 4\" using assms by (smt (verit) power_mod)\n  also have \"... = 4 mod 4\" by simp\n  also have \"... = 0\" by simp\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "theorem numbertheory_sqmod4in01d_special_case:\n  fixes a :: int\n  assumes \"a mod 4 = 2\"\n  shows \"a^2 mod 4 = 0\"\nproof -\n  have \"a^2 mod 4 = (2^2) mod 4\" using assms by (smt (verit) power_mod)\n  also have \"... = 4 mod 4\" by simp\n  also have \"... = 0\" by simp\n  finally show ?thesis by auto\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "numbertheory_sqmod4_in_01d_extended": {"skill_name": "numbertheory_sqmod4_in_01d_extended", "marker": "theorem numbertheory_sqmod4_in_01d_extended:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1) \\<or> (a^2 mod 4 = 2) \\<or> (a^2 mod 4 = 3)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\"\n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 4 = b^2 mod 4\" using c0\n    by (smt (verit) power_mod)\n  then show ?thesis\n  proof (cases \"b=0\")\n    case True\n    thus ?thesis using c2 by auto\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b=1\")\n      case True\n      thus ?thesis using c2 by auto\n    next\n      case False\n      have \"b = 2 \\<or> b = 3\" using c1 c3 by (smt (verit) False)\n      then show ?thesis\n      proof (cases \"b=2\")\n        case True\n        thus ?thesis using c2 by (simp add: power_mod)\n      next\n        case False\n        have \"b = 3\" using c1 c3 False by (metis \\<open>b = 2 \\<or> b = 3\\<close>)\n        thus ?thesis using c2 by (simp add: power_mod)\n      qed\n    qed\n  qed\nqed", "description": "-", "full_code": "theorem numbertheory_sqmod4_in_01d_extended:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1) \\<or> (a^2 mod 4 = 2) \\<or> (a^2 mod 4 = 3)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\"\n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 4 = b^2 mod 4\" using c0\n    by (smt (verit) power_mod)\n  then show ?thesis\n  proof (cases \"b=0\")\n    case True\n    thus ?thesis using c2 by auto\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b=1\")\n      case True\n      thus ?thesis using c2 by auto\n    next\n      case False\n      have \"b = 2 \\<or> b = 3\" using c1 c3 by (smt (verit) False)\n      then show ?thesis\n      proof (cases \"b=2\")\n        case True\n        thus ?thesis using c2 by (simp add: power_mod)\n      next\n        case False\n        have \"b = 3\" using c1 c3 False by (metis \\<open>b = 2 \\<or> b = 3\\<close>)\n        thus ?thesis using c2 by (simp add: power_mod)\n      qed\n    qed\n  qed\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "numbertheory_sqmod3in01d": {"skill_name": "numbertheory_sqmod3in01d", "marker": "theorem numbertheory_sqmod3in01d:\n  fixes a :: int\n  shows \"(a^2 mod 3 = 0) \\<or> (a^2 mod 3 = 1)\"\nproof -\n  obtain b::int where c0: \"b = a mod 3\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 2\"\n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 3 = b^2 mod 3\" using c0\n    by (smt (verit) power_mod)\n  then show ?thesis\n  proof (cases \"b=0\")\n    case True\n    have \"a^2 mod 3 = 0\" using True c2 by auto\n    then show ?thesis by auto\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b=1\")\n      case True\n      have \"a^2 mod 3 = 1\" using True c2 by auto\n      then show ?thesis by auto\n    next\n      case False\n      have \"b = 2\" using c1 c3 by (smt (verit) False)\n      hence \"a^2 mod 3 = 2^2 mod 3\" using c2 by auto\n      also have \"... = 1\" by simp\n      finally show ?thesis by auto\n    qed\n  qed\nqed", "description": "-", "full_code": "theorem numbertheory_sqmod3in01d:\n  fixes a :: int\n  shows \"(a^2 mod 3 = 0) \\<or> (a^2 mod 3 = 1)\"\nproof -\n  obtain b::int where c0: \"b = a mod 3\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 2\"\n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 3 = b^2 mod 3\" using c0\n    by (smt (verit) power_mod)\n  then show ?thesis\n  proof (cases \"b=0\")\n    case True\n    have \"a^2 mod 3 = 0\" using True c2 by auto\n    then show ?thesis by auto\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b=1\")\n      case True\n      have \"a^2 mod 3 = 1\" using True c2 by auto\n      then show ?thesis by auto\n    next\n      case False\n      have \"b = 2\" using c1 c3 by (smt (verit) False)\n      hence \"a^2 mod 3 = 2^2 mod 3\" using c2 by auto\n      also have \"... = 1\" by simp\n      finally show ?thesis by auto\n    qed\n  qed\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "square_modulo": {"skill_name": "square_modulo", "marker": "lemma square_modulo:\n  fixes a :: int\n  shows \"(a mod 4)^2 mod 4 = (a^2 mod 4)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\"\n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 4 = b^2 mod 4\" using c0\n    by (smt (verit) power_mod)\n  show ?thesis using c2 by (metis power_mod)\nqed", "description": "-", "full_code": "lemma square_modulo:\n  fixes a :: int\n  shows \"(a mod 4)^2 mod 4 = (a^2 mod 4)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\"\n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 4 = b^2 mod 4\" using c0\n    by (smt (verit) power_mod)\n  show ?thesis using c2 by (metis power_mod)\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "square_mod_property": {"skill_name": "square_mod_property", "marker": "lemma square_mod_property:\n  fixes a :: int\n  shows \"(a mod n)^2 mod n = (a^2 mod n)\"\nproof -\n  obtain b::int where c0: \"b = a mod n\" by auto\n  then have \"b = a - n * (a div n)\" by (auto simp: field_simps)\n  hence \"a^2 = (b + n * (a div n))^2\" by (simp add: algebra_simps)\n  also have \"... = b^2 + 2 * b * (n * (a div n)) + (n * (a div n))^2\" by (smt (verit) power2_sum)\n  also have \"... mod n = b^2 mod n\" by (smt (verit) \\<open>(b + n * (a div n))\\<^sup>2 = b\\<^sup>2 + 2 * b * (n * (a div n)) + (n * (a div n))\\<^sup>2\\<close> \\<open>a\\<^sup>2 = (b + n * (a div n))\\<^sup>2\\<close> c0 power_mod)\n  finally show ?thesis using c0 by auto\nqed", "description": "-", "full_code": "lemma square_mod_property:\n  fixes a :: int\n  shows \"(a mod n)^2 mod n = (a^2 mod n)\"\nproof -\n  obtain b::int where c0: \"b = a mod n\" by auto\n  then have \"b = a - n * (a div n)\" by (auto simp: field_simps)\n  hence \"a^2 = (b + n * (a div n))^2\" by (simp add: algebra_simps)\n  also have \"... = b^2 + 2 * b * (n * (a div n)) + (n * (a div n))^2\" by (smt (verit) power2_sum)\n  also have \"... mod n = b^2 mod n\" by (smt (verit) \\<open>(b + n * (a div n))\\<^sup>2 = b\\<^sup>2 + 2 * b * (n * (a div n)) + (n * (a div n))\\<^sup>2\\<close> \\<open>a\\<^sup>2 = (b + n * (a div n))\\<^sup>2\\<close> c0 power_mod)\n  finally show ?thesis using c0 by auto\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "square_mod_behavior": {"skill_name": "square_mod_behavior", "marker": "lemma square_mod_behavior:\n  fixes a :: int\n  shows \"(a mod n)^2 mod n = (a^2 mod n)\"\nproof -\n  obtain b::int where c0: \"b = a mod n\" by auto\n  have \"b^2 mod n = (a^2 mod n)\"\n  proof -\n    have \"b = a - n * (a div n)\" by (metis c0 cancel_ab_semigroup_add_class.diff_right_commute diff_eq_diff_eq minus_mod_eq_mult_div)\n    then have \"b^2 = (a - n * (a div n))^2\" by simp\n    also have \"... = a^2 - 2 * a * (n * (a div n)) + (n^2 * (a div n)^2)\" by (smt (verit) diff_add_eq power2_diff power_mult_distrib)\n    then have \"... mod n = a^2 mod n\" using mod_mult_self2 [of a \"n * (a div n)\"] by (smt (verit) \\<open>b = a - n * (a div n)\\<close> c0 power_mod)\n    thus ?thesis by (metis \\<open>b = a - n * (a div n)\\<close> c0 minus_mult_div_eq_mod mod_mod_trivial mod_mult_cong power2_eq_square)\n  qed\n  thus ?thesis by (metis power_mod)\nqed", "description": "-", "full_code": "lemma square_mod_behavior:\n  fixes a :: int\n  shows \"(a mod n)^2 mod n = (a^2 mod n)\"\nproof -\n  obtain b::int where c0: \"b = a mod n\" by auto\n  have \"b^2 mod n = (a^2 mod n)\"\n  proof -\n    have \"b = a - n * (a div n)\" by (metis c0 cancel_ab_semigroup_add_class.diff_right_commute diff_eq_diff_eq minus_mod_eq_mult_div)\n    then have \"b^2 = (a - n * (a div n))^2\" by simp\n    also have \"... = a^2 - 2 * a * (n * (a div n)) + (n^2 * (a div n)^2)\" by (smt (verit) diff_add_eq power2_diff power_mult_distrib)\n    then have \"... mod n = a^2 mod n\" using mod_mult_self2 [of a \"n * (a div n)\"] by (smt (verit) \\<open>b = a - n * (a div n)\\<close> c0 power_mod)\n    thus ?thesis by (metis \\<open>b = a - n * (a div n)\\<close> c0 minus_mult_div_eq_mod mod_mod_trivial mod_mult_cong power2_eq_square)\n  qed\n  thus ?thesis by (metis power_mod)\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "absolute_value_difference": {"skill_name": "absolute_value_difference", "marker": "lemma absolute_value_difference:\n  fixes a b c :: real\n  assumes \"abs(a - b) < c\"\n  shows \"b - c < a \\<and> a < b + c\"\nproof -\n  have \"a - b < c\" and \"-(a - b) < c\" using assms by auto\n  then show ?thesis\n  proof -\n    have \"b - c < a\" using `a - b < c` by (metis abs_diff_less_iff assms)\n    have \"a < b + c\" using `-(a - b) < c` by (metis abs_diff_less_iff assms)\n    thus ?thesis by (metis \\<open>b - c < a\\<close>)\n  qed\nqed", "description": "-", "full_code": "lemma absolute_value_difference:\n  fixes a b c :: real\n  assumes \"abs(a - b) < c\"\n  shows \"b - c < a \\<and> a < b + c\"\nproof -\n  have \"a - b < c\" and \"-(a - b) < c\" using assms by auto\n  then show ?thesis\n  proof -\n    have \"b - c < a\" using `a - b < c` by (metis abs_diff_less_iff assms)\n    have \"a < b + c\" using `-(a - b) < c` by (metis abs_diff_less_iff assms)\n    thus ?thesis by (metis \\<open>b - c < a\\<close>)\n  qed\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "int_square_mod": {"skill_name": "int_square_mod", "marker": "lemma int_square_mod:\n  fixes a :: int\n  shows \"(a mod n)^2 mod n = (a^2 mod n)\"\n  by (simp add: power_mod)", "description": "-", "full_code": "lemma int_square_mod:\n  fixes a :: int\n  shows \"(a mod n)^2 mod n = (a^2 mod n)\"\n  by (simp add: power_mod)", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "square_modulus_propertiesV2": {"skill_name": "square_modulus_propertiesV2", "marker": "theorem square_modulus_properties:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<or> (a mod 4 = 1) \\<or> (a mod 4 = 2) \\<or> (a mod 4 = 3)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "theorem square_modulus_properties:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<or> (a mod 4 = 1) \\<or> (a mod 4 = 2) \\<or> (a mod 4 = 3)\"\nproof -\n  have \"a mod 4 = 0 \\<or> a mod 4 = 1 \\<or> a mod 4 = 2 \\<or> a mod 4 = 3\" \n    by auto\n  thus ?thesis by auto\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "square_modulo_4": {"skill_name": "square_modulo_4", "marker": "lemma square_modulo_4:\n  fixes a :: int\n  shows \"((a mod 4)^2 mod 4 = 0) \\<or> ((a mod 4)^2 mod 4 = 1)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"b^2 mod 4 = (b mod 4)^2 mod 4\" by (simp add: power_mod)\n  show ?thesis\n  proof (cases \"b=0\")\n    case True\n    have \"b^2 mod 4 = 0\" using True c2 by auto\n    then show ?thesis by (metis True c0)\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b=1\")\n      case True\n      have \"b^2 mod 4 = 1\" using True c2 by auto\n      then show ?thesis by (metis True c0)\n    next\n      case False\n      have \"b = 2 \\<or> b = 3\" using c1 c3 by (smt (verit) False)\n      then show ?thesis\n      proof (cases \"b=2\")\n        case True\n        have \"b^2 mod 4 = 4 mod 4\" using c2 True by auto\n        also have \"... = 0\" by simp\n        finally show ?thesis by (metis c0 numbertheory_sqmod4in01d)\n      next\n        case False\n        have \"b = 3\" using c1 c3 False by (metis \\<open>b = 2 \\<or> b = 3\\<close>)\n        hence \"b^2 mod 4 = 9 mod 4\" using c2 by auto\n        also have \"... = 1\" by simp\n        finally show ?thesis by (metis \\<open>9 mod 4 = 1\\<close> \\<open>b\\<^sup>2 mod 4 = 9 mod 4\\<close> c0)\n      qed\n    qed\n  qed\nqed", "description": "-", "full_code": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 4 = b^2 mod 4\" using c0 by (smt (verit) power_mod)\n  have \"b = 0 \\<or> b = 1 \\<or> b = 2 \\<or> b = 3\" using c1 by auto\n  then show ?thesis\n  proof (cases \"b=0\")\n    case True\n    have \"a^2 mod 4 = 0\" using True c2 by auto\n    then show ?thesis by auto\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b=1\")\n      case True\n      have \"a^2 mod 4 = 1\" using True c2 by auto\n      then show ?thesis by auto\n    next\n      case False\n      have \"b = 2 \\<or> b = 3\" using c1 c3 by (smt (verit) False)\n      then show ?thesis\n      proof (cases \"b=2\")\n        case True\n        have \"a^2 mod 4 = 2^2 mod 4\" using c2 True by auto\n        also have \"... = 0\" by simp\n        finally show ?thesis by auto\n      next\n        case False\n        have \"b = 3\" using c1 c3 False by (metis \\<open>b = 2 \\<or> b = 3\\<close>)\n        hence \"a^2 mod 4 = 3^2 mod 4\" using c2 by auto\n        also have \"... = 1\" by simp\n        finally show ?thesis by auto\n      qed\n    qed\n  qed\nqed\n\nlemma square_modulo_4:\n  fixes a :: int\n  shows \"((a mod 4)^2 mod 4 = 0) \\<or> ((a mod 4)^2 mod 4 = 1)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"b^2 mod 4 = (b mod 4)^2 mod 4\" by (simp add: power_mod)\n  show ?thesis\n  proof (cases \"b=0\")\n    case True\n    have \"b^2 mod 4 = 0\" using True c2 by auto\n    then show ?thesis by (metis True c0)\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b=1\")\n      case True\n      have \"b^2 mod 4 = 1\" using True c2 by auto\n      then show ?thesis by (metis True c0)\n    next\n      case False\n      have \"b = 2 \\<or> b = 3\" using c1 c3 by (smt (verit) False)\n      then show ?thesis\n      proof (cases \"b=2\")\n        case True\n        have \"b^2 mod 4 = 4 mod 4\" using c2 True by auto\n        also have \"... = 0\" by simp\n        finally show ?thesis by (metis c0 numbertheory_sqmod4in01d)\n      next\n        case False\n        have \"b = 3\" using c1 c3 False by (metis \\<open>b = 2 \\<or> b = 3\\<close>)\n        hence \"b^2 mod 4 = 9 mod 4\" using c2 by auto\n        also have \"... = 1\" by simp\n        finally show ?thesis by (metis \\<open>9 mod 4 = 1\\<close> \\<open>b\\<^sup>2 mod 4 = 9 mod 4\\<close> c0)\n      qed\n    qed\n  qed\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "numbertheory_sqmod4in01d_special_caseV2": {"skill_name": "numbertheory_sqmod4in01d_special_caseV2", "marker": "lemma numbertheory_sqmod4in01d_special_case:\n  fixes a :: int\n  assumes \"a mod 4 = 2\"\n  shows \"a^2 mod 4 = 0\"\nproof -\n  have \"a^2 mod 4 = (2^2) mod 4\" using assms by (smt (verit) power_mod)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma numbertheory_sqmod4in01d_special_case:\n  fixes a :: int\n  assumes \"a mod 4 = 2\"\n  shows \"a^2 mod 4 = 0\"\nproof -\n  have \"a^2 mod 4 = (2^2) mod 4\" using assms by (smt (verit) power_mod)\n  thus ?thesis by simp\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "numbertheory_sqmod4_properties": {"skill_name": "numbertheory_sqmod4_properties", "marker": "theorem numbertheory_sqmod4_properties:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<or> (a mod 4 = 1) \\<or> (a mod 4 = 2) \\<or> (a mod 4 = 3)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have \"b \\<ge> 0 \\<and> b \\<le> 3\" by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "theorem numbertheory_sqmod4_properties:\n  fixes a :: int\n  shows \"(a mod 4 = 0) \\<or> (a mod 4 = 1) \\<or> (a mod 4 = 2) \\<or> (a mod 4 = 3)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have \"b \\<ge> 0 \\<and> b \\<le> 3\" by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  thus ?thesis by auto\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "numbertheory_sqmod4in01dV2": {"skill_name": "numbertheory_sqmod4in01dV2", "marker": "theorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  have c2: \"a^2 mod 4 = (a mod 4)^2 mod 4\" using square_mod4 by auto\n  show ?thesis\n  proof (cases \"b=0\")\n    case True\n    have \"a^2 mod 4 = 0\" using True c2 by (metis bits_mod_0 c0 zero_power2)\n    then show ?thesis by auto\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b=1\")\n      case True\n      have \"a^2 mod 4 = 1\" using True c2 by (metis c0 dbl_simps(3) dbl_simps(5) mod_mod_trivial one_power2)\n      then show ?thesis by auto\n    next\n      case False\n      have \"b = 2 \\<or> b = 3\" using c1 c3 by (smt (verit) False)\n      then show ?thesis\n      proof (cases \"b=2\")\n        case True\n        have \"a^2 mod 4 = 2^2 mod 4\" using c2 True by (smt (verit) c0)\n        also have \"... = 0\" by simp\n        finally show ?thesis by auto\n      next\n        case False\n        have \"b = 3\" using c1 c3 False by (metis \\<open>b = 2 \\<or> b = 3\\<close>)\n        hence \"a^2 mod 4 = 3^2 mod 4\" using c2 by (metis c0)\n        also have \"... = 1\" by simp\n        finally show ?thesis by auto\n      qed\n    qed\n  qed\nqed", "description": "-", "full_code": "lemma square_mod4:\n  fixes a :: int\n  shows \"a^2 mod 4 = (a mod 4)^2 mod 4\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 4 = b^2 mod 4\" using c0 by (smt (verit) power_mod)\n  thus ?thesis by (metis power_mod)\nqed\n\ntheorem numbertheory_sqmod4in01d:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  have c2: \"a^2 mod 4 = (a mod 4)^2 mod 4\" using square_mod4 by auto\n  show ?thesis\n  proof (cases \"b=0\")\n    case True\n    have \"a^2 mod 4 = 0\" using True c2 by (metis bits_mod_0 c0 zero_power2)\n    then show ?thesis by auto\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b=1\")\n      case True\n      have \"a^2 mod 4 = 1\" using True c2 by (metis c0 dbl_simps(3) dbl_simps(5) mod_mod_trivial one_power2)\n      then show ?thesis by auto\n    next\n      case False\n      have \"b = 2 \\<or> b = 3\" using c1 c3 by (smt (verit) False)\n      then show ?thesis\n      proof (cases \"b=2\")\n        case True\n        have \"a^2 mod 4 = 2^2 mod 4\" using c2 True by (smt (verit) c0)\n        also have \"... = 0\" by simp\n        finally show ?thesis by auto\n      next\n        case False\n        have \"b = 3\" using c1 c3 False by (metis \\<open>b = 2 \\<or> b = 3\\<close>)\n        hence \"a^2 mod 4 = 3^2 mod 4\" using c2 by (metis c0)\n        also have \"... = 1\" by simp\n        finally show ?thesis by auto\n      qed\n    qed\n  qed\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}, "numbertheory_sqmod4_propertiesV2": {"skill_name": "numbertheory_sqmod4_propertiesV2", "marker": "theorem numbertheory_sqmod4_properties:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1) \\<or> (a^2 mod 4 = 2) \\<or> (a^2 mod 4 = 3)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" \n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 4 = b^2 mod 4\" using c0\n    by (smt (verit) power_mod)\n  thus ?thesis\n  proof (cases \"b = 0\")\n    case True\n    then have \"a^2 mod 4 = 0\" using c2 by auto\n    thus ?thesis by auto\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b = 1\")\n      case True\n      then have \"a^2 mod 4 = 1\" using c2 by auto\n      thus ?thesis by auto\n    next\n      case False\n      have \"b = 2 \\<or> b = 3\" using c1 c3 by (smt (verit) False)\n      then show ?thesis\n      proof (cases \"b = 2\")\n        case True\n        then have \"a^2 mod 4 = 4 mod 4\" by (simp add: c2)\n        thus ?thesis by auto\n      next\n        case False\n        have \"b = 3\" using c1 c3 False by (metis \\<open>b = 2 \\<or> b = 3\\<close>)\n        then have \"a^2 mod 4 = 9 mod 4\" by (simp add: c2)\n        thus ?thesis by auto\n      qed\n    qed\n  qed\nqed", "description": "-", "full_code": "theorem numbertheory_sqmod4_properties:\n  fixes a :: int\n  shows \"(a^2 mod 4 = 0) \\<or> (a^2 mod 4 = 1) \\<or> (a^2 mod 4 = 2) \\<or> (a^2 mod 4 = 3)\"\nproof -\n  obtain b::int where c0: \"b = a mod 4\" by auto\n  have c1: \"b \\<ge> 0 \\<and> b \\<le> 3\" \n    by (smt (verit) Euclidean_Division.pos_mod_bound Euclidean_Division.pos_mod_sign c0 uminus_int_code(1) zle_add1_eq_le)\n  hence c2: \"a^2 mod 4 = b^2 mod 4\" using c0\n    by (smt (verit) power_mod)\n  thus ?thesis\n  proof (cases \"b = 0\")\n    case True\n    then have \"a^2 mod 4 = 0\" using c2 by auto\n    thus ?thesis by auto\n  next\n    case c3: False\n    then show ?thesis\n    proof (cases \"b = 1\")\n      case True\n      then have \"a^2 mod 4 = 1\" using c2 by auto\n      thus ?thesis by auto\n    next\n      case False\n      have \"b = 2 \\<or> b = 3\" using c1 c3 by (smt (verit) False)\n      then show ?thesis\n      proof (cases \"b = 2\")\n        case True\n        then have \"a^2 mod 4 = 4 mod 4\" by (simp add: c2)\n        thus ?thesis by auto\n      next\n        case False\n        have \"b = 3\" using c1 c3 False by (metis \\<open>b = 2 \\<or> b = 3\\<close>)\n        then have \"a^2 mod 4 = 9 mod 4\" by (simp add: c2)\n        thus ?thesis by auto\n      qed\n    qed\n  qed\nqed", "origin": "numbertheory_sqmod4in01d", "update_count": 0}}
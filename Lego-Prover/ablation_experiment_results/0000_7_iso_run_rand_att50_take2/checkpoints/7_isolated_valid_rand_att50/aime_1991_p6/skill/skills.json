{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "log_property": {"skill_name": "log_property", "marker": "lemma log_property:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\"\n  shows \"log a (a * b) = 1 + log a b\"\nproof -\n  have \"log a (a * b) = log a a + log a b\" by (metis assms(1) assms(2) assms(3) log_mult)\n  then have \"log a (a * b) = 1 + log a b\" using assms(1) assms(2) by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma log_property:\n  fixes a b :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\"\n  shows \"log a (a * b) = 1 + log a b\"\nproof -\n  have \"log a (a * b) = log a a + log a b\" by (metis assms(1) assms(2) assms(3) log_mult)\n  then have \"log a (a * b) = 1 + log a b\" using assms(1) assms(2) by simp\n  then show ?thesis by simp\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "logarithm_power_identity": {"skill_name": "logarithm_power_identity", "marker": "lemma logarithm_power_identity:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\" using log_nat_power[of a a n] by (simp add: assms(1))\n  also have \"log a a = 1\" using assms(1) assms(2) by (simp)\n  then have \"log a (a^n) = n * 1\" by (metis assms(1) assms(2) log_pow_cancel mult.right_neutral)\n  finally show ?thesis by (metis \\<open>log a (a ^ n) = real (n * 1)\\<close> mult.commute mult_1)\nqed", "description": "-", "full_code": "lemma logarithm_power_identity:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\" using log_nat_power[of a a n] by (simp add: assms(1))\n  also have \"log a a = 1\" using assms(1) assms(2) by (simp)\n  then have \"log a (a^n) = n * 1\" by (metis assms(1) assms(2) log_pow_cancel mult.right_neutral)\n  finally show ?thesis by (metis \\<open>log a (a ^ n) = real (n * 1)\\<close> mult.commute mult_1)\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "cal_log_value_general": {"skill_name": "cal_log_value_general", "marker": "lemma cal_log_value_general:\n  fixes a b :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nusing assms by (metis powr_log_cancel powr_realpow)", "description": "-", "full_code": "lemma cal_log_value_general:\n  fixes a b :: real\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nusing assms by (metis powr_log_cancel powr_realpow)", "origin": "cal_log_value", "update_count": 0}, "cancle_div_general": {"skill_name": "cancle_div_general", "marker": "lemma cancle_div_general:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof (cases \"x > 0\")\n  case True\n  then show ?thesis using cancle_div_with_nonzero[of x a b c] by (metis assms(2))\nnext\n  case False\n  then have \"x < 0\" using assms(1) by auto\n  then show ?thesis using cancle_div_with_neg[of x a b c] by (metis assms(2))\nqed", "description": "-", "full_code": "lemma cancle_div_with_neg:\n  fixes x a b c :: real\n  assumes \"x < 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  then show ?thesis using assms(1) by (simp add: mult.commute)\nqed\n\nlemma cancle_div_with_nonzero:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  then show ?thesis using assms(1) by (simp add: mult.commute)\nqed\n\nlemma cancle_div_general:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof (cases \"x > 0\")\n  case True\n  then show ?thesis using cancle_div_with_nonzero[of x a b c] by (metis assms(2))\nnext\n  case False\n  then have \"x < 0\" using assms(1) by auto\n  then show ?thesis using cancle_div_with_neg[of x a b c] by (metis assms(2))\nqed", "origin": "cancle_div", "update_count": 0}, "mod_add_power_general": {"skill_name": "mod_add_power_general", "marker": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"m > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \"x mod m = b\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  and \"((x + b)^c) mod m = ((b + b)^c) mod m\"\nproof -\n  have mod_n: \"((x + b)^c) mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(5) by auto\n  finally show \"((x + b)^c) mod n = ((a + b)^c) mod n\" by auto\n  have mod_m: \"((x + b)^c) mod m = ((x mod m) + b)^c mod m\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (b + b)^c mod m\"\n    using assms(6) by auto\n  finally show \"((x + b)^c) mod m = ((b + b)^c) mod m\" by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"m > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\" \"x mod m = b\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\n  and \"((x + b)^c) mod m = ((b + b)^c) mod m\"\nproof -\n  have mod_n: \"((x + b)^c) mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(5) by auto\n  finally show \"((x + b)^c) mod n = ((a + b)^c) mod n\" by auto\n  have mod_m: \"((x + b)^c) mod m = ((x mod m) + b)^c mod m\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (b + b)^c mod m\"\n    using assms(6) by auto\n  finally show \"((x + b)^c) mod m = ((b + b)^c) mod m\" by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_generalized": {"skill_name": "mod_add_power_generalized", "marker": "lemma mod_add_power_generalized:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = (((a + b)^c) + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c) mod n + d mod n) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c + d) mod n\"\n    by (smt (verit) assms(1) assms(2) assms(3) mod_add_left_eq mod_add_power_extended mod_add_right_eq)\n  also have \"... = ((a + b)^c + d) mod n\"\n    using assms(4) by (metis add.commute assms(5))\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_extended:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed\n\nlemma mod_add_power_generalized:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = (((a + b)^c) + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c) mod n + d mod n) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c + d) mod n\"\n    by (smt (verit) assms(1) assms(2) assms(3) mod_add_left_eq mod_add_power_extended mod_add_right_eq)\n  also have \"... = ((a + b)^c + d) mod n\"\n    using assms(4) by (metis add.commute assms(5))\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "cancel_div_general": {"skill_name": "cancel_div_general", "marker": "lemma cancel_div_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"d > 0\"\n  shows \"a + b / x = c \\<Longrightarrow> a * x + b = c * x\"\nproof -\n  assume \"a + b / x = c\"\n  have \"x * (a + b / x) = c * x\" using `a + b / x = c` by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  then show \"a * x + b = c * x\" using assms(1) by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancel_div_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"d > 0\"\n  shows \"a + b / x = c \\<Longrightarrow> a * x + b = c * x\"\nproof -\n  assume \"a + b / x = c\"\n  have \"x * (a + b / x) = c * x\" using `a + b / x = c` by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  then show \"a * x + b = c * x\" using assms(1) by (simp add: mult.commute)\nqed", "origin": "cancle_div", "update_count": 0}, "bounds_on_sum": {"skill_name": "bounds_on_sum", "marker": "lemma bounds_on_sum:\n  fixes n :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"0 \\<le> x \\<and> 0 \\<le> y\"\nproof -\n  from assms(2) have \"0 \\<le> x\" by simp\n  from assms(3) have \"0 \\<le> y\" by simp\n  show \"0 \\<le> x \\<and> 0 \\<le> y\" by (simp add: \\<open>0 \\<le> x\\<close> \\<open>0 \\<le> y\\<close>)\nqed", "description": "-", "full_code": "lemma bounds_on_sum:\n  fixes n :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"0 \\<le> x \\<and> 0 \\<le> y\"\nproof -\n  from assms(2) have \"0 \\<le> x\" by simp\n  from assms(3) have \"0 \\<le> y\" by simp\n  show \"0 \\<le> x \\<and> 0 \\<le> y\" by (simp add: \\<open>0 \\<le> x\\<close> \\<open>0 \\<le> y\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "bounds_on_sumV2": {"skill_name": "bounds_on_sumV2", "marker": "lemma bounds_on_sum:\n  fixes n :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"0 \\<le> x \\<and> 0 \\<le> y\"\nproof -\n  have \"0 \\<le> x\" using assms(2) by auto\n  have \"0 \\<le> y\" using assms(3) by auto\n  thus \"0 \\<le> x \\<and> 0 \\<le> y\" by (simp add: conjI)\nqed", "description": "-", "full_code": "lemma bounds_on_sum:\n  fixes n :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"0 \\<le> x \\<and> 0 \\<le> y\"\nproof -\n  have \"0 \\<le> x\" using assms(2) by auto\n  have \"0 \\<le> y\" using assms(3) by auto\n  thus \"0 \\<le> x \\<and> 0 \\<le> y\" by (simp add: conjI)\nqed", "origin": "do_request", "update_count": 0}, "bounds_on_sumV3": {"skill_name": "bounds_on_sumV3", "marker": "lemma bounds_on_sum:\n  fixes n :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"0 \\<le> x \\<and> 0 \\<le> y\"\nproof -\n  from assms(2) have \"x \\<ge> 0\" by simp\n  from assms(3) have \"y \\<ge> 0\" by simp\n  show \"0 \\<le> x \\<and> 0 \\<le> y\" by (simp add: assms(2) assms(3))\nqed", "description": "-", "full_code": "lemma bounds_on_sum:\n  fixes n :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"0 \\<le> x \\<and> 0 \\<le> y\"\nproof -\n  from assms(2) have \"x \\<ge> 0\" by simp\n  from assms(3) have \"y \\<ge> 0\" by simp\n  show \"0 \\<le> x \\<and> 0 \\<le> y\" by (simp add: assms(2) assms(3))\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_n_dimensional": {"skill_name": "cancel_div_n_dimensional", "marker": "lemma cancel_div_n_dimensional:\n  fixes x :: real\n  fixes a b c :: \"real list\"  \n  assumes \"x > 0\" \"length a = n\" \"length b = n\" \"length c = n\"\n  shows \"(\\<forall>i. a ! i + b ! i / x = c ! i) \\<Longrightarrow> (\\<forall>i. a ! i * x + b ! i = c ! i * x)\"\nproof -\n  assume \"(\\<forall>i. a ! i + b ! i / x = c ! i)\"\n  have \"\\<forall>i. x * (a ! i + b ! i / x) = c ! i * x\" using `\\<forall>i. a ! i + b ! i / x = c ! i` by auto\n  then have \"\\<forall>i. x * a ! i + b ! i = c ! i * x\" by (smt (verit) \\<open>\\<forall>i. a ! i + b ! i / x = c ! i\\<close> assms(1) cancel_div_general mult.commute of_nat_0_less_iff zero_less_one)\n  then show \"\\<forall>i. a ! i * x + b ! i = c ! i * x\" by (simp add: mult.commute)\nqed", "description": "-", "full_code": "lemma cancel_div_general:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"d > 0\"\n  shows \"a + b / x = c \\<Longrightarrow> a * x + b = c * x\"\nproof -\n  assume \"a + b / x = c\"\n  have \"x * (a + b / x) = c * x\" using `a + b / x = c` by auto\n  then have \"x * a + x * (b / x) = c * x\" by (simp add: distrib_left)\n  then show \"a * x + b = c * x\" using assms(1) by (simp add: mult.commute)\nqed\n\nlemma cancel_div_n_dimensional:\n  fixes x :: real\n  fixes a b c :: \"real list\"  \n  assumes \"x > 0\" \"length a = n\" \"length b = n\" \"length c = n\"\n  shows \"(\\<forall>i. a ! i + b ! i / x = c ! i) \\<Longrightarrow> (\\<forall>i. a ! i * x + b ! i = c ! i * x)\"\nproof -\n  assume \"(\\<forall>i. a ! i + b ! i / x = c ! i)\"\n  have \"\\<forall>i. x * (a ! i + b ! i / x) = c ! i * x\" using `\\<forall>i. a ! i + b ! i / x = c ! i` by auto\n  then have \"\\<forall>i. x * a ! i + b ! i = c ! i * x\" by (smt (verit) \\<open>\\<forall>i. a ! i + b ! i / x = c ! i\\<close> assms(1) cancel_div_general mult.commute of_nat_0_less_iff zero_less_one)\n  then show \"\\<forall>i. a ! i * x + b ! i = c ! i * x\" by (simp add: mult.commute)\nqed", "origin": "cancel_div_general", "update_count": 0}, "logarithm_identity": {"skill_name": "logarithm_identity", "marker": "lemma logarithm_identity:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\"\n  shows \"log a a = 1\"\nproof -\n  have \"log a a = 1\" using assms by (simp add: log_def)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_identity:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\"\n  shows \"log a a = 1\"\nproof -\n  have \"log a a = 1\" using assms by (simp add: log_def)\n  then show ?thesis by simp\nqed", "origin": "logarithm_power_identity", "update_count": 0}, "log_property_with_c": {"skill_name": "log_property_with_c", "marker": "lemma log_property_with_c:\n  fixes a b c :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"c > 0\"\n  shows \"log a (c * b) = log a c + log a b\"\nproof -\n  have \"log a (c * b) = log a c + log a b\" by (metis assms(1) assms(2) assms(3) assms(4) log_mult)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma log_property_with_c:\n  fixes a b c :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"b > 0\" \"c > 0\"\n  shows \"log a (c * b) = log a c + log a b\"\nproof -\n  have \"log a (c * b) = log a c + log a b\" by (metis assms(1) assms(2) assms(3) assms(4) log_mult)\n  then show ?thesis by simp\nqed", "origin": "log_property", "update_count": 0}, "multi_distrib_complex_general": {"skill_name": "multi_distrib_complex_general", "marker": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) * (e + f) = a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f\"\nproof -\n  have \"(a + b) * (c + d) * (e + f) = ((a + b) * (c + d)) * (e + f)\" by simp\n  also have \"... = (a * c + a * d + b * c + b * d) * (e + f)\" by (auto simp: field_simps)\n  also have \"... = (a * c + a * d + b * c + b * d) * e + (a * c + a * d + b * c + b * d) * f\" by (simp add: distrib_left)\n  also have \"... = (a * c * e + a * d * e + b * c * e + b * d * e) + (a * c * f + a * d * f + b * c * f + b * d * f)\" by (auto simp: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_general:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) * (e + f) = a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f\"\nproof -\n  have \"(a + b) * (c + d) * (e + f) = ((a + b) * (c + d)) * (e + f)\" by simp\n  also have \"... = (a * c + a * d + b * c + b * d) * (e + f)\" by (auto simp: field_simps)\n  also have \"... = (a * c + a * d + b * c + b * d) * e + (a * c + a * d + b * c + b * d) * f\" by (simp add: distrib_left)\n  also have \"... = (a * c * e + a * d * e + b * c * e + b * d * e) + (a * c * f + a * d * f + b * c * f + b * d * f)\" by (auto simp: field_simps)\n  finally show ?thesis by (auto simp: field_simps)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib_complex_advanced": {"skill_name": "multi_distrib_complex_advanced", "marker": "lemma multi_distrib_complex_advanced:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) * (e + f) = a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f\"\nproof -\n  have \"((a + b) * (c + d)) * (e + f) = (a * c + a * d + b * c + b * d) * (e + f)\"\n    by (auto simp: field_simps)\n  also have \"... = (a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f)\"\n    by (auto simp: field_simps)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_advanced:\n  fixes a b c d e f :: complex\n  shows \"(a + b) * (c + d) * (e + f) = a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f\"\nproof -\n  have \"((a + b) * (c + d)) * (e + f) = (a * c + a * d + b * c + b * d) * (e + f)\"\n    by (auto simp: field_simps)\n  also have \"... = (a * c * e + a * c * f + a * d * e + a * d * f + b * c * e + b * c * f + b * d * e + b * d * f)\"\n    by (auto simp: field_simps)\n  finally show ?thesis .\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "floor_add": {"skill_name": "floor_add", "marker": "lemma floor_add:\n  fixes x y :: real\n  shows \"floor (x + y) = floor x + floor y + (if (x + y) < (floor x + floor y) + 1 then 0 else 1)\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  have \"floor y \\<le> y\" by auto\n  have \"floor x + floor y \\<le> x + y\" by (simp add: add_mono)\n  moreover\n  have \"x < floor x + 1\" by auto\n  moreover\n  have \"y < floor y + 1\" by auto\n  ultimately have \"x + y < (floor x + floor y) + 2\" \n    by arith\n  show ?thesis\n  proof (cases \"x + y < floor x + floor y + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) floor_add floor_eq_iff linorder_not_less)\n  next\n    case False\n    then have \"floor x + floor y + 1 \\<le> x + y\" \n      by auto\n    then show ?thesis \n      by (smt (verit) False add.commute floor_add floor_less_iff less_add_one)\n  qed\nqed", "description": "-", "full_code": "lemma floor_add:\n  fixes x y :: real\n  shows \"floor (x + y) = floor x + floor y + (if (x + y) < (floor x + floor y) + 1 then 0 else 1)\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  have \"floor y \\<le> y\" by auto\n  have \"floor x + floor y \\<le> x + y\" by (simp add: add_mono)\n  moreover\n  have \"x < floor x + 1\" by auto\n  moreover\n  have \"y < floor y + 1\" by auto\n  ultimately have \"x + y < (floor x + floor y) + 2\" \n    by arith\n  show ?thesis\n  proof (cases \"x + y < floor x + floor y + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit) floor_add floor_eq_iff linorder_not_less)\n  next\n    case False\n    then have \"floor x + floor y + 1 \\<le> x + y\" \n      by auto\n    then show ?thesis \n      by (smt (verit) False add.commute floor_add floor_less_iff less_add_one)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "cal_log_exp_value_multi": {"skill_name": "cal_log_exp_value_multi", "marker": "lemma cal_log_exp_value_multi:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"m > 0\"\n  shows \"log a (a^(n+m)) = n + m\"\nproof -\n  have \"log a (a^(n+m)) = (n + m) * log a a\"\n    using log_nat_power[of a a \"n+m\"] by (metis assms(1) assms(2) add_nonneg_nonneg)\n  then show ?thesis \n    using assms(1) assms(2) by auto\nqed", "description": "-", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed\n\nlemma cal_log_exp_value_multi:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\" \"m > 0\"\n  shows \"log a (a^(n+m)) = n + m\"\nproof -\n  have \"log a (a^(n+m)) = (n + m) * log a a\"\n    using log_nat_power[of a a \"n+m\"] by (metis assms(1) assms(2) add_nonneg_nonneg)\n  then show ?thesis \n    using assms(1) assms(2) by auto\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "bounds_on_sumV4": {"skill_name": "bounds_on_sumV4", "marker": "lemma bounds_on_sum:\n  fixes n :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"0 \\<le> x \\<and> 0 \\<le> y\"\nproof -\n  have \"0 \\<le> x\" using assms(2) by auto\n  have \"0 \\<le> y\" using assms(3) by auto\n  show \"0 \\<le> x \\<and> 0 \\<le> y\" by auto\nqed", "description": "-", "full_code": "lemma bounds_on_sum:\n  fixes n :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"0 \\<le> x \\<and> 0 \\<le> y\"\nproof -\n  have \"0 \\<le> x\" using assms(2) by auto\n  have \"0 \\<le> y\" using assms(3) by auto\n  show \"0 \\<le> x \\<and> 0 \\<le> y\" by auto\nqed", "origin": "do_request", "update_count": 0}, "floor_sum": {"skill_name": "floor_sum", "marker": "lemma floor_sum:\n  fixes r :: real and k :: real\n  assumes \"n > 0\"\n  shows \"floor (r + k) = floor r + floor k + (if r + k < floor r + floor k + 1 then 0 else 1)\"\nproof -\n  have \"floor r \\<le> r\" by auto\n  have \"floor k \\<le> k\" by auto\n  have \"floor r + floor k \\<le> r + k\" by (simp add: add_mono)\n  moreover\n  have \"r < floor r + 1\" by auto\n  have \"k < floor k + 1\" by auto\n  ultimately have \"r + k < (floor r + floor k) + 2\" \n    by arith\n  show ?thesis\n  proof (cases \"r + k < floor r + floor k + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit, best) floor_add floor_eq_iff linorder_not_less)\n  next\n    case False\n    then have \"floor r + floor k + 1 \\<le> r + k\" \n      by auto\n    then show ?thesis \n      by (smt (verit, best) False add.commute floor_add floor_less_iff less_add_one)\n  qed\nqed", "description": "-", "full_code": "lemma floor_sum:\n  fixes r :: real and k :: real\n  assumes \"n > 0\"\n  shows \"floor (r + k) = floor r + floor k + (if r + k < floor r + floor k + 1 then 0 else 1)\"\nproof -\n  have \"floor r \\<le> r\" by auto\n  have \"floor k \\<le> k\" by auto\n  have \"floor r + floor k \\<le> r + k\" by (simp add: add_mono)\n  moreover\n  have \"r < floor r + 1\" by auto\n  have \"k < floor k + 1\" by auto\n  ultimately have \"r + k < (floor r + floor k) + 2\" \n    by arith\n  show ?thesis\n  proof (cases \"r + k < floor r + floor k + 1\")\n    case True\n    then show ?thesis \n      by (smt (verit, best) floor_add floor_eq_iff linorder_not_less)\n  next\n    case False\n    then have \"floor r + floor k + 1 \\<le> r + k\" \n      by auto\n    then show ?thesis \n      by (smt (verit, best) False add.commute floor_add floor_less_iff less_add_one)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_generalV2": {"skill_name": "cancel_div_generalV2", "marker": "lemma cancel_div_general:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(2) mult.commute nonzero_eq_divide_eq)\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma cancel_div_general:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" by (smt (verit) add_divide_eq_if_simps(1) assms(1) assms(2) mult.commute nonzero_eq_divide_eq)\n  then show ?thesis by sos\nqed", "origin": "cancle_div_general", "update_count": 0}, "non_negative_sums": {"skill_name": "non_negative_sums", "marker": "lemma non_negative_sums:\n  fixes a b :: nat\n  assumes \"a + b = n\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"0 \\<le> a \\<and> 0 \\<le> b\"\nproof -\n  from assms(2) have \"0 \\<le> a\" by simp\n  from assms(3) have \"0 \\<le> b\" by simp\n  show \"0 \\<le> a \\<and> 0 \\<le> b\" by (simp add: \\<open>0 \\<le> a\\<close> \\<open>0 \\<le> b\\<close>)\nqed", "description": "-", "full_code": "lemma non_negative_sums:\n  fixes a b :: nat\n  assumes \"a + b = n\" and \"a \\<ge> 0\" and \"b \\<ge> 0\"\n  shows \"0 \\<le> a \\<and> 0 \\<le> b\"\nproof -\n  from assms(2) have \"0 \\<le> a\" by simp\n  from assms(3) have \"0 \\<le> b\" by simp\n  show \"0 \\<le> a \\<and> 0 \\<le> b\" by (simp add: \\<open>0 \\<le> a\\<close> \\<open>0 \\<le> b\\<close>)\nqed", "origin": "bounds_on_sum", "update_count": 0}, "sum_of_naturals": {"skill_name": "sum_of_naturals", "marker": "lemma sum_of_naturals:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"(\\<Sum> i = 1..n. i) = n * (n + 1) div 2\"\nproof -\n  have \"(\\<Sum> i = 1..n. i) = n * (n + 1) div 2\" by (induction n) (auto)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_of_naturals:\n  fixes n :: nat\n  assumes \"n > 0\"\n  shows \"(\\<Sum> i = 1..n. i) = n * (n + 1) div 2\"\nproof -\n  have \"(\\<Sum> i = 1..n. i) = n * (n + 1) div 2\" by (induction n) (auto)\n  then show ?thesis by simp\nqed", "origin": "bounds_on_sum", "update_count": 0}, "non_negative_bounds": {"skill_name": "non_negative_bounds", "marker": "lemma non_negative_bounds:\n  fixes x y :: nat\n  assumes \"x + y = n\" and \"0 \\<le> x\" and \"0 \\<le> y\"\n  shows \"x \\<ge> 0 \\<and> y \\<ge> 0\"\nproof -\n  have \"0 \\<le> x\" using assms(2) by simp\n  have \"0 \\<le> y\" using assms(3) by simp\n  show \"x \\<ge> 0 \\<and> y \\<ge> 0\" by (simp add: \\<open>0 \\<le> x\\<close> \\<open>0 \\<le> y\\<close>)\nqed", "description": "-", "full_code": "lemma non_negative_bounds:\n  fixes x y :: nat\n  assumes \"x + y = n\" and \"0 \\<le> x\" and \"0 \\<le> y\"\n  shows \"x \\<ge> 0 \\<and> y \\<ge> 0\"\nproof -\n  have \"0 \\<le> x\" using assms(2) by simp\n  have \"0 \\<le> y\" using assms(3) by simp\n  show \"x \\<ge> 0 \\<and> y \\<ge> 0\" by (simp add: \\<open>0 \\<le> x\\<close> \\<open>0 \\<le> y\\<close>)\nqed", "origin": "bounds_on_sum", "update_count": 0}, "non_negative_bounds_multi": {"skill_name": "non_negative_bounds_multi", "marker": "lemma non_negative_bounds_multi:\n  fixes xs :: \"nat list\"\n  assumes \"sum_list xs = n\" and \"0 \\<le> n\"\n  shows \"\\<forall>x \\<in> set xs. x \\<ge> 0\"\nproof -\n  have \"\\<forall>x \\<in> set xs. x \\<ge> 0\" \n    by (induction xs) (auto simp: assms(2) sum_list_nonneg)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_negative_bounds_multi:\n  fixes xs :: \"nat list\"\n  assumes \"sum_list xs = n\" and \"0 \\<le> n\"\n  shows \"\\<forall>x \\<in> set xs. x \\<ge> 0\"\nproof -\n  have \"\\<forall>x \\<in> set xs. x \\<ge> 0\" \n    by (induction xs) (auto simp: assms(2) sum_list_nonneg)\n  then show ?thesis by simp\nqed", "origin": "non_negative_bounds", "update_count": 0}, "floor_function_properties": {"skill_name": "floor_function_properties", "marker": "lemma floor_function_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  then have \"floor x + 1 \\<le> x + 1\" by simp\n  moreover have \"x < floor x + 1\" by auto\n  ultimately have \"floor x + 1 < floor (x + 1) + 1\" \n    by auto\n  have \"floor (x + 1) \\<le> floor x + 1\" \n  proof -\n    have \"x + 1 < floor (x + 1) + 1\" \n      by arith\n    then show ?thesis \n      by auto\n  qed\n  thus ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma floor_function_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  then have \"floor x + 1 \\<le> x + 1\" by simp\n  moreover have \"x < floor x + 1\" by auto\n  ultimately have \"floor x + 1 < floor (x + 1) + 1\" \n    by auto\n  have \"floor (x + 1) \\<le> floor x + 1\" \n  proof -\n    have \"x + 1 < floor (x + 1) + 1\" \n      by arith\n    then show ?thesis \n      by auto\n  qed\n  thus ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "non_negative_bounds_on_sum": {"skill_name": "non_negative_bounds_on_sum", "marker": "lemma non_negative_bounds_on_sum:\n  fixes n :: nat and x y :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"0 \\<le> x \\<and> 0 \\<le> y\"\nproof -\n  have \"x \\<ge> 0\" using assms(2) by simp\n  have \"y \\<ge> 0\" using assms(3) by simp\n  show \"0 \\<le> x \\<and> 0 \\<le> y\" by (simp add: \\<open>x \\<ge> 0\\<close> \\<open>y \\<ge> 0\\<close>)\nqed", "description": "-", "full_code": "lemma non_negative_bounds_on_sum:\n  fixes n :: nat and x y :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"0 \\<le> x \\<and> 0 \\<le> y\"\nproof -\n  have \"x \\<ge> 0\" using assms(2) by simp\n  have \"y \\<ge> 0\" using assms(3) by simp\n  show \"0 \\<le> x \\<and> 0 \\<le> y\" by (simp add: \\<open>x \\<ge> 0\\<close> \\<open>y \\<ge> 0\\<close>)\nqed", "origin": "bounds_on_sum", "update_count": 0}, "non_negativity_of_sums": {"skill_name": "non_negativity_of_sums", "marker": "lemma non_negativity_of_sums:\n  fixes n :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"x \\<ge> 0 \\<and> y \\<ge> 0\"\nproof -\n  have \"x \\<ge> 0\" using assms(2) by simp\n  have \"y \\<ge> 0\" using assms(3) by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma non_negativity_of_sums:\n  fixes n :: nat\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"x \\<ge> 0 \\<and> y \\<ge> 0\"\nproof -\n  have \"x \\<ge> 0\" using assms(2) by simp\n  have \"y \\<ge> 0\" using assms(3) by simp\n  thus ?thesis by auto\nqed", "origin": "bounds_on_sum", "update_count": 0}, "non_negativity_of_sums_generalized": {"skill_name": "non_negativity_of_sums_generalized", "marker": "lemma non_negativity_of_sums_generalized:\n  fixes x y n :: real\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"n \\<ge> 0\"\nproof -\n  have \"x \\<ge> 0\" using assms(2) by simp\n  have \"y \\<ge> 0\" using assms(3) by simp\n  thus ?thesis using assms(1) by (metis assms(2) dual_order.trans le_add_same_cancel2)\nqed", "description": "-", "full_code": "lemma non_negativity_of_sums_generalized:\n  fixes x y n :: real\n  assumes \"x + y = n\" and \"x \\<ge> 0\" and \"y \\<ge> 0\"\n  shows \"n \\<ge> 0\"\nproof -\n  have \"x \\<ge> 0\" using assms(2) by simp\n  have \"y \\<ge> 0\" using assms(3) by simp\n  thus ?thesis using assms(1) by (metis assms(2) dual_order.trans le_add_same_cancel2)\nqed", "origin": "non_negativity_of_sums", "update_count": 0}, "basic_arithmetic_inequalities": {"skill_name": "basic_arithmetic_inequalities", "marker": "lemma basic_arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a \\<le> b\" and \"b \\<le> c\"\n  shows \"a \\<le> c\"\nproof -\n  have \"a \\<le> b\" using assms(1) by simp\n  have \"b \\<le> c\" using assms(2) by simp\n  then show \"a \\<le> c\" using `a \\<le> b` by (metis order_trans)\nqed", "description": "-", "full_code": "lemma basic_arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a \\<le> b\" and \"b \\<le> c\"\n  shows \"a \\<le> c\"\nproof -\n  have \"a \\<le> b\" using assms(1) by simp\n  have \"b \\<le> c\" using assms(2) by simp\n  then show \"a \\<le> c\" using `a \\<le> b` by (metis order_trans)\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_generalized": {"skill_name": "cancel_div_generalized", "marker": "lemma cancel_div_generalized:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then show ?thesis \n    by (smt (verit) assms(1) add_divide_eq_if_simps(1) mult.commute nonzero_eq_divide_eq)\nqed", "description": "-", "full_code": "lemma cancel_div_generalized:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then show ?thesis \n    by (smt (verit) assms(1) add_divide_eq_if_simps(1) mult.commute nonzero_eq_divide_eq)\nqed", "origin": "cancel_div_generalV2", "update_count": 0}, "cancel_div_generalizedV2": {"skill_name": "cancel_div_generalizedV2", "marker": "lemma cancel_div_generalized:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" using assms(1) by sos\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma cancel_div_generalized:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then have \"x * a + b = c * x\" using assms(1) by sos\n  then show ?thesis by sos\nqed", "origin": "cancel_div_generalV2", "update_count": 0}, "basic_arithmetic_inequalitiesV2": {"skill_name": "basic_arithmetic_inequalitiesV2", "marker": "lemma basic_arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a \\<le> b\" and \"b \\<le> c\"\n  shows \"a \\<le> c\"\nproof -\n  have \"a < c \\<or> a = c\" \n    using assms(1) assms(2) by auto\n  thus ?thesis\n    using le_cases by fastforce\nqed", "description": "-", "full_code": "lemma basic_arithmetic_inequalities:\n  fixes a b c :: real\n  assumes \"a \\<le> b\" and \"b \\<le> c\"\n  shows \"a \\<le> c\"\nproof -\n  have \"a < c \\<or> a = c\" \n    using assms(1) assms(2) by auto\n  thus ?thesis\n    using le_cases by fastforce\nqed", "origin": "do_request", "update_count": 0}, "log_of_power_generalized": {"skill_name": "log_of_power_generalized", "marker": "lemma log_of_power_generalized:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then show ?thesis \n    by (simp add: assms(1) assms(2) log_def)\nqed", "description": "-", "full_code": "lemma log_of_power_generalized:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then show ?thesis \n    by (simp add: assms(1) assms(2) log_def)\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "floor_function_propertiesV2": {"skill_name": "floor_function_propertiesV2", "marker": "lemma floor_function_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  then have \"floor x + 1 \\<le> x + 1\" by (simp add: add_le_mono)\n  moreover have \"x < floor x + 1\" by auto\n  ultimately have \"floor x + 1 < floor (x + 1) + 1\" \n    by (simp add: add_less_mono)\n  have \"floor (x + 1) \\<le> floor x + 1\" \n  proof -\n    have \"x + 1 < floor (x + 1) + 1\" \n      by arith\n    then show ?thesis \n      by (simp add: add_le_mono)\n  qed\n  thus ?thesis \n    by auto\nqed", "description": "-", "full_code": "lemma floor_function_properties:\n  fixes x :: real\n  shows \"floor (x + 1) = floor x + 1\"\nproof -\n  have \"floor x \\<le> x\" by auto\n  then have \"floor x + 1 \\<le> x + 1\" by (simp add: add_le_mono)\n  moreover have \"x < floor x + 1\" by auto\n  ultimately have \"floor x + 1 < floor (x + 1) + 1\" \n    by (simp add: add_less_mono)\n  have \"floor (x + 1) \\<le> floor x + 1\" \n  proof -\n    have \"x + 1 < floor (x + 1) + 1\" \n      by arith\n    then show ?thesis \n      by (simp add: add_le_mono)\n  qed\n  thus ?thesis \n    by auto\nqed", "origin": "do_request", "update_count": 0}, "linear_combination": {"skill_name": "linear_combination", "marker": "lemma linear_combination:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"c * x = a * x + b\"\n  shows \"b = c * x - a * x\"\nproof -\n  have \"c * x - a * x = b\" using assms(2) by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma linear_combination:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"c * x = a * x + b\"\n  shows \"b = c * x - a * x\"\nproof -\n  have \"c * x - a * x = b\" using assms(2) by simp\n  then show ?thesis by simp\nqed", "origin": "cancel_div_generalizedV2", "update_count": 0}, "floor_distribution": {"skill_name": "floor_distribution", "marker": "lemma floor_distribution:\n  fixes n :: nat and r :: real\n  assumes \"n = floor r\" \"n + 1 = floor (r + 1)\"\n  shows \"n + 1 - n = 1\"\nproof -\n  from assms have \"n + 1 - n = 1\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma floor_distribution:\n  fixes n :: nat and r :: real\n  assumes \"n = floor r\" \"n + 1 = floor (r + 1)\"\n  shows \"n + 1 - n = 1\"\nproof -\n  from assms have \"n + 1 - n = 1\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "floor_distributionV2": {"skill_name": "floor_distributionV2", "marker": "lemma floor_distribution:\n  fixes n :: nat and r :: real\n  assumes \"n = floor r\" \"n + 1 = floor (r + 1)\"\n  shows \"n + 1 - n = 1\"\nproof -\n  from assms(1) have \"n \\<le> r\" by arith\n  from assms(2) have \"n + 1 \\<le> r + 1\" by arith\n  from assms(2) have \"r + 1 < floor (r + 1) + 1\" by arith\n  hence \"r + 1 < (n + 1) + 1\" using assms(2) by (simp add: floor_eq_iff)\n  then have \"r < n + 1\" using `n + 1 \\<le> r + 1` by linarith\n  have \"n < n + 1\" by simp\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma floor_distribution:\n  fixes n :: nat and r :: real\n  assumes \"n = floor r\" \"n + 1 = floor (r + 1)\"\n  shows \"n + 1 - n = 1\"\nproof -\n  from assms(1) have \"n \\<le> r\" by arith\n  from assms(2) have \"n + 1 \\<le> r + 1\" by arith\n  from assms(2) have \"r + 1 < floor (r + 1) + 1\" by arith\n  hence \"r + 1 < (n + 1) + 1\" using assms(2) by (simp add: floor_eq_iff)\n  then have \"r < n + 1\" using `n + 1 \\<le> r + 1` by linarith\n  have \"n < n + 1\" by simp\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "floor_distributionV3": {"skill_name": "floor_distributionV3", "marker": "lemma floor_distribution:\n  fixes n :: nat\n  assumes \"n = floor r\" \"n + 1 = floor (r + 1)\"\n  shows \"n + 1 - n = 1\"\nproof -\n  have \"n + 1 - n = 1\" \n    by (simp add: algebra_simps)  \n  thus ?thesis\n    by simp\nqed", "description": "-", "full_code": "lemma floor_distribution:\n  fixes n :: nat\n  assumes \"n = floor r\" \"n + 1 = floor (r + 1)\"\n  shows \"n + 1 - n = 1\"\nproof -\n  have \"n + 1 - n = 1\" \n    by (simp add: algebra_simps)  \n  thus ?thesis\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "sum_terms_count": {"skill_name": "sum_terms_count", "marker": "lemma sum_terms_count:\n  fixes n :: nat\n  assumes \"n = 91 - 19 + 1\"\n  shows \"n = 73\"\nproof -\n  show ?thesis by (simp add: assms)\nqed", "description": "", "full_code": "lemma sum_terms_count:\n  fixes n :: nat\n  assumes \"n = 91 - 19 + 1\"\n  shows \"n = 73\"\nproof -\n  show ?thesis by (simp add: assms)\nqed", "origin": "data/full_data/debug/valid_rand/aime_1991_p6.json_v14", "update_count": -1}, "term_distribution": {"skill_name": "term_distribution", "marker": "lemma term_distribution:\n  fixes n x :: nat\n  assumes \"x = 35\"\n  shows \"38 = 73 - x\"\nproof -\n  have \"73 - x = 73 - 35\" using assms by simp\n  also have \"... = 38\" by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma term_distribution:\n  fixes n x :: nat\n  assumes \"x = 35\"\n  shows \"38 = 73 - x\"\nproof -\n  have \"73 - x = 73 - 35\" using assms by simp\n  also have \"... = 38\" by simp\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "rearrange_equation": {"skill_name": "rearrange_equation", "marker": "lemma rearrange_equation:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a * x + b = c * x\"\n  shows \"a + b / x = c\"\nproof -\n  have \"a * x + b = c * x\" using assms(2) by auto\n  then show ?thesis \n    by (metis assms(1) add_divide_eq_if_simps(1) nonzero_eq_divide_eq)\nqed", "description": "-", "full_code": "lemma rearrange_equation:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a * x + b = c * x\"\n  shows \"a + b / x = c\"\nproof -\n  have \"a * x + b = c * x\" using assms(2) by auto\n  then show ?thesis \n    by (metis assms(1) add_divide_eq_if_simps(1) nonzero_eq_divide_eq)\nqed", "origin": "cancel_div_generalized", "update_count": 0}, "cancel_div_generalizedV3": {"skill_name": "cancel_div_generalizedV3", "marker": "lemma cancel_div_generalized:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x - b = (a + b / x) * x - b\" using assms(2) by auto\n  then have \"c * x - b = a * x + b - b\" by (metis add_cancel_left_right assms(1) assms(2) cancel_div diff_self eq_diff_eq' frac_eq_eq group_cancel.sub1)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancel_div:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then show ?thesis \n    by (smt (verit) assms(1) add_divide_eq_if_simps(1) mult.commute nonzero_eq_divide_eq)\nqed\n\nlemma cancel_div_generalized:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x - b = (a + b / x) * x - b\" using assms(2) by auto\n  then have \"c * x - b = a * x + b - b\" by (metis add_cancel_left_right assms(1) assms(2) cancel_div diff_self eq_diff_eq' frac_eq_eq group_cancel.sub1)\n  thus ?thesis by simp\nqed", "origin": "cancel_div_generalized", "update_count": 0}, "linear_combinationV2": {"skill_name": "linear_combinationV2", "marker": "lemma linear_combination:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using cancel_div_generalized assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cancel_div_generalized:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\" using assms(2) by auto\n  then show ?thesis \n    by (smt (verit) assms(1) add_divide_eq_if_simps(1) mult.commute nonzero_eq_divide_eq)\nqed\n\nlemma linear_combination:\n  fixes x a b c :: real\n  assumes \"x \\<noteq> 0\" \"a + b / x = c\"\n  shows \"c * x - b = a * x\"\nproof -\n  have \"c * x = a * x + b\" using cancel_div_generalized assms by simp\n  then show ?thesis by simp\nqed", "origin": "cancel_div_generalized", "update_count": 0}, "sum_terms_count_n": {"skill_name": "sum_terms_count_n", "marker": "lemma sum_terms_count_n:\n  fixes n :: nat\n  assumes \"n = m - k + 1\"\n  shows \"n = (m - k + 1)\"\n  using assms by simp", "description": "-", "full_code": "lemma sum_terms_count_n:\n  fixes n :: nat\n  assumes \"n = m - k + 1\"\n  shows \"n = (m - k + 1)\"\n  using assms by simp", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_multi": {"skill_name": "sum_terms_count_multi", "marker": "lemma sum_terms_count_multi:\n  fixes n m :: nat\n  assumes \"m = b - a + 1\" and \"a \\<le> b\"\n  shows \"m = b - a + 1\"\nproof -\n  show ?thesis by (simp add: assms)\nqed", "description": "-", "full_code": "lemma sum_terms_count_multi:\n  fixes n m :: nat\n  assumes \"m = b - a + 1\" and \"a \\<le> b\"\n  shows \"m = b - a + 1\"\nproof -\n  show ?thesis by (simp add: assms)\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_extended": {"skill_name": "sum_terms_count_extended", "marker": "lemma sum_terms_count_extended:\n  fixes n :: nat and m :: nat\n  assumes \"n = m - 19 + 1\" and \"m > 19\"\n  shows \"n = m - 18\"\nproof -\n  have \"n = m - 19 + 1\" by (simp add: assms)\n  then show ?thesis by (metis Suc_diff_Suc Suc_eq_plus1 Suc_lessD assms(2) diff_Suc_1 eval_nat_numeral(3) numeral_One)\nqed", "description": "-", "full_code": "lemma sum_terms_count_extended:\n  fixes n :: nat and m :: nat\n  assumes \"n = m - 19 + 1\" and \"m > 19\"\n  shows \"n = m - 18\"\nproof -\n  have \"n = m - 19 + 1\" by (simp add: assms)\n  then show ?thesis by (metis Suc_diff_Suc Suc_eq_plus1 Suc_lessD assms(2) diff_Suc_1 eval_nat_numeral(3) numeral_One)\nqed", "origin": "sum_terms_count", "update_count": 0}, "count_terms_in_range": {"skill_name": "count_terms_in_range", "marker": "lemma count_terms_in_range:\n  fixes a b :: nat\n  assumes \"a \\<le> b\"\n  shows \"b - a + 1 = (b - a + 1)\"\nproof -\n  have \"b - a + 1 = (b - a + 1)\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms_in_range:\n  fixes a b :: nat\n  assumes \"a \\<le> b\"\n  shows \"b - a + 1 = (b - a + 1)\"\nproof -\n  have \"b - a + 1 = (b - a + 1)\" by simp\n  thus ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_countV2": {"skill_name": "sum_terms_countV2", "marker": "lemma sum_terms_count:\n  fixes n :: nat\n  assumes \"n = b - a + 1\" \n  and \"a = 19\" \n  and \"b = 91\"\n  shows \"n = 73\"\nproof -\n  have \"n = 91 - 19 + 1\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count:\n  fixes n :: nat\n  assumes \"n = b - a + 1\" \n  and \"a = 19\" \n  and \"b = 91\"\n  shows \"n = 73\"\nproof -\n  have \"n = 91 - 19 + 1\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "rearrangement": {"skill_name": "rearrangement", "marker": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"73 * n + 73 = 546\" using assms by simp\n  then have \"73 * n = 546 - 73\" by (simp add: algebra_simps)\n  then have \"73 * n = 473\" by simp\n  then show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"73 * n + 73 = 546\" using assms by simp\n  then have \"73 * n = 546 - 73\" by (simp add: algebra_simps)\n  then have \"73 * n = 473\" by simp\n  then show ?thesis by presburger\nqed", "origin": "do_request", "update_count": 0}, "rearrangementV2": {"skill_name": "rearrangementV2", "marker": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"x + 73 * n + 73 - x = 546\" using assms by simp\n  then have \"73 * n + 73 = 546\" by (simp add: algebra_simps)\n  then have \"73 * n = 546 - 73\" by (simp add: algebra_simps)\n  also have \"... = 473\" by simp\n  finally show ?thesis by presburger\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"x + 73 * n + 73 - x = 546\" using assms by simp\n  then have \"73 * n + 73 = 546\" by (simp add: algebra_simps)\n  then have \"73 * n = 546 - 73\" by (simp add: algebra_simps)\n  also have \"... = 473\" by simp\n  finally show ?thesis by presburger\nqed", "origin": "do_request", "update_count": 0}, "rearrangementV3": {"skill_name": "rearrangementV3", "marker": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"73 * n + 73 = 546\" using assms by simp\n  then have \"73 * n = 546 - 73\" by simp\n  also have \"546 - 73 = 473\" by (smt (verit) \\<open>73 * n + 73 = 546\\<close>)\n  finally have \"73 * n = 473\" by simp\n  then show \"73 * n - x = 473\" by presburger\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"73 * n + 73 = 546\" using assms by simp\n  then have \"73 * n = 546 - 73\" by simp\n  also have \"546 - 73 = 473\" by (smt (verit) \\<open>73 * n + 73 = 546\\<close>)\n  finally have \"73 * n = 473\" by simp\n  then show \"73 * n - x = 473\" by presburger\nqed", "origin": "do_request", "update_count": 0}, "sum_terms_count_general": {"skill_name": "sum_terms_count_general", "marker": "lemma sum_terms_count_general:\n  fixes a b :: nat\n  assumes \"b \\<ge> a\"\n  shows \"b - a + 1 = (card {a .. b})\"\nproof -\n  have \"card {a .. b} = b - a + 1\" by (metis Suc_diff_le Suc_eq_plus1 assms card_atLeastAtMost)\n  thus ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count_general:\n  fixes a b :: nat\n  assumes \"b \\<ge> a\"\n  shows \"b - a + 1 = (card {a .. b})\"\nproof -\n  have \"card {a .. b} = b - a + 1\" by (metis Suc_diff_le Suc_eq_plus1 assms card_atLeastAtMost)\n  thus ?thesis using assms by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_generalV2": {"skill_name": "sum_terms_count_generalV2", "marker": "lemma sum_terms_count_general:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"b - a + 1 = (b - a + 1)\"\nproof -\n  show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count_general:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"b - a + 1 = (b - a + 1)\"\nproof -\n  show ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_countV3": {"skill_name": "sum_terms_countV3", "marker": "lemma sum_terms_count:\n  fixes a b :: nat\n  assumes \"b = 91\" \"a = 19\"\n  shows \"b - a + 1 = 73\"\nproof -\n  have \"b - a + 1 = 91 - 19 + 1\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count:\n  fixes a b :: nat\n  assumes \"b = 91\" \"a = 19\"\n  shows \"b - a + 1 = 73\"\nproof -\n  have \"b - a + 1 = 91 - 19 + 1\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_extendedV2": {"skill_name": "sum_terms_count_extendedV2", "marker": "lemma sum_terms_count_extended:\n  fixes n d :: nat\n  assumes \"n = d - 19 + 1\" and \"d > 19\"\n  shows \"n = d - 18\"\nproof -\n  have \"d - 19 + 1 = d - 18\" using assms by simp\n  then show ?thesis by (metis assms(1) inc.simps(1))\nqed", "description": "-", "full_code": "lemma sum_terms_count_extended:\n  fixes n d :: nat\n  assumes \"n = d - 19 + 1\" and \"d > 19\"\n  shows \"n = d - 18\"\nproof -\n  have \"d - 19 + 1 = d - 18\" using assms by simp\n  then show ?thesis by (metis assms(1) inc.simps(1))\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_generalized": {"skill_name": "sum_terms_count_generalized", "marker": "lemma sum_terms_count_generalized:\n  fixes n a b c :: nat\n  assumes \"n = a - b + c\"\n  shows \"n = (a - b + c)\"\nproof -\n  show ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count_generalized:\n  fixes n a b c :: nat\n  assumes \"n = a - b + c\"\n  shows \"n = (a - b + c)\"\nproof -\n  show ?thesis using assms by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "count_terms_general": {"skill_name": "count_terms_general", "marker": "lemma count_terms_general:\n  fixes a b c :: nat\n  assumes \"a + b + 1 = c\"\n  shows \"c = a + b + 1\"\nproof -\n  have \"c = a + b + 1\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms_general:\n  fixes a b c :: nat\n  assumes \"a + b + 1 = c\"\n  shows \"c = a + b + 1\"\nproof -\n  have \"c = a + b + 1\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_extendedV3": {"skill_name": "sum_terms_count_extendedV3", "marker": "lemma sum_terms_count_extended:\n  fixes m n k :: nat\n  assumes \"m = 91\" \"n = 19\" \"k = 1\"\n  shows \"m - n + k = 73\"\nproof -\n  have \"m - n + k = 91 - 19 + 1\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count_extended:\n  fixes m n k :: nat\n  assumes \"m = 91\" \"n = 19\" \"k = 1\"\n  shows \"m - n + k = 73\"\nproof -\n  have \"m - n + k = 91 - 19 + 1\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "lower_bound_n": {"skill_name": "lower_bound_n", "marker": "lemma lower_bound_n:\n  fixes n :: int\n  shows \"73 * n - 473 \\<ge> 0 \\<longleftrightarrow> n \\<ge> 7\"\nproof -\n  have \"73 * n - 473 \\<ge> 0 \\<longleftrightarrow> 73 * n \\<ge> 473\" by simp\n  also have \"73 * n \\<ge> 473 \\<longleftrightarrow> n \\<ge> 473 / 73\" by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma lower_bound_n:\n  fixes n :: int\n  shows \"73 * n - 473 \\<ge> 0 \\<longleftrightarrow> n \\<ge> 7\"\nproof -\n  have \"73 * n - 473 \\<ge> 0 \\<longleftrightarrow> 73 * n \\<ge> 473\" by simp\n  also have \"73 * n \\<ge> 473 \\<longleftrightarrow> n \\<ge> 473 / 73\" by auto\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "rearrangementV4": {"skill_name": "rearrangementV4", "marker": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"x + 73 * n + 73 - x = 546\" using assms by simp\n  then have \"73 * n + 73 = 546\" by simp\n  then have \"73 * n = 546 - 73\" by (simp add: algebra_simps)\n  also have \"546 - 73 = 473\" by (smt (verit) \\<open>73 * n + 73 = 546\\<close>)\n  finally have \"73 * n = 473\" by simp\n  show \"73 * n - x = 473\" by (smt (verit) \\<open>73 * n = 473\\<close>)\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"x + 73 * n + 73 - x = 546\" using assms by simp\n  then have \"73 * n + 73 = 546\" by simp\n  then have \"73 * n = 546 - 73\" by (simp add: algebra_simps)\n  also have \"546 - 73 = 473\" by (smt (verit) \\<open>73 * n + 73 = 546\\<close>)\n  finally have \"73 * n = 473\" by simp\n  show \"73 * n - x = 473\" by (smt (verit) \\<open>73 * n = 473\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "sum_terms_countV4": {"skill_name": "sum_terms_countV4", "marker": "lemma sum_terms_count:\n  fixes a b :: nat\n  assumes \"b = 92\" and \"a = 19\"\n  shows \"(\\<Sum> k \\<in> {a..<b}. 1) = b - a\"\nproof -\n  have \"b - a = 92 - 19\" by (metis assms(1) assms(2))\n  also have \"... = 73\" by simp\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma sum_terms_count:\n  fixes a b :: nat\n  assumes \"b = 92\" and \"a = 19\"\n  shows \"(\\<Sum> k \\<in> {a..<b}. 1) = b - a\"\nproof -\n  have \"b - a = 92 - 19\" by (metis assms(1) assms(2))\n  also have \"... = 73\" by simp\n  finally show ?thesis by auto\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_generalizedV2": {"skill_name": "sum_terms_count_generalizedV2", "marker": "lemma sum_terms_count_generalized:\n  fixes a b c :: nat\n  assumes \"a = 91\" \"b = 19\" \"c = 1\"\n  shows \"a - b + c = 73\"\nproof -\n  have \"a - b + c = 91 - 19 + 1\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count_generalized:\n  fixes a b c :: nat\n  assumes \"a = 91\" \"b = 19\" \"c = 1\"\n  shows \"a - b + c = 73\"\nproof -\n  have \"a - b + c = 91 - 19 + 1\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_evolved": {"skill_name": "sum_terms_count_evolved", "marker": "lemma sum_terms_count_evolved:\n  fixes n m :: nat\n  assumes \"n = m - 19 + 1\" \"m = 91\"\n  shows \"n = 73\"\nproof -\n  have \"n = 91 - 19 + 1\" using assms(1) assms(2) by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count_evolved:\n  fixes n m :: nat\n  assumes \"n = m - 19 + 1\" \"m = 91\"\n  shows \"n = 73\"\nproof -\n  have \"n = 91 - 19 + 1\" using assms(1) assms(2) by simp\n  thus ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "rearrangementV5": {"skill_name": "rearrangementV5", "marker": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"73 * n + 73 = 546\" using assms by simp\n  then have \"73 * n = 546 - 73\" by simp\n  then have \"73 * n = 473\" by simp\n  show \"73 * n - x = 473\" by (smt (verit) \\<open>73 * n = 473\\<close>)\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"73 * n + 73 = 546\" using assms by simp\n  then have \"73 * n = 546 - 73\" by simp\n  then have \"73 * n = 473\" by simp\n  show \"73 * n - x = 473\" by (smt (verit) \\<open>73 * n = 473\\<close>)\nqed", "origin": "do_request", "update_count": 0}, "rearrangementV6": {"skill_name": "rearrangementV6", "marker": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"x + 73 * n + 73 - x = 546\" using assms by simp\n  then have \"73 * n + 73 = 546\" by simp\n  then have \"73 * n = 546 - 73\" by simp\n  also have \"... = 473\" by simp\n  finally have \"73 * n = 473\" by simp\n  then show \"73 * n - x = 473\" by presburger\nqed", "description": "-", "full_code": "lemma rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"73 * n - x = 473\"\nproof -\n  have \"x + 73 * n + 73 - x = 546\" using assms by simp\n  then have \"73 * n + 73 = 546\" by simp\n  then have \"73 * n = 546 - 73\" by simp\n  also have \"... = 473\" by simp\n  finally have \"73 * n = 473\" by simp\n  then show \"73 * n - x = 473\" by presburger\nqed", "origin": "do_request", "update_count": 0}, "sum_terms_count_extendedV4": {"skill_name": "sum_terms_count_extendedV4", "marker": "lemma sum_terms_count_extended:\n  fixes n m :: nat\n  assumes \"n + m = 91 - 19 + 1\" \n  shows \"n + m = 73\"\n  and \"m = 73 - n\"\nproof -\n  show \"n + m = 73\" using assms by (simp)\n  show \"m = 73 - n\" by (metis \\<open>n + m = 73\\<close> add_diff_cancel_left')\nqed", "description": "-", "full_code": "lemma sum_terms_count_extended:\n  fixes n m :: nat\n  assumes \"n + m = 91 - 19 + 1\" \n  shows \"n + m = 73\"\n  and \"m = 73 - n\"\nproof -\n  show \"n + m = 73\" using assms by (simp)\n  show \"m = 73 - n\" by (metis \\<open>n + m = 73\\<close> add_diff_cancel_left')\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_terms_count_extendedV5": {"skill_name": "sum_terms_count_extendedV5", "marker": "lemma sum_terms_count_extended:\n  fixes n m :: nat\n  assumes \"n = m + 1\" \"m = 91 - 19\"\n  shows \"n = 73\"\nproof -\n  have \"m = 91 - 19\" using assms(2) by simp\n  hence \"m = 72\" by simp\n  then show ?thesis using assms(1) by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count_extended:\n  fixes n m :: nat\n  assumes \"n = m + 1\" \"m = 91 - 19\"\n  shows \"n = 73\"\nproof -\n  have \"m = 91 - 19\" using assms(2) by simp\n  hence \"m = 72\" by simp\n  then show ?thesis using assms(1) by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "floor_rational": {"skill_name": "floor_rational", "marker": "lemma floor_rational:\n  fixes r :: real\n  assumes \"r = a / b\" and \"b > 0\"\n  shows \"floor r = floor a div b\"\nproof -\n  have \"r = a / b\" by (rule assms(1))\n  then have \"floor r * b \\<le> a\" using assms(2) by (auto simp: field_simps)\n  then have \"floor a div b \\<le> floor r\" using assms(2) by (smt (verit) assms(1) dual_order.eq_iff floor_divide_real_eq_div leD mult_less_cancel_right)\n  then show \"floor r = floor a div b\" by (smt (verit) assms(1) assms(2) floor_divide_real_eq_div nless_le)\nqed", "description": "-", "full_code": "lemma floor_rational:\n  fixes r :: real\n  assumes \"r = a / b\" and \"b > 0\"\n  shows \"floor r = floor a div b\"\nproof -\n  have \"r = a / b\" by (rule assms(1))\n  then have \"floor r * b \\<le> a\" using assms(2) by (auto simp: field_simps)\n  then have \"floor a div b \\<le> floor r\" using assms(2) by (smt (verit) assms(1) dual_order.eq_iff floor_divide_real_eq_div leD mult_less_cancel_right)\n  then show \"floor r = floor a div b\" by (smt (verit) assms(1) assms(2) floor_divide_real_eq_div nless_le)\nqed", "origin": "do_request", "update_count": 0}, "sum_floor_function": {"skill_name": "sum_floor_function", "marker": "lemma sum_floor_function:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\nproof -\n  have \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\" using assms by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_floor_function:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\nproof -\n  have \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\" using assms by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "count_range_terms": {"skill_name": "count_range_terms", "marker": "lemma count_range_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"b - a + 1 = card {a..b}\"\nproof -\n  have \"b - a + 1 = length [x. x \\<leftarrow> [a..b]]\" by (smt (verit) assms ceiling_less_one ceiling_one int_ops(2) int_ops(6) length_upto less_numeral_extra(3) list.map_ident nat_diff_split nat_less_as_int nat_plus_as_int zero_less_diff)\n  also have \"... = card {a..b}\" by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_range_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"b - a + 1 = card {a..b}\"\nproof -\n  have \"b - a + 1 = length [x. x \\<leftarrow> [a..b]]\" by (smt (verit) assms ceiling_less_one ceiling_one int_ops(2) int_ops(6) length_upto less_numeral_extra(3) list.map_ident nat_diff_split nat_less_as_int nat_plus_as_int zero_less_diff)\n  also have \"... = card {a..b}\" by simp\n  finally show ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_floor_functionV2": {"skill_name": "sum_floor_functionV2", "marker": "lemma sum_floor_function:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\nproof -\n  show ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma sum_floor_function:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"(\\<Sum> k \\<in> {19::nat..<92}. (floor (r + k / 100))) = 546\"\nproof -\n  show ?thesis using assms by simp\nqed", "origin": "do_request", "update_count": 0}, "inequality_manipulation": {"skill_name": "inequality_manipulation", "marker": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a \\<le> b\" and \"b \\<le> c\"\n  shows \"a \\<le> c\"\nproof -\n  from assms(1) and assms(2) have \"a < c \\<or> a = c\" \n    by auto\n  thus ?thesis\n    using le_cases by fastforce\nqed", "description": "-", "full_code": "lemma inequality_manipulation:\n  fixes a b c :: real\n  assumes \"a \\<le> b\" and \"b \\<le> c\"\n  shows \"a \\<le> c\"\nproof -\n  from assms(1) and assms(2) have \"a < c \\<or> a = c\" \n    by auto\n  thus ?thesis\n    using le_cases by fastforce\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_property": {"skill_name": "floor_sum_property", "marker": "lemma floor_sum_property:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b then 1 else 0)\"\nproof -\n  have \"floor a \\<le> a\" by auto\n  have \"floor b \\<le> b\" by auto\n  have \"floor a + floor b \\<le> a + b\" by (simp add: add_mono)\n  have \"a < floor a + 1\" by auto\n  have \"b < floor b + 1\" by auto\n  then have \"a + b < (floor a + 1) + (floor b + 1)\" \n    by (simp add: add_less_mono)\n  thus \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b then 1 else 0)\"\n  proof (cases \"a + b < floor a + floor b\")\n    case True\n    then have \"floor (a + b) = floor a + floor b - 1\" \n      by auto\n    thus ?thesis \n      using True by simp\n  next\n    case False\n    then have \"floor (a + b) = floor a + floor b\" \n      by auto\n    thus ?thesis \n      using False by simp\n  qed\nqed", "description": "-", "full_code": "lemma floor_sum_property:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b then 1 else 0)\"\nproof -\n  have \"floor a \\<le> a\" by auto\n  have \"floor b \\<le> b\" by auto\n  have \"floor a + floor b \\<le> a + b\" by (simp add: add_mono)\n  have \"a < floor a + 1\" by auto\n  have \"b < floor b + 1\" by auto\n  then have \"a + b < (floor a + 1) + (floor b + 1)\" \n    by (simp add: add_less_mono)\n  thus \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b then 1 else 0)\"\n  proof (cases \"a + b < floor a + floor b\")\n    case True\n    then have \"floor (a + b) = floor a + floor b - 1\" \n      by auto\n    thus ?thesis \n      using True by simp\n  next\n    case False\n    then have \"floor (a + b) = floor a + floor b\" \n      by auto\n    thus ?thesis \n      using False by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "floor_sum_propertyV2": {"skill_name": "floor_sum_propertyV2", "marker": "lemma floor_sum_property:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b then 1 else 0)\"\nproof -\n  have \"floor a \\<le> a\" by auto\n  have \"floor b \\<le> b\" by auto\n  have \"floor a + floor b \\<le> a + b\" by (simp add: add_mono)\n  moreover have \"a < floor a + 1\" by auto\n  moreover have \"b < floor b + 1\" by auto\n  ultimately have \"a + b < (floor a + floor b) + 2\" \n    by arith\n  have \"floor (a + b) \\<le> a + b\" by auto\n  show ?thesis\n  proof (cases \"a + b < floor a + floor b\")\n    case True\n    then have \"floor (a + b) = floor a + floor b - 1\" \n      by auto\n    then show ?thesis \n      by (simp add: True)\n  next\n    case False\n    then have \"floor (a + b) = floor a + floor b\" \n      using `floor (a + b) \\<le> a + b` `a + b < (floor a + floor b) + 2` by auto\n    then show ?thesis \n      by (simp add: False)\n  qed\nqed", "description": "-", "full_code": "lemma floor_sum_property:\n  fixes r :: real\n  assumes \"a < b\"\n  shows \"floor a + floor b = floor (a + b) + (if a + b < floor a + floor b then 1 else 0)\"\nproof -\n  have \"floor a \\<le> a\" by auto\n  have \"floor b \\<le> b\" by auto\n  have \"floor a + floor b \\<le> a + b\" by (simp add: add_mono)\n  moreover have \"a < floor a + 1\" by auto\n  moreover have \"b < floor b + 1\" by auto\n  ultimately have \"a + b < (floor a + floor b) + 2\" \n    by arith\n  have \"floor (a + b) \\<le> a + b\" by auto\n  show ?thesis\n  proof (cases \"a + b < floor a + floor b\")\n    case True\n    then have \"floor (a + b) = floor a + floor b - 1\" \n      by auto\n    then show ?thesis \n      by (simp add: True)\n  next\n    case False\n    then have \"floor (a + b) = floor a + floor b\" \n      using `floor (a + b) \\<le> a + b` `a + b < (floor a + floor b) + 2` by auto\n    then show ?thesis \n      by (simp add: False)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sum_terms_count_extendedV6": {"skill_name": "sum_terms_count_extendedV6", "marker": "lemma sum_terms_count_extended:\n  fixes n :: nat\n  assumes \"n = a - b + 1\" \"a = 91\" \"b = 19\"\n  shows \"n = 73\"\nproof -\n  have \"n = 91 - 19 + 1\" using assms(1) assms(2) assms(3) by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_terms_count_extended:\n  fixes n :: nat\n  assumes \"n = a - b + 1\" \"a = 91\" \"b = 19\"\n  shows \"n = 73\"\nproof -\n  have \"n = 91 - 19 + 1\" using assms(1) assms(2) assms(3) by auto\n  then show ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "case_analysis_terms": {"skill_name": "case_analysis_terms", "marker": "lemma case_analysis_terms:\n  fixes n m :: nat\n  assumes \"m + 73 - m = 546\"\n  shows \"m = 546 - 73 * n\"\nproof -\n  have \"73 = 546\" using assms by simp\n  then have \"m + 73 - m = 546\" by (metis assms)\n  then have \"73 = 546\" by (simp add: assms)\n  thus ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma case_analysis_terms:\n  fixes n m :: nat\n  assumes \"m + 73 - m = 546\"\n  shows \"m = 546 - 73 * n\"\nproof -\n  have \"73 = 546\" using assms by simp\n  then have \"m + 73 - m = 546\" by (metis assms)\n  then have \"73 = 546\" by (simp add: assms)\n  thus ?thesis using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "num_terms": {"skill_name": "num_terms", "marker": "lemma num_terms:\n  shows \"card {19::nat..<92} = 73\"\n  by simp", "description": "", "full_code": "lemma num_terms:\n  shows \"card {19::nat..<92} = 73\"\n  by simp", "origin": "data/full_data/debug/valid_rand/aime_1991_p6.json_v33", "update_count": -1}, "arithmetic_rearrangement": {"skill_name": "arithmetic_rearrangement", "marker": "lemma arithmetic_rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"n = (546 - 73) div 73\"\nproof -\n  have \"73 * n + 73 = 546\" using assms by simp\n  then have \"73 * n = 546 - 73\" by (simp add: algebra_simps)\n  then show ?thesis by auto \nqed", "description": "-", "full_code": "lemma arithmetic_rearrangement:\n  fixes n :: int and x :: nat\n  assumes \"x + 73 * n + 73 - x = 546\"\n  shows \"n = (546 - 73) div 73\"\nproof -\n  have \"73 * n + 73 = 546\" using assms by simp\n  then have \"73 * n = 546 - 73\" by (simp add: algebra_simps)\n  then show ?thesis by auto \nqed", "origin": "sum_terms_count", "update_count": 0}, "count_terms_range": {"skill_name": "count_terms_range", "marker": "lemma count_terms_range:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" by simp\n  then show ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma count_terms_range:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" by simp\n  then show ?thesis using assms by simp\nqed", "origin": "num_terms", "update_count": 0}, "count_consecutive_nats": {"skill_name": "count_consecutive_nats", "marker": "lemma count_consecutive_nats:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" using assms\n    by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_consecutive_nats:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" using assms\n    by auto\n  then show ?thesis by simp\nqed", "origin": "num_terms", "update_count": 0}, "floor_count": {"skill_name": "floor_count", "marker": "lemma floor_count:\n  fixes a b :: nat\n  assumes \"a + b = 73\" \"a * floor r + b * (floor r + 1) = 546\"\n  shows \"a = 73 * floor r - 473\"\nproof -\n  obtain n where \"n = floor r\" using floor_real_def by auto\n  have \"a * n + b * (n + 1) = 546\" using assms(2) by (metis \\<open>n = \\<lfloor>r\\<rfloor>\\<close> add.commute floor_numeral floor_of_nat mult.commute of_nat_numeral or_not_num_neg.simps(2))\n  then have \"a * n + b * n + b = 546\" by (auto simp: field_simps)\n  also have \"... = (a + b) * n + b\" using assms(1) by (metis add.commute add.inverse_unique calculation cancel_comm_monoid_add_class.diff_cancel diff_minus_eq_add int_distrib(1) int_eq_iff_numeral int_ops(3) minus_equation_iff mult.commute of_nat_add verit_minus_simplify(3))\n  finally have \"73 * n + b = 546\" using assms(1) by (metis \\<open>546 = int (a + b) * n + int b\\<close> add.commute diff_minus_eq_add int_ops(3) mult_of_nat_commute verit_minus_simplify(3))\n  thus ?thesis \n  proof -\n    have \"b = 546 - 73 * n\" by (metis \\<open>546 = int (a + b) * n + int b\\<close> add.commute add_diff_cancel_right' assms(1) floor_numeral floor_of_nat mult_of_nat_commute nat_int_add of_nat_add of_nat_numeral or_not_num_neg.simps(2))\n    then have \"a = 73 * n - 473\" using assms(1) by simp\n    thus ?thesis by (metis \\<open>n = \\<lfloor>r\\<rfloor>\\<close>)\n  qed\nqed", "description": "-", "full_code": "lemma floor_count:\n  fixes a b :: nat\n  assumes \"a + b = 73\" \"a * floor r + b * (floor r + 1) = 546\"\n  shows \"a = 73 * floor r - 473\"\nproof -\n  obtain n where \"n = floor r\" using floor_real_def by auto\n  have \"a * n + b * (n + 1) = 546\" using assms(2) by (metis \\<open>n = \\<lfloor>r\\<rfloor>\\<close> add.commute floor_numeral floor_of_nat mult.commute of_nat_numeral or_not_num_neg.simps(2))\n  then have \"a * n + b * n + b = 546\" by (auto simp: field_simps)\n  also have \"... = (a + b) * n + b\" using assms(1) by (metis add.commute add.inverse_unique calculation cancel_comm_monoid_add_class.diff_cancel diff_minus_eq_add int_distrib(1) int_eq_iff_numeral int_ops(3) minus_equation_iff mult.commute of_nat_add verit_minus_simplify(3))\n  finally have \"73 * n + b = 546\" using assms(1) by (metis \\<open>546 = int (a + b) * n + int b\\<close> add.commute diff_minus_eq_add int_ops(3) mult_of_nat_commute verit_minus_simplify(3))\n  thus ?thesis \n  proof -\n    have \"b = 546 - 73 * n\" by (metis \\<open>546 = int (a + b) * n + int b\\<close> add.commute add_diff_cancel_right' assms(1) floor_numeral floor_of_nat mult_of_nat_commute nat_int_add of_nat_add of_nat_numeral or_not_num_neg.simps(2))\n    then have \"a = 73 * n - 473\" using assms(1) by simp\n    thus ?thesis by (metis \\<open>n = \\<lfloor>r\\<rfloor>\\<close>)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "num_terms_in_range": {"skill_name": "num_terms_in_range", "marker": "lemma num_terms_in_range:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"{a::nat..<b} = {k. a \\<le> k \\<and> k < b}\" by auto\n  then show ?thesis by fastforce\nqed", "description": "-", "full_code": "lemma num_terms_in_range:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"{a::nat..<b} = {k. a \\<le> k \\<and> k < b}\" by auto\n  then show ?thesis by fastforce\nqed", "origin": "num_terms", "update_count": 0}, "count_terms": {"skill_name": "count_terms", "marker": "lemma count_terms:\n  fixes a b :: nat\n  assumes \"a + b = 73\"\n  shows \"b = 73 - a\"\nproof -\n  show ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma count_terms:\n  fixes a b :: nat\n  assumes \"a + b = 73\"\n  shows \"b = 73 - a\"\nproof -\n  show ?thesis using assms by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "fixed_sum_expression": {"skill_name": "fixed_sum_expression", "marker": "lemma fixed_sum_expression:\n  fixes a b :: nat\n  assumes \"a + b = 73\"\n  shows \"b = 73 - a\"\nproof -\n  have \"b = 73 - a\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma fixed_sum_expression:\n  fixes a b :: nat\n  assumes \"a + b = 73\"\n  shows \"b = 73 - a\"\nproof -\n  have \"b = 73 - a\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "sum_count": {"skill_name": "sum_count", "marker": "lemma sum_count:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\nproof -\n  have \"card {k. k \\<in> {19::nat..<92}} = 92 - 19\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "description": "", "full_code": "lemma sum_count:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\nproof -\n  have \"card {k. k \\<in> {19::nat..<92}} = 92 - 19\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "origin": "data/full_data/debug/valid_rand/aime_1991_p6.json_v36", "update_count": -1}, "sum_count_in_fewer_dimensions": {"skill_name": "sum_count_in_fewer_dimensions", "marker": "lemma sum_count_in_fewer_dimensions:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{19::nat..<47}. (floor (r + k / 100))) = 246\"  \n  shows \"card {k. k \\<in> {19::nat..<47}} = 28\"  \nproof -\n  have \"card {k. k \\<in> {19::nat..<47}} = 47 - 19\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_count_in_fewer_dimensions:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{19::nat..<47}. (floor (r + k / 100))) = 246\"  \n  shows \"card {k. k \\<in> {19::nat..<47}} = 28\"  \nproof -\n  have \"card {k. k \\<in> {19::nat..<47}} = 47 - 19\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "origin": "sum_count", "update_count": 0}, "substitution_and_simplification": {"skill_name": "substitution_and_simplification", "marker": "lemma substitution_and_simplification:\n  fixes a :: int and b :: int and n :: int\n  assumes \"a + b = 73\" and \"a * n + b * (n + 1) = 546\"\n  shows \"73 * n - a = 473\"\nproof -\n  have \"b = 73 - a\" using assms(1) by simp\n  then have \"a * n + (73 - a) * (n + 1) = 546\" using assms(2) by simp\n  hence \"a * n + (73 - a) * n + (73 - a) = 546\" by (auto simp: field_simps)\n  thus \"73 * n - a = 473\" by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma substitution_and_simplification:\n  fixes a :: int and b :: int and n :: int\n  assumes \"a + b = 73\" and \"a * n + b * (n + 1) = 546\"\n  shows \"73 * n - a = 473\"\nproof -\n  have \"b = 73 - a\" using assms(1) by simp\n  then have \"a * n + (73 - a) * (n + 1) = 546\" using assms(2) by simp\n  hence \"a * n + (73 - a) * n + (73 - a) = 546\" by (auto simp: field_simps)\n  thus \"73 * n - a = 473\" by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "count_terms_rearranged": {"skill_name": "count_terms_rearranged", "marker": "lemma count_terms_rearranged:\n  fixes n :: nat\n  shows \"n = 73 \\<Longrightarrow> n = 91 - 19 + 1\"\nproof -\n  assume \"n = 73\"\n  then show \"n = 91 - 19 + 1\" by simp\nqed", "description": "-", "full_code": "lemma count_terms:\n  fixes n :: nat\n  assumes \"n = 91 - 19 + 1\"\n  shows \"n = 73\"\nproof -\n  have \"n = 91 - 19 + 1\" using assms by simp\n  then show ?thesis by simp\nqed\n\nlemma count_terms_rearranged:\n  fixes n :: nat\n  shows \"n = 73 \\<Longrightarrow> n = 91 - 19 + 1\"\nproof -\n  assume \"n = 73\"\n  then show \"n = 91 - 19 + 1\" by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "count_termsV2": {"skill_name": "count_termsV2", "marker": "lemma count_terms:\n  fixes n :: nat\n  assumes \"n = 91 - 19 + 1\"\n  shows \"n = 73\"\nproof -\n  from assms have \"n = 91 - 19 + 1\" by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms:\n  fixes n :: nat\n  assumes \"n = 91 - 19 + 1\"\n  shows \"n = 73\"\nproof -\n  from assms have \"n = 91 - 19 + 1\" by simp\n  then show ?thesis by simp\nqed", "origin": "sum_terms_count", "update_count": 0}, "num_termsV2": {"skill_name": "num_termsV2", "marker": "lemma num_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" \n    by (simp add: atLeastLessThan_iff)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma num_terms:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" \n    by (simp add: atLeastLessThan_iff)\n  thus ?thesis by simp\nqed", "origin": "num_terms", "update_count": 0}, "count_termsV3": {"skill_name": "count_termsV3", "marker": "lemma count_terms:\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\nproof -\n  have \"card {k. k \\<in> {19::nat..<92}} = 92 - 19\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "description": "", "full_code": "lemma count_terms:\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\nproof -\n  have \"card {k. k \\<in> {19::nat..<92}} = 92 - 19\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "origin": "data/full_data/debug/valid_rand/aime_1991_p6.json_v39", "update_count": -1}, "sum_count_generalized": {"skill_name": "sum_count_generalized", "marker": "lemma sum_count_generalized:\n  fixes r :: real\n  fixes a b :: nat\n  assumes \"(\\<Sum> k \\<in> {a::nat..<b}. (floor (r + k / 100))) = 546\"\n  shows \"card {k. k \\<in> {a::nat..<b}} = b - a\"\nproof -\n  have \"card {k. k \\<in> {a::nat..<b}} = b - a\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_count_generalized:\n  fixes r :: real\n  fixes a b :: nat\n  assumes \"(\\<Sum> k \\<in> {a::nat..<b}. (floor (r + k / 100))) = 546\"\n  shows \"card {k. k \\<in> {a::nat..<b}} = b - a\"\nproof -\n  have \"card {k. k \\<in> {a::nat..<b}} = b - a\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "origin": "sum_count", "update_count": 0}, "substitution_and_simplificationV2": {"skill_name": "substitution_and_simplificationV2", "marker": "lemma substitution_and_simplification:\n  fixes a :: int and b :: int and n :: int\n  assumes \"a + b = 73\" and \"a * n + b * (n + 1) = 546\"\n  shows \"73 * n - a = 473\"\nproof -\n  have \"b = 73 - a\" using assms(1) by simp\n  then have \"a * n + (73 - a) * (n + 1) = 546\" using assms(2) by simp\n  have \"a * n + (73 - a) * n + (73 - a) = 546\" by (metis \\<open>b = 73 - a\\<close> add.commute assms(1) assms(2) group_cancel.add2 mult.commute mult.right_neutral ring_class.ring_distribs(1) ring_class.ring_distribs(2))\n  have \"a * n + 73 * n - a * n + 73 - a = 546\" by (metis \\<open>a * n + (73 - a) * n + (73 - a) = 546\\<close> \\<open>b = 73 - a\\<close> ab_semigroup_add_class.add_ac(1) add.commute add_diff_cancel_left' assms(1) assms(2) int_distrib(1) mult.commute)\n  thus \"73 * n - a = 473\" using `a * n + 73 * n - a * n + 73 - a = 546`\n      by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma substitution_and_simplification:\n  fixes a :: int and b :: int and n :: int\n  assumes \"a + b = 73\" and \"a * n + b * (n + 1) = 546\"\n  shows \"73 * n - a = 473\"\nproof -\n  have \"b = 73 - a\" using assms(1) by simp\n  then have \"a * n + (73 - a) * (n + 1) = 546\" using assms(2) by simp\n  have \"a * n + (73 - a) * n + (73 - a) = 546\" by (metis \\<open>b = 73 - a\\<close> add.commute assms(1) assms(2) group_cancel.add2 mult.commute mult.right_neutral ring_class.ring_distribs(1) ring_class.ring_distribs(2))\n  have \"a * n + 73 * n - a * n + 73 - a = 546\" by (metis \\<open>a * n + (73 - a) * n + (73 - a) = 546\\<close> \\<open>b = 73 - a\\<close> ab_semigroup_add_class.add_ac(1) add.commute add_diff_cancel_left' assms(1) assms(2) int_distrib(1) mult.commute)\n  thus \"73 * n - a = 473\" using `a * n + 73 * n - a * n + 73 - a = 546`\n      by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "substitution_and_simplificationV3": {"skill_name": "substitution_and_simplificationV3", "marker": "lemma substitution_and_simplification:\n  fixes a b n :: int\n  assumes \"a + b = 73\" and \"a * n + b * (n + 1) = 546\"\n  shows \"73 * n - a = 473\"\nproof -\n  have \"b = 73 - a\" using assms(1) by simp\n  then have \"a * n + (73 - a) * (n + 1) = 546\" using assms(2) by simp\n  hence \"a * n + (73 - a) * n + (73 - a) = 546\" by (simp add: algebra_simps)\n  thus \"73 * n - a = 473\" by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma substitution_and_simplification:\n  fixes a b n :: int\n  assumes \"a + b = 73\" and \"a * n + b * (n + 1) = 546\"\n  shows \"73 * n - a = 473\"\nproof -\n  have \"b = 73 - a\" using assms(1) by simp\n  then have \"a * n + (73 - a) * (n + 1) = 546\" using assms(2) by simp\n  hence \"a * n + (73 - a) * n + (73 - a) = 546\" by (simp add: algebra_simps)\n  thus \"73 * n - a = 473\" by (simp add: algebra_simps)\nqed", "origin": "do_request", "update_count": 0}, "num_terms_specific_range": {"skill_name": "num_terms_specific_range", "marker": "lemma num_terms_specific_range:\n  shows \"card {19::nat..<92} = 73\"\n  by (simp add: num_terms_multi_dim)", "description": "-", "full_code": "lemma num_terms_multi_dim:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\n  using assms by auto\n\nlemma num_terms_specific_range:\n  shows \"card {19::nat..<92} = 73\"\n  by (simp add: num_terms_multi_dim)", "origin": "num_terms", "update_count": 0}, "num_terms_multi_dim": {"skill_name": "num_terms_multi_dim", "marker": "lemma num_terms_multi_dim:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\n  using assms by auto", "description": "-", "full_code": "lemma num_terms_multi_dim:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\n  using assms by auto", "origin": "num_terms", "update_count": 0}, "count_terms_in_rangeV2": {"skill_name": "count_terms_in_rangeV2", "marker": "lemma count_terms_in_range:\n  fixes lower upper :: nat\n  assumes \"lower < upper\"\n  shows \"card {k. k \\<in> {lower::nat..<upper}} = upper - lower\"\nproof -\n  have \"card {k. k \\<in> {lower::nat..<upper}} = upper - lower\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms_in_range:\n  fixes lower upper :: nat\n  assumes \"lower < upper\"\n  shows \"card {k. k \\<in> {lower::nat..<upper}} = upper - lower\"\nproof -\n  have \"card {k. k \\<in> {lower::nat..<upper}} = upper - lower\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "origin": "count_termsV3", "update_count": 0}, "count_terms_in_rangeV3": {"skill_name": "count_terms_in_rangeV3", "marker": "lemma count_terms_in_range:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {k. k \\<in> {a::nat..<b}} = b - a\"\nproof -\n  have \"card {k. k \\<in> {a::nat..<b}} = b - a\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms_in_range:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {k. k \\<in> {a::nat..<b}} = b - a\"\nproof -\n  have \"card {k. k \\<in> {a::nat..<b}} = b - a\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "origin": "count_termsV3", "update_count": 0}, "total_terms": {"skill_name": "total_terms", "marker": "lemma total_terms:\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\nproof -\n  have \"card {k. k \\<in> {19::nat..<92}} = card {19::nat..<92}\" \n    by (metis Collect_mem_eq)\n  also have \"... = 92 - 19\" \n    by (metis card_atLeastLessThan)\n  finally show ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma total_terms:\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\nproof -\n  have \"card {k. k \\<in> {19::nat..<92}} = card {19::nat..<92}\" \n    by (metis Collect_mem_eq)\n  also have \"... = 92 - 19\" \n    by (metis card_atLeastLessThan)\n  finally show ?thesis \n    by simp\nqed", "origin": "do_request", "update_count": 0}, "count_terms_generalized": {"skill_name": "count_terms_generalized", "marker": "lemma count_terms_generalized:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {k. k \\<in> {a..b}} = b - a + 1\"\nproof -\n  have \"card {k. k \\<in> {a..b}} = b - a + 1\" \n    by (metis Collect_mem_eq Suc_diff_Suc Suc_eq_plus1 assms card_atLeastAtMost diff_Suc_Suc less_SucI)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms_generalized:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {k. k \\<in> {a..b}} = b - a + 1\"\nproof -\n  have \"card {k. k \\<in> {a..b}} = b - a + 1\" \n    by (metis Collect_mem_eq Suc_diff_Suc Suc_eq_plus1 assms card_atLeastAtMost diff_Suc_Suc less_SucI)\n  thus ?thesis by simp\nqed", "origin": "count_termsV3", "update_count": 0}, "count_terms_special_case": {"skill_name": "count_terms_special_case", "marker": "theorem count_terms_special_case:\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\n  using count_terms_generalized[of 19 92] by auto", "description": "-", "full_code": "lemma count_terms_generalized:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {k. k \\<in> {a::nat..<b}} = b - a\"\nproof -\n  have \"card {k. k \\<in> {a::nat..<b}} = b - a\" \n    by (metis Collect_mem_eq card_atLeastLessThan assms)\n  thus ?thesis by simp\nqed\n\ntheorem count_terms_special_case:\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\n  using count_terms_generalized[of 19 92] by auto", "origin": "count_termsV3", "update_count": 0}, "count_terms_empty": {"skill_name": "count_terms_empty", "marker": "lemma count_terms_empty:\n  shows \"card {k. k \\<in> {10::nat..<10}} = 0\"\nproof -\n  have \"card {k. k \\<in> {10::nat..<10}} = 10 - 10\" \n    by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma count_terms_empty:\n  shows \"card {k. k \\<in> {10::nat..<10}} = 0\"\nproof -\n  have \"card {k. k \\<in> {10::nat..<10}} = 10 - 10\" \n    by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "origin": "count_termsV3", "update_count": 0}, "sum_count_extended": {"skill_name": "sum_count_extended", "marker": "lemma sum_count_extended:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{m::nat..<n}. (floor (r + k / 100))) = s\"\n  shows \"card {k. k \\<in> {m::nat..<n}} = n - m\"\nproof -\n  have \"card {k. k \\<in> {m::nat..<n}} = n - m\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_count_extended:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{m::nat..<n}. (floor (r + k / 100))) = s\"\n  shows \"card {k. k \\<in> {m::nat..<n}} = n - m\"\nproof -\n  have \"card {k. k \\<in> {m::nat..<n}} = n - m\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "origin": "sum_count", "update_count": 0}, "floor_countV2": {"skill_name": "floor_countV2", "marker": "lemma floor_count:\n  fixes a b :: nat\n  assumes \"a + b = 73\" \"a * floor r + b * (floor r + 1) = 546\"\n  shows \"a = 73 * floor r - 473\"\nproof -\n  obtain n where \"n = floor r\" using floor_real_def by auto\n  have \"a * n + b * (n + 1) = 546\" using assms(2) by (metis \\<open>n = \\<lfloor>r\\<rfloor>\\<close> add.commute floor_numeral floor_of_nat mult.commute of_nat_numeral or_not_num_neg.simps(2))\n  have \"a * n + b * (n + 1) = a * n + b * n + b\" by (simp add: algebra_simps)\n  also have \"... = (a + b) * n + b\" using assms(1) by (metis add.commute add.inverse_unique calculation cancel_comm_monoid_add_class.diff_cancel diff_minus_eq_add int_distrib(1) int_eq_iff_numeral int_ops(3) minus_equation_iff mult.commute of_nat_add verit_minus_simplify(3))\n  finally have \"73 * n + b = 546\" using assms(1) by (metis \\<open>int a * n + int b * (n + 1) = 546\\<close> \\<open>int a * n + int b * (n + 1) = int a * n + int b * n + int b\\<close> add.commute add.inverse_unique diff_0 diff_minus_eq_add diff_self equation_minus_iff int_distrib(1) int_eq_iff_numeral int_ops(3) int_ops(5) mult.commute mult_of_nat_commute)\n  have \"b = 546 - 73 * n\" by (smt (verit) \\<open>73 * n + int b = 546\\<close>)\n  have \"a + (546 - 73 * n) = 73\" using assms(1) by (metis \\<open>int b = 546 - 73 * n\\<close> floor_numeral floor_of_nat int_ops(5) nat_int_add of_nat_numeral or_not_num_neg.simps(2))\n  thus ?thesis \n  proof -\n    have \"a = 73 - (546 - 73 * n)\" by (metis \\<open>int b = 546 - 73 * n\\<close> add_diff_cancel_right' assms(1) floor_numeral floor_of_nat int_ops(5) nat_int_add of_nat_numeral or_not_num_neg.simps(2))\n    thus ?thesis by (smt (verit) \\<open>n = \\<lfloor>r\\<rfloor>\\<close>)\n  qed\nqed", "description": "-", "full_code": "lemma floor_count:\n  fixes a b :: nat\n  assumes \"a + b = 73\" \"a * floor r + b * (floor r + 1) = 546\"\n  shows \"a = 73 * floor r - 473\"\nproof -\n  obtain n where \"n = floor r\" using floor_real_def by auto\n  have \"a * n + b * (n + 1) = 546\" using assms(2) by (metis \\<open>n = \\<lfloor>r\\<rfloor>\\<close> add.commute floor_numeral floor_of_nat mult.commute of_nat_numeral or_not_num_neg.simps(2))\n  have \"a * n + b * (n + 1) = a * n + b * n + b\" by (simp add: algebra_simps)\n  also have \"... = (a + b) * n + b\" using assms(1) by (metis add.commute add.inverse_unique calculation cancel_comm_monoid_add_class.diff_cancel diff_minus_eq_add int_distrib(1) int_eq_iff_numeral int_ops(3) minus_equation_iff mult.commute of_nat_add verit_minus_simplify(3))\n  finally have \"73 * n + b = 546\" using assms(1) by (metis \\<open>int a * n + int b * (n + 1) = 546\\<close> \\<open>int a * n + int b * (n + 1) = int a * n + int b * n + int b\\<close> add.commute add.inverse_unique diff_0 diff_minus_eq_add diff_self equation_minus_iff int_distrib(1) int_eq_iff_numeral int_ops(3) int_ops(5) mult.commute mult_of_nat_commute)\n  have \"b = 546 - 73 * n\" by (smt (verit) \\<open>73 * n + int b = 546\\<close>)\n  have \"a + (546 - 73 * n) = 73\" using assms(1) by (metis \\<open>int b = 546 - 73 * n\\<close> floor_numeral floor_of_nat int_ops(5) nat_int_add of_nat_numeral or_not_num_neg.simps(2))\n  thus ?thesis \n  proof -\n    have \"a = 73 - (546 - 73 * n)\" by (metis \\<open>int b = 546 - 73 * n\\<close> add_diff_cancel_right' assms(1) floor_numeral floor_of_nat int_ops(5) nat_int_add of_nat_numeral or_not_num_neg.simps(2))\n    thus ?thesis by (smt (verit) \\<open>n = \\<lfloor>r\\<rfloor>\\<close>)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "sum_count_extendedV2": {"skill_name": "sum_count_extendedV2", "marker": "lemma sum_count_extended:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"card {k. k \\<in> {m::nat..<n}} = n - m\"\nproof -\n  let ?A = \"{k. k \\<in> {m::nat..<n}}\"\n  have \"card ?A = n - m\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_count_extended:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"card {k. k \\<in> {m::nat..<n}} = n - m\"\nproof -\n  let ?A = \"{k. k \\<in> {m::nat..<n}}\"\n  have \"card ?A = n - m\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "origin": "sum_count", "update_count": 0}, "num_terms_generalized": {"skill_name": "num_terms_generalized", "marker": "lemma num_terms_generalized:\n  fixes m n :: nat\n  assumes \"m < n\"\n  shows \"card {m::nat..<n} = n - m\"\nproof -\n  have \"card {m::nat..<n} = n - m\"\n    by (simp add: assms)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma num_terms_generalized:\n  fixes m n :: nat\n  assumes \"m < n\"\n  shows \"card {m::nat..<n} = n - m\"\nproof -\n  have \"card {m::nat..<n} = n - m\"\n    by (simp add: assms)\n  then show ?thesis by simp\nqed", "origin": "num_terms", "update_count": 0}, "sum_count_consecutive": {"skill_name": "sum_count_consecutive", "marker": "lemma sum_count_consecutive:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{k1::nat..<k2}. (floor (r + k / 100))) = total_sum\"\n  shows \"card {k. k \\<in> {k1::nat..<k2}} = k2 - k1\"\nproof -\n  have \"card {k. k \\<in> {k1::nat..<k2}} = k2 - k1\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_count_consecutive:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{k1::nat..<k2}. (floor (r + k / 100))) = total_sum\"\n  shows \"card {k. k \\<in> {k1::nat..<k2}} = k2 - k1\"\nproof -\n  have \"card {k. k \\<in> {k1::nat..<k2}} = k2 - k1\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed", "origin": "sum_count", "update_count": 0}, "sum_count_floor_range": {"skill_name": "sum_count_floor_range", "marker": "lemma sum_count_floor_range:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"(\\<Sum> k \\<in>{19::nat..<92}. (floor (r + k / 100))) - 73 = 473\"\nproof -\n  have \"(\\<Sum> k \\<in>{19::nat..<92}. (floor (r + k / 100))) - card {k. k \\<in> {19::nat..<92}} = 546 - 73\"\n    using assms sum_count_floor_value by simp\n  thus ?thesis by (smt (verit) assms)\nqed", "description": "-", "full_code": "lemma sum_count_floor_value:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\nproof -\n  have \"card {k. k \\<in> {19::nat..<92}} = 92 - 19\" by (metis Collect_mem_eq card_atLeastLessThan)\n  thus ?thesis by simp\nqed\n\nlemma sum_count_floor_range:\n  fixes r :: real\n  assumes \"(\\<Sum> k \\<in>{19::nat..<92}. (floor (r + k / 100))) = 546\"\n  shows \"(\\<Sum> k \\<in>{19::nat..<92}. (floor (r + k / 100))) - 73 = 473\"\nproof -\n  have \"(\\<Sum> k \\<in>{19::nat..<92}. (floor (r + k / 100))) - card {k. k \\<in> {19::nat..<92}} = 546 - 73\"\n    using assms sum_count_floor_value by simp\n  thus ?thesis by (smt (verit) assms)\nqed", "origin": "sum_count", "update_count": 0}, "num_terms_extended": {"skill_name": "num_terms_extended", "marker": "lemma num_terms_extended:\n  shows \"card {19::nat..<92} = 73\"\n  by (simp add: num_terms_in_interval)", "description": "-", "full_code": "lemma num_terms_in_interval:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"card {a::nat..<b} = b - a\"\nproof -\n  have \"card {a::nat..<b} = b - a\" by auto\n  thus ?thesis by auto\nqed\n\nlemma num_terms_extended:\n  shows \"card {19::nat..<92} = 73\"\n  by (simp add: num_terms_in_interval)", "origin": "num_terms", "update_count": 0}, "total_termsV2": {"skill_name": "total_termsV2", "marker": "lemma total_terms:\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\nproof -\n  let ?S = \"{k. k \\<in> {19::nat..<92}}\"\n  have \"card ?S = card {19::nat..<92}\" \n    by (metis Collect_mem_eq)\n  also have \"... = 92 - 19\" \n    by (metis card_atLeastLessThan)\n  also have \"... = 73\" \n    by simp\n  finally show ?thesis \n    by simp\nqed", "description": "-", "full_code": "lemma total_terms:\n  shows \"card {k. k \\<in> {19::nat..<92}} = 73\"\nproof -\n  let ?S = \"{k. k \\<in> {19::nat..<92}}\"\n  have \"card ?S = card {19::nat..<92}\" \n    by (metis Collect_mem_eq)\n  also have \"... = 92 - 19\" \n    by (metis card_atLeastLessThan)\n  also have \"... = 73\" \n    by simp\n  finally show ?thesis \n    by simp\nqed", "origin": "do_request", "update_count": 0}}
{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "distribution_property": {"skill_name": "distribution_property", "marker": "lemma distribution_property:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by (auto simp: field_simps)\n  also have \"... = a * c + a * d + b * c + b * d\" by (simp add: distrib_left)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma distribution_property:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + b * c + a * d + b * d\"\nproof -\n  have \"(a + b) * (c + d) = a * (c + d) + b * (c + d)\" by (auto simp: field_simps)\n  also have \"... = a * c + a * d + b * c + b * d\" by (simp add: distrib_left)\n  finally show ?thesis by simp\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "mod_add_power_general": {"skill_name": "mod_add_power_general", "marker": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b) mod n) = ((x mod n) + (b mod n)) mod n\"\n    by presburger\n  also have \"... = (a + b) mod n\"\n    using assms(4) by presburger\n  finally show ?thesis using power_mod by (smt (verit) \\<open>(x + b) mod n = (x mod n + b mod n) mod n\\<close> \\<open>(x mod n + b mod n) mod n = (a + b) mod n\\<close>)\nqed", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b) mod n) = ((x mod n) + (b mod n)) mod n\"\n    by presburger\n  also have \"... = (a + b) mod n\"\n    using assms(4) by presburger\n  finally show ?thesis using power_mod by (smt (verit) \\<open>(x + b) mod n = (x mod n + b mod n) mod n\\<close> \\<open>(x mod n + b mod n) mod n = (a + b) mod n\\<close>)\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_property": {"skill_name": "mod_add_property", "marker": "lemma mod_add_property:\n  fixes x a b n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"((x + b) mod n) = ((a + b) mod n)\"\nproof -\n  have \"((x + b) mod n) = ((x mod n) + (b mod n)) mod n\"\n    by presburger\n  also have \"... = (a + (b mod n)) mod n\"\n    using assms(3) by auto\n  also have \"... = (a + b) mod n\"\n    by presburger\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_property:\n  fixes x a b n :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\"\n  shows \"((x + b) mod n) = ((a + b) mod n)\"\nproof -\n  have \"((x + b) mod n) = ((x mod n) + (b mod n)) mod n\"\n    by presburger\n  also have \"... = (a + (b mod n)) mod n\"\n    using assms(3) by auto\n  also have \"... = (a + b) mod n\"\n    by presburger\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_extended": {"skill_name": "mod_add_power_extended", "marker": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c mod n + d) mod n\"\n    by (smt (verit) mod_add_cong mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c + d) mod n\"\n    using assms(4) by (metis add.commute assms(5) mod_add_right_eq)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c mod n + d) mod n\"\n    by (smt (verit) mod_add_cong mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c + d) mod n\"\n    using assms(4) by (metis add.commute assms(5) mod_add_right_eq)\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_extendedV2": {"skill_name": "mod_add_power_extendedV2", "marker": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c + d) mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c + d) mod n\"\n    using assms(5) by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = ((a + b)^c + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = (((x mod n) + b)^c + d) mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = ((a + b)^c + d) mod n\"\n    using assms(5) by auto\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_extendedV3": {"skill_name": "mod_add_power_extendedV3", "marker": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = (((a + b)^c) + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = ((a + b)^c + d) mod n\"\n  proof -\n    have \"((x + b)^c mod n) = ((x mod n + b)^c mod n)\"\n      by (smt (verit) mod_add_left_eq power_mod)\n    also have \"... = ((a + b)^c mod n)\"\n      using assms(5) by auto\n    finally show ?thesis by presburger\n  qed\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power_extended:\n  fixes x n a b c d :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"d > 0\" \"x mod n = a\"\n  shows \"((x + b)^c + d) mod n = (((a + b)^c) + d) mod n\"\nproof -\n  have \"((x + b)^c + d) mod n = (((x + b)^c mod n) + d) mod n\"\n    by presburger\n  also have \"... = ((a + b)^c + d) mod n\"\n  proof -\n    have \"((x + b)^c mod n) = ((x mod n + b)^c mod n)\"\n      by (smt (verit) mod_add_left_eq power_mod)\n    also have \"... = ((a + b)^c mod n)\"\n      using assms(5) by auto\n    finally show ?thesis by presburger\n  qed\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "rearrange_equation": {"skill_name": "rearrange_equation", "marker": "lemma rearrange_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "", "full_code": "lemma rearrange_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "data/full_data/debug/valid_rand/amc12a_2013_p8.json_v2", "update_count": -1}, "rearrange_equation_with_common_terms": {"skill_name": "rearrange_equation_with_common_terms", "marker": "lemma rearrange_equation_with_common_terms:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" using algebra_simps by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_common_terms:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" using algebra_simps by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_and_solve": {"skill_name": "rearrange_and_solve", "marker": "lemma rearrange_and_solve:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_and_solve:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "equal_terms_rearrangement": {"skill_name": "equal_terms_rearrangement", "marker": "lemma equal_terms_rearrangement:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" using algebra_simps by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma equal_terms_rearrangement:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" using algebra_simps by auto\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "factor_out": {"skill_name": "factor_out", "marker": "lemma factor_out:\n  fixes x y :: real\n  assumes \"x + 2 / x = y + 2 / y\"\n    and \"x \\<noteq> y\"\n  shows \"x - y = (2 * (x - y)) / (x * y)\"\nproof -\n  have \"x + 2 / x - (y + 2 / y) = 0\" using assms(1) by auto\n  hence \"x - y + (2 / x - 2 / y) = 0\" by (simp add: algebra_simps)\n  then have \"x - y = - (2 / x - 2 / y)\" by simp\n  then have \"x - y = - (2 * (y - x)) / (x * y)\" by sos\n  then have \"x - y = (2 * (x - y)) / (x * y)\" by (simp add: algebra_simps)\n  thus ?thesis using assms(2) by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma factor_out:\n  fixes x y :: real\n  assumes \"x + 2 / x = y + 2 / y\"\n    and \"x \\<noteq> y\"\n  shows \"x - y = (2 * (x - y)) / (x * y)\"\nproof -\n  have \"x + 2 / x - (y + 2 / y) = 0\" using assms(1) by auto\n  hence \"x - y + (2 / x - 2 / y) = 0\" by (simp add: algebra_simps)\n  then have \"x - y = - (2 / x - 2 / y)\" by simp\n  then have \"x - y = - (2 * (y - x)) / (x * y)\" by sos\n  then have \"x - y = (2 * (x - y)) / (x * y)\" by (simp add: algebra_simps)\n  thus ?thesis using assms(2) by (simp add: field_simps)\nqed", "origin": "do_request", "update_count": 0}, "rearrange_equation_general": {"skill_name": "rearrange_equation_general", "marker": "lemma rearrange_equation_general:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\" \n    and \"x \\<noteq> y\" \n    and \"x > 0\" \n    and \"y > 0\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms by simp\n  then have \"x - y = (b/y - a/x)\" \n    by (simp add: assms(1) algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_general:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\" \n    and \"x \\<noteq> y\" \n    and \"x > 0\" \n    and \"y > 0\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms by simp\n  then have \"x - y = (b/y - a/x)\" \n    by (simp add: assms(1) algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_with_common_denominator": {"skill_name": "rearrange_equation_with_common_denominator", "marker": "lemma rearrange_equation_with_common_denominator:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2 * (x - y)) / (x * y)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then show ?thesis\n    using `x + 2/x = y + 2/y` \n    by sos\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_common_denominator:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2 * (x - y)) / (x * y)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then show ?thesis\n    using `x + 2/x = y + 2/y` \n    by sos\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_difference": {"skill_name": "rearrange_difference", "marker": "lemma rearrange_difference:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x) * (x - y) / (x - y)\" \n  (is \"x - y = ?rhs\")\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x) * (x - y) / (x - y)\" by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_difference:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x) * (x - y) / (x - y)\" \n  (is \"x - y = ?rhs\")\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x) * (x - y) / (x - y)\" by auto\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "divide_both_sides": {"skill_name": "divide_both_sides", "marker": "lemma divide_both_sides:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" \n      and \"x \\<noteq> 0\" \n      and \"y \\<noteq> 0\"\n      and \"x \\<noteq> y\"\n  shows \"1 = 2 / (x * y)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms(1) by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  hence \"x - y = (2 * (x - y)) / (x * y)\" \n    using assms(2) assms(3) by (simp add: field_simps)\n  have \"x - y \\<noteq> 0\" using assms(4) by auto\n  then have \"1 = 2 / (x * y)\" \n    using `x - y = (2 * (x - y)) / (x * y)` \n    by sos\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma divide_both_sides:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" \n      and \"x \\<noteq> 0\" \n      and \"y \\<noteq> 0\"\n      and \"x \\<noteq> y\"\n  shows \"1 = 2 / (x * y)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms(1) by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  hence \"x - y = (2 * (x - y)) / (x * y)\" \n    using assms(2) assms(3) by (simp add: field_simps)\n  have \"x - y \\<noteq> 0\" using assms(4) by auto\n  then have \"1 = 2 / (x * y)\" \n    using `x - y = (2 * (x - y)) / (x * y)` \n    by sos\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "rearrange_equation_generalized": {"skill_name": "rearrange_equation_generalized", "marker": "lemma rearrange_equation_generalized:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\"\n    and \"x \\<noteq> 0\"\n    and \"y \\<noteq> 0\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_generalized:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\"\n    and \"x \\<noteq> 0\"\n    and \"y \\<noteq> 0\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "common_denominator": {"skill_name": "common_denominator", "marker": "lemma common_denominator:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2 * (x - y)) / (x * y)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then have \"x - y = (2 * (x - y)) / (x * y)\" \n    by sos\n  thus ?thesis by blast\nqed", "description": "-", "full_code": "lemma common_denominator:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2 * (x - y)) / (x * y)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then have \"x - y = (2 * (x - y)) / (x * y)\" \n    by sos\n  thus ?thesis by blast\nqed", "origin": "do_request", "update_count": 0}, "common_denominatorV2": {"skill_name": "common_denominatorV2", "marker": "lemma common_denominator:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2 * (x - y)) / (x * y)\"\nproof -\n  have \"x + 2 / x - (y + 2 / y) = 0\" using assms by simp\n  then have \"x + 2/x = y + 2/y\" by (simp add: field_simps)\n  then have \"x - y = (2/y - 2/x)\" using field_simps by auto\n  then have \"x - y = (2 * (x - y)) / (x * y)\" \n    by sos\n  thus ?thesis by blast\nqed", "description": "-", "full_code": "lemma common_denominator:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2 * (x - y)) / (x * y)\"\nproof -\n  have \"x + 2 / x - (y + 2 / y) = 0\" using assms by simp\n  then have \"x + 2/x = y + 2/y\" by (simp add: field_simps)\n  then have \"x - y = (2/y - 2/x)\" using field_simps by auto\n  then have \"x - y = (2 * (x - y)) / (x * y)\" \n    by sos\n  thus ?thesis by blast\nqed", "origin": "do_request", "update_count": 0}, "rearrange_equation_multiple": {"skill_name": "rearrange_equation_multiple", "marker": "lemma rearrange_equation_multiple:\n  fixes x1 x2 y1 y2 :: real\n  assumes \"x1 + 2/x1 = y1 + 2/y1\" \n      and \"x2 + 2/x2 = y2 + 2/y2\"\n  shows \"(x1 - y1) = (2/y1 - 2/x1) \\<and> (x2 - y2) = (2/y2 - 2/x2)\"\nproof -\n  have \"x1 + 2/x1 - (y1 + 2/y1) = 0\" \n    using assms(1) by simp\n  hence \"x1 - y1 = (2/y1 - 2/x1)\" by simp\n  have \"x2 + 2/x2 - (y2 + 2/y2) = 0\" \n    using assms(2) by simp\n  hence \"x2 - y2 = (2/y2 - 2/x2)\" by simp\n  thus ?thesis by (metis \\<open>x1 - y1 = 2 / y1 - 2 / x1\\<close>)\nqed", "description": "-", "full_code": "lemma rearrange_equation_multiple:\n  fixes x1 x2 y1 y2 :: real\n  assumes \"x1 + 2/x1 = y1 + 2/y1\" \n      and \"x2 + 2/x2 = y2 + 2/y2\"\n  shows \"(x1 - y1) = (2/y1 - 2/x1) \\<and> (x2 - y2) = (2/y2 - 2/x2)\"\nproof -\n  have \"x1 + 2/x1 - (y1 + 2/y1) = 0\" \n    using assms(1) by simp\n  hence \"x1 - y1 = (2/y1 - 2/x1)\" by simp\n  have \"x2 + 2/x2 - (y2 + 2/y2) = 0\" \n    using assms(2) by simp\n  hence \"x2 - y2 = (2/y2 - 2/x2)\" by simp\n  thus ?thesis by (metis \\<open>x1 - y1 = 2 / y1 - 2 / x1\\<close>)\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_with_conditions": {"skill_name": "rearrange_equation_with_conditions", "marker": "lemma rearrange_equation_with_conditions:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n      and \"x \\<noteq> 0\" \n      and \"y \\<noteq> 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms(1) by simp\n  then show ?thesis by (simp add: assms(2) assms(3))\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_conditions:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n      and \"x \\<noteq> 0\" \n      and \"y \\<noteq> 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms(1) by simp\n  then show ?thesis by (simp add: assms(2) assms(3))\nqed", "origin": "rearrange_equation", "update_count": 0}, "manipulate_fractional_equation": {"skill_name": "manipulate_fractional_equation", "marker": "lemma manipulate_fractional_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" \n    by auto\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma manipulate_fractional_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" \n    by auto\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "algebraic_manipulation": {"skill_name": "algebraic_manipulation", "marker": "lemma algebraic_manipulation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y + 2 * (y - x) / (x * y) = 0\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using assms by simp\n  have \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: field_simps)\n  have \"x - y + 2 * (y - x) / (x * y) = (x - y) - 2 * (x - y) / (x * y)\"\n    by (smt (verit) \\<open>x - y = 2 / y - 2 / x\\<close> diff_minus_eq_add eq minus_divide_left mult_2)\n  have \"(x - y) * (1 - 2/(x * y)) = 0\"\n    using `x - y = (2/y - 2/x)` by sos\n  show ?thesis\n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"1 - 2/(x * y) = 0\" by (smt (verit) \\<open>(x - y) * (1 - 2 / (x * y)) = 0\\<close> no_zero_divisors)\n    then show ?thesis by (auto simp: field_simps)\n  qed\nqed", "description": "-", "full_code": "lemma algebraic_manipulation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y + 2 * (y - x) / (x * y) = 0\"\nproof -\n  have eq: \"x + 2/x = y + 2/y\" using assms by simp\n  have \"x - y = (2/y - 2/x)\" \n    using eq by (simp add: field_simps)\n  have \"x - y + 2 * (y - x) / (x * y) = (x - y) - 2 * (x - y) / (x * y)\"\n    by (smt (verit) \\<open>x - y = 2 / y - 2 / x\\<close> diff_minus_eq_add eq minus_divide_left mult_2)\n  have \"(x - y) * (1 - 2/(x * y)) = 0\"\n    using `x - y = (2/y - 2/x)` by sos\n  show ?thesis\n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"1 - 2/(x * y) = 0\" by (smt (verit) \\<open>(x - y) * (1 - 2 / (x * y)) = 0\\<close> no_zero_divisors)\n    then show ?thesis by (auto simp: field_simps)\n  qed\nqed", "origin": "do_request", "update_count": 0}, "factorization": {"skill_name": "factorization", "marker": "lemma factorization:\n  fixes a b :: real\n  shows \"a - b = (a - b) * 1\"\nproof -\n  have \"a - b = (a - b) * 1\" by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma factorization:\n  fixes a b :: real\n  shows \"a - b = (a - b) * 1\"\nproof -\n  have \"a - b = (a - b) * 1\" by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "rearrange_equation_v2": {"skill_name": "rearrange_equation_v2", "marker": "lemma rearrange_equation_v2:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" \n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_v2:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" \n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearranged_equation_with_inequality": {"skill_name": "rearranged_equation_with_inequality", "marker": "lemma rearranged_equation_with_inequality:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" and \"x > 0\" and \"y > 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms(1) by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearranged_equation_with_inequality:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" and \"x > 0\" and \"y > 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms(1) by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "factorization_lemma": {"skill_name": "factorization_lemma", "marker": "lemma factorization_lemma:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> b\"\n  shows \"(a - b) * (c + d) = 0 \\<longleftrightarrow> c + d = 0\"\nproof -\n  have \"(a - b) * (c + d) = 0 \\<Longrightarrow> c + d = 0\" \n  proof -\n    assume \"(a - b) * (c + d) = 0\"\n    then have \"c + d = 0\" using assms by auto\n    thus ?thesis by simp\n  qed\n  have \"c + d = 0 \\<Longrightarrow> (a - b) * (c + d) = 0\"\n  proof -\n    assume \"c + d = 0\"\n    then have \"(a - b) * 0 = 0\" by simp\n    thus ?thesis by (metis \\<open>c + d = 0\\<close>)\n  qed\n  show \"(a - b) * (c + d) = 0 \\<longleftrightarrow> c + d = 0\"\n    by (metis \\<open>(a - b) * (c + d) = 0 \\<Longrightarrow> c + d = 0\\<close> mult_zero_right)\nqed", "description": "-", "full_code": "lemma factorization_lemma:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> b\"\n  shows \"(a - b) * (c + d) = 0 \\<longleftrightarrow> c + d = 0\"\nproof -\n  have \"(a - b) * (c + d) = 0 \\<Longrightarrow> c + d = 0\" \n  proof -\n    assume \"(a - b) * (c + d) = 0\"\n    then have \"c + d = 0\" using assms by auto\n    thus ?thesis by simp\n  qed\n  have \"c + d = 0 \\<Longrightarrow> (a - b) * (c + d) = 0\"\n  proof -\n    assume \"c + d = 0\"\n    then have \"(a - b) * 0 = 0\" by simp\n    thus ?thesis by (metis \\<open>c + d = 0\\<close>)\n  qed\n  show \"(a - b) * (c + d) = 0 \\<longleftrightarrow> c + d = 0\"\n    by (metis \\<open>(a - b) * (c + d) = 0 \\<Longrightarrow> c + d = 0\\<close> mult_zero_right)\nqed", "origin": "do_request", "update_count": 0}, "factorization_lemmaV2": {"skill_name": "factorization_lemmaV2", "marker": "lemma factorization_lemma:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> b\"\n  shows \"(a - b) * (c + d) = 0 \\<longleftrightarrow> c + d = 0\"\nproof -\n  have \"((a - b) * (c + d) = 0) \\<longleftrightarrow> (c + d = 0 \\<or> a - b = 0)\" \n    by (metis assms mult_eq_0_iff)\n  thus ?thesis \n    by (simp add: assms)\nqed", "description": "-", "full_code": "lemma factorization_lemma:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> b\"\n  shows \"(a - b) * (c + d) = 0 \\<longleftrightarrow> c + d = 0\"\nproof -\n  have \"((a - b) * (c + d) = 0) \\<longleftrightarrow> (c + d = 0 \\<or> a - b = 0)\" \n    by (metis assms mult_eq_0_iff)\n  thus ?thesis \n    by (simp add: assms)\nqed", "origin": "do_request", "update_count": 0}, "factorization_lemmaV3": {"skill_name": "factorization_lemmaV3", "marker": "lemma factorization_lemma:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> b\"\n  shows \"(a - b) * (c + d) = 0 \\<longleftrightarrow> c + d = 0\"\nproof\n  assume rhs: \"c + d = 0\"\n  then have \"(a - b) * (c + d) = (a - b) * 0\" by simp\n  thus \"(a - b) * (c + d) = 0\" by simp\nnext\n  assume lhs: \"(a - b) * (c + d) = 0\"\n  have \"c + d = 0 \\<longleftrightarrow> (a - b) * (c + d) = 0\" using lhs\n  proof (cases \"c + d = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"c + d \\<noteq> 0\" by simp\n    then have \"a - b = 0\" by (metis lhs mult_eq_0_iff)\n    with assms show ?thesis by auto\n  qed\n  thus \"c + d = 0\" by (metis lhs)\nqed", "description": "-", "full_code": "lemma factorization_lemma:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> b\"\n  shows \"(a - b) * (c + d) = 0 \\<longleftrightarrow> c + d = 0\"\nproof\n  assume rhs: \"c + d = 0\"\n  then have \"(a - b) * (c + d) = (a - b) * 0\" by simp\n  thus \"(a - b) * (c + d) = 0\" by simp\nnext\n  assume lhs: \"(a - b) * (c + d) = 0\"\n  have \"c + d = 0 \\<longleftrightarrow> (a - b) * (c + d) = 0\" using lhs\n  proof (cases \"c + d = 0\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"c + d \\<noteq> 0\" by simp\n    then have \"a - b = 0\" by (metis lhs mult_eq_0_iff)\n    with assms show ?thesis by auto\n  qed\n  thus \"c + d = 0\" by (metis lhs)\nqed", "origin": "do_request", "update_count": 0}, "factorization_lemmaV4": {"skill_name": "factorization_lemmaV4", "marker": "lemma factorization_lemma:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> b\"\n  shows \"(a - b) * (c + d) = 0 \\<longleftrightarrow> c + d = 0\"\nproof -\n  have \"(a - b) * (c + d) = 0 \\<longleftrightarrow> (c + d) = 0\" \n    using assms by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma factorization_lemma:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> b\"\n  shows \"(a - b) * (c + d) = 0 \\<longleftrightarrow> c + d = 0\"\nproof -\n  have \"(a - b) * (c + d) = 0 \\<longleftrightarrow> (c + d) = 0\" \n    using assms by auto\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "rearrange_equation_generic": {"skill_name": "rearrange_equation_generic", "marker": "lemma rearrange_equation_generic:\n  fixes x y :: \"'a::field\"\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by (auto simp: field_simps)\nqed", "description": "-", "full_code": "lemma rearrange_equation_generic:\n  fixes x y :: \"'a::field\"\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by (auto simp: field_simps)\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_n_dimensions": {"skill_name": "rearrange_equation_n_dimensions", "marker": "lemma rearrange_equation_n_dimensions:\n  fixes x y :: \"real list\"\n  assumes \"length x = n\" \"length y = n\"\n    and \"sum_list x + 2/sum_list x = sum_list y + 2/sum_list y\"\n  shows \"sum_list x - sum_list y = (2/sum_list y - 2/sum_list x)\"\nproof -\n  have \"sum_list x + 2/sum_list x - (sum_list y + 2/sum_list y) = 0\" using assms\n    by (simp add: sum_list_def)\n  then show ?thesis \n    by (simp add: sum_list_def field_simps)\nqed", "description": "-", "full_code": "lemma rearrange_equation_n_dimensions:\n  fixes x y :: \"real list\"\n  assumes \"length x = n\" \"length y = n\"\n    and \"sum_list x + 2/sum_list x = sum_list y + 2/sum_list y\"\n  shows \"sum_list x - sum_list y = (2/sum_list y - 2/sum_list x)\"\nproof -\n  have \"sum_list x + 2/sum_list x - (sum_list y + 2/sum_list y) = 0\" using assms\n    by (simp add: sum_list_def)\n  then show ?thesis \n    by (simp add: sum_list_def field_simps)\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_with_product": {"skill_name": "rearrange_equation_with_product", "marker": "lemma rearrange_equation_with_product:\n  fixes x y z :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"(x - y) * (1 - (2/(x * y))) = 0\"\nproof -\n  have \"x - y = (2/y - 2/x)\" using rearrange_equation_with_factor assms by simp\n  then show ?thesis using assms by sos\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_factor:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by (simp add: field_simps)\nqed\n\nlemma rearrange_equation_with_product:\n  fixes x y z :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"(x - y) * (1 - (2/(x * y))) = 0\"\nproof -\n  have \"x - y = (2/y - 2/x)\" using rearrange_equation_with_factor assms by simp\n  then show ?thesis using assms by sos\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_with_common_termsV2": {"skill_name": "rearrange_equation_with_common_termsV2", "marker": "lemma rearrange_equation_with_common_terms:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_common_terms:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" using assms by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "amc12a_2013_p8": {"skill_name": "amc12a_2013_p8", "marker": "theorem amc12a_2013_p8:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2 / x = y + 2 / y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" using eq by (simp add: field_simps)\n  have cross_mult: \"(x - y) * (x * y) = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h2 by auto\n  next\n    case False\n    then have \"x * y = 2\" using cross_mult by sos\n    thus ?thesis by simp\n  qed\n  thus ?thesis by blast\nqed", "description": "", "full_code": "theorem amc12a_2013_p8:\n  fixes x y :: real\n  assumes h0 : \"x\\<noteq>0\"\n    and h1 : \"y\\<noteq>0\"\n    and h2 : \"x\\<noteq>y\"\n    and h3 : \"x + 2/x = y + 2/y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2 / x = y + 2 / y\" using h3 by simp\n  have rearranged: \"x - y = (2/y - 2/x)\" using eq by (simp add: field_simps)\n  have cross_mult: \"(x - y) * (x * y) = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h2 by auto\n  next\n    case False\n    then have \"x * y = 2\" using cross_mult by sos\n    thus ?thesis by simp\n  qed\n  thus ?thesis by blast\nqed", "origin": "data/full_data/debug/valid_rand/amc12a_2013_p8.json_v10", "update_count": -1}, "cross_multiplication": {"skill_name": "cross_multiplication", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \n    and \"a/b = c/d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a/b - c/d = 0\" using assms by simp\n  then have \"a * d - b * c = 0\" using field_simps by (metis assms(1) assms(2) assms(3) diff_self divide_inverse divide_inverse_commute field_class.field_divide_inverse frac_eq_eq real_scaleR_def)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\" \n    and \"a/b = c/d\"\n  shows \"a * d = b * c\"\nproof -\n  have \"a/b - c/d = 0\" using assms by simp\n  then have \"a * d - b * c = 0\" using field_simps by (metis assms(1) assms(2) assms(3) diff_self divide_inverse divide_inverse_commute field_class.field_divide_inverse frac_eq_eq real_scaleR_def)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiplicationV2": {"skill_name": "cross_multiplicationV2", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> b\" \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a - b) * c = (a - b) * d \\<longrightarrow> c = d\"\n  using assms by auto", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"a \\<noteq> b\" \"c \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a - b) * c = (a - b) * d \\<longrightarrow> c = d\"\n  using assms by auto", "origin": "amc12a_2013_p8", "update_count": 0}, "manipulate_equation": {"skill_name": "manipulate_equation", "marker": "lemma manipulate_equation:\n  fixes x y :: real\n  assumes h0: \"x + 2/x = y + 2/y\"\n    and h1: \"x \\<noteq> 0\"\n    and h2: \"y \\<noteq> 0\"\n    and h3: \"x \\<noteq> y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using h0 by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  have \"x * y * (x - y) = 2 * (x - y)\" using `x - y = (2/y - 2/x)` \n    by sos\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h3 by auto\n  next\n    case False\n    then show ?thesis using `x * y * (x - y) = 2 * (x - y)` by sos\n  qed\n  thus ?thesis by blast\nqed", "description": "-", "full_code": "lemma manipulate_equation:\n  fixes x y :: real\n  assumes h0: \"x + 2/x = y + 2/y\"\n    and h1: \"x \\<noteq> 0\"\n    and h2: \"y \\<noteq> 0\"\n    and h3: \"x \\<noteq> y\"\n  shows \"x * y = 2\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using h0 by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  have \"x * y * (x - y) = 2 * (x - y)\" using `x - y = (2/y - 2/x)` \n    by sos\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h3 by auto\n  next\n    case False\n    then show ?thesis using `x * y * (x - y) = 2 * (x - y)` by sos\n  qed\n  thus ?thesis by blast\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "rearrange_equation_generalV2": {"skill_name": "rearrange_equation_generalV2", "marker": "lemma rearrange_equation_general:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" and \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma rearrange_equation_general:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" and \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by (simp add: field_simps)\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_and_factor_equation": {"skill_name": "rearrange_and_factor_equation", "marker": "lemma rearrange_and_factor_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" \n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_and_factor_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" \n    by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "cross_multiplicationV3": {"skill_name": "cross_multiplicationV3", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(a - c) * (b * d) = (b * a - b * c) * d\"\nproof -\n  have \"b * a - b * c = b * (a - c)\" by sos\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(a - c) * (b * d) = (b * a - b * c) * d\"\nproof -\n  have \"b * a - b * c = b * (a - c)\" by sos\n  then show ?thesis using assms by (simp add: field_simps)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "rearrangement_identity": {"skill_name": "rearrangement_identity", "marker": "lemma rearrangement_identity:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma rearrangement_identity:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show ?thesis by (simp add: algebra_simps)\nqed", "origin": "rearrange_equation", "update_count": 0}, "cross_multiply_equation": {"skill_name": "cross_multiply_equation", "marker": "lemma cross_multiply_equation:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a/b) = (c/d) \\<longleftrightarrow> (a * d = c * b)\"\nproof -\n  have \"(a/b) = (c/d) \\<longleftrightarrow> (a * d = c * b)\" using assms by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma cross_multiply_equation:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" \"d \\<noteq> 0\"\n  shows \"(a/b) = (c/d) \\<longleftrightarrow> (a * d = c * b)\"\nproof -\n  have \"(a/b) = (c/d) \\<longleftrightarrow> (a * d = c * b)\" using assms by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "symmetric_difference": {"skill_name": "symmetric_difference", "marker": "lemma symmetric_difference:\n  fixes a b :: real\n  shows \"a - b = (2/b - 2/a) \\<longleftrightarrow> a + 2/a = b + 2/b\"\nproof -\n  {\n    assume \"a - b = (2/b - 2/a)\"\n    then have \"a + 2/a = b + 2/b\" by (simp add: field_simps)\n  }\n  moreover {\n    assume \"a + 2/a = b + 2/b\"\n    hence \"a - b = (2/b - 2/a)\" by (simp add: field_simps)\n  }\n  ultimately show \"a - b = (2/b - 2/a) \\<longleftrightarrow> a + 2/a = b + 2/b\" by blast\nqed", "description": "-", "full_code": "lemma symmetric_difference:\n  fixes a b :: real\n  shows \"a - b = (2/b - 2/a) \\<longleftrightarrow> a + 2/a = b + 2/b\"\nproof -\n  {\n    assume \"a - b = (2/b - 2/a)\"\n    then have \"a + 2/a = b + 2/b\" by (simp add: field_simps)\n  }\n  moreover {\n    assume \"a + 2/a = b + 2/b\"\n    hence \"a - b = (2/b - 2/a)\" by (simp add: field_simps)\n  }\n  ultimately show \"a - b = (2/b - 2/a) \\<longleftrightarrow> a + 2/a = b + 2/b\" by blast\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_with_simplification": {"skill_name": "rearrange_equation_with_simplification", "marker": "lemma rearrange_equation_with_simplification:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  hence \"x - y = 2/y - 2/x\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_simplification:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  hence \"x - y = 2/y - 2/x\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_with_square": {"skill_name": "rearrange_equation_with_square", "marker": "lemma rearrange_equation_with_square:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"(x - y)^2 = (2/y - 2/x)^2\"\nproof -\n  have \"x - y = (2/y - 2/x)\" using rearrange_equation_with_simplification assms by auto\n  thus ?thesis by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_simplification:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  hence \"x - y = 2/y - 2/x\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed\n\nlemma rearrange_equation_with_square:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"(x - y)^2 = (2/y - 2/x)^2\"\nproof -\n  have \"x - y = (2/y - 2/x)\" using rearrange_equation_with_simplification assms by auto\n  thus ?thesis by (simp add: power2_eq_square)\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_generalV3": {"skill_name": "rearrange_equation_generalV3", "marker": "lemma rearrange_equation_general:\n  fixes x y :: real\n  assumes \"x + c/x = y + c/y\" \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"c > 0\"\n  shows \"x - y = (c/y - c/x)\"\nproof -\n  have \"x + c/x - (y + c/y) = 0\" using assms(1) by simp\n  then have \"x - y = (c/y - c/x)\" \n    using assms(2) assms(3) by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_general:\n  fixes x y :: real\n  assumes \"x + c/x = y + c/y\" \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"c > 0\"\n  shows \"x - y = (c/y - c/x)\"\nproof -\n  have \"x + c/x - (y + c/y) = 0\" using assms(1) by simp\n  then have \"x - y = (c/y - c/x)\" \n    using assms(2) assms(3) by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearranged_expression_simplified": {"skill_name": "rearranged_expression_simplified", "marker": "lemma rearranged_expression_simplified:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" \"x > 0\" \"y > 0\"\n  shows \"x - y = 2 * (1/y - 1/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by simp\n  thus ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma rearranged_expression_simplified:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" \"x > 0\" \"y > 0\"\n  shows \"x - y = 2 * (1/y - 1/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by simp\n  thus ?thesis by (simp add: field_simps)\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearranged_equation_with_factorization": {"skill_name": "rearranged_equation_with_factorization", "marker": "lemma rearranged_equation_with_factorization:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = 2/y - 2/x\" by (simp add: field_simps)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma rearranged_equation_with_factorization:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = 2/y - 2/x\" by (simp add: field_simps)\n  thus ?thesis by auto\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearranged_equation_extended": {"skill_name": "rearranged_equation_extended", "marker": "lemma rearranged_equation_extended:\n  fixes x y z :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\n  and \"x + z + 2/x = y + z + 2/y\"\nproof -\n  have eq: \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show \"x - y = (2/y - 2/x)\" by simp\n  have \"x + z + 2/x = y + z + 2/y\" \n    using eq by (simp add: field_simps)\n  thus \"x + z + 2/x = y + z + 2/y\" by simp\nqed", "description": "-", "full_code": "lemma rearranged_equation_extended:\n  fixes x y z :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\n  and \"x + z + 2/x = y + z + 2/y\"\nproof -\n  have eq: \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then show \"x - y = (2/y - 2/x)\" by simp\n  have \"x + z + 2/x = y + z + 2/y\" \n    using eq by (simp add: field_simps)\n  thus \"x + z + 2/x = y + z + 2/y\" by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "complex_case_equivalence": {"skill_name": "complex_case_equivalence", "marker": "theorem complex_case_equivalence:\n  fixes x y :: complex\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2 / x = y + 2 / y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2 / x = y + 2 / y\" using h3 by simp\n  have rearranged: \"x - y = (2 / y - 2 / x)\" using eq by (simp add: field_simps)\n  have cross_mult: \"(x - y) * (x * y) = 2 * (x - y)\" \n    using rearranged by (smt (verit) diff_frac_eq divide_divide_eq_left' eq_iff_diff_eq_0 frac_eq_eq h0 h1 h2 mult.commute no_zero_divisors nonzero_mult_divide_mult_cancel_left right_diff_distrib')\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h2 by auto\n  next\n    case False\n    then have \"x * y = 2\" using cross_mult by (smt (verit) eq_divide_imp nonzero_mult_div_cancel_left)\n    thus ?thesis by simp\n  qed\n  thus ?thesis by blast\nqed", "description": "-", "full_code": "theorem complex_case_equivalence:\n  fixes x y :: complex\n  assumes h0 : \"x \\<noteq> 0\"\n    and h1 : \"y \\<noteq> 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2 / x = y + 2 / y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2 / x = y + 2 / y\" using h3 by simp\n  have rearranged: \"x - y = (2 / y - 2 / x)\" using eq by (simp add: field_simps)\n  have cross_mult: \"(x - y) * (x * y) = 2 * (x - y)\" \n    using rearranged by (smt (verit) diff_frac_eq divide_divide_eq_left' eq_iff_diff_eq_0 frac_eq_eq h0 h1 h2 mult.commute no_zero_divisors nonzero_mult_divide_mult_cancel_left right_diff_distrib')\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h2 by auto\n  next\n    case False\n    then have \"x * y = 2\" using cross_mult by (smt (verit) eq_divide_imp nonzero_mult_div_cancel_left)\n    thus ?thesis by simp\n  qed\n  thus ?thesis by blast\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "common_terms": {"skill_name": "common_terms", "marker": "lemma common_terms:\n  fixes a b :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b + b = c\" by (simp add: assms)\n  then show ?thesis by (metis add.commute add_cancel_left_right assms cancel_ab_semigroup_add_class.diff_right_commute crossproduct_eq diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0 minus_diff_eq mult.commute mult_cancel_right2 mult_eq_0_iff mult_minus_right neg_0_equal_iff_equal zero_neq_neg_one)\nqed", "description": "-", "full_code": "lemma common_terms:\n  fixes a b :: real\n  assumes \"a + b = c\"\n  shows \"a = c - b\"\nproof -\n  have \"c - b + b = c\" by (simp add: assms)\n  then show ?thesis by (metis add.commute add_cancel_left_right assms cancel_ab_semigroup_add_class.diff_right_commute crossproduct_eq diff_add_eq_diff_diff_swap diff_eq_diff_eq eq_iff_diff_eq_0 minus_diff_eq mult.commute mult_cancel_right2 mult_eq_0_iff mult_minus_right neg_0_equal_iff_equal zero_neq_neg_one)\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equationV2": {"skill_name": "rearrange_equationV2", "marker": "lemma rearrange_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" using algebra_simps by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" using algebra_simps by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_and_factor": {"skill_name": "rearrange_and_factor", "marker": "lemma rearrange_and_factor:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_and_factor:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "amc12a_2013_p8_extended": {"skill_name": "amc12a_2013_p8_extended", "marker": "theorem amc12a_2013_p8_extended:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\" and h1 : \"y\\<noteq>0\" and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\" and h4 : \"x\\<noteq>z\" and h5 : \"y\\<noteq>z\"\n    and h6 : \"x + 2/x = y + 2/y\" and h7: \"x + 2/x = z + 2/z\"\n  shows \"x * y * z = 2 * (y + z + 2/(y + z))\"\nproof -\n  have eq_xy: \"x + 2 / x = y + 2 / y\" using h6 by simp\n  have eq_xz: \"x + 2 / x = z + 2 / z\" using h7 by simp\n  have rearranged_xy: \"x - y = (2/y - 2/x)\" using eq_xy by (simp add: field_simps)\n  have rearranged_xz: \"x - z = (2/z - 2/x)\" using eq_xz by (simp add: field_simps)\n  have cross_mult_xy: \"(x - y) * (x * y) = 2 * (x - y)\" using rearranged_xy by sos\n  have cross_mult_xz: \"(x - z) * (x * z) = 2 * (x - z)\" using rearranged_xz by sos\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h3 by auto\n  next\n    case False\n    then have \"x * y = 2\" using cross_mult_xy by sos\n    thus ?thesis by simp\n  qed\n  have \"x * z = 2\" \n  proof (cases \"x - z = 0\")\n    case True\n    then show ?thesis using h4 by auto\n  next\n    case False\n    then have \"x * z = 2\" using cross_mult_xz by sos\n    thus ?thesis by simp\n  qed\n  then show ?thesis using `x * y = 2` by (metis add.commute add_diff_cancel_left' add_divide_eq_if_simps(1) dbl_simps(3) divide_eq_eq h1 h2 h5 h6 h7)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_extended:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\" and h1 : \"y\\<noteq>0\" and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\" and h4 : \"x\\<noteq>z\" and h5 : \"y\\<noteq>z\"\n    and h6 : \"x + 2/x = y + 2/y\" and h7: \"x + 2/x = z + 2/z\"\n  shows \"x * y * z = 2 * (y + z + 2/(y + z))\"\nproof -\n  have eq_xy: \"x + 2 / x = y + 2 / y\" using h6 by simp\n  have eq_xz: \"x + 2 / x = z + 2 / z\" using h7 by simp\n  have rearranged_xy: \"x - y = (2/y - 2/x)\" using eq_xy by (simp add: field_simps)\n  have rearranged_xz: \"x - z = (2/z - 2/x)\" using eq_xz by (simp add: field_simps)\n  have cross_mult_xy: \"(x - y) * (x * y) = 2 * (x - y)\" using rearranged_xy by sos\n  have cross_mult_xz: \"(x - z) * (x * z) = 2 * (x - z)\" using rearranged_xz by sos\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h3 by auto\n  next\n    case False\n    then have \"x * y = 2\" using cross_mult_xy by sos\n    thus ?thesis by simp\n  qed\n  have \"x * z = 2\" \n  proof (cases \"x - z = 0\")\n    case True\n    then show ?thesis using h4 by auto\n  next\n    case False\n    then have \"x * z = 2\" using cross_mult_xz by sos\n    thus ?thesis by simp\n  qed\n  then show ?thesis using `x * y = 2` by (metis add.commute add_diff_cancel_left' add_divide_eq_if_simps(1) dbl_simps(3) divide_eq_eq h1 h2 h5 h6 h7)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "rearrange_equationV3": {"skill_name": "rearrange_equationV3", "marker": "lemma rearrange_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" \n    using field_simps by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" \n    using field_simps by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_with_mult": {"skill_name": "rearrange_equation_with_mult", "marker": "lemma rearrange_equation_with_mult:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = 2/y - 2/x\" \n    by (simp add: field_simps)  \n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_mult:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = 2/y - 2/x\" \n    by (simp add: field_simps)  \n  thus ?thesis by auto\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_with_conditionsV2": {"skill_name": "rearrange_equation_with_conditionsV2", "marker": "lemma rearrange_equation_with_conditions:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\" \"x > 0\" \"y > 0\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms(1) by simp\n  then show ?thesis by (simp add: assms(2) assms(3))\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_conditions:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\" \"x > 0\" \"y > 0\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms(1) by simp\n  then show ?thesis by (simp add: assms(2) assms(3))\nqed", "origin": "rearrange_equation", "update_count": 0}, "general_equation_identity": {"skill_name": "general_equation_identity", "marker": "lemma general_equation_identity:\n  fixes x y :: real\n  assumes \"x + 2 / a = y + 2 / b\"\n  shows \"x - y = (2 / b - 2 / a)\"\nproof -\n  have \"x + 2 / a - (y + 2 / b) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma general_equation_identity:\n  fixes x y :: real\n  assumes \"x + 2 / a = y + 2 / b\"\n  shows \"x - y = (2 / b - 2 / a)\"\nproof -\n  have \"x + 2 / a - (y + 2 / b) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "generalize_rearrangement": {"skill_name": "generalize_rearrangement", "marker": "lemma generalize_rearrangement:\n  fixes a b x y :: real\n  assumes \"x + a / x = y + b / y\"\n  shows \"x - y = (b / y - a / x)\"\nproof -\n  have \"x + a / x - (y + b / y) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma generalize_rearrangement:\n  fixes a b x y :: real\n  assumes \"x + a / x = y + b / y\"\n  shows \"x - y = (b / y - a / x)\"\nproof -\n  have \"x + a / x - (y + b / y) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "sum_product_relation": {"skill_name": "sum_product_relation", "marker": "lemma sum_product_relation:\n  fixes x y :: real\n  assumes \"x + y = s\" and \"x * y = p\"\n  shows \"x^2 + y^2 = s^2 - 2 * p\"\nproof -\n  have \"x^2 + y^2 = (x + y)^2 - 2 * x * y\" \n    by sos\n  then show ?thesis using assms by simp\nqed", "description": "-", "full_code": "lemma sum_product_relation:\n  fixes x y :: real\n  assumes \"x + y = s\" and \"x * y = p\"\n  shows \"x^2 + y^2 = s^2 - 2 * p\"\nproof -\n  have \"x^2 + y^2 = (x + y)^2 - 2 * x * y\" \n    by sos\n  then show ?thesis using assms by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "manipulate_equationV2": {"skill_name": "manipulate_equationV2", "marker": "lemma manipulate_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma manipulate_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "cross_multiply_difference": {"skill_name": "cross_multiply_difference", "marker": "lemma cross_multiply_difference:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> a\" and \"d \\<noteq> c\"\n  shows \"(a - b) * (c - d) = (a * c - a * d - b * c + b * d)\"\nproof -\n  have \"a * c - a * d - b * c + b * d = (a - b) * (c - d)\"\n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma cross_multiply_difference:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> a\" and \"d \\<noteq> c\"\n  shows \"(a - b) * (c - d) = (a * c - a * d - b * c + b * d)\"\nproof -\n  have \"a * c - a * d - b * c + b * d = (a - b) * (c - d)\"\n    by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "rearrange_equation_with_common_termsV3": {"skill_name": "rearrange_equation_with_common_termsV3", "marker": "lemma rearrange_equation_with_common_terms:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = 2/y - 2/x\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_common_terms:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = 2/y - 2/x\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_and_multiply": {"skill_name": "rearrange_and_multiply", "marker": "lemma rearrange_and_multiply:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms by simp\n  thus ?thesis by (simp add: algebra_simps)\nqed", "description": "-", "full_code": "lemma rearrange_and_multiply:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms by simp\n  thus ?thesis by (simp add: algebra_simps)\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_generalV4": {"skill_name": "rearrange_equation_generalV4", "marker": "lemma rearrange_equation_general:\n  fixes x y :: real\n  assumes \"x + a/x = y + a/y\" \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"x - y = (a/y - a/x)\"\nproof -\n  have \"x + a/x - (y + a/y) = 0\" using assms(1) by simp\n  then have \"x - y = (a/y - a/x)\" \n    using assms(2) assms(3) by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_general:\n  fixes x y :: real\n  assumes \"x + a/x = y + a/y\" \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"x - y = (a/y - a/x)\"\nproof -\n  have \"x + a/x - (y + a/y) = 0\" using assms(1) by simp\n  then have \"x - y = (a/y - a/x)\" \n    using assms(2) assms(3) by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_for_rat": {"skill_name": "rearrange_equation_for_rat", "marker": "lemma rearrange_equation_for_rat:\n  fixes x y :: rat\n  assumes \"x + 2/x = y + 2/y\" and \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms(1) by simp\n  thus ?thesis by (simp add: assms(2) assms(3) field_simps)\nqed", "description": "-", "full_code": "lemma rearrange_equation_for_rat:\n  fixes x y :: rat\n  assumes \"x + 2/x = y + 2/y\" and \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms(1) by simp\n  thus ?thesis by (simp add: assms(2) assms(3) field_simps)\nqed", "origin": "rearrange_equation", "update_count": 0}, "generalize_rearrangementV2": {"skill_name": "generalize_rearrangementV2", "marker": "lemma generalize_rearrangement:\n  fixes x y :: real\n  assumes \"x + a/x = y + a/y\" and \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x - y = (a/y - a/x)\"\nproof -\n  have \"x + a/x - (y + a/y) = 0\" using assms(1) by simp\n  then have \"x - y = a/y - a/x\" by (simp add: field_simps)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma generalize_rearrangement:\n  fixes x y :: real\n  assumes \"x + a/x = y + a/y\" and \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x - y = (a/y - a/x)\"\nproof -\n  have \"x + a/x - (y + a/y) = 0\" using assms(1) by simp\n  then have \"x - y = a/y - a/x\" by (simp add: field_simps)\n  thus ?thesis by auto\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_and_simplify_two_equations": {"skill_name": "rearrange_and_simplify_two_equations", "marker": "lemma rearrange_and_simplify_two_equations:\n  fixes x y z :: real\n  assumes \"x + 2/x = y + 2/y\" \"x + 2/x = z + 2/z\"\n  shows \"y - z = (2/z - 2/y)\"\nproof -\n  have \"y + 2/y = x + 2/x\" and \"z + 2/z = x + 2/x\" using assms by simp_all\n  thus ?thesis \n    using rearrange_and_simplify_equation by auto\nqed", "description": "-", "full_code": "lemma rearrange_and_simplify_equation:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" \n    by (auto simp add: field_simps)\n  thus ?thesis by simp\nqed\n\nlemma rearrange_and_simplify_two_equations:\n  fixes x y z :: real\n  assumes \"x + 2/x = y + 2/y\" \"x + 2/x = z + 2/z\"\n  shows \"y - z = (2/z - 2/y)\"\nproof -\n  have \"y + 2/y = x + 2/x\" and \"z + 2/z = x + 2/x\" using assms by simp_all\n  thus ?thesis \n    using rearrange_and_simplify_equation by auto\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_with_nonnegatives": {"skill_name": "rearrange_equation_with_nonnegatives", "marker": "lemma rearrange_equation_with_nonnegatives:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" \"x > 0\" \"y > 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms(1) by simp\n  hence \"x - y = (2/y - 2/x)\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_nonnegatives:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" \"x > 0\" \"y > 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms(1) by simp\n  hence \"x - y = (2/y - 2/x)\" by simp\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "absolute_value_triangle_inequality": {"skill_name": "absolute_value_triangle_inequality", "marker": "theorem absolute_value_triangle_inequality:\n  fixes a b c :: real\n  assumes h0: \"c > 0\"\n  shows \"abs(a - b) \\<le> abs(a - c) + abs(c - b)\"\nproof -\n  have \"a - b \\<le> abs(a - c) + abs(c - b)\" \n    by auto\n  moreover have \"b - a \\<le> abs(a - c) + abs(c - b)\"\n    by auto\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "theorem absolute_value_triangle_inequality:\n  fixes a b c :: real\n  assumes h0: \"c > 0\"\n  shows \"abs(a - b) \\<le> abs(a - c) + abs(c - b)\"\nproof -\n  have \"a - b \\<le> abs(a - c) + abs(c - b)\" \n    by auto\n  moreover have \"b - a \\<le> abs(a - c) + abs(c - b)\"\n    by auto\n  ultimately show ?thesis by auto\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_positive": {"skill_name": "amc12a_2013_p8_positive", "marker": "theorem amc12a_2013_p8_positive:\n  fixes x y :: real\n  assumes h0 : \"x > 0\"\n    and h1 : \"y > 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2 / x = y + 2 / y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2 / x = y + 2 / y\" using h3 by simp\n  have rearranged: \"x - y = (2 / y - 2 / x)\" using eq by (simp add: field_simps)\n  have cross_mult: \"(x - y) * (x * y) = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h2 by auto\n  next\n    case False\n    then have \"x * y = 2\" using cross_mult by sos\n    thus ?thesis by simp\n  qed\n  thus ?thesis by blast\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_positive:\n  fixes x y :: real\n  assumes h0 : \"x > 0\"\n    and h1 : \"y > 0\"\n    and h2 : \"x \\<noteq> y\"\n    and h3 : \"x + 2 / x = y + 2 / y\"\n  shows \"x * y = 2\"\nproof -\n  have eq: \"x + 2 / x = y + 2 / y\" using h3 by simp\n  have rearranged: \"x - y = (2 / y - 2 / x)\" using eq by (simp add: field_simps)\n  have cross_mult: \"(x - y) * (x * y) = 2 * (x - y)\" \n    using rearranged by sos\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h2 by auto\n  next\n    case False\n    then have \"x * y = 2\" using cross_mult by sos\n    thus ?thesis by simp\n  qed\n  thus ?thesis by blast\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "generalized_rearrangement": {"skill_name": "generalized_rearrangement", "marker": "theorem generalized_rearrangement:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "theorem generalized_rearrangement:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearranged_equation_difference": {"skill_name": "rearranged_equation_difference", "marker": "lemma rearranged_equation_difference:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  hence \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearranged_equation_difference:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  hence \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "generalized_rearrangementV2": {"skill_name": "generalized_rearrangementV2", "marker": "lemma generalized_rearrangement:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms by simp\n  hence \"x - y = (b/y - a/x)\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma generalized_rearrangement:\n  fixes x y a b :: real\n  assumes \"x + a/x = y + b/y\"\n  shows \"x - y = (b/y - a/x)\"\nproof -\n  have \"x + a/x - (y + b/y) = 0\" using assms by simp\n  hence \"x - y = (b/y - a/x)\" by (simp add: field_simps)\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "manipulate_fraction": {"skill_name": "manipulate_fraction", "marker": "lemma manipulate_fraction:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma manipulate_fraction:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "differences_of_rearrangements": {"skill_name": "differences_of_rearrangements", "marker": "theorem differences_of_rearrangements:\n  fixes a b :: real\n  assumes \"a + 2/a = b + 2/b\"\n  shows \"a - b = (2/b - 2/a)\"\nproof -\n  have \"a + 2/a - (b + 2/b) = 0\" using assms by simp\n  then show ?thesis by (simp add: field_simps)\nqed", "description": "-", "full_code": "theorem differences_of_rearrangements:\n  fixes a b :: real\n  assumes \"a + 2/a = b + 2/b\"\n  shows \"a - b = (2/b - 2/a)\"\nproof -\n  have \"a + 2/a - (b + 2/b) = 0\" using assms by simp\n  then show ?thesis by (simp add: field_simps)\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_and_simplify": {"skill_name": "rearrange_and_simplify", "marker": "lemma rearrange_and_simplify:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: algebra_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_and_simplify:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by (simp add: algebra_simps)\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_n_dimensionsV2": {"skill_name": "rearrange_equation_n_dimensionsV2", "marker": "lemma rearrange_equation_n_dimensions:\n  fixes x y :: \"real set\"\n  assumes \"finite x\" \"finite y\" \n    and \"(\\<Sum>i\\<in>x. i) + 2/(\\<Sum>i\\<in>x. i) = (\\<Sum>j\\<in>y. j) + 2/(\\<Sum>j\\<in>y. j)\"\n  shows \"(\\<Sum>i\\<in>x. i) - (\\<Sum>j\\<in>y. j) = (2/(\\<Sum>j\\<in>y. j) - 2/(\\<Sum>i\\<in>x. i))\"\nproof -\n  have \"(\\<Sum>i\\<in>x. i) + 2/(\\<Sum>i\\<in>x. i) - ((\\<Sum>j\\<in>y. j) + 2/(\\<Sum>j\\<in>y. j)) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_n_dimensions:\n  fixes x y :: \"real set\"\n  assumes \"finite x\" \"finite y\" \n    and \"(\\<Sum>i\\<in>x. i) + 2/(\\<Sum>i\\<in>x. i) = (\\<Sum>j\\<in>y. j) + 2/(\\<Sum>j\\<in>y. j)\"\n  shows \"(\\<Sum>i\\<in>x. i) - (\\<Sum>j\\<in>y. j) = (2/(\\<Sum>j\\<in>y. j) - 2/(\\<Sum>i\\<in>x. i))\"\nproof -\n  have \"(\\<Sum>i\\<in>x. i) + 2/(\\<Sum>i\\<in>x. i) - ((\\<Sum>j\\<in>y. j) + 2/(\\<Sum>j\\<in>y. j)) = 0\" using assms by simp\n  then show ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_with_division_multiple": {"skill_name": "rearrange_equation_with_division_multiple", "marker": "lemma rearrange_equation_with_division_multiple:\n  fixes x y z :: real\n  assumes \"x + 2/x + z = y + 2/y + z\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x + z - (y + 2/y + z) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_division:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x) + (y - y)\" by simp\n  thus ?thesis by simp\nqed\n\nlemma rearrange_equation_with_division_multiple:\n  fixes x y z :: real\n  assumes \"x + 2/x + z = y + 2/y + z\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x + z - (y + 2/y + z) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" by simp\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "cross_multiplicationV4": {"skill_name": "cross_multiplicationV4", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> d\"\n  shows \"(a - b) * (c - d) = (a * c - a * d - b * c + b * d)\"\nproof -\n  have \"a * c - a * d - b * c + b * d = a * (c - d) - b * (c - d)\"\n    by (simp add: algebra_simps)\n  then show ?thesis \n    by (simp add: field_simps)\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> d\"\n  shows \"(a - b) * (c - d) = (a * c - a * d - b * c + b * d)\"\nproof -\n  have \"a * c - a * d - b * c + b * d = a * (c - d) - b * (c - d)\"\n    by (simp add: algebra_simps)\n  then show ?thesis \n    by (simp add: field_simps)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "amc12a_2013_p8_extendedV2": {"skill_name": "amc12a_2013_p8_extendedV2", "marker": "theorem amc12a_2013_p8_extended:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\" and h1 : \"y\\<noteq>0\" and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\" and h4 : \"y\\<noteq>z\" and h5 : \"x\\<noteq>z\"\n    and h6 : \"x + 2/x = y + 2/y\" and h7 : \"y + 2/y = z + 2/z\"\n  shows \"x * y * z = 4\"\nproof -\n  have eq1: \"x + 2 / x = y + 2 / y\" using h6 by simp\n  have eq2: \"y + 2 / y = z + 2 / z\" using h7 by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" using eq1 by (simp add: field_simps)\n  have rearranged2: \"y - z = (2/z - 2/y)\" using eq2 by (simp add: field_simps)\n  have cross_mult1: \"(x - y) * (x * y) = 2 * (x - y)\" \n    using rearranged1 by sos\n  have cross_mult2: \"(y - z) * (y * z) = 2 * (y - z)\" \n    using rearranged2 by sos\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h3 by auto\n  next\n    case False\n    then have \"x * y = 2\" using cross_mult1 by sos\n    thus ?thesis by simp\n  qed\n  then have \"y * z = 2\" \n  proof (cases \"y - z = 0\")\n    case True\n    then show ?thesis using h4 by auto\n  next\n    case False\n    then have \"y * z = 2\" using cross_mult2 by sos\n    thus ?thesis by simp\n  qed\n  thus ?thesis using `x * y = 2` and `y * z = 2` by (metis add_diff_cancel_left' dbl_simps(3) diff_add_cancel eq_divide_eq h1 h2 h5 rearranged2)\nqed", "description": "-", "full_code": "theorem amc12a_2013_p8_extended:\n  fixes x y z :: real\n  assumes h0 : \"x\\<noteq>0\" and h1 : \"y\\<noteq>0\" and h2 : \"z\\<noteq>0\"\n    and h3 : \"x\\<noteq>y\" and h4 : \"y\\<noteq>z\" and h5 : \"x\\<noteq>z\"\n    and h6 : \"x + 2/x = y + 2/y\" and h7 : \"y + 2/y = z + 2/z\"\n  shows \"x * y * z = 4\"\nproof -\n  have eq1: \"x + 2 / x = y + 2 / y\" using h6 by simp\n  have eq2: \"y + 2 / y = z + 2 / z\" using h7 by simp\n  have rearranged1: \"x - y = (2/y - 2/x)\" using eq1 by (simp add: field_simps)\n  have rearranged2: \"y - z = (2/z - 2/y)\" using eq2 by (simp add: field_simps)\n  have cross_mult1: \"(x - y) * (x * y) = 2 * (x - y)\" \n    using rearranged1 by sos\n  have cross_mult2: \"(y - z) * (y * z) = 2 * (y - z)\" \n    using rearranged2 by sos\n  have \"x * y = 2\" \n  proof (cases \"x - y = 0\")\n    case True\n    then show ?thesis using h3 by auto\n  next\n    case False\n    then have \"x * y = 2\" using cross_mult1 by sos\n    thus ?thesis by simp\n  qed\n  then have \"y * z = 2\" \n  proof (cases \"y - z = 0\")\n    case True\n    then show ?thesis using h4 by auto\n  next\n    case False\n    then have \"y * z = 2\" using cross_mult2 by sos\n    thus ?thesis by simp\n  qed\n  thus ?thesis using `x * y = 2` and `y * z = 2` by (metis add_diff_cancel_left' dbl_simps(3) diff_add_cancel eq_divide_eq h1 h2 h5 rearranged2)\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiplicationV5": {"skill_name": "cross_multiplicationV5", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(a - c) * (b * d) = d * (a * b - c * b)\"\nproof -\n  have \"b * d * (a - c) = d * (b * a - b * c)\" by (simp add: field_simps)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(a - c) * (b * d) = d * (a * b - c * b)\"\nproof -\n  have \"b * d * (a - c) = d * (b * a - b * c)\" by (simp add: field_simps)\n  thus ?thesis by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiplicationV6": {"skill_name": "cross_multiplicationV6", "marker": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(a - b) * (c - d) = a*c - a*d - b*c + b*d\"\nproof -\n  have \"a * (c - d) - b * (c - d) = a * c - a * d - b * c + b * d\"\n    by (simp add: algebra_simps)\n  thus ?thesis by sos\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(a - b) * (c - d) = a*c - a*d - b*c + b*d\"\nproof -\n  have \"a * (c - d) - b * (c - d) = a * c - a * d - b * c + b * d\"\n    by (simp add: algebra_simps)\n  thus ?thesis by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiply": {"skill_name": "cross_multiply", "marker": "lemma cross_multiply:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(a - c) * (b * d) = (d * (a - c)) * b\"\nproof -\n  have \"(a - c) * b * d = (d * (a - c)) * b\" by (simp add: assms)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma cross_multiply:\n  fixes a b c d :: real\n  assumes \"b \\<noteq> 0\" and \"d \\<noteq> 0\"\n  shows \"(a - c) * (b * d) = (d * (a - c)) * b\"\nproof -\n  have \"(a - c) * b * d = (d * (a - c)) * b\" by (simp add: assms)\n  thus ?thesis by auto\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "cross_multiplicationV7": {"skill_name": "cross_multiplicationV7", "marker": "lemma cross_multiplication:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\"\n    and \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n    and \"x + 2/x = y + 2/y\"\n  shows \"(x - y) * (x * y) = 2 * (x - y)\"\nproof -\n  have eq: \"x + 2 / x = y + 2 / y\" using assms(3) by (metis assms(4))\n  have rearranged: \"x - y = (2/y - 2/x)\" using eq by (simp add: field_simps)\n  then show ?thesis by sos\nqed", "description": "-", "full_code": "lemma cross_multiplication:\n  fixes x y :: real\n  assumes \"x \\<noteq> y\"\n    and \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n    and \"x + 2/x = y + 2/y\"\n  shows \"(x - y) * (x * y) = 2 * (x - y)\"\nproof -\n  have eq: \"x + 2 / x = y + 2 / y\" using assms(3) by (metis assms(4))\n  have rearranged: \"x - y = (2/y - 2/x)\" using eq by (simp add: field_simps)\n  then show ?thesis by sos\nqed", "origin": "amc12a_2013_p8", "update_count": 0}, "manipulate_fractions": {"skill_name": "manipulate_fractions", "marker": "lemma manipulate_fractions:\n  fixes a b :: real\n  assumes \"b \\<noteq> 0\" \"a \\<noteq> 0\"\n  shows \"1/a - 1/b = (b - a)/(a*b)\"\nproof -\n  have \"1/a - 1/b = b/(a*b) - a/(a*b)\" using assms by simp\n  then show ?thesis by (smt (verit) diff_divide_distrib)\nqed", "description": "-", "full_code": "lemma manipulate_fractions:\n  fixes a b :: real\n  assumes \"b \\<noteq> 0\" \"a \\<noteq> 0\"\n  shows \"1/a - 1/b = (b - a)/(a*b)\"\nproof -\n  have \"1/a - 1/b = b/(a*b) - a/(a*b)\" using assms by simp\n  then show ?thesis by (smt (verit) diff_divide_distrib)\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_with_differences": {"skill_name": "rearrange_equation_with_differences", "marker": "lemma rearrange_equation_with_differences:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" and \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" \n    by auto\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma rearrange_equation_with_differences:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\" and \"x \\<noteq> 0\" and \"y \\<noteq> 0\"\n  shows \"x - y = (2/y - 2/x)\"\nproof -\n  have \"x + 2/x - (y + 2/y) = 0\" using assms by simp\n  then have \"x - y = (2/y - 2/x)\" \n    by auto\n  thus ?thesis by simp\nqed", "origin": "rearrange_equation", "update_count": 0}, "rearrange_equation_simplified": {"skill_name": "rearrange_equation_simplified", "marker": "lemma rearrange_equation_simplified:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\n  using rearrange_equation_general[of x y 2] assms by simp", "description": "-", "full_code": "lemma rearrange_equation_general:\n  fixes x y :: real\n  assumes \"x + a/x = y + a/y\" and \"a > 0\"\n  shows \"x - y = (a/y - a/x)\"\nproof -\n  have \"x + a/x - (y + a/y) = 0\" using assms by simp\n  then show ?thesis by simp\nqed\n\nlemma rearrange_equation_simplified:\n  fixes x y :: real\n  assumes \"x + 2/x = y + 2/y\"\n  shows \"x - y = (2/y - 2/x)\"\n  using rearrange_equation_general[of x y 2] assms by simp", "origin": "rearrange_equation", "update_count": 0}}
{"cal_log_value": {"skill_name": "cal_log_value", "marker": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "description": "This skill calculates the value of a number given its logarithm. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes four arguments: two real numbers 'a' and 'b' which are greater than 0 and 'a' is not equal to 1, and a real number 'c' which is the logarithm base 'a' of 'b'. It returns the value of 'b', which is equal to 'a' raised to the power 'c'.", "full_code": "lemma cal_log_value:\n  assumes \"a > 0\" and \"a \u2260 1\" and \"b > 0\" and \"log a b = c\"\n  shows \"b = a ^ c\"\nby (metis assms(1) assms(2) assms(3) assms(4) powr_log_cancel powr_realpow)", "origin": "", "update_count": 0}, "mod_add_power": {"skill_name": "mod_add_power", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "description": "This skill is a mathematical property that states that if `x mod n = a`, then the modulus of the power of `(x + b)` and `(a + b)` with respect to `n` are equal. This skill can be used in any context where the modulus of the power of two numbers is required.", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b)^c mod n = ((x mod n) + b)^c mod n\"\n    by (smt (verit) mod_add_left_eq power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by auto\n  finally show ?thesis by auto\nqed", "origin": "", "update_count": 0}, "cancle_div": {"skill_name": "cancle_div", "marker": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "description": "This skill is a mathematical property that can be used to simplify expressions involving division and multiplication. If you have an equation of the form \"a + b / x = c\" for some real numbers a, b, c, and x (where x > 0), you can use this skill to transform the equation into \"a * x + b = c * x\". This can be useful in many mathematical proofs where simplification of expressions is required.", "full_code": "lemma cancle_div:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show ?thesis\n    using assms(1) by (simp add: mult.commute)\nqed", "origin": "", "update_count": 0}, "multi_distrib_complex": {"skill_name": "multi_distrib_complex", "marker": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "description": "This skill is a generalization of the distributive property of multiplication over addition for complex numbers. It can be used in any context where the distributive property of multiplication over addition for complex numbers is needed. To use this skill, you need to provide four complex numbers a, b, c, and d. The skill will then prove that the product of the sum of a and b and the sum of c and d is equal to the sum of the products of each pair of complex numbers.", "full_code": "lemma multi_distrib_complex:\n  fixes a b c d :: complex\n  shows \"(a + b) * (c + d) = a * c + a * d + b * c + b * d\"\n  by (simp add: distrib_left distrib_right)", "origin": "", "update_count": 0}, "cal_log_exp_value": {"skill_name": "cal_log_exp_value", "marker": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "description": "This skill calculates the logarithm of a number raised to a power. It is a general mathematical property and can be used in any context where logarithms are involved. The skill takes three arguments: a real number 'a' which is greater than 0 and not equal to 1, and a positive integer 'n'. It returns the logarithm base 'a' of 'a' raised to the power 'n', which is equal to 'n'.", "full_code": "lemma cal_log_exp_value:\n  fixes a :: real\n  assumes \"a > 0\" \"a \u2260 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have c0: \"log a a = 1\"\n    by (simp add: assms(1) assms(2))\n  have \"log a (a^n) = n * (log a a)\"\n    using log_nat_power[of a a n] by (simp add: assms(1))\n  then have c1: \"log a (a^n) = n\"\n    using c0 by simp\n  then show ?thesis \n    by (simp add: c1)\nqed", "origin": "", "update_count": 0}, "a_times_vera": {"skill_name": "a_times_vera", "marker": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "description": "This skill demonstrates the property of any non-zero real number that when it is multiplied by its reciprocal, the result is 1. This is a fundamental property of division and multiplication in the field of real numbers. This skill can be used in any context where this property needs to be proven or used.", "full_code": "lemma a_times_vera:\n  fixes a :: real\n  assumes \"a \u2260 0\"\n  shows \" a * (1 / a) = 1\"\n  by (simp add: assms)", "origin": "", "update_count": 0}, "mod_exponentiation": {"skill_name": "mod_exponentiation", "marker": "lemma mod_exponentiation:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"(x^b) mod n = (a^b) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_exponentiation:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"(x^b) mod n = (a^b) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally show ?thesis by auto\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_general": {"skill_name": "mod_add_power_general", "marker": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b) mod n = (a + b) mod n\" using assms by (smt (verit) mod_add_left_eq)\n  then show ?thesis using assms by (metis mod_add_left_eq power_mod)\nqed", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b) mod n = (a + b) mod n\" using assms by (smt (verit) mod_add_left_eq)\n  then show ?thesis using assms by (metis mod_add_left_eq power_mod)\nqed", "origin": "mod_add_power", "update_count": 0}, "mod_add_power_generalV2": {"skill_name": "mod_add_power_generalV2", "marker": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b) mod n) = ((x mod n) + (b mod n)) mod n\" \n    using assms(1) by presburger\n  also have \"... = (a + b) mod n\"\n    using assms(4) by presburger\n  finally show ?thesis \n    using power_mod by (smt (verit) \\<open>(x + b) mod n = (x mod n + b mod n) mod n\\<close> \\<open>(x mod n + b mod n) mod n = (a + b) mod n\\<close>)\nqed", "description": "-", "full_code": "lemma mod_add_power_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"((x + b) mod n) = ((x mod n) + (b mod n)) mod n\" \n    using assms(1) by presburger\n  also have \"... = (a + b) mod n\"\n    using assms(4) by presburger\n  finally show ?thesis \n    using power_mod by (smt (verit) \\<open>(x + b) mod n = (x mod n + b mod n) mod n\\<close> \\<open>(x mod n + b mod n) mod n = (a + b) mod n\\<close>)\nqed", "origin": "mod_add_power", "update_count": 0}, "logarithm_of_power_generalized": {"skill_name": "logarithm_of_power_generalized", "marker": "lemma logarithm_of_power_generalized:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"k > 0\"\n  shows \"log a (a^k) = k\"\n  using logarithm_of_power[of a k] by (metis assms(1) assms(2) assms(3))", "description": "-", "full_code": "lemma logarithm_of_power:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    using log_nat_power[of a a n] by (simp add: assms(1) assms(2))\n  also have \"... = n * 1\"\n    by (metis assms(1) assms(2) log_eq_one mult.comm_neutral nat_mult_1_right)\n  finally show ?thesis by simp\nqed\n\nlemma logarithm_of_power_generalized:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"k > 0\"\n  shows \"log a (a^k) = k\"\n  using logarithm_of_power[of a k] by (metis assms(1) assms(2) assms(3))", "origin": "cal_log_exp_value", "update_count": 0}, "logarithm_of_power": {"skill_name": "logarithm_of_power", "marker": "lemma logarithm_of_power:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    using log_nat_power[of a a n] by (simp add: assms(1) assms(2))\n  also have \"... = n * 1\"\n    by (metis assms(1) assms(2) log_eq_one mult.comm_neutral nat_mult_1_right)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma logarithm_of_power:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    using log_nat_power[of a a n] by (simp add: assms(1) assms(2))\n  also have \"... = n * 1\"\n    by (metis assms(1) assms(2) log_eq_one mult.comm_neutral nat_mult_1_right)\n  finally show ?thesis by simp\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "logarithm_of_powerV2": {"skill_name": "logarithm_of_powerV2", "marker": "lemma logarithm_of_power:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    using log_nat_power[of a a n] assms(1) by simp\n  then show ?thesis \n    by (metis assms(1) assms(2) log_pow_cancel)\nqed", "description": "-", "full_code": "lemma logarithm_of_power:\n  fixes a :: real\n  assumes \"a > 0\" \"a \\<noteq> 1\" \"n > 0\"\n  shows \"log a (a^n) = n\"\nproof -\n  have \"log a (a^n) = n * log a a\"\n    using log_nat_power[of a a n] assms(1) by simp\n  then show ?thesis \n    by (metis assms(1) assms(2) log_pow_cancel)\nqed", "origin": "cal_log_exp_value", "update_count": 0}, "non_zero_times_inverse_extended": {"skill_name": "non_zero_times_inverse_extended", "marker": "lemma non_zero_times_inverse_extended:\n  fixes a :: \"real set\"\n  assumes \"\\<forall>x \\<in> a. x \\<noteq> 0\"\n  shows \"\\<forall>x \\<in> a. x * (1 / x) = 1\"\nproof -\n  have \"\\<forall>x \\<in> a. x * (1 / x) = 1\" \n  proof\n    fix x\n    assume \"x \\<in> a\"\n    then have \"x \\<noteq> 0\" using assms by auto\n    thus \"x * (1 / x) = 1\" by (simp add: non_zero_times_inverse)\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma non_zero_times_inverse:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  by (simp add: assms)\n\nlemma non_zero_times_inverse_extended:\n  fixes a :: \"real set\"\n  assumes \"\\<forall>x \\<in> a. x \\<noteq> 0\"\n  shows \"\\<forall>x \\<in> a. x * (1 / x) = 1\"\nproof -\n  have \"\\<forall>x \\<in> a. x * (1 / x) = 1\" \n  proof\n    fix x\n    assume \"x \\<in> a\"\n    then have \"x \\<noteq> 0\" using assms by auto\n    thus \"x * (1 / x) = 1\" by (simp add: non_zero_times_inverse)\n  qed\n  thus ?thesis by auto\nqed", "origin": "a_times_vera", "update_count": 0}, "a_times_vera_generalized": {"skill_name": "a_times_vera_generalized", "marker": "lemma a_times_vera_generalized:\n  fixes a :: real and b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (b / a) = b\"\n  by (simp add: assms)", "description": "-", "full_code": "lemma a_times_vera_generalized:\n  fixes a :: real and b :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (b / a) = b\"\n  by (simp add: assms)", "origin": "a_times_vera", "update_count": 0}, "mod_exponentiation_general": {"skill_name": "mod_exponentiation_general", "marker": "lemma mod_exponentiation_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\" \"c > 0\"\n  shows \"(x^(b + c)) mod n = ((a^b) * (a^c)) mod n\"\nproof -\n  have \"(x^(b + c)) mod n = ((x mod n)^(b + c)) mod n\" using assms by (metis power_mod)\n  also have \"... = ((a^(b + c)) mod n)\" using assms(2) by auto\n  also have \"... = ((a^b * a^c) mod n)\" by (metis power_add)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_exponentiation:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"(x^b) mod n = (a^b) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally show ?thesis by auto\nqed\n\nlemma mod_exponentiation_general:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\" \"c > 0\"\n  shows \"(x^(b + c)) mod n = ((a^b) * (a^c)) mod n\"\nproof -\n  have \"(x^(b + c)) mod n = ((x mod n)^(b + c)) mod n\" using assms by (metis power_mod)\n  also have \"... = ((a^(b + c)) mod n)\" using assms(2) by auto\n  also have \"... = ((a^b * a^c) mod n)\" by (metis power_add)\n  finally show ?thesis by auto\nqed", "origin": "mod_exponentiation", "update_count": 0}, "mod_addition": {"skill_name": "mod_addition", "marker": "lemma mod_addition:\n  fixes x y n :: nat\n  assumes \"n > 0\"\n  shows \"(x + y) mod n = ((x mod n) + (y mod n)) mod n\"\nproof -\n  have \"x mod n + y mod n < 2 * n\" using assms by (metis add_mono_thms_linordered_field(5) mod_less_divisor mult.commute mult_2_right)\n  then show ?thesis\n    by presburger\nqed", "description": "-", "full_code": "lemma mod_addition:\n  fixes x y n :: nat\n  assumes \"n > 0\"\n  shows \"(x + y) mod n = ((x mod n) + (y mod n)) mod n\"\nproof -\n  have \"x mod n + y mod n < 2 * n\" using assms by (metis add_mono_thms_linordered_field(5) mod_less_divisor mult.commute mult_2_right)\n  then show ?thesis\n    by presburger\nqed", "origin": "mod_exponentiation", "update_count": 0}, "combine_units_digits": {"skill_name": "combine_units_digits", "marker": "lemma combine_units_digits:\n  fixes x y :: nat\n  shows \"((x mod 10) + (y mod 10)) mod 10 = (x + y) mod 10\"\nproof -\n  have \"((x + y) mod 10) = ((x mod 10) + (y mod 10)) mod 10\"\n  proof -\n    have \"x = (x div 10) * 10 + (x mod 10)\" by (metis div_mult_mod_eq)\n    moreover have \"y = (y div 10) * 10 + (y mod 10)\" by (metis div_mult_mod_eq)\n    ultimately have \"x + y = ((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))\" \n      by auto\n    then show ?thesis \n      using mod_add_eq by metis\n  qed\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_units_digits:\n  fixes x y :: nat\n  shows \"((x mod 10) + (y mod 10)) mod 10 = (x + y) mod 10\"\nproof -\n  have \"((x + y) mod 10) = ((x mod 10) + (y mod 10)) mod 10\"\n  proof -\n    have \"x = (x div 10) * 10 + (x mod 10)\" by (metis div_mult_mod_eq)\n    moreover have \"y = (y div 10) * 10 + (y mod 10)\" by (metis div_mult_mod_eq)\n    ultimately have \"x + y = ((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))\" \n      by auto\n    then show ?thesis \n      using mod_add_eq by metis\n  qed\n  then show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "cancel_div_generalized": {"skill_name": "cancel_div_generalized", "marker": "lemma cancel_div_generalized:\n  fixes x a b c d:: real\n  assumes \"x > 0\" \"c > 0\" \"a + b / x = c + d / x\"\n  shows \"a * x + b = c * x + d\"\nproof -\n  have \"x * (a + b / x) = x * (c + d / x)\"\n    using assms(2) by (simp add: assms(3))\n  then have \"x * a + b = c * x + d\" \n    by (metis add.commute assms(1) assms(3) cancel_div_with_conditions mult.commute)\n  thus ?thesis using assms(1) by sos\nqed", "description": "-", "full_code": "lemma cancel_div_with_conditions:\n  fixes x a b c:: real\n  assumes \"x > 0\" \"a + b / x = c\"\n  shows \"a * x + b = c * x\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  moreover have \"x * (b / x) = b\" using assms(1) by simp\n  ultimately show ?thesis \n    using assms(1) by (simp add: mult.commute)\nqed\n\nlemma cancel_div_generalized:\n  fixes x a b c d:: real\n  assumes \"x > 0\" \"c > 0\" \"a + b / x = c + d / x\"\n  shows \"a * x + b = c * x + d\"\nproof -\n  have \"x * (a + b / x) = x * (c + d / x)\"\n    using assms(2) by (simp add: assms(3))\n  then have \"x * a + b = c * x + d\" \n    by (metis add.commute assms(1) assms(3) cancel_div_with_conditions mult.commute)\n  thus ?thesis using assms(1) by sos\nqed", "origin": "cancle_div", "update_count": 0}, "cancle_div_extended": {"skill_name": "cancle_div_extended", "marker": "lemma cancle_div_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"d > 0\"\n  shows \"a * x + b = c * x\" \n    and \"d * (a + b / x) = d * c\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show \"a * x + b = c * x\"\n    using assms(1) by (simp add: mult.commute)\n  have \"d * (a + b / x) = d * c\"\n    using assms(2) by (simp add: distrib_right)\n  thus \"d * (a + b / x) = d * c\" by simp\nqed", "description": "-", "full_code": "lemma cancle_div_extended:\n  fixes x a b c d :: real\n  assumes \"x > 0\" \"a + b / x = c\" \"d > 0\"\n  shows \"a * x + b = c * x\" \n    and \"d * (a + b / x) = d * c\"\nproof -\n  have \"x * (a + b / x) = c * x\"\n    using assms(2) by auto\n  then have \"x * a + x * (b / x) = c * x\"\n    by (simp add: distrib_left)\n  then show \"a * x + b = c * x\"\n    using assms(1) by (simp add: mult.commute)\n  have \"d * (a + b / x) = d * c\"\n    using assms(2) by (simp add: distrib_right)\n  thus \"d * (a + b / x) = d * c\" by simp\nqed", "origin": "cancle_div", "update_count": 0}, "mod_square": {"skill_name": "mod_square", "marker": "lemma mod_square:\n  fixes a m x :: nat\n  assumes \"a mod m = x\"\n  shows \"(a^2) mod m = (x^2) mod m\"\nproof -\n  have \"(a^2) mod m = ((a mod m) ^ 2) mod m\" using assms by (metis power_mod)\n  also have \"... = (x^2) mod m\" using assms by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a m x :: nat\n  assumes \"a mod m = x\"\n  shows \"(a^2) mod m = (x^2) mod m\"\nproof -\n  have \"(a^2) mod m = ((a mod m) ^ 2) mod m\" using assms by (metis power_mod)\n  also have \"... = (x^2) mod m\" using assms by auto\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_sum": {"skill_name": "mod_sum", "marker": "lemma mod_sum:\n  fixes x y n :: nat\n  shows \"(x + y) mod n = ((x mod n) + (y mod n)) mod n\"\nproof -\n  have \"x + y = (x mod n) + (y mod n) + (x div n + y div n) * n\"\n    by (auto simp: field_simps)\n  then have \"(x + y) mod n = ((x mod n) + (y mod n) + (x div n + y div n) * n) mod n\"\n    by simp\n  also have \"... = ((x mod n) + (y mod n)) mod n\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y n :: nat\n  shows \"(x + y) mod n = ((x mod n) + (y mod n)) mod n\"\nproof -\n  have \"x + y = (x mod n) + (y mod n) + (x div n + y div n) * n\"\n    by (auto simp: field_simps)\n  then have \"(x + y) mod n = ((x mod n) + (y mod n) + (x div n + y div n) * n) mod n\"\n    by simp\n  also have \"... = ((x mod n) + (y mod n)) mod n\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_mod_10": {"skill_name": "square_mod_10", "marker": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?a = \"n mod 10\"  \n  have \"n = 10 * (n div 10) + ?a\" \n    by auto\n  then have \"n^2 = (10 * (n div 10) + ?a)^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?a + ?a^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... mod 10 = (?a^2) mod 10\" \n    by (metis calculation eval_mod_exp(4) mod_exp_code power2_eq_square power_mod semiring_norm(3))\n  finally have \"(n^2 mod 10) = (?a^2) mod 10\" by simp\n  thus ?thesis \n    by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?a = \"n mod 10\"  \n  have \"n = 10 * (n div 10) + ?a\" \n    by auto\n  then have \"n^2 = (10 * (n div 10) + ?a)^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?a + ?a^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... mod 10 = (?a^2) mod 10\" \n    by (metis calculation eval_mod_exp(4) mod_exp_code power2_eq_square power_mod semiring_norm(3))\n  finally have \"(n^2 mod 10) = (?a^2) mod 10\" by simp\n  thus ?thesis \n    by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "logarithmic_identity_with_base_change": {"skill_name": "logarithmic_identity_with_base_change", "marker": "lemma logarithmic_identity_with_base_change:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"log a b = d\"\n  shows \"b = a ^ d\"\nproof -\n  have \"d = log a b\" using assms(4) by (metis assms(5))\n  thus \"b = a ^ d\" using assms(1,2,3) by (metis powr_log_cancel powr_realpow)\nqed", "description": "-", "full_code": "lemma logarithmic_identity_with_base_change:\n  assumes \"a > 0\" and \"a \\<noteq> 1\" and \"b > 0\" and \"c > 0\" and \"log a b = d\"\n  shows \"b = a ^ d\"\nproof -\n  have \"d = log a b\" using assms(4) by (metis assms(5))\n  thus \"b = a ^ d\" using assms(1,2,3) by (metis powr_log_cancel powr_realpow)\nqed", "origin": "cal_log_value", "update_count": 0}, "sum_and_product_to_sum_of_squares_general": {"skill_name": "sum_and_product_to_sum_of_squares_general", "marker": "theorem sum_and_product_to_sum_of_squares_general:\n  fixes x y a b :: real\n  assumes h0 : \"x + y = a\"\n    and h1 : \"x * y = b\"\n    and h2 : \"a > 0\"\n    and h3 : \"b > 0\"\n  shows \"sqrt (x^2 + y^2) = sqrt (a^2 - 2*b)\"\nproof -\n  have \"sqrt (x^2 + y^2) = sqrt ((x + y)^2 - 2*x*y)\" \n    by (smt (verit) power2_sum real_sqrt_eq_iff)\n  also have \"... = sqrt (a^2 - 2*b)\" using h0 h1\n    by (metis ab_semigroup_mult_class.mult_ac(1) mult.commute mult.left_commute mult_2_right power2_eq_square)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "theorem sum_and_product_to_sum_of_squares_general:\n  fixes x y a b :: real\n  assumes h0 : \"x + y = a\"\n    and h1 : \"x * y = b\"\n    and h2 : \"a > 0\"\n    and h3 : \"b > 0\"\n  shows \"sqrt (x^2 + y^2) = sqrt (a^2 - 2*b)\"\nproof -\n  have \"sqrt (x^2 + y^2) = sqrt ((x + y)^2 - 2*x*y)\" \n    by (smt (verit) power2_sum real_sqrt_eq_iff)\n  also have \"... = sqrt (a^2 - 2*b)\" using h0 h1\n    by (metis ab_semigroup_mult_class.mult_ac(1) mult.commute mult.left_commute mult_2_right power2_eq_square)\n  finally show ?thesis by simp\nqed", "origin": "mod_exponentiation", "update_count": 0}, "solve_linear_equation_general": {"skill_name": "solve_linear_equation_general", "marker": "lemma solve_linear_equation_general:\n  fixes n a b c :: nat\n  assumes \"a > 0\"\n  assumes \"a*n + b = c\"\n  shows \"n = (c - b) div a\"\nproof -\n  have \"a*n + b = c\" using assms by simp\n  then have \"a*n = c - b\" by simp\n  then show \"n = (c - b) div a\" using `a > 0`\n    by (smt (verit) div_mult_self1_is_m)\nqed", "description": "-", "full_code": "lemma solve_linear_equation_general:\n  fixes n a b c :: nat\n  assumes \"a > 0\"\n  assumes \"a*n + b = c\"\n  shows \"n = (c - b) div a\"\nproof -\n  have \"a*n + b = c\" using assms by simp\n  then have \"a*n = c - b\" by simp\n  then show \"n = (c - b) div a\" using `a > 0`\n    by (smt (verit) div_mult_self1_is_m)\nqed", "origin": "mod_exponentiation", "update_count": 0}, "mod_exponentiation_with_variable_base": {"skill_name": "mod_exponentiation_with_variable_base", "marker": "lemma mod_exponentiation_with_variable_base:\n  fixes x n b :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\" \n  shows \"(x^b) mod n = (a^b) mod n\"\n  using mod_exponentiation_general[of x n a b] assms by (metis mod_exp_def power_mod)", "description": "-", "full_code": "lemma mod_exponentiation_general:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"(x^b) mod n = (a^b) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally show ?thesis by auto\nqed\n\nlemma mod_exponentiation_with_variable_base:\n  fixes x n b :: nat\n  assumes \"n > 0\" \"b > 0\" \"x mod n = a\" \n  shows \"(x^b) mod n = (a^b) mod n\"\n  using mod_exponentiation_general[of x n a b] assms by (metis mod_exp_def power_mod)", "origin": "mod_exponentiation", "update_count": 0}, "mod_exponentiation_with_variable_baseV2": {"skill_name": "mod_exponentiation_with_variable_baseV2", "marker": "lemma mod_exponentiation_with_variable_base:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"a mod n = b\" \"k > 0\"\n  shows \"((a + x)^k) mod n = ((b + x)^k) mod n\"\nproof -\n  have \"((a + x)^k) mod n = (((a mod n) + (x mod n))^k) mod n\" \n    using assms by (smt (verit) mod_add_left_eq mod_add_right_eq mod_exponentiation_general)\n  also have \"... = ((b + (x mod n))^k) mod n\" using assms(2) by simp\n  finally show ?thesis by (smt (verit) \\<open>(a + x) ^ k mod n = (a mod n + x mod n) ^ k mod n\\<close> assms(1) assms(2) assms(3) mod_add_right_eq mod_exponentiation_general)\nqed", "description": "-", "full_code": "lemma mod_exponentiation_general:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"(x^b) mod n = (a^b) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally show ?thesis by auto\nqed\n\nlemma mod_exponentiation_with_variable_base:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"a mod n = b\" \"k > 0\"\n  shows \"((a + x)^k) mod n = ((b + x)^k) mod n\"\nproof -\n  have \"((a + x)^k) mod n = (((a mod n) + (x mod n))^k) mod n\" \n    using assms by (smt (verit) mod_add_left_eq mod_add_right_eq mod_exponentiation_general)\n  also have \"... = ((b + (x mod n))^k) mod n\" using assms(2) by simp\n  finally show ?thesis by (smt (verit) \\<open>(a + x) ^ k mod n = (a mod n + x mod n) ^ k mod n\\<close> assms(1) assms(2) assms(3) mod_add_right_eq mod_exponentiation_general)\nqed", "origin": "mod_exponentiation", "update_count": 0}, "combine_units_digits_general": {"skill_name": "combine_units_digits_general", "marker": "lemma combine_units_digits_general:\n  fixes x y d :: nat\n  assumes \"d > 0\"\n  shows \"((x mod d) + (y mod d)) mod d = (x + y) mod d\"\nproof -\n  have \"((x + y) mod d) = ((x mod d) + (y mod d)) mod d\"\n  proof -\n    have \"x = (x div d) * d + (x mod d)\" by (metis div_mult_mod_eq)\n    moreover have \"y = (y div d) * d + (y mod d)\" by (metis div_mult_mod_eq)\n    ultimately have \"x + y = ((x div d) + (y div d)) * d + ((x mod d) + (y mod d))\"\n      by (auto simp: field_simps)\n    then show ?thesis \n      using mod_add_eq by metis\n  qed\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_units_digits_general:\n  fixes x y d :: nat\n  assumes \"d > 0\"\n  shows \"((x mod d) + (y mod d)) mod d = (x + y) mod d\"\nproof -\n  have \"((x + y) mod d) = ((x mod d) + (y mod d)) mod d\"\n  proof -\n    have \"x = (x div d) * d + (x mod d)\" by (metis div_mult_mod_eq)\n    moreover have \"y = (y div d) * d + (y mod d)\" by (metis div_mult_mod_eq)\n    ultimately have \"x + y = ((x div d) + (y div d)) * d + ((x mod d) + (y mod d))\"\n      by (auto simp: field_simps)\n    then show ?thesis \n      using mod_add_eq by metis\n  qed\n  then show ?thesis by simp\nqed", "origin": "combine_units_digits", "update_count": 0}, "combine_units_digits_base": {"skill_name": "combine_units_digits_base", "marker": "lemma combine_units_digits_base:\n  fixes x y :: nat and b :: nat\n  assumes \"b > 1\"\n  shows \"((x mod b) + (y mod b)) mod b = (x + y) mod b\"\nproof -\n  have \"((x + y) mod b) = ((x mod b) + (y mod b)) mod b\"\n  proof -\n    have \"x = (x div b) * b + (x mod b)\" by (metis div_mult_mod_eq)\n    moreover have \"y = (y div b) * b + (y mod b)\" by (metis div_mult_mod_eq)\n    ultimately have \"x + y = ((x div b) + (y div b)) * b + ((x mod b) + (y mod b))\" \n      by (auto simp: field_simps)\n    then show ?thesis \n      using mod_add_eq by metis\n  qed\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_units_digits_base:\n  fixes x y :: nat and b :: nat\n  assumes \"b > 1\"\n  shows \"((x mod b) + (y mod b)) mod b = (x + y) mod b\"\nproof -\n  have \"((x + y) mod b) = ((x mod b) + (y mod b)) mod b\"\n  proof -\n    have \"x = (x div b) * b + (x mod b)\" by (metis div_mult_mod_eq)\n    moreover have \"y = (y div b) * b + (y mod b)\" by (metis div_mult_mod_eq)\n    ultimately have \"x + y = ((x div b) + (y div b)) * b + ((x mod b) + (y mod b))\" \n      by (auto simp: field_simps)\n    then show ?thesis \n      using mod_add_eq by metis\n  qed\n  then show ?thesis by simp\nqed", "origin": "combine_units_digits", "update_count": 0}, "division_inequality": {"skill_name": "division_inequality", "marker": "lemma division_inequality:\n  fixes x a b :: real\n  assumes \"x > 0\" \"a / x < b\"\n  shows \"a < b * x\"\nproof -\n  have \"a < b * x\" using assms by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma division_inequality:\n  fixes x a b :: real\n  assumes \"x > 0\" \"a / x < b\"\n  shows \"a < b * x\"\nproof -\n  have \"a < b * x\" using assms by (simp add: field_simps)\n  then show ?thesis by simp\nqed", "origin": "cancle_div", "update_count": 0}, "multiply_divide": {"skill_name": "multiply_divide", "marker": "lemma multiply_divide:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a * x = c * x - b\"\n  shows \"a = c - b / x\"\nproof -\n  have \"a * x = c * x - b\" using assms(2) by simp\n  then have \"a = (c * x - b) / x\" using assms(1) by (simp add: divide_simps)\n  then show ?thesis by (smt (verit) assms(1) diff_divide_eq_iff)\nqed", "description": "-", "full_code": "lemma multiply_divide:\n  fixes x a b c :: real\n  assumes \"x > 0\" \"a * x = c * x - b\"\n  shows \"a = c - b / x\"\nproof -\n  have \"a * x = c * x - b\" using assms(2) by simp\n  then have \"a = (c * x - b) / x\" using assms(1) by (simp add: divide_simps)\n  then show ?thesis by (smt (verit) assms(1) diff_divide_eq_iff)\nqed", "origin": "cancle_div", "update_count": 0}, "mod_power": {"skill_name": "mod_power", "marker": "lemma mod_power:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by auto\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^Suc n = a * (a^n)\" by simp\n    then have \"(a^Suc n) mod m = (a * (a^n)) mod m\" by simp\n    also have \"... = ((a mod m) * (a^n mod m)) mod m\" using assms by (metis mod_mult_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\" by (metis Suc \\<open>a * a ^ n mod m = a mod m * (a ^ n mod m) mod m\\<close> \\<open>a ^ Suc n = a * a ^ n\\<close> \\<open>a ^ Suc n mod m = a * a ^ n mod m\\<close> mod_mult_cong mod_mult_eq)\n    also have \"... = ((a mod m)^(n + 1)) mod m\" by (metis Suc_eq_plus1 calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_power:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by auto\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^Suc n = a * (a^n)\" by simp\n    then have \"(a^Suc n) mod m = (a * (a^n)) mod m\" by simp\n    also have \"... = ((a mod m) * (a^n mod m)) mod m\" using assms by (metis mod_mult_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\" by (metis Suc \\<open>a * a ^ n mod m = a mod m * (a ^ n mod m) mod m\\<close> \\<open>a ^ Suc n = a * a ^ n\\<close> \\<open>a ^ Suc n mod m = a * a ^ n mod m\\<close> mod_mult_cong mod_mult_eq)\n    also have \"... = ((a mod m)^(n + 1)) mod m\" by (metis Suc_eq_plus1 calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "mod_powerV2": {"skill_name": "mod_powerV2", "marker": "lemma mod_power:\n  fixes a n :: nat\n  assumes \"n > 0\"\n  shows \"a^n mod n = (a mod n)^n mod n\"\nproof -\n  have \"a^n mod n = ((a mod n) + (a div n * n))^n mod n\"\n    using assms by auto\n  also have \"... = ((a mod n)^n + (a div n * n)^n) mod n\"\n    by (metis assms calculation less_numeral_extra(3) mod_add_cong mod_mult_div_eq mod_mult_eq mod_mult_self1_is_0 mult.commute mult_0_right old.nat.exhaust power_Suc2 power_mod verit_sum_simplify)\n  also have \"... = (a mod n)^n mod n\"\n    using assms by (metis calculation power_mod)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_power:\n  fixes a n :: nat\n  assumes \"n > 0\"\n  shows \"a^n mod n = (a mod n)^n mod n\"\nproof -\n  have \"a^n mod n = ((a mod n) + (a div n * n))^n mod n\"\n    using assms by auto\n  also have \"... = ((a mod n)^n + (a div n * n)^n) mod n\"\n    by (metis assms calculation less_numeral_extra(3) mod_add_cong mod_mult_div_eq mod_mult_eq mod_mult_self1_is_0 mult.commute mult_0_right old.nat.exhaust power_Suc2 power_mod verit_sum_simplify)\n  also have \"... = (a mod n)^n mod n\"\n    using assms by (metis calculation power_mod)\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_powerV3": {"skill_name": "mod_powerV3", "marker": "lemma mod_power:\n  fixes a n :: nat\n  assumes \"n > 0\"\n  shows \"a^n mod n = (a mod n)^n mod n\"\nproof -\n  have \"(a^n mod n) = ((a mod n)^n) mod n\" using assms by (metis power_mod)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_power:\n  fixes a n :: nat\n  assumes \"n > 0\"\n  shows \"a^n mod n = (a mod n)^n mod n\"\nproof -\n  have \"(a^n mod n) = ((a mod n)^n) mod n\" using assms by (metis power_mod)\n  thus ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_squareV2": {"skill_name": "mod_squareV2", "marker": "lemma mod_square:\n  fixes a m x :: nat\n  assumes \"a mod m = x\"\n  shows \"(a^2) mod m = (x^2) mod m\"\nproof -\n  have \"a mod m = x\" by (simp add: assms)\n  then have \"(a^2) mod m = (a mod m)^2 mod m\" by (metis power_mod)\n  also have \"... = x^2 mod m\" by (simp add: assms)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_square:\n  fixes a m x :: nat\n  assumes \"a mod m = x\"\n  shows \"(a^2) mod m = (x^2) mod m\"\nproof -\n  have \"a mod m = x\" by (simp add: assms)\n  then have \"(a^2) mod m = (a mod m)^2 mod m\" by (metis power_mod)\n  also have \"... = x^2 mod m\" by (simp add: assms)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_10_units_digit": {"skill_name": "mod_10_units_digit", "marker": "lemma mod_10_units_digit:\n  fixes n :: nat\n  shows \"n mod 10 = (n mod 10)\"\nproof -\n  have \"n mod 10 = n mod 10\" by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_10_units_digit:\n  fixes n :: nat\n  shows \"n mod 10 = (n mod 10)\"\nproof -\n  have \"n mod 10 = n mod 10\" by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_10_units_digitV2": {"skill_name": "mod_10_units_digitV2", "marker": "lemma mod_10_units_digit:\n  fixes n :: nat\n  shows \"n mod 10 = (n mod 10)\"\nproof -\n  show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_10_units_digit:\n  fixes n :: nat\n  shows \"n mod 10 = (n mod 10)\"\nproof -\n  show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_exponentiation_multi": {"skill_name": "mod_exponentiation_multi", "marker": "lemma mod_exponentiation_multi:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"(x^b) mod n = (a^b) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally show ?thesis by auto\nqed\nprimrec mod_exponentiation_list :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list [] n b = 1\" |\n  \"mod_exponentiation_list (x#xs) n b = (x^b) mod n * mod_exponentiation_list xs n b mod n\"", "description": "-", "full_code": "lemma mod_exponentiation_multi:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"(x^b) mod n = (a^b) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally show ?thesis by auto\nqed\nprimrec mod_exponentiation_list :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list [] n b = 1\" |\n  \"mod_exponentiation_list (x#xs) n b = (x^b) mod n * mod_exponentiation_list xs n b mod n\"", "origin": "mod_exponentiation", "update_count": 0}, "mod_d_remainder": {"skill_name": "mod_d_remainder", "marker": "lemma mod_d_remainder:\n  fixes n d :: nat\n  assumes \"d > 0\"\n  shows \"n mod d \\<in> {0..d-1}\"\nproof -\n  have \"n mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  moreover have \"n mod d \\<ge> 0\" by simp\n  ultimately show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_d_remainder:\n  fixes n d :: nat\n  assumes \"d > 0\"\n  shows \"n mod d \\<in> {0..d-1}\"\nproof -\n  have \"n mod d < d\" by (rule mod_less_divisor[OF assms(1)])\n  moreover have \"n mod d \\<ge> 0\" by simp\n  ultimately show ?thesis by auto\nqed", "origin": "mod_10_units_digit", "update_count": 0}, "square_mod_10V2": {"skill_name": "square_mod_10V2", "marker": "lemma square_mod_10:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  obtain x where \"k = 10 * x\" using assms by auto\n  then have \"k^2 = (10 * x)^2\" by simp\n  also have \"... = 100 * x^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod 10 = (100 * x^2) mod 10\" by simp\n  also have \"... = 0\" by auto\n  thus ?thesis by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_mod_10:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  obtain x where \"k = 10 * x\" using assms by auto\n  then have \"k^2 = (10 * x)^2\" by simp\n  also have \"... = 100 * x^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod 10 = (100 * x^2) mod 10\" by simp\n  also have \"... = 0\" by auto\n  thus ?thesis by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "square_mod_10V3": {"skill_name": "square_mod_10V3", "marker": "lemma square_mod_10:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by (simp add: power2_eq_square)\n  then have \"k^2 = 100 * (k div 10)^2\" by (simp add: algebra_simps)\n  thus \"k^2 mod 10 = 0\" by auto\nqed", "description": "-", "full_code": "lemma square_mod_10:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by (simp add: power2_eq_square)\n  then have \"k^2 = 100 * (k div 10)^2\" by (simp add: algebra_simps)\n  thus \"k^2 mod 10 = 0\" by auto\nqed", "origin": "do_request", "update_count": 0}, "square_mod_n": {"skill_name": "square_mod_n", "marker": "lemma square_mod_n:\n  fixes k n :: nat\n  assumes \"k mod n = 0\"\n  shows \"k^2 mod n = 0\"\nproof -\n  have \"k = n * (k div n)\" using assms by auto\n  then have \"k^2 = (n * (k div n))^2\" by (simp add: power2_eq_square)\n  then have \"k^2 = n^2 * (k div n)^2\" by (simp add: algebra_simps)\n  thus \"k^2 mod n = 0\" by auto\nqed", "description": "-", "full_code": "lemma square_mod_n:\n  fixes k n :: nat\n  assumes \"k mod n = 0\"\n  shows \"k^2 mod n = 0\"\nproof -\n  have \"k = n * (k div n)\" using assms by auto\n  then have \"k^2 = (n * (k div n))^2\" by (simp add: power2_eq_square)\n  then have \"k^2 = n^2 * (k div n)^2\" by (simp add: algebra_simps)\n  thus \"k^2 mod n = 0\" by auto\nqed", "origin": "square_mod_10V3", "update_count": 0}, "multi_distrib_complex_generalized": {"skill_name": "multi_distrib_complex_generalized", "marker": "lemma multi_distrib_complex_generalized:\n  fixes a b c d e f :: complex\n  assumes \"x = a + b\" \"y = c + d\"\n  shows \"x * y = a * c + a * d + b * c + b * d\"\nproof -\n  have \"x * y = (a + b) * (c + d)\" using assms by simp\n  then show ?thesis by (simp add: distrib_left distrib_right)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_generalized:\n  fixes a b c d e f :: complex\n  assumes \"x = a + b\" \"y = c + d\"\n  shows \"x * y = a * c + a * d + b * c + b * d\"\nproof -\n  have \"x * y = (a + b) * (c + d)\" using assms by simp\n  then show ?thesis by (simp add: distrib_left distrib_right)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "multi_distrib_complex_gen": {"skill_name": "multi_distrib_complex_gen", "marker": "lemma multi_distrib_complex_gen:\n  fixes z1 z2 z3 z4 :: complex\n  assumes \"z1 = a + b\" and \"z2 = c + d\"\n  shows \"z1 * z2 = a * c + a * d + b * c + b * d\"\nproof -\n  have \"z1 * z2 = (a + b) * (c + d)\" using assms by simp\n  then show ?thesis by (simp add: distrib_left distrib_right)\nqed", "description": "-", "full_code": "lemma multi_distrib_complex_gen:\n  fixes z1 z2 z3 z4 :: complex\n  assumes \"z1 = a + b\" and \"z2 = c + d\"\n  shows \"z1 * z2 = a * c + a * d + b * c + b * d\"\nproof -\n  have \"z1 * z2 = (a + b) * (c + d)\" using assms by simp\n  then show ?thesis by (simp add: distrib_left distrib_right)\nqed", "origin": "multi_distrib_complex", "update_count": 0}, "combine_units_digits_base_k": {"skill_name": "combine_units_digits_base_k", "marker": "lemma combine_units_digits_base_k:\n  fixes x y :: nat and k :: nat\n  assumes \"k > 1\"\n  shows \"((x mod k) + (y mod k)) mod k = (x + y) mod k\"\nusing combine_units_digits_general[of x y k] assms by presburger", "description": "-", "full_code": "lemma combine_units_digits_general:\n  fixes x y :: nat and b :: nat\n  assumes \"b > 1\"\n  shows \"((x mod b) + (y mod b)) mod b = (x + y) mod b\"\nproof -\n  have \"((x + y) mod b) = ((x mod b) + (y mod b)) mod b\"\n  proof -\n    have \"x = (x div b) * b + (x mod b)\" by (metis div_mult_mod_eq)\n    moreover have \"y = (y div b) * b + (y mod b)\" by (metis div_mult_mod_eq)\n    ultimately have \"x + y = ((x div b) + (y div b)) * b + ((x mod b) + (y mod b))\" \n      by (auto simp: field_simps)\n    then show ?thesis \n      using mod_add_eq by metis\n  qed\n  then show ?thesis by simp\nqed\n\nlemma combine_units_digits_base_k:\n  fixes x y :: nat and k :: nat\n  assumes \"k > 1\"\n  shows \"((x mod k) + (y mod k)) mod k = (x + y) mod k\"\nusing combine_units_digits_general[of x y k] assms by presburger", "origin": "combine_units_digits_base", "update_count": 0}, "combine_units_digits_arbitrary_base": {"skill_name": "combine_units_digits_arbitrary_base", "marker": "lemma combine_units_digits_arbitrary_base:\n  fixes x y b :: nat\n  assumes \"b > 1\"\n  shows \"((x mod b) + (y mod b)) mod b = (x + y) mod b\"\n  using combine_units_digits_n_base[of x y b] assms by presburger", "description": "-", "full_code": "lemma combine_units_digits_n_base:\n  fixes x y :: nat and b :: nat\n  assumes \"b > 1\"\n  shows \"((x mod b) + (y mod b)) mod b = (x + y) mod b\"\nproof -\n  have \"((x + y) mod b) = ((x mod b) + (y mod b)) mod b\"\n  proof -\n    have \"x = (x div b) * b + (x mod b)\" by (metis div_mult_mod_eq)\n    moreover have \"y = (y div b) * b + (y mod b)\" by (metis div_mult_mod_eq)\n    ultimately have \"x + y = ((x div b) + (y div b)) * b + ((x mod b) + (y mod b))\" \n      by (auto simp: field_simps)\n    then show ?thesis \n      using mod_add_eq by metis\n  qed\n  then show ?thesis by simp\nqed\n\nlemma combine_units_digits_arbitrary_base:\n  fixes x y b :: nat\n  assumes \"b > 1\"\n  shows \"((x mod b) + (y mod b)) mod b = (x + y) mod b\"\n  using combine_units_digits_n_base[of x y b] assms by presburger", "origin": "combine_units_digits_base", "update_count": 0}, "square_mod_k": {"skill_name": "square_mod_k", "marker": "lemma square_mod_k:\n  fixes k :: nat\n  assumes \"k mod n = 0\" and \"n > 0\"\n  shows \"k^2 mod n = 0\"\nproof -\n  obtain x where \"k = n * x\" using assms(1) by auto\n  then have \"k^2 = (n * x)^2\" by simp\n  also have \"... = n^2 * x^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod n = (n^2 * x^2) mod n\" by simp\n  also have \"... = 0\" by auto\n  thus ?thesis by (metis assms(1) dvd_imp_mod_0 dvd_mult less_numeral_extra(3) mod_greater_zero_iff_not_dvd power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_mod_k:\n  fixes k :: nat\n  assumes \"k mod n = 0\" and \"n > 0\"\n  shows \"k^2 mod n = 0\"\nproof -\n  obtain x where \"k = n * x\" using assms(1) by auto\n  then have \"k^2 = (n * x)^2\" by simp\n  also have \"... = n^2 * x^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod n = (n^2 * x^2) mod n\" by simp\n  also have \"... = 0\" by auto\n  thus ?thesis by (metis assms(1) dvd_imp_mod_0 dvd_mult less_numeral_extra(3) mod_greater_zero_iff_not_dvd power2_eq_square)\nqed", "origin": "square_mod_10V2", "update_count": 0}, "mod_exponentiation_multiV2": {"skill_name": "mod_exponentiation_multiV2", "marker": "lemma mod_exponentiation_multi:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"(x^b) mod n = (a^b) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally show ?thesis by auto\nqed\nprimrec mod_exponentiation_list :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list [] n b = 1\" |\n  \"mod_exponentiation_list (x#xs) n b = ((x^b) mod n * mod_exponentiation_list xs n b) mod n\"\nprimrec mod_exponentiation_matrix :: \"nat list list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_matrix [] n b = 1\" |\n  \"mod_exponentiation_matrix (row#rows) n b = \n     (mod_exponentiation_list row n b * mod_exponentiation_matrix rows n b) mod n\"", "description": "-", "full_code": "lemma mod_exponentiation_multi:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"(x^b) mod n = (a^b) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally show ?thesis by auto\nqed\nprimrec mod_exponentiation_list :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list [] n b = 1\" |\n  \"mod_exponentiation_list (x#xs) n b = ((x^b) mod n * mod_exponentiation_list xs n b) mod n\"\nprimrec mod_exponentiation_matrix :: \"nat list list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_matrix [] n b = 1\" |\n  \"mod_exponentiation_matrix (row#rows) n b = \n     (mod_exponentiation_list row n b * mod_exponentiation_matrix rows n b) mod n\"", "origin": "mod_exponentiation_multi", "update_count": 0}, "mod_exponentiation_multi_dimensional": {"skill_name": "mod_exponentiation_multi_dimensional", "marker": "lemma mod_exponentiation_multi_dimensional:\n  fixes x n a b d :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\" \"d > 0\"\n  shows \"(\\<Prod>(i::nat) = 1..d. (x^b) mod n) = (\\<Prod>(i::nat) = 1..d. (a^b) mod n)\"\nproof -\n  have \"(\\<Prod>(i::nat) = 1..d. (x^b) mod n) = (\\<Prod>(i::nat) = 1..d. ((x mod n)^b) mod n)\" using assms(1) by (metis power_mod)\n  also have \"... = (\\<Prod>(i::nat) = 1..d. (a^b) mod n)\" using assms(2) by auto\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_exponentiation_multi:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"(x^b) mod n = (a^b) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally show ?thesis by auto\nqed\nprimrec mod_exponentiation_list :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list [] n b = 1\" |\n  \"mod_exponentiation_list (x#xs) n b = ((x^b) mod n) * (mod_exponentiation_list xs n b) mod n\"\n\nlemma mod_exponentiation_multi_dimensional:\n  fixes x n a b d :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\" \"d > 0\"\n  shows \"(\\<Prod>(i::nat) = 1..d. (x^b) mod n) = (\\<Prod>(i::nat) = 1..d. (a^b) mod n)\"\nproof -\n  have \"(\\<Prod>(i::nat) = 1..d. (x^b) mod n) = (\\<Prod>(i::nat) = 1..d. ((x mod n)^b) mod n)\" using assms(1) by (metis power_mod)\n  also have \"... = (\\<Prod>(i::nat) = 1..d. (a^b) mod n)\" using assms(2) by auto\n  finally show ?thesis by auto\nqed", "origin": "mod_exponentiation_multi", "update_count": 0}, "mod_exponentiation_multi_k": {"skill_name": "mod_exponentiation_multi_k", "marker": "lemma mod_exponentiation_multi_k:\n  fixes x n a b k :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\" \"k > 0\"\n  shows \"(x^(b*k)) mod n = (a^k)^b mod n\"\nproof -\n  have \"(x^(b*k)) mod n = ((x mod n)^(b*k)) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^(b*k)) mod n\" using assms(2) by auto\n  finally show ?thesis by (metis \\<open>x ^ (b * k) mod n = (x mod n) ^ (b * k) mod n\\<close> assms(2) mod_exp_def mult.commute mult_delta_right power_mult)\nqed\nprimrec mod_exponentiation_list_k :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list_k [] n b k = 1\" |\n  \"mod_exponentiation_list_k (x#xs) n b k = ((x^(b*k)) mod n * mod_exponentiation_list_k xs n b k) mod n\"", "description": "-", "full_code": "lemma mod_exponentiation_multi:\n  fixes x n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\"\n  shows \"(x^b) mod n = (a^b) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally show ?thesis by auto\nqed\nprimrec mod_exponentiation_list :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list [] n b = 1\" |\n  \"mod_exponentiation_list (x#xs) n b = ((x^b) mod n * mod_exponentiation_list xs n b) mod n\"\n\nlemma mod_exponentiation_multi_k:\n  fixes x n a b k :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\" \"k > 0\"\n  shows \"(x^(b*k)) mod n = (a^k)^b mod n\"\nproof -\n  have \"(x^(b*k)) mod n = ((x mod n)^(b*k)) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^(b*k)) mod n\" using assms(2) by auto\n  finally show ?thesis by (metis \\<open>x ^ (b * k) mod n = (x mod n) ^ (b * k) mod n\\<close> assms(2) mod_exp_def mult.commute mult_delta_right power_mult)\nqed\nprimrec mod_exponentiation_list_k :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list_k [] n b k = 1\" |\n  \"mod_exponentiation_list_k (x#xs) n b k = ((x^(b*k)) mod n * mod_exponentiation_list_k xs n b k) mod n\"", "origin": "mod_exponentiation_multi", "update_count": 0}, "mod_add": {"skill_name": "mod_add", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  have \"a = (a mod m) + (a div m) * m\" by auto\n  have \"b = (b mod m) + (b div m) * m\" by auto\n  then have \"a + b = ((a mod m) + (b mod m)) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = (((a mod m) + (b mod m)) + ((a div m) + (b div m)) * m) mod m\" \n    by simp\n  also have \"... = ((a mod m) + (b mod m)) mod m\" \n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  have \"a = (a mod m) + (a div m) * m\" by auto\n  have \"b = (b mod m) + (b div m) * m\" by auto\n  then have \"a + b = ((a mod m) + (b mod m)) + ((a div m) + (b div m)) * m\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod m = (((a mod m) + (b mod m)) + ((a div m) + (b div m)) * m) mod m\" \n    by simp\n  also have \"... = ((a mod m) + (b mod m)) mod m\" \n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_addV2": {"skill_name": "mod_addV2", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  have \"a + b = (a mod m) + (b mod m) + (a div m + b div m) * m\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod m = ((a mod m) + (b mod m) + (a div m + b div m) * m) mod m\"\n    by simp\n  also have \"... = ((a mod m) + (b mod m)) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  shows \"(a mod m + b mod m) mod m = (a + b) mod m\"\nproof -\n  have \"a + b = (a mod m) + (b mod m) + (a div m + b div m) * m\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod m = ((a mod m) + (b mod m) + (a div m + b div m) * m) mod m\"\n    by simp\n  also have \"... = ((a mod m) + (b mod m)) mod m\"\n    by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_exponentiation_multi_generalized": {"skill_name": "mod_exponentiation_multi_generalized", "marker": "lemma mod_exponentiation_multi_generalized:\n  fixes x n a b k :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\" \"k > 0\"\n  shows \"(x^(b*k)) mod n = (a^k)^b mod n\"\nproof -\n  have \"(x^(b*k)) mod n = ((x mod n)^(b*k)) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^(b*k)) mod n\" using assms(2) by auto\n  finally show ?thesis by (metis \\<open>x ^ (b * k) mod n = (x mod n) ^ (b * k) mod n\\<close> assms(2) mod_exp_def mult.commute mult_delta_right power_mult)\nqed", "description": "-", "full_code": "lemma mod_exponentiation_multi_generalized:\n  fixes x n a b k :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\" \"k > 0\"\n  shows \"(x^(b*k)) mod n = (a^k)^b mod n\"\nproof -\n  have \"(x^(b*k)) mod n = ((x mod n)^(b*k)) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^(b*k)) mod n\" using assms(2) by auto\n  finally show ?thesis by (metis \\<open>x ^ (b * k) mod n = (x mod n) ^ (b * k) mod n\\<close> assms(2) mod_exp_def mult.commute mult_delta_right power_mult)\nqed", "origin": "mod_exponentiation_multi_k", "update_count": 0}, "mod_exponentiation_list_general": {"skill_name": "mod_exponentiation_list_general", "marker": "fun mod_exponentiation_list_general :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list_general [] n b = 1\" |\n  \"mod_exponentiation_list_general (x#xs) n b = \n    ((x^b) mod n * mod_exponentiation_list_general xs n b) mod n\"", "description": "-", "full_code": "fun mod_exponentiation_list_general :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list_general [] n b = 1\" |\n  \"mod_exponentiation_list_general (x#xs) n b = \n    ((x^b) mod n * mod_exponentiation_list_general xs n b) mod n\"", "origin": "mod_exponentiation_multi", "update_count": 0}, "mod_exponentiation_multi_extended": {"skill_name": "mod_exponentiation_multi_extended", "marker": "lemma mod_exponentiation_multi_extended:\n  fixes x n a b d :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\" \"d > 0\"\n  shows \"(x^b) mod n = (a^b) mod n \\<and> (x^d) mod n = (a^d) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally have \"x^b mod n = a^b mod n\" by auto\n  have \"(x^d) mod n = ((x mod n)^d) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^d) mod n\" using assms(2) by auto\n  finally have \"x^d mod n = a^d mod n\" by auto\n  thus ?thesis by (metis \\<open>x ^ b mod n = a ^ b mod n\\<close>)\nqed\nprimrec mod_exponentiation_list_extended :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list_extended [] n b = 1\" |\n  \"mod_exponentiation_list_extended (x#xs) n b = ((x^b) mod n) * (mod_exponentiation_list_extended xs n b) mod n\"", "description": "-", "full_code": "lemma mod_exponentiation_multi_extended:\n  fixes x n a b d :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"b > 0\" \"d > 0\"\n  shows \"(x^b) mod n = (a^b) mod n \\<and> (x^d) mod n = (a^d) mod n\"\nproof -\n  have \"(x^b) mod n = ((x mod n)^b) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^b) mod n\" using assms(2) by auto\n  finally have \"x^b mod n = a^b mod n\" by auto\n  have \"(x^d) mod n = ((x mod n)^d) mod n\" using assms by (metis power_mod)\n  also have \"... = (a^d) mod n\" using assms(2) by auto\n  finally have \"x^d mod n = a^d mod n\" by auto\n  thus ?thesis by (metis \\<open>x ^ b mod n = a ^ b mod n\\<close>)\nqed\nprimrec mod_exponentiation_list_extended :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list_extended [] n b = 1\" |\n  \"mod_exponentiation_list_extended (x#xs) n b = ((x^b) mod n) * (mod_exponentiation_list_extended xs n b) mod n\"", "origin": "mod_exponentiation_multi", "update_count": 0}, "mod_power_generalized": {"skill_name": "mod_power_generalized", "marker": "lemma mod_power_generalized:\n  fixes a b n :: nat\n  assumes \"n > 0\" \"b > 0\"\n  shows \"(a^b mod n) = ((a mod n)^b) mod n\"\nproof -\n  have \"(a^b mod n) = ((a mod n)^b) mod n\" using assms by (metis power_mod)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_power_generalized:\n  fixes a b n :: nat\n  assumes \"n > 0\" \"b > 0\"\n  shows \"(a^b mod n) = ((a mod n)^b) mod n\"\nproof -\n  have \"(a^b mod n) = ((a mod n)^b) mod n\" using assms by (metis power_mod)\n  thus ?thesis by auto\nqed", "origin": "mod_powerV3", "update_count": 0}, "mod_power_with_addition": {"skill_name": "mod_power_with_addition", "marker": "lemma mod_power_with_addition:\n  fixes a b n :: nat\n  assumes \"n > 0\" \"b > 0\"\n  shows \"(a + b)^n mod n = ((a mod n + b mod n) mod n)^n mod n\"\nproof -\n  have \"((a + b) mod n) = ((a mod n + b mod n) mod n)\" using assms by presburger\n  hence \"(a + b)^n mod n = ((a mod n + b mod n) mod n)^n mod n\" using assms by (metis power_mod)\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_power_with_addition:\n  fixes a b n :: nat\n  assumes \"n > 0\" \"b > 0\"\n  shows \"(a + b)^n mod n = ((a mod n + b mod n) mod n)^n mod n\"\nproof -\n  have \"((a + b) mod n) = ((a mod n + b mod n) mod n)\" using assms by presburger\n  hence \"(a + b)^n mod n = ((a mod n + b mod n) mod n)^n mod n\" using assms by (metis power_mod)\n  thus ?thesis by auto\nqed", "origin": "mod_powerV3", "update_count": 0}, "mod_power_cycle_with_condition": {"skill_name": "mod_power_cycle_with_condition", "marker": "lemma mod_power_cycle_with_condition:\n  fixes a n m :: nat\n  assumes \"n > 0\" \"m > 0\"\n  shows \"a^n mod m = (if a mod m = 0 then 0 else (a mod m)^n mod m)\"\nproof -\n  have \"a^n mod m = (a mod m)^n mod m\" using assms by (metis power_mod)\n  then show ?thesis\n  proof (cases \"a mod m = 0\")\n    case True\n    then show ?thesis by (metis \\<open>a ^ n mod m = (a mod m) ^ n mod m\\<close> assms(1) less_numeral_extra(3) mod_0 power_0_left)\n  next\n    case False\n    then show ?thesis by (metis \\<open>a ^ n mod m = (a mod m) ^ n mod m\\<close>)\n  qed\nqed", "description": "-", "full_code": "lemma mod_power_cycle_with_condition:\n  fixes a n m :: nat\n  assumes \"n > 0\" \"m > 0\"\n  shows \"a^n mod m = (if a mod m = 0 then 0 else (a mod m)^n mod m)\"\nproof -\n  have \"a^n mod m = (a mod m)^n mod m\" using assms by (metis power_mod)\n  then show ?thesis\n  proof (cases \"a mod m = 0\")\n    case True\n    then show ?thesis by (metis \\<open>a ^ n mod m = (a mod m) ^ n mod m\\<close> assms(1) less_numeral_extra(3) mod_0 power_0_left)\n  next\n    case False\n    then show ?thesis by (metis \\<open>a ^ n mod m = (a mod m) ^ n mod m\\<close>)\n  qed\nqed", "origin": "mod_powerV3", "update_count": 0}, "non_zero_times_inverse_with_property": {"skill_name": "non_zero_times_inverse_with_property", "marker": "lemma non_zero_times_inverse_with_property:\n  fixes a :: \"real set\" and P :: \"real \\<Rightarrow> bool\"\n  assumes \"\\<forall>x \\<in> a. x \\<noteq> 0\" \"\\<forall>x \\<in> a. P x\"\n  shows \"\\<forall>x \\<in> a. x * (1 / x) = 1 \\<and> P x\"\nproof -\n  have \"\\<forall>x \\<in> a. x * (1 / x) = 1\" \n  proof\n    fix x\n    assume \"x \\<in> a\"\n    then have \"x \\<noteq> 0\" using assms(1) by auto\n    thus \"x * (1 / x) = 1\" by auto\n  qed\n  thus ?thesis using assms(2) by auto\nqed", "description": "-", "full_code": "lemma non_zero_times_inverse_with_property:\n  fixes a :: \"real set\" and P :: \"real \\<Rightarrow> bool\"\n  assumes \"\\<forall>x \\<in> a. x \\<noteq> 0\" \"\\<forall>x \\<in> a. P x\"\n  shows \"\\<forall>x \\<in> a. x * (1 / x) = 1 \\<and> P x\"\nproof -\n  have \"\\<forall>x \\<in> a. x * (1 / x) = 1\" \n  proof\n    fix x\n    assume \"x \\<in> a\"\n    then have \"x \\<noteq> 0\" using assms(1) by auto\n    thus \"x * (1 / x) = 1\" by auto\n  qed\n  thus ?thesis using assms(2) by auto\nqed", "origin": "non_zero_times_inverse_extended", "update_count": 0}, "non_zero_times_inverse_generalized": {"skill_name": "non_zero_times_inverse_generalized", "marker": "lemma non_zero_times_inverse_generalized:\n  fixes a :: \"real set\"\n  assumes \"\\<forall>x \\<in> a. x \\<noteq> 0\"\n  shows \"\\<forall>x \\<in> a. x * (1 / x) = 1\"\nproof -\n  {\n    fix x\n    assume \"x \\<in> a\"\n    then have \"x \\<noteq> 0\" using assms by auto\n    have \"x * (1 / x) = 1\" by (metis \\<open>x \\<noteq> 0\\<close> divide_cancel_right nonzero_mult_div_cancel_left)\n    hence \"x * (1 / x) = 1\" by auto\n  }\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma non_zero_times_inverse_generalized:\n  fixes a :: \"real set\"\n  assumes \"\\<forall>x \\<in> a. x \\<noteq> 0\"\n  shows \"\\<forall>x \\<in> a. x * (1 / x) = 1\"\nproof -\n  {\n    fix x\n    assume \"x \\<in> a\"\n    then have \"x \\<noteq> 0\" using assms by auto\n    have \"x * (1 / x) = 1\" by (metis \\<open>x \\<noteq> 0\\<close> divide_cancel_right nonzero_mult_div_cancel_left)\n    hence \"x * (1 / x) = 1\" by auto\n  }\n  thus ?thesis by auto\nqed", "origin": "non_zero_times_inverse_extended", "update_count": 0}, "non_zero_times_inverse_for_any": {"skill_name": "non_zero_times_inverse_for_any", "marker": "lemma non_zero_times_inverse_for_any:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<exists>b. b = 1/a\"\nproof -\n  let ?b = \"1/a\"\n  have \"?b * a = 1\" using assms by auto\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma non_zero_times_inverse_for_any:\n  fixes a :: real\n  assumes \"a \\<noteq> 0\"\n  shows \"\\<exists>b. b = 1/a\"\nproof -\n  let ?b = \"1/a\"\n  have \"?b * a = 1\" using assms by auto\n  thus ?thesis by auto\nqed", "origin": "non_zero_times_inverse_extended", "update_count": 0}, "non_zero_times_inverse_for_list": {"skill_name": "non_zero_times_inverse_for_list", "marker": "lemma non_zero_times_inverse_for_list:\n  fixes xs :: \"real list\"\n  assumes \"\\<forall>x \\<in> set xs. x \\<noteq> 0\"\n  shows \"\\<forall>x \\<in> set xs. x * (1 / x) = 1\"\nproof -\n  have \"\\<forall>x \\<in> set xs. x * (1 / x) = 1\"\n  proof\n    fix x\n    assume \"x \\<in> set xs\"\n    then have \"x \\<noteq> 0\" using assms by auto\n    thus \"x * (1 / x) = 1\" by (simp add: non_zero_times_inverse_generalized)\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma non_zero_times_inverse_generalized:\n  fixes a :: \"'a::field\"\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  by (simp add: assms)\n\nlemma non_zero_times_inverse_for_list:\n  fixes xs :: \"real list\"\n  assumes \"\\<forall>x \\<in> set xs. x \\<noteq> 0\"\n  shows \"\\<forall>x \\<in> set xs. x * (1 / x) = 1\"\nproof -\n  have \"\\<forall>x \\<in> set xs. x * (1 / x) = 1\"\n  proof\n    fix x\n    assume \"x \\<in> set xs\"\n    then have \"x \\<noteq> 0\" using assms by auto\n    thus \"x * (1 / x) = 1\" by (simp add: non_zero_times_inverse_generalized)\n  qed\n  thus ?thesis by auto\nqed", "origin": "non_zero_times_inverse_extended", "update_count": 0}, "non_zero_times_inverse_for_set": {"skill_name": "non_zero_times_inverse_for_set", "marker": "lemma non_zero_times_inverse_for_set:\n  fixes A :: \"'a::field set\"\n  assumes \"\\<forall>x \\<in> A. x \\<noteq> 0\"\n  shows \"\\<forall>x \\<in> A. x * (1 / x) = 1\"\nproof -\n  have \"\\<forall>x \\<in> A. x * (1 / x) = 1\" \n  proof\n    fix x\n    assume \"x \\<in> A\"\n    then have \"x \\<noteq> 0\" using assms by auto\n    thus \"x * (1 / x) = 1\" by (simp add: non_zero_times_inverse_generalized)\n  qed\n  thus ?thesis by auto\nqed", "description": "-", "full_code": "lemma non_zero_times_inverse_generalized:\n  fixes a :: \"'a::field\"\n  assumes \"a \\<noteq> 0\"\n  shows \"a * (1 / a) = 1\"\n  by (simp add: assms)\n\nlemma non_zero_times_inverse_for_set:\n  fixes A :: \"'a::field set\"\n  assumes \"\\<forall>x \\<in> A. x \\<noteq> 0\"\n  shows \"\\<forall>x \\<in> A. x * (1 / x) = 1\"\nproof -\n  have \"\\<forall>x \\<in> A. x * (1 / x) = 1\" \n  proof\n    fix x\n    assume \"x \\<in> A\"\n    then have \"x \\<noteq> 0\" using assms by auto\n    thus \"x * (1 / x) = 1\" by (simp add: non_zero_times_inverse_generalized)\n  qed\n  thus ?thesis by auto\nqed", "origin": "non_zero_times_inverse_extended", "update_count": 0}, "square_mod_d": {"skill_name": "square_mod_d", "marker": "lemma square_mod_d:\n  fixes k :: nat and d :: nat\n  assumes \"d > 0\" \"k mod d = 0\"\n  shows \"k^2 mod d = 0\"\nproof -\n  have \"k = d * (k div d)\" using assms(2) by auto\n  then have \"k^2 = (d * (k div d))^2\" by (simp add: power2_eq_square)\n  then have \"k^2 = d^2 * (k div d)^2\" by (simp add: algebra_simps)\n  thus \"k^2 mod d = 0\" by (simp add: mod_mult_self2)\nqed", "description": "-", "full_code": "lemma square_mod_d:\n  fixes k :: nat and d :: nat\n  assumes \"d > 0\" \"k mod d = 0\"\n  shows \"k^2 mod d = 0\"\nproof -\n  have \"k = d * (k div d)\" using assms(2) by auto\n  then have \"k^2 = (d * (k div d))^2\" by (simp add: power2_eq_square)\n  then have \"k^2 = d^2 * (k div d)^2\" by (simp add: algebra_simps)\n  thus \"k^2 mod d = 0\" by (simp add: mod_mult_self2)\nqed", "origin": "square_mod_10V3", "update_count": 0}, "mod_exponentiation_multi_k_sum": {"skill_name": "mod_exponentiation_multi_k_sum", "marker": "lemma mod_exponentiation_multi_k_sum:\n  fixes x y n a b k :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\" \"b > 0\" \"k > 0\"\n  shows \"((x + y)^(b*k)) mod n = ((a + b)^k)^b mod n\"\nproof -\n  have \"((x + y)^(b*k)) mod n = (((x + y) mod n)^(b*k)) mod n\" using assms by (metis power_mod)\n  also have \"... = ((a + b)^(b*k)) mod n\" using assms(2, 3) by (smt (verit) mod_add_eq power_mod)\n  finally show ?thesis by (metis \\<open>((x + y) mod n) ^ (b * k) mod n = (a + b) ^ (b * k) mod n\\<close> \\<open>(x + y) ^ (b * k) mod n = ((x + y) mod n) ^ (b * k) mod n\\<close> mult.commute power_mult)\nqed\nprimrec mod_exponentiation_list_sum :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list_sum [] n b = 1\" |\n  \"mod_exponentiation_list_sum (x#xs) n b = (((x^b) mod n + mod_exponentiation_list_sum xs n b) mod n)\"", "description": "-", "full_code": "lemma mod_exponentiation_multi_k_sum:\n  fixes x y n a b k :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\" \"b > 0\" \"k > 0\"\n  shows \"((x + y)^(b*k)) mod n = ((a + b)^k)^b mod n\"\nproof -\n  have \"((x + y)^(b*k)) mod n = (((x + y) mod n)^(b*k)) mod n\" using assms by (metis power_mod)\n  also have \"... = ((a + b)^(b*k)) mod n\" using assms(2, 3) by (smt (verit) mod_add_eq power_mod)\n  finally show ?thesis by (metis \\<open>((x + y) mod n) ^ (b * k) mod n = (a + b) ^ (b * k) mod n\\<close> \\<open>(x + y) ^ (b * k) mod n = ((x + y) mod n) ^ (b * k) mod n\\<close> mult.commute power_mult)\nqed\nprimrec mod_exponentiation_list_sum :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list_sum [] n b = 1\" |\n  \"mod_exponentiation_list_sum (x#xs) n b = (((x^b) mod n + mod_exponentiation_list_sum xs n b) mod n)\"", "origin": "mod_exponentiation_multi_k", "update_count": 0}, "mod_exponentiation_sum": {"skill_name": "mod_exponentiation_sum", "marker": "lemma mod_exponentiation_sum:\n  fixes x y n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\" \"b > 0\"\n  shows \"((x + y)^b) mod n = ((a + b)^b) mod n\"\nproof -\n  have \"((x + y)^b) mod n = ((x mod n + y mod n)^b) mod n\" using assms by (smt (verit) mod_add_left_eq mod_add_right_eq power_mod)\n  also have \"... = (a + b)^b mod n\" using assms(2, 3) by auto\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma mod_exponentiation_sum:\n  fixes x y n a b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\" \"b > 0\"\n  shows \"((x + y)^b) mod n = ((a + b)^b) mod n\"\nproof -\n  have \"((x + y)^b) mod n = ((x mod n + y mod n)^b) mod n\" using assms by (smt (verit) mod_add_left_eq mod_add_right_eq power_mod)\n  also have \"... = (a + b)^b mod n\" using assms(2, 3) by auto\n  finally show ?thesis .\nqed", "origin": "mod_exponentiation_multi_k", "update_count": 0}, "mod_exponentiation_sumV2": {"skill_name": "mod_exponentiation_sumV2", "marker": "lemma mod_exponentiation_sum:\n  fixes x y n b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\" \"b > 0\"\n  shows \"((x + y)^b) mod n = ((a + b)^b) mod n\"\nproof -\n  have \"((x + y)^b) mod n = (((x mod n) + (y mod n))^b) mod n\" using assms by (smt (verit) mod_add_left_eq mod_add_right_eq power_mod)\n  also have \"... = ((a + b)^b) mod n\" using assms(2) assms(3) by auto\n  finally show ?thesis by auto\nqed\nprimrec mod_exponentiation_list_sum :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list_sum [] n b = 1\" |\n  \"mod_exponentiation_list_sum (x#xs) n b = ((x^b mod n) + (mod_exponentiation_list_sum xs n b)) mod n\"\nprimrec mod_exponentiation_matrix_sum :: \"nat list list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_matrix_sum [] n b = 1\" |\n  \"mod_exponentiation_matrix_sum (row#rows) n b = \n     (mod_exponentiation_list_sum row n b + mod_exponentiation_matrix_sum rows n b) mod n\"", "description": "-", "full_code": "lemma mod_exponentiation_sum:\n  fixes x y n b :: nat\n  assumes \"n > 0\" \"x mod n = a\" \"y mod n = b\" \"b > 0\"\n  shows \"((x + y)^b) mod n = ((a + b)^b) mod n\"\nproof -\n  have \"((x + y)^b) mod n = (((x mod n) + (y mod n))^b) mod n\" using assms by (smt (verit) mod_add_left_eq mod_add_right_eq power_mod)\n  also have \"... = ((a + b)^b) mod n\" using assms(2) assms(3) by auto\n  finally show ?thesis by auto\nqed\nprimrec mod_exponentiation_list_sum :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_list_sum [] n b = 1\" |\n  \"mod_exponentiation_list_sum (x#xs) n b = ((x^b mod n) + (mod_exponentiation_list_sum xs n b)) mod n\"\nprimrec mod_exponentiation_matrix_sum :: \"nat list list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"mod_exponentiation_matrix_sum [] n b = 1\" |\n  \"mod_exponentiation_matrix_sum (row#rows) n b = \n     (mod_exponentiation_list_sum row n b + mod_exponentiation_matrix_sum rows n b) mod n\"", "origin": "mod_exponentiation_multiV2", "update_count": 0}, "mod_sumV2": {"skill_name": "mod_sumV2", "marker": "lemma mod_sum:\n  fixes x y n :: nat\n  shows \"(x + y) mod n = ((x mod n) + (y mod n)) mod n\"\nproof (cases \"n = 0\")\n  case True\n  then show ?thesis\n    by simp\nnext\n  case False\n  then have \"n > 0\" by simp\n  have \"x mod n < n\" and \"y mod n < n\" using False by auto\n  hence \"((x mod n) + (y mod n)) < 2 * n\" by arith\n  have \"x + y = (x mod n) + (y mod n) + (x div n + y div n) * n\"\n    by (auto simp: field_simps)\n  then have \"(x + y) mod n = (((x mod n) + (y mod n)) + (x div n + y div n) * n) mod n\"\n    by simp\n  also have \"... = ((x mod n) + (y mod n)) mod n\"\n  proof -\n    have \"((x mod n) + (y mod n) + (x div n + y div n) * n) mod n = ((x mod n) + (y mod n)) mod n\"\n      using `((x mod n) + (y mod n)) < 2 * n` by auto\n    thus ?thesis by simp\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes x y n :: nat\n  shows \"(x + y) mod n = ((x mod n) + (y mod n)) mod n\"\nproof (cases \"n = 0\")\n  case True\n  then show ?thesis\n    by simp\nnext\n  case False\n  then have \"n > 0\" by simp\n  have \"x mod n < n\" and \"y mod n < n\" using False by auto\n  hence \"((x mod n) + (y mod n)) < 2 * n\" by arith\n  have \"x + y = (x mod n) + (y mod n) + (x div n + y div n) * n\"\n    by (auto simp: field_simps)\n  then have \"(x + y) mod n = (((x mod n) + (y mod n)) + (x div n + y div n) * n) mod n\"\n    by simp\n  also have \"... = ((x mod n) + (y mod n)) mod n\"\n  proof -\n    have \"((x mod n) + (y mod n) + (x div n + y div n) * n) mod n = ((x mod n) + (y mod n)) mod n\"\n      using `((x mod n) + (y mod n)) < 2 * n` by auto\n    thus ?thesis by simp\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_mod_prime": {"skill_name": "square_mod_prime", "marker": "lemma square_mod_prime:\n  fixes k p :: nat\n  assumes \"p > 1\" \"prime p\" \"k mod p = 0\"\n  shows \"k^2 mod p = 0\"\n  using square_mod_n[of k p] assms by auto", "description": "-", "full_code": "lemma square_mod_n:\n  fixes k n :: nat\n  assumes \"k mod n = 0\"\n  shows \"k^2 mod n = 0\"\nproof -\n  obtain x where \"k = n * x\" using assms by auto\n  then have \"k^2 = (n * x)^2\" by simp\n  also have \"... = n^2 * x^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod n = (n^2 * x^2) mod n\" by simp\n  also have \"... = 0\" by auto\n  thus ?thesis by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed\n\nlemma square_mod_prime:\n  fixes k p :: nat\n  assumes \"p > 1\" \"prime p\" \"k mod p = 0\"\n  shows \"k^2 mod p = 0\"\n  using square_mod_n[of k p] assms by auto", "origin": "square_mod_10V2", "update_count": 0}, "square_mod_nV2": {"skill_name": "square_mod_nV2", "marker": "lemma square_mod_n:\n  fixes k n :: nat\n  assumes \"k mod n = 0\"\n  shows \"k^2 mod n = 0\"\nproof -\n  obtain x where \"k = n * x\" using assms by auto\n  then have \"k^2 = (n * x)^2\" by simp\n  also have \"... = n^2 * x^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod n = (n^2 * x^2) mod n\" by simp\n  also have \"... = 0\" by auto\n  thus ?thesis by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_mod_n:\n  fixes k n :: nat\n  assumes \"k mod n = 0\"\n  shows \"k^2 mod n = 0\"\nproof -\n  obtain x where \"k = n * x\" using assms by auto\n  then have \"k^2 = (n * x)^2\" by simp\n  also have \"... = n^2 * x^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod n = (n^2 * x^2) mod n\" by simp\n  also have \"... = 0\" by auto\n  thus ?thesis by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "origin": "square_mod_10V2", "update_count": 0}, "square_mod_10_extended": {"skill_name": "square_mod_10_extended", "marker": "lemma square_mod_10_extended:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 100 = 0\"\nproof -\n  have \"k^2 mod 100 = (k^2) mod (10^2)\" by (simp add: power2_eq_square)\n  have \"k^2 = (10 * (k div 10))^2\" using assms by auto\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod 100 = 0\" by auto\n  thus ?thesis by (simp add: assms)\nqed", "description": "-", "full_code": "lemma square_mod_10_extended:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 100 = 0\"\nproof -\n  have \"k^2 mod 100 = (k^2) mod (10^2)\" by (simp add: power2_eq_square)\n  have \"k^2 = (10 * (k div 10))^2\" using assms by auto\n  also have \"... = 100 * (k div 10)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod 100 = 0\" by auto\n  thus ?thesis by (simp add: assms)\nqed", "origin": "square_mod_10V2", "update_count": 0}, "square_mod_10_general": {"skill_name": "square_mod_10_general", "marker": "lemma square_mod_10_general:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\n  using square_mod_n[of k 10] assms by simp", "description": "-", "full_code": "lemma square_mod_n:\n  fixes k n :: nat\n  assumes \"k mod n = 0\"\n  shows \"k^2 mod n = 0\"\nproof -\n  obtain x where \"k = n * x\" using assms by auto\n  then have \"k^2 = (n * x)^2\" by simp\n  also have \"... = n^2 * x^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod n = (n^2 * x^2) mod n\" by simp\n  also have \"... = 0\" by auto\n  thus ?thesis by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed\n\nlemma square_mod_10_general:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\n  using square_mod_n[of k 10] assms by simp", "origin": "square_mod_10V2", "update_count": 0}, "mod_10_of_power": {"skill_name": "mod_10_of_power", "marker": "lemma mod_10_of_power:\n  fixes a :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod 10 = (a mod 10)^n mod 10\"\nproof -\n  have \"a^n mod 10 = (a mod 10)^n mod 10\" using assms\n    by (metis power_mod)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_10_of_power:\n  fixes a :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod 10 = (a mod 10)^n mod 10\"\nproof -\n  have \"a^n mod 10 = (a mod 10)^n mod 10\" using assms\n    by (metis power_mod)\n  thus ?thesis by simp\nqed", "origin": "mod_10_units_digit", "update_count": 0}, "units_digit_of_power": {"skill_name": "units_digit_of_power", "marker": "lemma units_digit_of_power:\n  fixes a :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod 10 = (a mod 10)^n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^(Suc n) = a * a^n\" by simp\n    then have \"a^(Suc n) mod 10 = (a * a^n) mod 10\"\n      by auto\n    also have \"... = (a mod 10 * (a^n mod 10)) mod 10\"\n      by (metis mod_mult_eq)\n    finally show ?case by (metis power_mod)\n  qed\nqed", "description": "-", "full_code": "lemma units_digit_of_power:\n  fixes a :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod 10 = (a mod 10)^n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^(Suc n) = a * a^n\" by simp\n    then have \"a^(Suc n) mod 10 = (a * a^n) mod 10\"\n      by auto\n    also have \"... = (a mod 10 * (a^n mod 10)) mod 10\"\n      by (metis mod_mult_eq)\n    finally show ?case by (metis power_mod)\n  qed\nqed", "origin": "mod_10_units_digit", "update_count": 0}, "inverse_property": {"skill_name": "inverse_property", "marker": "lemma inverse_property:\n  fixes x :: real\n  assumes \"x \\<noteq> 0\"\n  shows \"x * (1 / x) = 1\"\n  using assms by auto", "description": "-", "full_code": "lemma inverse_property:\n  fixes x :: real\n  assumes \"x \\<noteq> 0\"\n  shows \"x * (1 / x) = 1\"\n  using assms by auto", "origin": "non_zero_times_inverse_with_property", "update_count": 0}, "product_non_zero": {"skill_name": "product_non_zero", "marker": "lemma product_non_zero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * b \\<noteq> 0\"\nproof -\n  have \"a * b = 0 \\<Longrightarrow> (a = 0 \\<or> b = 0)\" by auto\n  thus ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma product_non_zero:\n  fixes a b :: real\n  assumes \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"a * b \\<noteq> 0\"\nproof -\n  have \"a * b = 0 \\<Longrightarrow> (a = 0 \\<or> b = 0)\" by auto\n  thus ?thesis using assms by auto\nqed", "origin": "non_zero_times_inverse_with_property", "update_count": 0}, "non_zero_sum_property": {"skill_name": "non_zero_sum_property", "marker": "lemma non_zero_sum_property:\n  fixes a b :: real\n  assumes \"a + b \\<noteq> 0\" \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1 / a + 1 / b = (a + b) / (a * b)\"\nproof -\n  have \"1 / a + 1 / b = b / (a * b) + a / (a * b)\" by (metis assms(2) assms(3) nonzero_divide_mult_cancel_left nonzero_divide_mult_cancel_right)\n  also have \"... = (a + b) / (a * b)\" by (auto simp: field_simps)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma non_zero_sum_property:\n  fixes a b :: real\n  assumes \"a + b \\<noteq> 0\" \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n  shows \"1 / a + 1 / b = (a + b) / (a * b)\"\nproof -\n  have \"1 / a + 1 / b = b / (a * b) + a / (a * b)\" by (metis assms(2) assms(3) nonzero_divide_mult_cancel_left nonzero_divide_mult_cancel_right)\n  also have \"... = (a + b) / (a * b)\" by (auto simp: field_simps)\n  finally show ?thesis by simp\nqed", "origin": "non_zero_times_inverse_with_property", "update_count": 0}, "mod_10_of_powerV2": {"skill_name": "mod_10_of_powerV2", "marker": "lemma mod_10_of_power:\n  fixes a :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod 10 = (a mod 10)^n mod 10\"\n  using assms by (metis power_mod)", "description": "", "full_code": "lemma mod_10_of_power:\n  fixes a :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod 10 = (a mod 10)^n mod 10\"\n  using assms by (metis power_mod)", "origin": "data/full_data/debug/valid_rand/amc12a_2008_p15.json_v21", "update_count": -1}, "square_mod_nV3": {"skill_name": "square_mod_nV3", "marker": "lemma square_mod_n:\n  fixes k :: nat and n :: nat\n  assumes \"k mod n = 0\"\n  shows \"k^2 mod (n^2) = 0\"\nproof -\n  have \"k^2 mod (n^2) = (k^2) mod (n^2)\" by (simp add: power2_eq_square)\n  have \"k^2 = (n * (k div n))^2\" using assms by auto\n  also have \"... = n^2 * (k div n)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod (n^2) = 0\" by auto\n  thus ?thesis by (simp add: assms)\nqed", "description": "-", "full_code": "lemma square_mod_n:\n  fixes k :: nat and n :: nat\n  assumes \"k mod n = 0\"\n  shows \"k^2 mod (n^2) = 0\"\nproof -\n  have \"k^2 mod (n^2) = (k^2) mod (n^2)\" by (simp add: power2_eq_square)\n  have \"k^2 = (n * (k div n))^2\" using assms by auto\n  also have \"... = n^2 * (k div n)^2\" by (simp add: power2_eq_square)\n  finally have \"k^2 mod (n^2) = 0\" by auto\n  thus ?thesis by (simp add: assms)\nqed", "origin": "square_mod_10_extended", "update_count": 0}, "sum_mod": {"skill_name": "sum_mod", "marker": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  have \"a + b = (a mod 10) + (b mod 10) + (a div 10 + b div 10) * 10\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + (a div 10 + b div 10) * 10) mod 10\"\n    by presburger\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\"\n    by presburger  \n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  have \"a + b = (a mod 10) + (b mod 10) + (a div 10 + b div 10) * 10\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + (a div 10 + b div 10) * 10) mod 10\"\n    by presburger\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\"\n    by presburger  \n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_of_power_congruent_to_mod_of_base": {"skill_name": "mod_of_power_congruent_to_mod_of_base", "marker": "lemma mod_of_power_congruent_to_mod_of_base:\n  fixes a n :: nat\n  assumes \"a > 0\" \"n > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (cases \"n = 1\")\n  case True\n  then show ?thesis\n    by simp\nnext\n  case False\n  then have \"n \\<ge> 2\"\n    using assms\n    by simp\n  show ?thesis\n  proof (induction n)\n    case 0\n    then show ?case\n      by simp\n  next\n    case (Suc n)\n    assume IH: \"(a^n) mod m = (a mod m)^n mod m\"\n    have \"(a^(Suc n)) mod m = (a * (a^n)) mod m\"\n      by simp\n    also have \"... = (a * ((a mod m)^n mod m)) mod m\"\n      using IH\n      by (metis mod_mult_right_eq)\n    also have \"... = ((a mod m) * (a mod m)^n) mod m\"\n      by (metis mod_mult_left_eq mod_mult_right_eq)\n    also have \"... = ((a mod m)^(Suc n)) mod m\"\n      by simp\n    finally show ?case\n      by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_of_power_congruent_to_mod_of_base:\n  fixes a n :: nat\n  assumes \"a > 0\" \"n > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (cases \"n = 1\")\n  case True\n  then show ?thesis\n    by simp\nnext\n  case False\n  then have \"n \\<ge> 2\"\n    using assms\n    by simp\n  show ?thesis\n  proof (induction n)\n    case 0\n    then show ?case\n      by simp\n  next\n    case (Suc n)\n    assume IH: \"(a^n) mod m = (a mod m)^n mod m\"\n    have \"(a^(Suc n)) mod m = (a * (a^n)) mod m\"\n      by simp\n    also have \"... = (a * ((a mod m)^n mod m)) mod m\"\n      using IH\n      by (metis mod_mult_right_eq)\n    also have \"... = ((a mod m) * (a mod m)^n) mod m\"\n      by (metis mod_mult_left_eq mod_mult_right_eq)\n    also have \"... = ((a mod m)^(Suc n)) mod m\"\n      by simp\n    finally show ?case\n      by simp\n  qed\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_of_power": {"skill_name": "mod_of_power", "marker": "lemma mod_of_power:\n  fixes a n m :: nat\n  assumes \"a > 0\" \"n > 0\" \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (cases \"n = 1\")\n  case True\n  then show ?thesis\n    by simp\nnext\n  case False\n  then have \"n \\<ge> 2\"\n    using assms\n    by simp\n  show ?thesis\n  proof (induction n)\n    case 0\n    then show ?case\n      by simp\n  next\n    case (Suc n)\n    assume IH: \"(a^n) mod m = (a mod m)^n mod m\"\n    have \"(a^(Suc n)) mod m = (a * (a^n)) mod m\"\n      by simp\n    also have \"... = (a * ((a mod m)^n mod m)) mod m\"\n      using IH by (metis mod_mult_right_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\"\n      by (metis mod_mult_left_eq)\n    also have \"... = ((a mod m)^(Suc n)) mod m\"\n      by (metis calculation power_mod)\n    finally show ?case\n      by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_of_power:\n  fixes a n m :: nat\n  assumes \"a > 0\" \"n > 0\" \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (cases \"n = 1\")\n  case True\n  then show ?thesis\n    by simp\nnext\n  case False\n  then have \"n \\<ge> 2\"\n    using assms\n    by simp\n  show ?thesis\n  proof (induction n)\n    case 0\n    then show ?case\n      by simp\n  next\n    case (Suc n)\n    assume IH: \"(a^n) mod m = (a mod m)^n mod m\"\n    have \"(a^(Suc n)) mod m = (a * (a^n)) mod m\"\n      by simp\n    also have \"... = (a * ((a mod m)^n mod m)) mod m\"\n      using IH by (metis mod_mult_right_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\"\n      by (metis mod_mult_left_eq)\n    also have \"... = ((a mod m)^(Suc n)) mod m\"\n      by (metis calculation power_mod)\n    finally show ?case\n      by simp\n  qed\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_property": {"skill_name": "mod_power_property", "marker": "lemma mod_power_property:\n  fixes a :: nat\n  assumes \"a > 0\" and \"n > 0\"\n  shows \"(a mod 10)^n mod 10 = a^n mod 10\"\nproof -\n  have \"a^n mod 10 = (a mod 10)^n mod 10\" by (metis power_mod)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_power_property:\n  fixes a :: nat\n  assumes \"a > 0\" and \"n > 0\"\n  shows \"(a mod 10)^n mod 10 = a^n mod 10\"\nproof -\n  have \"a^n mod 10 = (a mod 10)^n mod 10\" by (metis power_mod)\n  then show ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_exponentiation": {"skill_name": "mod_power_exponentiation", "marker": "lemma mod_power_exponentiation:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"(a mod 10)^n mod 10 = a^n mod 10\"\nproof -\n  have \"a^n mod 10 = (a mod 10)^n mod 10\" using assms by (metis power_mod)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_power_exponentiation:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"(a mod 10)^n mod 10 = a^n mod 10\"\nproof -\n  have \"a^n mod 10 = (a mod 10)^n mod 10\" using assms by (metis power_mod)\n  then show ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_k_of_power": {"skill_name": "mod_k_of_power", "marker": "lemma mod_k_of_power:\n  fixes a n k :: nat\n  assumes \"a > 0\" \"k > 0\"\n  shows \"a^n mod k = (a mod k)^n mod k\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) mod k = (a * a^n) mod k\"\n    by simp\n  also have \"... = ((a mod k) * (a^n mod k)) mod k\"\n    by (metis Suc.IH mod_mult_eq mod_eq_0_iff_dvd)\n  also have \"... = ((a mod k) * ((a mod k)^n mod k)) mod k\"\n    by (metis Suc.IH)\n  thus ?case by (metis power_mod)\nqed", "description": "-", "full_code": "lemma mod_k_of_power:\n  fixes a n k :: nat\n  assumes \"a > 0\" \"k > 0\"\n  shows \"a^n mod k = (a mod k)^n mod k\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) mod k = (a * a^n) mod k\"\n    by simp\n  also have \"... = ((a mod k) * (a^n mod k)) mod k\"\n    by (metis Suc.IH mod_mult_eq mod_eq_0_iff_dvd)\n  also have \"... = ((a mod k) * ((a mod k)^n mod k)) mod k\"\n    by (metis Suc.IH)\n  thus ?case by (metis power_mod)\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_10_of_power_extended": {"skill_name": "mod_10_of_power_extended", "marker": "lemma mod_10_of_power_extended:\n  fixes a n d :: nat\n  assumes \"a > 0\" \"d > 0\" \"n > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof -\n  have \"a^n mod d = ((a mod d) + (d * (a div d)))^n mod d\"\n    by auto\n  also have \"... = (a mod d)^n mod d\" \n    by (simp add: assms(2) assms(3) power_mod)\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma mod_10_of_power_extended:\n  fixes a n d :: nat\n  assumes \"a > 0\" \"d > 0\" \"n > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof -\n  have \"a^n mod d = ((a mod d) + (d * (a div d)))^n mod d\"\n    by auto\n  also have \"... = (a mod d)^n mod d\" \n    by (simp add: assms(2) assms(3) power_mod)\n  finally show ?thesis .\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_addV3": {"skill_name": "mod_addV3", "marker": "lemma mod_add:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"a mod m < m\" and \"b mod m < m\" using assms by auto\n  then have \"((a mod m) + (b mod m)) < 2 * m\" by arith\n  have \"((a mod m) + (b mod m)) mod m = (a mod m + b mod m) - (m * ((a mod m + b mod m) div m))\" \n    by (metis minus_mult_div_eq_mod)\n  moreover have \"(a + b) mod m = (a + b) - (m * ((a + b) div m))\" \n    by (metis minus_div_mult_eq_mod minus_mult_div_eq_mod)\n  ultimately show ?thesis \n    by presburger\nqed", "description": "-", "full_code": "lemma mod_add:\n  fixes a b m :: nat\n  assumes \"m > 0\"\n  shows \"(a + b) mod m = ((a mod m) + (b mod m)) mod m\"\nproof -\n  have \"a mod m < m\" and \"b mod m < m\" using assms by auto\n  then have \"((a mod m) + (b mod m)) < 2 * m\" by arith\n  have \"((a mod m) + (b mod m)) mod m = (a mod m + b mod m) - (m * ((a mod m + b mod m) div m))\" \n    by (metis minus_mult_div_eq_mod)\n  moreover have \"(a + b) mod m = (a + b) - (m * ((a + b) div m))\" \n    by (metis minus_div_mult_eq_mod minus_mult_div_eq_mod)\n  ultimately show ?thesis \n    by presburger\nqed", "origin": "do_request", "update_count": 0}, "mod_exp_identity": {"skill_name": "mod_exp_identity", "marker": "lemma mod_exp_identity:\n  fixes a b n :: nat\n  assumes \"a > 0\" \"b > 0\" \"n > 0\"\n  shows \"(a * b)^n mod 10 = ((a mod 10) * (b mod 10))^n mod 10\"\nproof -\n  have \"((a * b)^n mod 10) = (a mod 10 * b mod 10)^n mod 10\"\n    by (metis mod_mult_left_eq power_mod)\n  thus ?thesis using assms by (smt (verit) mod_mult_right_eq power_mod)\nqed", "description": "-", "full_code": "lemma mod_exp_identity:\n  fixes a b n :: nat\n  assumes \"a > 0\" \"b > 0\" \"n > 0\"\n  shows \"(a * b)^n mod 10 = ((a mod 10) * (b mod 10))^n mod 10\"\nproof -\n  have \"((a * b)^n mod 10) = (a mod 10 * b mod 10)^n mod 10\"\n    by (metis mod_mult_left_eq power_mod)\n  thus ?thesis using assms by (smt (verit) mod_mult_right_eq power_mod)\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "modular_arithmetic": {"skill_name": "modular_arithmetic", "marker": "lemma modular_arithmetic:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = (a div 10) * 10\" using assms(1) by auto \n  have \"b = (b div 10) * 10 + 6\" using assms(2) by presburger\n  then have \"a + b = (a div 10) * 10 + ((b div 10) * 10 + 6)\" \n    by (metis \\<open>a = a div 10 * 10\\<close>)\n  then have \"a + b = ((a div 10) + (b div 10)) * 10 + 6\" by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (((a div 10) + (b div 10)) * 10 + 6) mod 10\" \n    by simp\n  also have \"... = 6 mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma modular_arithmetic:\n  fixes a b :: nat\n  assumes \"a mod 10 = 0\" \"b mod 10 = 6\"\n  shows \"(a + b) mod 10 = 6\"\nproof -\n  have \"a = (a div 10) * 10\" using assms(1) by auto \n  have \"b = (b div 10) * 10 + 6\" using assms(2) by presburger\n  then have \"a + b = (a div 10) * 10 + ((b div 10) * 10 + 6)\" \n    by (metis \\<open>a = a div 10 * 10\\<close>)\n  then have \"a + b = ((a div 10) + (b div 10)) * 10 + 6\" by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (((a div 10) + (b div 10)) * 10 + 6) mod 10\" \n    by simp\n  also have \"... = 6 mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "sum_modV2": {"skill_name": "sum_modV2", "marker": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  have \"a = (a mod 10) + (a div 10) * 10\" by auto\n  have \"b = (b mod 10) + (b div 10) * 10\" by auto\n  then have \"a + b = ((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10) mod 10\" \n    by presburger\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma sum_mod:\n  fixes a b :: nat\n  shows \"(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10\"\nproof -\n  have \"a = (a mod 10) + (a div 10) * 10\" by auto\n  have \"b = (b mod 10) + (b div 10) * 10\" by auto\n  then have \"a + b = ((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10\" \n    by (simp add: algebra_simps)\n  then have \"(a + b) mod 10 = (((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10) mod 10\" \n    by presburger\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\" \n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_power_equivalence": {"skill_name": "mod_power_equivalence", "marker": "lemma mod_power_equivalence:\n  fixes a :: nat and n :: nat and k :: nat\n  assumes \"n > 0\" and \"k > 0\"\n  shows \"(a mod k)^n mod k = a^n mod k\"\nproof -\n  have \"a^n mod k = (a mod k)^n mod k\"\n    using assms by (metis power_mod)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_power_equivalence:\n  fixes a :: nat and n :: nat and k :: nat\n  assumes \"n > 0\" and \"k > 0\"\n  shows \"(a mod k)^n mod k = a^n mod k\"\nproof -\n  have \"a^n mod k = (a mod k)^n mod k\"\n    using assms by (metis power_mod)\n  thus ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_reduction": {"skill_name": "mod_power_reduction", "marker": "lemma mod_power_reduction:\n  fixes a :: nat and n :: nat and k :: nat\n  assumes \"n > 0\" and \"k > 0\"\n  shows \"a^n mod k = (a mod k)^n mod k\"\nproof -\n  have \"a^n mod k = (a mod k)^n mod k\" using assms by (metis power_mod)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_power_reduction:\n  fixes a :: nat and n :: nat and k :: nat\n  assumes \"n > 0\" and \"k > 0\"\n  shows \"a^n mod k = (a mod k)^n mod k\"\nproof -\n  have \"a^n mod k = (a mod k)^n mod k\" using assms by (metis power_mod)\n  then show ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_powerV4": {"skill_name": "mod_powerV4", "marker": "lemma mod_power:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case\n    by simp\nnext\n  case (Suc n)\n  assume IH: \"(a^n) mod m = (a mod m)^n mod m\"\n  have \"(a^(Suc n)) mod m = (a * (a^n)) mod m\"\n    by simp\n  also have \"... = (a * ((a mod m)^n mod m)) mod m\"\n    using IH by (metis mod_mult_right_eq)\n  also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\"\n    by (metis mod_mult_left_eq)\n  also have \"... = ((a mod m)^(Suc n)) mod m\"\n    by (metis calculation power_mod)\n  finally show ?case\n    by simp\nqed", "description": "-", "full_code": "lemma mod_power:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case\n    by simp\nnext\n  case (Suc n)\n  assume IH: \"(a^n) mod m = (a mod m)^n mod m\"\n  have \"(a^(Suc n)) mod m = (a * (a^n)) mod m\"\n    by simp\n  also have \"... = (a * ((a mod m)^n mod m)) mod m\"\n    using IH by (metis mod_mult_right_eq)\n  also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\"\n    by (metis mod_mult_left_eq)\n  also have \"... = ((a mod m)^(Suc n)) mod m\"\n    by (metis calculation power_mod)\n  finally show ?case\n    by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_m_of_power": {"skill_name": "mod_m_of_power", "marker": "lemma mod_m_of_power:\n  fixes a n m :: nat\n  assumes \"a > 0\" and \"m > 0\"\n  shows \"a^n mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^(Suc n) mod m = (a * a^n) mod m\" by simp\n    also have \"... = (a mod m * a^n mod m) mod m\" using assms by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod m) * (a^n mod m)) mod m\" by (metis \\<open>a * a ^ n mod m = a mod m * a ^ n mod m mod m\\<close> mod_mult_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\" using Suc.IH by simp\n    finally show ?case by (metis power_mod)\n  qed\nqed", "description": "-", "full_code": "lemma mod_m_of_power:\n  fixes a n m :: nat\n  assumes \"a > 0\" and \"m > 0\"\n  shows \"a^n mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^(Suc n) mod m = (a * a^n) mod m\" by simp\n    also have \"... = (a mod m * a^n mod m) mod m\" using assms by (metis mod_mod_trivial mod_mult_left_eq)\n    also have \"... = ((a mod m) * (a^n mod m)) mod m\" by (metis \\<open>a * a ^ n mod m = a mod m * a ^ n mod m mod m\\<close> mod_mult_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\" using Suc.IH by simp\n    finally show ?case by (metis power_mod)\n  qed\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "last_digit_of_square": {"skill_name": "last_digit_of_square", "marker": "lemma last_digit_of_square:\n  fixes a :: nat\n  shows \"(a mod 10)^2 mod 10 = (a^2 mod 10)\"\nproof -\n  let ?x = \"a mod 10\"\n  have \"a^2 mod 10 = (a mod 10)^2 mod 10\" by (metis power_mod)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma last_digit_of_square:\n  fixes a :: nat\n  shows \"(a mod 10)^2 mod 10 = (a^2 mod 10)\"\nproof -\n  let ?x = \"a mod 10\"\n  have \"a^2 mod 10 = (a mod 10)^2 mod 10\" by (metis power_mod)\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "last_digit_of_squareV2": {"skill_name": "last_digit_of_squareV2", "marker": "lemma last_digit_of_square:\n  fixes a :: nat\n  shows \"(a mod 10)^2 mod 10 = (a^2 mod 10)\"\nproof -\n  let ?x = \"a mod 10\"\n  have \"a = 10 * (a div 10) + ?x\" by (simp)\n  then have \"a^2 = (10 * (a div 10) + ?x)^2\" by simp\n  also have \"... = (10 * (a div 10))^2 + 2 * (10 * (a div 10)) * ?x + ?x^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (a div 10)^2 + 20 * (a div 10) * ?x + ?x^2\" by (simp add: algebra_simps)\n  finally have \"a^2 mod 10 = (100 * (a div 10)^2 + 20 * (a div 10) * ?x + ?x^2) mod 10\" by simp\n  also have \"... = (?x^2) mod 10\" by (metis calculation power_mod)\n  moreover have \"(?x)^2 mod 10 = (?x^2) mod 10\" by simp\n  ultimately show ?thesis by simp\nqed", "description": "-", "full_code": "lemma last_digit_of_square:\n  fixes a :: nat\n  shows \"(a mod 10)^2 mod 10 = (a^2 mod 10)\"\nproof -\n  let ?x = \"a mod 10\"\n  have \"a = 10 * (a div 10) + ?x\" by (simp)\n  then have \"a^2 = (10 * (a div 10) + ?x)^2\" by simp\n  also have \"... = (10 * (a div 10))^2 + 2 * (10 * (a div 10)) * ?x + ?x^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (a div 10)^2 + 20 * (a div 10) * ?x + ?x^2\" by (simp add: algebra_simps)\n  finally have \"a^2 mod 10 = (100 * (a div 10)^2 + 20 * (a div 10) * ?x + ?x^2) mod 10\" by simp\n  also have \"... = (?x^2) mod 10\" by (metis calculation power_mod)\n  moreover have \"(?x)^2 mod 10 = (?x^2) mod 10\" by simp\n  ultimately show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_d_of_power": {"skill_name": "mod_d_of_power", "marker": "lemma mod_d_of_power:\n  fixes a n d :: nat\n  assumes \"a > 0\" \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case \n  proof -\n    have \"a^(Suc n) mod d = (a * a^n) mod d\"\n      by simp\n    also have \"... = ((a mod d) * (a^n mod d)) mod d\"\n      by (metis mod_mult_eq)\n    also have \"... = ((a mod d) * ((a mod d)^n mod d)) mod d\" \n      by (metis Suc.IH)\n    finally show ?case by (metis power_mod)\n  qed\nqed", "description": "-", "full_code": "lemma mod_d_of_power:\n  fixes a n d :: nat\n  assumes \"a > 0\" \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case \n  proof -\n    have \"a^(Suc n) mod d = (a * a^n) mod d\"\n      by simp\n    also have \"... = ((a mod d) * (a^n mod d)) mod d\"\n      by (metis mod_mult_eq)\n    also have \"... = ((a mod d) * ((a mod d)^n mod d)) mod d\" \n      by (metis Suc.IH)\n    finally show ?case by (metis power_mod)\n  qed\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_d_of_powerV2": {"skill_name": "mod_d_of_powerV2", "marker": "lemma mod_d_of_power:\n  fixes a d n :: nat\n  assumes \"a > 0\" and \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) mod d = (a * a^n) mod d\"\n    by (simp)\n  also have \"... = ((a mod d) * (a^n mod d)) mod d\"\n    by (metis mod_mult_eq)\n  also have \"... = ((a mod d) * ((a mod d)^n mod d)) mod d\"\n    by (metis Suc \\<open>a * a ^ n mod d = a mod d * (a ^ n mod d) mod d\\<close> \\<open>a ^ Suc n mod d = a * a ^ n mod d\\<close> calculation mod_mod_trivial mod_mult_cong mod_mult_eq)\n  finally show ?case by (metis power_mod)\nqed", "description": "-", "full_code": "lemma mod_d_of_power:\n  fixes a d n :: nat\n  assumes \"a > 0\" and \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) mod d = (a * a^n) mod d\"\n    by (simp)\n  also have \"... = ((a mod d) * (a^n mod d)) mod d\"\n    by (metis mod_mult_eq)\n  also have \"... = ((a mod d) * ((a mod d)^n mod d)) mod d\"\n    by (metis Suc \\<open>a * a ^ n mod d = a mod d * (a ^ n mod d) mod d\\<close> \\<open>a ^ Suc n mod d = a * a ^ n mod d\\<close> calculation mod_mod_trivial mod_mult_cong mod_mult_eq)\n  finally show ?case by (metis power_mod)\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_k_of_powerV2": {"skill_name": "mod_k_of_powerV2", "marker": "lemma mod_k_of_power:\n  fixes a n k :: nat\n  assumes \"a > 0\" and \"k > 0\"\n  shows \"a^n mod k = (a mod k)^n mod k\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case \n  proof -\n    have \"a^(Suc n) mod k = (a * a^n) mod k\"\n      by simp\n    also have \"... = ((a mod k) * (a^n mod k)) mod k\" \n      using `a > 0` by (metis mod_mult_eq mod_eq_0_iff_dvd)\n    also have \"... = ((a mod k) * ((a mod k)^n mod k)) mod k\" \n      using `k > 0` by (metis Suc \\<open>a * a ^ n mod k = a mod k * (a ^ n mod k) mod k\\<close> \\<open>a ^ Suc n mod k = a * a ^ n mod k\\<close> calculation mod_mod_trivial mod_mult_cong mod_mult_eq)\n    finally show ?case by (metis power_mod)\n  qed\nqed", "description": "-", "full_code": "lemma mod_k_of_power:\n  fixes a n k :: nat\n  assumes \"a > 0\" and \"k > 0\"\n  shows \"a^n mod k = (a mod k)^n mod k\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case \n  proof -\n    have \"a^(Suc n) mod k = (a * a^n) mod k\"\n      by simp\n    also have \"... = ((a mod k) * (a^n mod k)) mod k\" \n      using `a > 0` by (metis mod_mult_eq mod_eq_0_iff_dvd)\n    also have \"... = ((a mod k) * ((a mod k)^n mod k)) mod k\" \n      using `k > 0` by (metis Suc \\<open>a * a ^ n mod k = a mod k * (a ^ n mod k) mod k\\<close> \\<open>a ^ Suc n mod k = a * a ^ n mod k\\<close> calculation mod_mod_trivial mod_mult_cong mod_mult_eq)\n    finally show ?case by (metis power_mod)\n  qed\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "square_mod_10V4": {"skill_name": "square_mod_10V4", "marker": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  have \"n = 10 * (n div 10) + (n mod 10)\" by auto\n  then have \"n^2 = (10 * (n div 10) + (n mod 10))^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * (n mod 10) + (n mod 10)^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2\" by (simp add: algebra_simps)\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2) mod 10\" by simp\n  have \"100 * (n div 10)^2 mod 10 = 0\" by auto\n  have \"20 * (n div 10) * (n mod 10) mod 10 = 0\" by auto\n  thus ?thesis by (metis power_mod)\nqed", "description": "-", "full_code": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  have \"n = 10 * (n div 10) + (n mod 10)\" by auto\n  then have \"n^2 = (10 * (n div 10) + (n mod 10))^2\" by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * (n mod 10) + (n mod 10)^2\" by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2\" by (simp add: algebra_simps)\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * (n mod 10) + (n mod 10)^2) mod 10\" by simp\n  have \"100 * (n div 10)^2 mod 10 = 0\" by auto\n  have \"20 * (n div 10) * (n mod 10) mod 10 = 0\" by auto\n  thus ?thesis by (metis power_mod)\nqed", "origin": "do_request", "update_count": 0}, "mod_power_add": {"skill_name": "mod_power_add", "marker": "lemma mod_power_add:\n  fixes a n m :: nat\n  assumes \"m > 0\" \"n > 0\"\n  shows \"(a + b) ^ n mod m = ((a mod m) + (b mod m)) ^ n mod m\"\nproof -\n  have \"((a + b) mod m) = ((a mod m) + (b mod m)) mod m\" by presburger\n  then show ?thesis using assms by (metis power_mod)\nqed", "description": "-", "full_code": "lemma mod_power_add:\n  fixes a n m :: nat\n  assumes \"m > 0\" \"n > 0\"\n  shows \"(a + b) ^ n mod m = ((a mod m) + (b mod m)) ^ n mod m\"\nproof -\n  have \"((a + b) mod m) = ((a mod m) + (b mod m)) mod m\" by presburger\n  then show ?thesis using assms by (metis power_mod)\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_reductionV2": {"skill_name": "mod_power_reductionV2", "marker": "lemma mod_power_reduction:\n  fixes a n :: nat\n  assumes \"a > 0\" \"n > 0\"\n  shows \"(a^n) mod m = ((a mod m)^n) mod m\"\n  by (metis assms power_mod)", "description": "-", "full_code": "lemma mod_power_reduction:\n  fixes a n :: nat\n  assumes \"a > 0\" \"n > 0\"\n  shows \"(a^n) mod m = ((a mod m)^n) mod m\"\n  by (metis assms power_mod)", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_equivalenceV2": {"skill_name": "mod_power_equivalenceV2", "marker": "lemma mod_power_equivalence:\n  fixes a n m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof -\n  have \"a^n mod m = (a mod m)^n mod m\"\n    using assms by (metis power_mod)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_power_equivalence:\n  fixes a n m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof -\n  have \"a^n mod m = (a mod m)^n mod m\"\n    using assms by (metis power_mod)\n  thus ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_cycle": {"skill_name": "mod_power_cycle", "marker": "lemma mod_power_cycle:\n  fixes a n m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof -\n  have \"a^n mod m = ((a mod m) + k * m)^n mod m\" for k :: nat\n    by (smt (verit) mod_mod_trivial mod_mult_self1 power_mod)\n  then show ?thesis\n    by (metis power_mod)\nqed", "description": "-", "full_code": "lemma mod_power_cycle:\n  fixes a n m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof -\n  have \"a^n mod m = ((a mod m) + k * m)^n mod m\" for k :: nat\n    by (smt (verit) mod_mod_trivial mod_mult_self1 power_mod)\n  then show ?thesis\n    by (metis power_mod)\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_of_base_with_sum": {"skill_name": "mod_power_of_base_with_sum", "marker": "lemma mod_power_of_base_with_sum:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"((a + b)^n) mod 10 = ((a mod 10 + b mod 10)^n) mod 10\"\nproof -\n  have \"((a + b) mod 10) = ((a mod 10 + b mod 10) mod 10)\" using assms by presburger\n  then show ?thesis\n    using assms by (smt (verit) power_mod)\nqed", "description": "-", "full_code": "lemma mod_power_of_base:\n  fixes a :: nat\n  assumes \"a > 0\" \"n > 0\"\n  shows \"(a^n) mod 10 = ((a mod 10)^n) mod 10\"\n  using assms by (metis power_mod)\n\nlemma mod_power_of_base_with_sum:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\"\n  shows \"((a + b)^n) mod 10 = ((a mod 10 + b mod 10)^n) mod 10\"\nproof -\n  have \"((a + b) mod 10) = ((a mod 10 + b mod 10) mod 10)\" using assms by presburger\n  then show ?thesis\n    using assms by (smt (verit) power_mod)\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_general": {"skill_name": "mod_power_general", "marker": "lemma mod_power_general:\n  fixes a n m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"a^n mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) mod m = (a * a^n) mod m\"\n    by (simp add: power_Suc)\n  also have \"... = ((a mod m) * (a^n mod m)) mod m\"\n    by (metis mod_mult_eq)\n  also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\"\n    by (metis Suc \\<open>a * a ^ n mod m = a mod m * (a ^ n mod m) mod m\\<close> \\<open>a ^ Suc n mod m = a * a ^ n mod m\\<close> calculation mod_mod_trivial mod_mult_cong mod_mult_eq)\n  also have \"... = (a mod m)^(Suc n) mod m\"\n    by (metis calculation power_mod)\n  finally show ?case .\nqed", "description": "-", "full_code": "lemma mod_power_general:\n  fixes a n m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"a^n mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) mod m = (a * a^n) mod m\"\n    by (simp add: power_Suc)\n  also have \"... = ((a mod m) * (a^n mod m)) mod m\"\n    by (metis mod_mult_eq)\n  also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\"\n    by (metis Suc \\<open>a * a ^ n mod m = a mod m * (a ^ n mod m) mod m\\<close> \\<open>a ^ Suc n mod m = a * a ^ n mod m\\<close> calculation mod_mod_trivial mod_mult_cong mod_mult_eq)\n  also have \"... = (a mod m)^(Suc n) mod m\"\n    by (metis calculation power_mod)\n  finally show ?case .\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_with_multiple_bases": {"skill_name": "mod_power_with_multiple_bases", "marker": "lemma mod_power_with_multiple_bases:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"n > 0\" \"m > 0\"\n  shows \"(a * b)^n mod m = ((a mod m) * (b mod m))^n mod m\"\nproof -\n  have \"(a * b)^n mod m = ((a mod m) * (b mod m))^n mod m\"\n    using assms by (smt (verit) mod_mult_left_eq mod_mult_right_eq mod_power_with_base mult_pos_pos power_mod)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_power_with_base:\n  fixes a :: nat\n  assumes \"a > 0\" \"n > 0\" \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof -\n  have \"a^n mod m = (a mod m)^n mod m\"\n    using assms by (metis power_mod)\n  thus ?thesis by simp\nqed\n\nlemma mod_power_with_multiple_bases:\n  fixes a b :: nat\n  assumes \"a > 0\" \"b > 0\" \"n > 0\" \"m > 0\"\n  shows \"(a * b)^n mod m = ((a mod m) * (b mod m))^n mod m\"\nproof -\n  have \"(a * b)^n mod m = ((a mod m) * (b mod m))^n mod m\"\n    using assms by (smt (verit) mod_mult_left_eq mod_mult_right_eq mod_power_with_base mult_pos_pos power_mod)\n  thus ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_add_powerV2": {"skill_name": "mod_add_powerV2", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b) mod n = (x mod n + b mod n) mod n\"\n    using assms(1) by presburger\n  then have \"(x + b) mod n = (a + b) mod n\"\n    using assms(4) by presburger\n  thus ?thesis\n    by (metis (full_types) power_mod)\nqed", "description": "-", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b) mod n = (x mod n + b mod n) mod n\"\n    using assms(1) by presburger\n  then have \"(x + b) mod n = (a + b) mod n\"\n    using assms(4) by presburger\n  thus ?thesis\n    by (metis (full_types) power_mod)\nqed", "origin": "do_request", "update_count": 0}, "mod_add_powerV3": {"skill_name": "mod_add_powerV3", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b) mod n = (x mod n + b mod n) mod n\"\n    by presburger\n  then have \"((x + b)^c) mod n = ((x mod n + b mod n) ^ c) mod n\"\n    by (metis power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by (smt (verit) mod_add_right_eq power_mod)\n  finally show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"(x + b) mod n = (x mod n + b mod n) mod n\"\n    by presburger\n  then have \"((x + b)^c) mod n = ((x mod n + b mod n) ^ c) mod n\"\n    by (metis power_mod)\n  also have \"... = (a + b)^c mod n\"\n    using assms(4) by (smt (verit) mod_add_right_eq power_mod)\n  finally show ?thesis by auto\nqed", "origin": "do_request", "update_count": 0}, "mod_add_powerV4": {"skill_name": "mod_add_powerV4", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"x mod n = a\" by (simp add: assms(4))\n  hence \"(x + b) mod n = (a + b) mod n\" \n    by (metis add.commute add.assoc mod_add_left_eq)\n  have \"(x + b)^c mod n = ((x + b) mod n)^c mod n\" \n    by (metis power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\" \n    using `x mod n = a` by (metis \\<open>(x + b) mod n = (a + b) mod n\\<close> power_mod)\n  finally show ?thesis \n    by (metis power_mod)\nqed", "description": "-", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"x mod n = a\" by (simp add: assms(4))\n  hence \"(x + b) mod n = (a + b) mod n\" \n    by (metis add.commute add.assoc mod_add_left_eq)\n  have \"(x + b)^c mod n = ((x + b) mod n)^c mod n\" \n    by (metis power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\" \n    using `x mod n = a` by (metis \\<open>(x + b) mod n = (a + b) mod n\\<close> power_mod)\n  finally show ?thesis \n    by (metis power_mod)\nqed", "origin": "do_request", "update_count": 0}, "mod_power_cycleV2": {"skill_name": "mod_power_cycleV2", "marker": "lemma mod_power_cycle:\n  fixes a :: nat\n  assumes \"a > 0\"\n  shows \"(a^n mod 10) = ((a mod 10)^n mod 10)\"\nproof -\n  have \"a^n mod 10 = (a mod 10)^n mod 10\" using assms by (metis power_mod)\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_power_cycle:\n  fixes a :: nat\n  assumes \"a > 0\"\n  shows \"(a^n mod 10) = ((a mod 10)^n mod 10)\"\nproof -\n  have \"a^n mod 10 = (a mod 10)^n mod 10\" using assms by (metis power_mod)\n  thus ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "square_mod_10V5": {"skill_name": "square_mod_10V5", "marker": "lemma square_mod_10:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by (simp add: power2_eq_square)\n  also have \"... = 100 * (k div 10)^2\" by (simp add: algebra_simps)\n  finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  also have \"... = 0\" by (simp add: mod_mult_self2)\n  thus ?thesis by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_mod_10:\n  fixes k :: nat\n  assumes \"k mod 10 = 0\"\n  shows \"k^2 mod 10 = 0\"\nproof -\n  have \"k = 10 * (k div 10)\" using assms by auto\n  then have \"k^2 = (10 * (k div 10))^2\" by (simp add: power2_eq_square)\n  also have \"... = 100 * (k div 10)^2\" by (simp add: algebra_simps)\n  finally have \"k^2 mod 10 = (100 * (k div 10)^2) mod 10\" by simp\n  also have \"... = 0\" by (simp add: mod_mult_self2)\n  thus ?thesis by (metis assms mod_mult_cong mod_mult_self2_is_0 mod_self power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "mod_add_powerV5": {"skill_name": "mod_add_powerV5", "marker": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"x mod n = a\" by (simp add: assms(4))\n  have \"(x + b) mod n = (x mod n + b mod n) mod n\" \n    using assms(1) by (metis add.commute add.assoc mod_add_left_eq)\n  also have \"... = (a + b) mod n\" \n    using `x mod n = a` assms(2) by presburger\n  finally have \"((x + b) mod n) = ((a + b) mod n)\" by blast\n  have \"((x + b)^c) mod n = ((x + b) mod n)^c mod n\" \n    by (metis power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\" \n    using `((x + b) mod n) = ((a + b) mod n)` by simp\n  finally show ?thesis \n    by (metis power_mod)\nqed", "description": "-", "full_code": "lemma mod_add_power:\n  fixes x n a b c :: nat\n  assumes \"n > 0\" \"b > 0\" \"c > 0\" \"x mod n = a\"\n  shows \"((x + b)^c) mod n = ((a + b)^c) mod n\"\nproof -\n  have \"x mod n = a\" by (simp add: assms(4))\n  have \"(x + b) mod n = (x mod n + b mod n) mod n\" \n    using assms(1) by (metis add.commute add.assoc mod_add_left_eq)\n  also have \"... = (a + b) mod n\" \n    using `x mod n = a` assms(2) by presburger\n  finally have \"((x + b) mod n) = ((a + b) mod n)\" by blast\n  have \"((x + b)^c) mod n = ((x + b) mod n)^c mod n\" \n    by (metis power_mod)\n  also have \"... = ((a + b) mod n)^c mod n\" \n    using `((x + b) mod n) = ((a + b) mod n)` by simp\n  finally show ?thesis \n    by (metis power_mod)\nqed", "origin": "do_request", "update_count": 0}, "mod_powerV5": {"skill_name": "mod_powerV5", "marker": "lemma mod_power:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case\n    by simp\nnext\n  case (Suc n)\n  assume IH: \"(a^n) mod m = (a mod m)^n mod m\"\n  have \"a^(Suc n) = a * (a^n)\" by simp\n  thus ?case\n  proof -\n    have \"(a^(Suc n)) mod m = (a * (a^n)) mod m\" by simp\n    also have \"... = (a * ((a mod m)^n mod m)) mod m\" using IH by (metis mod_mult_right_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\" by (metis mod_mult_left_eq)\n    also have \"... = ((a mod m)^(Suc n)) mod m\" by (metis calculation power_mod)\n    finally show ?thesis by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_power:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case\n    by simp\nnext\n  case (Suc n)\n  assume IH: \"(a^n) mod m = (a mod m)^n mod m\"\n  have \"a^(Suc n) = a * (a^n)\" by simp\n  thus ?case\n  proof -\n    have \"(a^(Suc n)) mod m = (a * (a^n)) mod m\" by simp\n    also have \"... = (a * ((a mod m)^n mod m)) mod m\" using IH by (metis mod_mult_right_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\" by (metis mod_mult_left_eq)\n    also have \"... = ((a mod m)^(Suc n)) mod m\" by (metis calculation power_mod)\n    finally show ?thesis by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "k_definition": {"skill_name": "k_definition", "marker": "lemma k_definition:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"k = 2008^2 + 2^2008\"\n  by (simp add: k_def)", "description": "", "full_code": "lemma k_definition:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"k = 2008^2 + 2^2008\"\n  by (simp add: k_def)", "origin": "data/full_data/debug/valid_rand/amc12a_2008_p15.json_v31", "update_count": -1}, "mod_d_of_powerV3": {"skill_name": "mod_d_of_powerV3", "marker": "lemma mod_d_of_power:\n  fixes a n d :: nat\n  assumes \"a > 0\" \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof -\n  have \"a^n mod d = (a mod d)^n mod d\" for n :: nat\n  proof (induction n)\n    case 0\n    then show ?case by simp\n  next\n    case (Suc n)\n    then show ?case\n    proof -\n      have \"a^(Suc n) = a * a^n\" by simp\n      hence \"a^(Suc n) mod d = (a * a^n) mod d\" by simp\n      also have \"... = (a mod d * (a^n mod d)) mod d\" using assms by (metis mod_mult_eq)\n      finally show ?thesis using `a^n mod d = (a mod d)^n mod d` by (metis power_mod)\n    qed\n  qed\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_d_of_power:\n  fixes a n d :: nat\n  assumes \"a > 0\" \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof -\n  have \"a^n mod d = (a mod d)^n mod d\" for n :: nat\n  proof (induction n)\n    case 0\n    then show ?case by simp\n  next\n    case (Suc n)\n    then show ?case\n    proof -\n      have \"a^(Suc n) = a * a^n\" by simp\n      hence \"a^(Suc n) mod d = (a * a^n) mod d\" by simp\n      also have \"... = (a mod d * (a^n mod d)) mod d\" using assms by (metis mod_mult_eq)\n      finally show ?thesis using `a^n mod d = (a mod d)^n mod d` by (metis power_mod)\n    qed\n  qed\n  then show ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_d_of_powerV4": {"skill_name": "mod_d_of_powerV4", "marker": "lemma mod_d_of_power:\n  fixes a n d :: nat\n  assumes \"a > 0\" and \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof -\n  have \"a^n mod d = (a mod d)^n mod d\"\n  proof (induction n)\n    case 0\n    then show ?case by simp\n  next\n    case (Suc n)\n    then show ?case \n      by (metis power_mod)\n  qed\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_d_of_power:\n  fixes a n d :: nat\n  assumes \"a > 0\" and \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof -\n  have \"a^n mod d = (a mod d)^n mod d\"\n  proof (induction n)\n    case 0\n    then show ?case by simp\n  next\n    case (Suc n)\n    then show ?case \n      by (metis power_mod)\n  qed\n  thus ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_cyclic": {"skill_name": "mod_power_cyclic", "marker": "lemma mod_power_cyclic:\n  fixes a n m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) mod m = (a * a^n) mod m\" by simp\n  also have \"... = (a mod m * a^n mod m) mod m\" using Suc.IH by (metis mod_mod_trivial mod_mult_left_eq)\n  also have \"... = (a mod m)^(Suc n) mod m\" by (metis calculation power_mod)\n  finally show ?case .\nqed", "description": "-", "full_code": "lemma mod_power_cyclic:\n  fixes a n m :: nat\n  assumes \"a > 0\" \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) mod m = (a * a^n) mod m\" by simp\n  also have \"... = (a mod m * a^n mod m) mod m\" using Suc.IH by (metis mod_mod_trivial mod_mult_left_eq)\n  also have \"... = (a mod m)^(Suc n) mod m\" by (metis calculation power_mod)\n  finally show ?case .\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_propertyV2": {"skill_name": "mod_power_propertyV2", "marker": "lemma mod_power_property:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) = a * a^n\" by simp\n  then have \"(a^(Suc n)) mod m = (a * a^n) mod m\" by simp\n  also have \"... = ((a mod m) * (a^n mod m)) mod m\" by (metis mod_mult_eq)\n  also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\" using Suc.IH by simp\n  also have \"... = (a mod m)^(Suc n) mod m\" by (metis calculation power_mod)\n  finally show ?case by simp\nqed", "description": "-", "full_code": "lemma mod_power_property:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) = a * a^n\" by simp\n  then have \"(a^(Suc n)) mod m = (a * a^n) mod m\" by simp\n  also have \"... = ((a mod m) * (a^n mod m)) mod m\" by (metis mod_mult_eq)\n  also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\" using Suc.IH by simp\n  also have \"... = (a mod m)^(Suc n) mod m\" by (metis calculation power_mod)\n  finally show ?case by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_powers_generalized": {"skill_name": "mod_powers_generalized", "marker": "lemma mod_powers_generalized:\n  fixes a :: nat and n :: nat and p :: nat\n  assumes \"a > 0\" and \"p > 0\"\n  shows \"a^n mod p = (a mod p)^n mod p\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) mod p = (a * a^n) mod p\"\n    by simp\n  also have \"... = ((a mod p) * (a^n mod p)) mod p\"\n    by (metis mod_mult_eq)\n  also have \"... = ((a mod p) * ((a mod p)^n mod p)) mod p\"\n    using Suc.IH by simp\n  also have \"... = (a mod p)^(Suc n) mod p\"\n    by (metis calculation power_mod)\n  finally show ?case .\nqed", "description": "-", "full_code": "lemma mod_powers_generalized:\n  fixes a :: nat and n :: nat and p :: nat\n  assumes \"a > 0\" and \"p > 0\"\n  shows \"a^n mod p = (a mod p)^n mod p\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) mod p = (a * a^n) mod p\"\n    by simp\n  also have \"... = ((a mod p) * (a^n mod p)) mod p\"\n    by (metis mod_mult_eq)\n  also have \"... = ((a mod p) * ((a mod p)^n mod p)) mod p\"\n    using Suc.IH by simp\n  also have \"... = (a mod p)^(Suc n) mod p\"\n    by (metis calculation power_mod)\n  finally show ?case .\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_generalV2": {"skill_name": "mod_power_generalV2", "marker": "lemma mod_power_general:\n  fixes a :: nat and n :: nat and d :: nat\n  assumes \"a > 0\" and \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) = a * a^n\" by simp\n  then show ?case \n  proof -\n    have \"a^(Suc n) mod d = (a * a^n) mod d\"\n      by simp\n    also have \"... = ((a mod d) * (a^n mod d)) mod d\"\n      by (metis mod_mult_eq)\n    also have \"... = ((a mod d) * ((a mod d)^n)) mod d\"\n      using Suc.IH by (metis \\<open>a * a ^ n mod d = a mod d * (a ^ n mod d) mod d\\<close> \\<open>a ^ Suc n = a * a ^ n\\<close> \\<open>a ^ Suc n mod d = a * a ^ n mod d\\<close> mod_mult_cong mod_mult_left_eq)\n    finally show ?case by auto\n  qed\nqed", "description": "-", "full_code": "lemma mod_power_general:\n  fixes a :: nat and n :: nat and d :: nat\n  assumes \"a > 0\" and \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) = a * a^n\" by simp\n  then show ?case \n  proof -\n    have \"a^(Suc n) mod d = (a * a^n) mod d\"\n      by simp\n    also have \"... = ((a mod d) * (a^n mod d)) mod d\"\n      by (metis mod_mult_eq)\n    also have \"... = ((a mod d) * ((a mod d)^n)) mod d\"\n      using Suc.IH by (metis \\<open>a * a ^ n mod d = a mod d * (a ^ n mod d) mod d\\<close> \\<open>a ^ Suc n = a * a ^ n\\<close> \\<open>a ^ Suc n mod d = a * a ^ n mod d\\<close> mod_mult_cong mod_mult_left_eq)\n    finally show ?case by auto\n  qed\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_m_of_powerV2": {"skill_name": "mod_m_of_powerV2", "marker": "lemma mod_m_of_power:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"a > 0\" and \"m > 1\"\n  shows \"a^n mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"(a mod m)^Suc n = (a mod m) * ((a mod m)^n)\"\n    by simp\n  also have \"... mod m = ((a mod m) * (a^n mod m)) mod m\"\n    by (metis calculation mod_mult_eq power_Suc power_mod)\n  finally show ?case using Suc.IH by (metis power_mod)\nqed", "description": "-", "full_code": "lemma mod_m_of_power:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"a > 0\" and \"m > 1\"\n  shows \"a^n mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"(a mod m)^Suc n = (a mod m) * ((a mod m)^n)\"\n    by simp\n  also have \"... mod m = ((a mod m) * (a^n mod m)) mod m\"\n    by (metis calculation mod_mult_eq power_Suc power_mod)\n  finally show ?case using Suc.IH by (metis power_mod)\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "combine_mod": {"skill_name": "combine_mod", "marker": "lemma combine_mod:\n  fixes x y :: nat\n  assumes \"x mod 10 = a\" \"y mod 10 = b\"\n  shows \"(x + y) mod 10 = (a + b) mod 10\"\nproof -\n  have \"x = (x mod 10) + (x div 10) * 10\" using assms(1) by auto\n  have \"y = (y mod 10) + (y div 10) * 10\" using assms(2) by auto\n  then have \"x + y = ((x mod 10) + (y mod 10)) + ((x div 10) + (y div 10)) * 10\"\n    by (simp add: algebra_simps)\n  then have \"(x + y) mod 10 = (((x mod 10) + (y mod 10)) + ((x div 10) + (y div 10)) * 10) mod 10\"\n    by presburger\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\" \n    by presburger\n  finally show ?thesis using assms by auto\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes x y :: nat\n  assumes \"x mod 10 = a\" \"y mod 10 = b\"\n  shows \"(x + y) mod 10 = (a + b) mod 10\"\nproof -\n  have \"x = (x mod 10) + (x div 10) * 10\" using assms(1) by auto\n  have \"y = (y mod 10) + (y div 10) * 10\" using assms(2) by auto\n  then have \"x + y = ((x mod 10) + (y mod 10)) + ((x div 10) + (y div 10)) * 10\"\n    by (simp add: algebra_simps)\n  then have \"(x + y) mod 10 = (((x mod 10) + (y mod 10)) + ((x div 10) + (y div 10)) * 10) mod 10\"\n    by presburger\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\" \n    by presburger\n  finally show ?thesis using assms by auto\nqed", "origin": "do_request", "update_count": 0}, "combine_modV2": {"skill_name": "combine_modV2", "marker": "lemma combine_mod:\n  fixes x y :: nat\n  assumes \"x mod 10 = a\" \"y mod 10 = b\"\n  shows \"(x + y) mod 10 = (a + b) mod 10\"\nproof -\n  have \"x = (x div 10) * 10 + (x mod 10)\" by (metis div_mult_mod_eq)\n  moreover have \"y = (y div 10) * 10 + (y mod 10)\" by (metis div_mult_mod_eq)\n  ultimately have \"x + y = ((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))\"\n    by auto\n  have \"((x mod 10) + (y mod 10)) mod 10 = (a + b) mod 10\"\n    using assms by simp\n  then have \"(x + y) mod 10 = (((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = (((x div 10) + (y div 10)) * 10) mod 10 + ((x mod 10) + (y mod 10)) mod 10\"\n    by (metis add.commute add_cancel_right_right calculation mod_add_eq mod_mult_self2_is_0)\n  also have \"... = 0 + (a + b) mod 10\"\n    by (metis \\<open>(x mod 10 + y mod 10) mod 10 = (a + b) mod 10\\<close> add_0 add_cancel_left_left mod_mult_self2_is_0)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes x y :: nat\n  assumes \"x mod 10 = a\" \"y mod 10 = b\"\n  shows \"(x + y) mod 10 = (a + b) mod 10\"\nproof -\n  have \"x = (x div 10) * 10 + (x mod 10)\" by (metis div_mult_mod_eq)\n  moreover have \"y = (y div 10) * 10 + (y mod 10)\" by (metis div_mult_mod_eq)\n  ultimately have \"x + y = ((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))\"\n    by auto\n  have \"((x mod 10) + (y mod 10)) mod 10 = (a + b) mod 10\"\n    using assms by simp\n  then have \"(x + y) mod 10 = (((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = (((x div 10) + (y div 10)) * 10) mod 10 + ((x mod 10) + (y mod 10)) mod 10\"\n    by (metis add.commute add_cancel_right_right calculation mod_add_eq mod_mult_self2_is_0)\n  also have \"... = 0 + (a + b) mod 10\"\n    by (metis \\<open>(x mod 10 + y mod 10) mod 10 = (a + b) mod 10\\<close> add_0 add_cancel_left_left mod_mult_self2_is_0)\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_modV3": {"skill_name": "combine_modV3", "marker": "lemma combine_mod:\n  fixes x y :: nat\n  assumes \"x mod 10 = a\" \"y mod 10 = b\"\n  shows \"(x + y) mod 10 = (a + b) mod 10\"\nproof -\n  have \"x = (x div 10) * 10 + (x mod 10)\" by (metis div_mult_mod_eq)\n  moreover have \"y = (y div 10) * 10 + (y mod 10)\" by (metis div_mult_mod_eq)\n  ultimately have \"x + y = ((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))\" \n    by auto\n  then have \"(x + y) mod 10 = (((x mod 10) + (y mod 10)) mod 10)\" \n    using mod_add_eq by metis\n  also have \"... = (a + b) mod 10\" \n    using assms by auto\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes x y :: nat\n  assumes \"x mod 10 = a\" \"y mod 10 = b\"\n  shows \"(x + y) mod 10 = (a + b) mod 10\"\nproof -\n  have \"x = (x div 10) * 10 + (x mod 10)\" by (metis div_mult_mod_eq)\n  moreover have \"y = (y div 10) * 10 + (y mod 10)\" by (metis div_mult_mod_eq)\n  ultimately have \"x + y = ((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))\" \n    by auto\n  then have \"(x + y) mod 10 = (((x mod 10) + (y mod 10)) mod 10)\" \n    using mod_add_eq by metis\n  also have \"... = (a + b) mod 10\" \n    using assms by auto\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "combine_modV4": {"skill_name": "combine_modV4", "marker": "lemma combine_mod:\n  fixes x y :: nat\n  assumes \"x mod 10 = a\" \"y mod 10 = b\"\n  shows \"(x + y) mod 10 = (a + b) mod 10\"\nproof -\n  have \"x = (x div 10) * 10 + (x mod 10)\" by (metis div_mult_mod_eq)\n  moreover have \"y = (y div 10) * 10 + (y mod 10)\" by (metis div_mult_mod_eq)\n  ultimately have \"x + y = ((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))\"\n    by auto\n  have \"(x + y) mod 10 = (((x div 10) + (y div 10)) * 10 + (x mod 10 + y mod 10)) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = (x mod 10 + y mod 10) mod 10\"\n    using mod_add_eq by (metis mod_mult_self3)\n  moreover have \"x mod 10 = a\" using assms(1) by simp\n  moreover have \"y mod 10 = b\" using assms(2) by simp\n  ultimately show ?thesis \n    by (simp add: mod_add_eq)\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes x y :: nat\n  assumes \"x mod 10 = a\" \"y mod 10 = b\"\n  shows \"(x + y) mod 10 = (a + b) mod 10\"\nproof -\n  have \"x = (x div 10) * 10 + (x mod 10)\" by (metis div_mult_mod_eq)\n  moreover have \"y = (y div 10) * 10 + (y mod 10)\" by (metis div_mult_mod_eq)\n  ultimately have \"x + y = ((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))\"\n    by auto\n  have \"(x + y) mod 10 = (((x div 10) + (y div 10)) * 10 + (x mod 10 + y mod 10)) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = (x mod 10 + y mod 10) mod 10\"\n    using mod_add_eq by (metis mod_mult_self3)\n  moreover have \"x mod 10 = a\" using assms(1) by simp\n  moreover have \"y mod 10 = b\" using assms(2) by simp\n  ultimately show ?thesis \n    by (simp add: mod_add_eq)\nqed", "origin": "do_request", "update_count": 0}, "generalized_k_definition": {"skill_name": "generalized_k_definition", "marker": "lemma generalized_k_definition:\n  fixes a :: nat and b :: nat\n  defines \"k \\<equiv> a^2 + b^a\"\n  shows \"k = a^2 + b^a\"\n  by (simp add: k_def)", "description": "-", "full_code": "lemma generalized_k_definition:\n  fixes a :: nat and b :: nat\n  defines \"k \\<equiv> a^2 + b^a\"\n  shows \"k = a^2 + b^a\"\n  by (simp add: k_def)", "origin": "k_definition", "update_count": 0}, "k_mod_10_extended": {"skill_name": "k_mod_10_extended", "marker": "lemma k_mod_10_extended:\n  fixes k :: nat\n  assumes \"k = n^2 + 2^n\"  \n  shows \"k mod 10 = (n^2 mod 10 + (2^n mod 10)) mod 10\"\nproof -\n  have \"k mod 10 = (n^2 + 2^n) mod 10\" by (simp add: assms)\n  also have \"... = (n^2 mod 10 + 2^n mod 10) mod 10\" by presburger\n  finally show ?thesis.\nqed", "description": "-", "full_code": "lemma k_mod_10_extended:\n  fixes k :: nat\n  assumes \"k = n^2 + 2^n\"  \n  shows \"k mod 10 = (n^2 mod 10 + (2^n mod 10)) mod 10\"\nproof -\n  have \"k mod 10 = (n^2 + 2^n) mod 10\" by (simp add: assms)\n  also have \"... = (n^2 mod 10 + 2^n mod 10) mod 10\" by presburger\n  finally show ?thesis.\nqed", "origin": "k_definition", "update_count": 0}, "k_definition_extended": {"skill_name": "k_definition_extended", "marker": "lemma k_definition_extended:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"k = 2008^2 + 2^2008\"\nproof -\n  have \"k = 2008^2 + 2^2008\" by (simp add: k_def)\n  thus ?thesis .\nqed", "description": "-", "full_code": "lemma k_definition_extended:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"k = 2008^2 + 2^2008\"\nproof -\n  have \"k = 2008^2 + 2^2008\" by (simp add: k_def)\n  thus ?thesis .\nqed", "origin": "k_definition", "update_count": 0}, "k_properties": {"skill_name": "k_properties", "marker": "lemma k_properties:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = (2008^2 + 2^2008) mod 10\" by (metis add.commute k_def mod_add_cong numeral_1_eq_Suc_0 one_eq_numeral_iff push_bit_of_Suc_0)\n  also have \"... = (2008^2 mod 10 + 2^2008 mod 10) mod 10\" by eval\n  finally show ?thesis .\nqed", "description": "-", "full_code": "lemma k_properties:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k mod 10 = (2008^2 + 2^2008) mod 10\" by (metis add.commute k_def mod_add_cong numeral_1_eq_Suc_0 one_eq_numeral_iff push_bit_of_Suc_0)\n  also have \"... = (2008^2 mod 10 + 2^2008 mod 10) mod 10\" by eval\n  finally show ?thesis .\nqed", "origin": "k_definition", "update_count": 0}, "k_definition_with_mod": {"skill_name": "k_definition_with_mod", "marker": "lemma k_definition_with_mod:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k = 2008^2 + 2^2008\" by (simp add: k_def)\n  then show ?thesis\n    by presburger\nqed", "description": "-", "full_code": "lemma k_definition_with_mod:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k = 2008^2 + 2^2008\" by (simp add: k_def)\n  then show ?thesis\n    by presburger\nqed", "origin": "k_definition", "update_count": 0}, "mod_power_of_base": {"skill_name": "mod_power_of_base", "marker": "lemma mod_power_of_base:\n  fixes a :: nat\n  fixes n :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod k = (a mod k)^n mod k\"\nproof -\n  have \"a^n mod k = (a mod k)^n mod k\"\n    by (metis power_mod)\n  then show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_power_of_base:\n  fixes a :: nat\n  fixes n :: nat\n  assumes \"a > 0\"\n  shows \"a^n mod k = (a mod k)^n mod k\"\nproof -\n  have \"a^n mod k = (a mod k)^n mod k\"\n    by (metis power_mod)\n  then show ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_exp_base": {"skill_name": "mod_exp_base", "marker": "lemma mod_exp_base:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"(a^n) mod 10 = (a mod 10)^n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) = a * a^n\" by simp\n  then have \"a^(Suc n) mod 10 = (a * a^n) mod 10\"\n    by simp\n  also have \"... = (a mod 10) * (a^n mod 10) mod 10\" \n    using assms by (metis mod_mult_eq)\n  also have \"... = (a mod 10) * ((a mod 10)^n mod 10) mod 10\" \n    using Suc.IH by auto\n  also have \"... = ((a mod 10)^(Suc n)) mod 10\" \n    by (metis calculation power_mod)\n  finally show ?case by simp\nqed", "description": "-", "full_code": "lemma mod_exp_base:\n  fixes a :: nat and n :: nat\n  assumes \"a > 0\"\n  shows \"(a^n) mod 10 = (a mod 10)^n mod 10\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  have \"a^(Suc n) = a * a^n\" by simp\n  then have \"a^(Suc n) mod 10 = (a * a^n) mod 10\"\n    by simp\n  also have \"... = (a mod 10) * (a^n mod 10) mod 10\" \n    using assms by (metis mod_mult_eq)\n  also have \"... = (a mod 10) * ((a mod 10)^n mod 10) mod 10\" \n    using Suc.IH by auto\n  also have \"... = ((a mod 10)^(Suc n)) mod 10\" \n    by (metis calculation power_mod)\n  finally show ?case by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "k_mod_definition": {"skill_name": "k_mod_definition", "marker": "lemma k_mod_definition:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"(k mod 10) = ((2008^2 mod 10) + (2^2008 mod 10)) mod 10\"\nproof -\n  have \"k = 2008^2 + 2^2008\" by (simp add: k_def)\n  then show ?thesis\n    by presburger\nqed", "description": "-", "full_code": "lemma k_mod_definition:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"(k mod 10) = ((2008^2 mod 10) + (2^2008 mod 10)) mod 10\"\nproof -\n  have \"k = 2008^2 + 2^2008\" by (simp add: k_def)\n  then show ?thesis\n    by presburger\nqed", "origin": "k_definition", "update_count": 0}, "mod_k_of_powerV3": {"skill_name": "mod_k_of_powerV3", "marker": "lemma mod_k_of_power:\n  fixes a n k :: nat\n  assumes \"a > 0\" \"k > 0\"\n  shows \"a^n mod k = (a mod k)^n mod k\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then obtain r where \"a^n mod k = (a mod k)^n mod k\" by auto\n  then have \"a^Suc n mod k = (a^n * a) mod k\" by (auto simp: field_simps)\n  also have \"... = ((a mod k)^n mod k * (a mod k)) mod k\" \n    using `a^n mod k = (a mod k)^n mod k` by (metis calculation mod_mult_eq mult.commute power_Suc)\n  also have \"... = ((a mod k)^(Suc n)) mod k\" by (metis calculation power_mod)\n  finally show ?case by simp\nqed", "description": "-", "full_code": "lemma mod_k_of_power:\n  fixes a n k :: nat\n  assumes \"a > 0\" \"k > 0\"\n  shows \"a^n mod k = (a mod k)^n mod k\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then obtain r where \"a^n mod k = (a mod k)^n mod k\" by auto\n  then have \"a^Suc n mod k = (a^n * a) mod k\" by (auto simp: field_simps)\n  also have \"... = ((a mod k)^n mod k * (a mod k)) mod k\" \n    using `a^n mod k = (a mod k)^n mod k` by (metis calculation mod_mult_eq mult.commute power_Suc)\n  also have \"... = ((a mod k)^(Suc n)) mod k\" by (metis calculation power_mod)\n  finally show ?case by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_of_power_general": {"skill_name": "mod_of_power_general", "marker": "lemma mod_of_power_general:\n  fixes a n d :: nat\n  assumes \"a > 0\" \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof -\n  have \"a^n mod d = (a mod d)^n mod d\" \n    by (metis power_mod assms(1) assms(2))\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_of_power_general:\n  fixes a n d :: nat\n  assumes \"a > 0\" \"d > 0\"\n  shows \"a^n mod d = (a mod d)^n mod d\"\nproof -\n  have \"a^n mod d = (a mod d)^n mod d\" \n    by (metis power_mod assms(1) assms(2))\n  thus ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_powerV6": {"skill_name": "mod_powerV6", "marker": "lemma mod_power:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case\n    by auto\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^(Suc n) = a * (a^n)\" by simp\n    then have \"(a^(Suc n)) mod m = (a * (a^n)) mod m\" by simp\n    also have \"... = ((a mod m) * (a^n mod m)) mod m\" using assms by (metis mod_mult_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\" \n      using Suc.IH by auto \n    also have \"... = ((a mod m)^(Suc n)) mod m\" \n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "description": "-", "full_code": "lemma mod_power:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof (induction n)\n  case 0\n  then show ?case\n    by auto\nnext\n  case (Suc n)\n  then show ?case\n  proof -\n    have \"a^(Suc n) = a * (a^n)\" by simp\n    then have \"(a^(Suc n)) mod m = (a * (a^n)) mod m\" by simp\n    also have \"... = ((a mod m) * (a^n mod m)) mod m\" using assms by (metis mod_mult_eq)\n    also have \"... = ((a mod m) * ((a mod m)^n mod m)) mod m\" \n      using Suc.IH by auto \n    also have \"... = ((a mod m)^(Suc n)) mod m\" \n      by (metis calculation power_mod)\n    finally show ?case by simp\n  qed\nqed", "origin": "do_request", "update_count": 0}, "combine_modulo": {"skill_name": "combine_modulo", "marker": "lemma combine_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a + b = (a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\"\n    by presburger\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_modulo:\n  fixes a b :: nat\n  shows \"(a mod 10 + b mod 10) mod 10 = (a + b) mod 10\"\nproof -\n  have \"a + b = (a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = ((a mod 10) + (b mod 10)) mod 10\"\n    by presburger\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "k_mod_10": {"skill_name": "k_mod_10", "marker": "lemma k_mod_10:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k = 2008^2 + 2^2008\" using k_def by simp\n  also have \"... mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\" \n    by eval\n  finally show ?thesis by blast\nqed", "description": "-", "full_code": "lemma k_mod_10:\n  fixes k :: nat\n  defines \"k \\<equiv> 2008^2 + 2^2008\"\n  shows \"k mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\"\nproof -\n  have \"k = 2008^2 + 2^2008\" using k_def by simp\n  also have \"... mod 10 = (2008^2 mod 10 + 2^2008 mod 10) mod 10\" \n    by eval\n  finally show ?thesis by blast\nqed", "origin": "k_definition", "update_count": 0}, "mod_sumV3": {"skill_name": "mod_sumV3", "marker": "lemma mod_sum:\n  fixes a b :: nat\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a + b = (a mod c) + (b mod c) + c * (((a div c) + (b div c)))\" by (auto simp: field_simps)\n  then show ?thesis by auto\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes a b :: nat\n  shows \"(a + b) mod c = ((a mod c) + (b mod c)) mod c\"\nproof -\n  have \"a + b = (a mod c) + (b mod c) + c * (((a div c) + (b div c)))\" by (auto simp: field_simps)\n  then show ?thesis by auto\nqed", "origin": "k_definition", "update_count": 0}, "mod_power_generalV3": {"skill_name": "mod_power_generalV3", "marker": "lemma mod_power_general:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof -\n  have \"a mod m = a - (a div m) * m\" by (metis minus_div_mult_eq_mod)\n  then show ?thesis\n    by (metis modulo_nat_def power_mod)\nqed", "description": "-", "full_code": "lemma mod_power_general:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof -\n  have \"a mod m = a - (a div m) * m\" by (metis minus_div_mult_eq_mod)\n  then show ?thesis\n    by (metis modulo_nat_def power_mod)\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_generalV4": {"skill_name": "mod_power_generalV4", "marker": "lemma mod_power_general:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof -\n  have \"(a mod m) ^ n mod m = ((a - (a div m) * m) ^ n) mod m\"\n    by (metis minus_div_mult_eq_mod)\n  also have \"... = (a ^ n) mod m\" using assms by (metis minus_div_mult_eq_mod power_mod)\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_power_general:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof -\n  have \"(a mod m) ^ n mod m = ((a - (a div m) * m) ^ n) mod m\"\n    by (metis minus_div_mult_eq_mod)\n  also have \"... = (a ^ n) mod m\" using assms by (metis minus_div_mult_eq_mod power_mod)\n  finally show ?thesis by simp\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_power_generalV5": {"skill_name": "mod_power_generalV5", "marker": "lemma mod_power_general:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\n  using assms by (metis power_mod)", "description": "-", "full_code": "lemma mod_power_general:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\n  using assms by (metis power_mod)", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_powerV7": {"skill_name": "mod_powerV7", "marker": "lemma mod_power:\n  fixes a n :: nat\n  assumes \"a > 0\" \"n > 0\"\n  shows \"(a mod m)^n mod m = a^n mod m\"\n  using assms by (metis power_mod)", "description": "-", "full_code": "lemma mod_power:\n  fixes a n :: nat\n  assumes \"a > 0\" \"n > 0\"\n  shows \"(a mod m)^n mod m = a^n mod m\"\n  using assms by (metis power_mod)", "origin": "mod_10_of_powerV2", "update_count": 0}, "mod_sumV4": {"skill_name": "mod_sumV4", "marker": "lemma mod_sum:\n  fixes a b :: nat\n  assumes \"a mod 10 + b mod 10 < 10\"\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10)\"\nproof -\n  have \"a + b = (a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10) + (b mod 10)\"\n  proof -\n    have \"10 * (a div 10 + b div 10) mod 10 = 0\" \n      by (simp add: mod_mult_eq)\n    thus \"((a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)) mod 10 = (a mod 10) + (b mod 10)\"\n      by (metis \\<open>a + b = a mod 10 + b mod 10 + 10 * (a div 10 + b div 10)\\<close> assms mod_add_left_eq mod_add_right_eq mod_less)\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes a b :: nat\n  assumes \"a mod 10 + b mod 10 < 10\"\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10)\"\nproof -\n  have \"a + b = (a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10) + (b mod 10)\"\n  proof -\n    have \"10 * (a div 10 + b div 10) mod 10 = 0\" \n      by (simp add: mod_mult_eq)\n    thus \"((a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)) mod 10 = (a mod 10) + (b mod 10)\"\n      by (metis \\<open>a + b = a mod 10 + b mod 10 + 10 * (a div 10 + b div 10)\\<close> assms mod_add_left_eq mod_add_right_eq mod_less)\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_sumV5": {"skill_name": "mod_sumV5", "marker": "lemma mod_sum:\n  fixes a b :: nat\n  assumes \"a mod 10 + b mod 10 < 10\"\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10)\"\nproof -\n  have \"a + b = (a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10) + (b mod 10)\"\n  proof -\n    have \"10 * (a div 10 + b div 10) mod 10 = 0\"\n      by simp\n    then show ?thesis \n      using assms by fastforce\n  qed\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes a b :: nat\n  assumes \"a mod 10 + b mod 10 < 10\"\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10)\"\nproof -\n  have \"a + b = (a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)\"\n    by (auto simp: field_simps)\n  then have \"(a + b) mod 10 = ((a mod 10) + (b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10) + (b mod 10)\"\n  proof -\n    have \"10 * (a div 10 + b div 10) mod 10 = 0\"\n      by simp\n    then show ?thesis \n      using assms by fastforce\n  qed\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_sumV6": {"skill_name": "mod_sumV6", "marker": "lemma mod_sum:\n  fixes a b :: nat\n  assumes \"a mod 10 + b mod 10 < 10\"\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10)\"\nproof -\n  have \"a = (a mod 10) + (a div 10) * 10\" by auto\n  have \"b = (b mod 10) + (b div 10) * 10\" by auto\n  then have \"a + b = ((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10\"\n    by (simp add: algebra_simps)\n  have \"a + b = (a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)\" by simp\n  then have \"(a + b) mod 10 = ((a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n    by presburger\n  also have \"... = a mod 10 + b mod 10\"\n    using assms by simp\n  finally show ?thesis by simp\nqed", "description": "-", "full_code": "lemma mod_sum:\n  fixes a b :: nat\n  assumes \"a mod 10 + b mod 10 < 10\"\n  shows \"(a + b) mod 10 = (a mod 10 + b mod 10)\"\nproof -\n  have \"a = (a mod 10) + (a div 10) * 10\" by auto\n  have \"b = (b mod 10) + (b div 10) * 10\" by auto\n  then have \"a + b = ((a mod 10) + (b mod 10)) + ((a div 10) + (b div 10)) * 10\"\n    by (simp add: algebra_simps)\n  have \"a + b = (a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)\" by simp\n  then have \"(a + b) mod 10 = ((a mod 10 + b mod 10) + 10 * (a div 10 + b div 10)) mod 10\"\n    by presburger\n  also have \"... = (a mod 10 + b mod 10) mod 10\"\n    by presburger\n  also have \"... = a mod 10 + b mod 10\"\n    using assms by simp\n  finally show ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "mod_power_generalV6": {"skill_name": "mod_power_generalV6", "marker": "lemma mod_power_general:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof -\n  have \"a mod m = a - (m * (a div m))\" by (metis minus_div_mult_eq_mod minus_mult_div_eq_mod)\n  then have \"a^n mod m = (a - (m * (a div m)))^n mod m\" by (metis minus_mult_div_eq_mod power_mod)\n  thus ?thesis using assms by (metis power_mod)\nqed", "description": "-", "full_code": "lemma mod_power_general:\n  fixes a :: nat and n :: nat and m :: nat\n  assumes \"m > 0\"\n  shows \"(a^n) mod m = (a mod m)^n mod m\"\nproof -\n  have \"a mod m = a - (m * (a div m))\" by (metis minus_div_mult_eq_mod minus_mult_div_eq_mod)\n  then have \"a^n mod m = (a - (m * (a div m)))^n mod m\" by (metis minus_mult_div_eq_mod power_mod)\n  thus ?thesis using assms by (metis power_mod)\nqed", "origin": "mod_10_of_powerV2", "update_count": 0}, "combine_modV5": {"skill_name": "combine_modV5", "marker": "lemma combine_mod:\n  fixes x y :: nat\n  assumes \"x mod 10 = a\" \"y mod 10 = b\"\n  shows \"(x + y) mod 10 = (a + b) mod 10\"\nproof -\n  have \"x = (x div 10) * 10 + (x mod 10)\" by (metis div_mult_mod_eq)\n  moreover have \"y = (y div 10) * 10 + (y mod 10)\" by (metis div_mult_mod_eq)\n  ultimately have \"x + y = ((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))\"\n    by auto\n  have \"(x + y) mod 10 = (((x div 10) + (y div 10)) * 10 + (x mod 10 + y mod 10)) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\"\n    by (metis mod_mult_self3)\n  moreover have \"x mod 10 = a\" using assms(1) by simp\n  moreover have \"y mod 10 = b\" using assms(2) by simp\n  ultimately have \"(x + y) mod 10 = (a + b) mod 10\"\n    by simp\n  thus ?thesis by simp\nqed", "description": "-", "full_code": "lemma combine_mod:\n  fixes x y :: nat\n  assumes \"x mod 10 = a\" \"y mod 10 = b\"\n  shows \"(x + y) mod 10 = (a + b) mod 10\"\nproof -\n  have \"x = (x div 10) * 10 + (x mod 10)\" by (metis div_mult_mod_eq)\n  moreover have \"y = (y div 10) * 10 + (y mod 10)\" by (metis div_mult_mod_eq)\n  ultimately have \"x + y = ((x div 10) + (y div 10)) * 10 + ((x mod 10) + (y mod 10))\"\n    by auto\n  have \"(x + y) mod 10 = (((x div 10) + (y div 10)) * 10 + (x mod 10 + y mod 10)) mod 10\"\n    by (auto simp: field_simps)\n  also have \"... = ((x mod 10) + (y mod 10)) mod 10\"\n    by (metis mod_mult_self3)\n  moreover have \"x mod 10 = a\" using assms(1) by simp\n  moreover have \"y mod 10 = b\" using assms(2) by simp\n  ultimately have \"(x + y) mod 10 = (a + b) mod 10\"\n    by simp\n  thus ?thesis by simp\nqed", "origin": "do_request", "update_count": 0}, "square_mod_10V6": {"skill_name": "square_mod_10V6", "marker": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?a = \"n mod 10\"  \n  have \"n = 10 * (n div 10) + ?a\" \n    by auto\n  then have \"n^2 = (10 * (n div 10) + ?a)^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?a + ?a^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2\" \n    by (simp add: algebra_simps)\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2) mod 10\" \n    by simp\n  have \"100 * (n div 10)^2 mod 10 = 0\" \n    by (simp add: mod_mult_self2_is_0)\n  have \"20 * (n div 10) * ?a mod 10 = 0\" \n    by (simp add: mod_mult_self2_is_0)\n  thus ?thesis \n    by (simp add: power_mod)\nqed", "description": "-", "full_code": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?a = \"n mod 10\"  \n  have \"n = 10 * (n div 10) + ?a\" \n    by auto\n  then have \"n^2 = (10 * (n div 10) + ?a)^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?a + ?a^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2\" \n    by (simp add: algebra_simps)\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2) mod 10\" \n    by simp\n  have \"100 * (n div 10)^2 mod 10 = 0\" \n    by (simp add: mod_mult_self2_is_0)\n  have \"20 * (n div 10) * ?a mod 10 = 0\" \n    by (simp add: mod_mult_self2_is_0)\n  thus ?thesis \n    by (simp add: power_mod)\nqed", "origin": "do_request", "update_count": 0}, "square_mod_10V7": {"skill_name": "square_mod_10V7", "marker": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?a = \"n mod 10\"  \n  have \"n = 10 * (n div 10) + ?a\" \n    by auto\n  then have \"n^2 = (10 * (n div 10) + ?a)^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?a + ?a^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2\" \n    by (simp add: algebra_simps)\n  then have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2) mod 10\" \n    by (metis calculation eval_mod_exp(4) mod_exp_code semiring_norm(3))\n  moreover have \"100 * (n div 10)^2 mod 10 = 0\" \n    by auto\n  moreover have \"20 * (n div 10) * ?a mod 10 = 0\" \n    by auto\n  ultimately have \"n^2 mod 10 = (?a^2) mod 10\" \n    by (metis power_mod)\n  thus ?thesis \n    by (simp add: power2_eq_square)\nqed", "description": "-", "full_code": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?a = \"n mod 10\"  \n  have \"n = 10 * (n div 10) + ?a\" \n    by auto\n  then have \"n^2 = (10 * (n div 10) + ?a)^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?a + ?a^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2\" \n    by (simp add: algebra_simps)\n  then have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2) mod 10\" \n    by (metis calculation eval_mod_exp(4) mod_exp_code semiring_norm(3))\n  moreover have \"100 * (n div 10)^2 mod 10 = 0\" \n    by auto\n  moreover have \"20 * (n div 10) * ?a mod 10 = 0\" \n    by auto\n  ultimately have \"n^2 mod 10 = (?a^2) mod 10\" \n    by (metis power_mod)\n  thus ?thesis \n    by (simp add: power2_eq_square)\nqed", "origin": "do_request", "update_count": 0}, "square_mod_10V8": {"skill_name": "square_mod_10V8", "marker": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?a = \"n mod 10\"  \n  have \"n = 10 * (n div 10) + ?a\" \n    by auto\n  then have \"n^2 = (10 * (n div 10) + ?a)^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?a + ?a^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2\" \n    by (simp add: algebra_simps)\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2) mod 10\" \n    by simp\n  have \"100 * (n div 10)^2 mod 10 = 0\" \n    by auto\n  have \"20 * (n div 10) * ?a mod 10 = 0\" \n    by auto\n  have \"?a^2 mod 10 = (?a)^2 mod 10\" \n    by simp\n  thus ?thesis \n    by (metis power_mod)\nqed", "description": "-", "full_code": "lemma square_mod_10:\n  fixes n :: nat\n  shows \"(n mod 10)^2 mod 10 = (n^2 mod 10)\"\nproof -\n  let ?a = \"n mod 10\"  \n  have \"n = 10 * (n div 10) + ?a\" \n    by auto\n  then have \"n^2 = (10 * (n div 10) + ?a)^2\"\n    by simp\n  also have \"... = (10 * (n div 10))^2 + 2 * (10 * (n div 10)) * ?a + ?a^2\"\n    by (smt (z3) ab_semigroup_add_class.add_ac(1) add.assoc add.commute add.left_commute power2_sum)\n  also have \"... = 100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2\" \n    by (simp add: algebra_simps)\n  finally have \"n^2 mod 10 = (100 * (n div 10)^2 + 20 * (n div 10) * ?a + ?a^2) mod 10\" \n    by simp\n  have \"100 * (n div 10)^2 mod 10 = 0\" \n    by auto\n  have \"20 * (n div 10) * ?a mod 10 = 0\" \n    by auto\n  have \"?a^2 mod 10 = (?a)^2 mod 10\" \n    by simp\n  thus ?thesis \n    by (metis power_mod)\nqed", "origin": "do_request", "update_count": 0}}